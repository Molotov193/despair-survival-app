<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />

<title>Despair Survival</title>
<style>
body {
  background-color: #111; /* èƒŒæ™¯ç”»åƒãŒãªã„å ´åˆã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè‰² */
  color: #eee;
  font-family: monospace, monospace;
  margin: 0;
  user-select: none;
  height: 100vh;
  overflow: hidden;
  position: relative;
  transition: background-color 2s linear;
}

/* â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ–°ã—ã<style>ã‚¿ã‚°å†…ã«è¿½åŠ  â–¼â–¼â–¼ */
.background-layer {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-size: cover;
  background-position: center center;
  background-repeat: no-repeat;
  /* é€æ˜åº¦ã®å¤‰åŒ–ã‚’1.5ç§’ã‹ã‘ã¦æ»‘ã‚‰ã‹ã«è¡Œã† */
  transition: opacity 1.5s ease-in-out;
  /* z-indexã§ã‚²ãƒ¼ãƒ ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®èƒŒå¾Œã«é…ç½® */
  z-index: -10;
}

.bg-morning { background-image: url('images/background_morning.png'); }
.bg-day     { background-image: url('images/background_day.png'); }
.bg-evening { background-image: url('images/background_evening.png'); }
.bg-night   { background-image: url('images/background_night.png'); }
/* â–²â–²â–² è¿½åŠ ã¯ã“ã“ã¾ã§ â–²â–²â–² */
@keyframes npc-move-in {
    from {
        /* å°‘ã—ä¸‹ã‹ã‚‰ã€é€æ˜ãªçŠ¶æ…‹ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆ */
        transform: translateY(10px);
        opacity: 0;
    }
    to {
        /* æœ¬æ¥ã®ä½ç½®ã«ã€ä¸é€æ˜ãªçŠ¶æ…‹ã§çµ‚äº† */
        transform: translateY(0);
        opacity: 1;
    }
}

/* ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é©ç”¨ã™ã‚‹ã‚¯ãƒ©ã‚¹ */
.entity-move-animation {
    /* 0.2ç§’ã‹ã‘ã¦ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œ */
    animation: npc-move-in 0.2s ease-out;
}

#startScreen, #gameClearScreen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #111;
  color: #eee;
  z-index: 10000;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
  font-family: sans-serif;
}
#startScreen h1 {
  font-size: 3em;
  color: #e74c3c;
  text-shadow: 0 0 10px #c0392b;
}
#startScreen button, #gameClearScreen button {
  padding: 15px 30px;
  font-size: 1.5em;
  background: #333;
  color: #eee;
  border: 1px solid #555;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.3s ease;
  margin-top: 20px;
}
#startScreen button:hover, #gameClearScreen button:hover {
  background: #555;
  border-color: #777;
  transform: scale(1.05);
}
#quitGameBtn {
    background: #a04040 !important;
    border-color: #c06060 !important;
}
#quitGameBtn:hover {
    background: #c0392b !important;
}
/* â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’<style>ã‚¿ã‚°å†…ã«è¿½åŠ  â–¼â–¼â–¼ */
#languageSwitcher button {
    padding: 8px 15px;
    margin: 0 5px;
    background-color: #333;
    border: 1px solid #555;
    color: #eee;
    cursor: pointer;
    transition: background-color 0.2s;
}
#languageSwitcher button:hover {
    background-color: #555;
}
#languageSwitcher button.active {
    background-color: #2ecc71;
    color: #111;
    border-color: #27ae60;
    font-weight: bold;
}
/* â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–² */
/* â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’CSSå†…ã«è¿½åŠ  â–¼â–¼â–¼ */
#playerDirectionArrow {
  position: absolute;
  /* ãƒãƒƒãƒ—ä¸­å¤®ã®ã‚¿ã‚¤ãƒ«ã«é…ç½® */
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  /* CSSã§ä¸‰è§’å½¢ã‚’ä½œæˆ */
  border-left: 10px solid transparent;
  border-right: 10px solid transparent;
  border-bottom: 20px solid red;
  /* æ ¹æœ¬ã‚’å›è»¢ã®ä¸­å¿ƒã«è¨­å®š */
  transform-origin: 50% 100%;
  z-index: 50;
  pointer-events: none;
  opacity: 0; /* æœ€åˆã¯éè¡¨ç¤º */
  transition: opacity 0.2s ease, transform 0.2s ease;
}
#gameClearScreen .gate-art {
  font-size: 1.5em;
  line-height: 1.2;
  white-space: pre;
  color: #f1c40f;
  margin-bottom: 20px;
}
#gameClearScreen h2 {
    font-size: 2.5em;
    margin-bottom: 20px;
}
#gameClearScreen p {
    font-size: 1.2em;
    margin-bottom: 30px;
}
#droppedItemsList {
    flex-grow: 1;
    overflow-y: auto;
}
#currentLocationBody {
    overflow-y: auto !important;
    flex-shrink: 0;
    height: auto !important;
}
.tile .tile-player {
  z-index: 3 !important; /* ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ */
}

/* â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã§ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼ */
.panel {
  position: absolute;
  /* â˜… è‰²ã‚’æ˜ã‚‹ã„ã‚°ãƒ¬ãƒ¼ã«å¤‰æ›´ã—ã€é€æ˜åº¦ã‚’å°‘ã—èª¿æ•´ */
  background-color: rgba(68, 68, 68, 0.9);
  border-radius: 6px;
  /* â˜… å¢ƒç•Œç·šã‚‚å°‘ã—æ˜ã‚‹ãã™ã‚‹ã¨é¦´æŸ“ã¿ã¾ã™ */
  border: 1px solid #555;
  padding: 10px;
  box-sizing: border-box;
  cursor: grab;
  user-select: none;
  z-index: 10;
  box-shadow: 0 0 15px #000a inset;
  overflow: hidden;
  display: flex;
  flex-direction: column;

  /* â–¼â–¼â–¼ èƒŒæ™¯ç”»åƒã®è¨­å®š â–¼â–¼â–¼ */
  background-image: url('images/panel_background_noise.png'); /* ç”»åƒåã¯ãŠå¥½ã¿ã§å¤‰æ›´ã—ã¦ãã ã•ã„ */
  background-size: cover;
  background-position: center;
  /* â˜… background-blend-mode ã®è¡Œã‚’å‰Šé™¤ã€ã¾ãŸã¯ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã—ã¾ã™ */
}
/* â–²â–²â–² ç½®ãæ›ãˆã“ã“ã¾ã§ â–²â–²â–² */
.panel .resize-handle {
  position: absolute;
  width: 16px;
  height: 16px;
  right: 2px;
  bottom: 2px;
  background: #888;
  border-radius: 4px;
  cursor: nwse-resize;
  z-index: 1000;
}
.panel .resize-handle:hover {
  background: #aaa;
}
#mapPanel .resize-handle {
  display: none;
}
/* â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’CSSå†…ã«è¿½åŠ  â–¼â–¼â–¼ */
#characterPanel .resize-handle,
#statusPanel .resize-handle,
#turnPanel .resize-handle {
  display: none;
}
/* â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–² */
.panel-header {
  font-weight: bold;
  margin-bottom: 6px;
  cursor: grab;
  user-select: none;
  padding-bottom: 4px;
  border-bottom: 1px solid #555;
  user-select:none;
  -webkit-user-select:none;
  -moz-user-select:none;
  -ms-user-select:none;
  display: flex;
  justify-content: space-between;
  align-items: center;
}
#mapHeaderInfo {
    font-size: 14px;
    font-weight: normal;
    color: #ccc;
    /* pointer-events: none; ã®è¡Œã‚’å‰Šé™¤ */
}
#mapHeaderInfo .temp-hot { color: #e74c3c; }
#mapHeaderInfo .temp-normal { color: #2ecc71; }
#mapHeaderInfo .temp-cold { color: #3498db; }
#mapHeaderInfo span { margin: 0 5px; }

#map {
  display: grid;
  grid-gap: 0px;
  width: 100%;
  height: 100%;
  overflow: visible;
  font-size: 12px;
  position: relative;
  justify-content: center; /* â† æ¨ªæ–¹å‘ã®ä¸­å¤®æƒãˆã‚’è¿½åŠ  */
  align-content: center;   /* â† ç¸¦æ–¹å‘ã®ä¸­å¤®æƒãˆã‚’è¿½åŠ  */
}
/* â–¼â–¼â–¼ æ—¢å­˜ã® .tile ã®å®šç¾©ã‚’ã€ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼ */
.tile {
  width: 40px;
  height: 40px;
  cursor: pointer;
  background: #555;
  user-select: none;
  position: relative; /* â† ç”»åƒã‚’é‡ã­ã‚‹ãŸã‚ã®åŸºæº–ç‚¹ã«ã™ã‚‹ */
  transition: background-color 0.3s;
}

/* ç”»åƒã‚’é‡ã­ã‚‹ãŸã‚ã®æ–°ã—ã„ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¿½åŠ  */
.tile-img {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  image-rendering: pixelated;
}

/* â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã§ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼ */
.tile .tile-terrain {
  z-index: 1 !important; /* åœ°å½¢ */
}
.tile .tile-object {
  z-index: 2 !important; /* æ­»ä½“ãªã©ã®è¨­ç½®ç‰© */
}
.tile .tile-entity {
  z-index: 4 !important; /* æ•µã‚„NPCãªã©ã®å‹•ãå­˜åœ¨ */
}
/* â–²â–²â–² ç½®ãæ›ãˆã“ã“ã¾ã§ â–²â–²â–² */
.tile.targeting {
    background-color: #8E44AD;
    box-shadow: 0 0 10px #8E44AD;
}
.tile.targeting:hover {
    background-color: #9B59B6;
}
.unexplored {
  background: #555;
  color: #555;
}
.explored {
  background: #777;
}
.memorized-tile {
  background: #5a3d24; /* è¨˜æ†¶ã‚’è¡¨ã™èŒ¶è‰² */
  color: #aaa; /* è¨˜æ†¶å†…ã®ã‚¢ã‚¤ã‚³ãƒ³ã‚’å°‘ã—æš—ãã™ã‚‹ */
}
.road-tile {
  background: #4a4a4a;
}
.memorized-tile img {
  opacity: 0.5; /* ç”»åƒã‚’åŠé€æ˜ã«ã™ã‚‹ */
}
.player-tile {
  background: #2c3e50; /* Changed background for player tile */
  position: relative;
}
.map-overlay-icon {
    position: absolute;
    font-size: 32px;
    z-index: 60;
    text-shadow: 0 0 8px #000;
    pointer-events: all;
    cursor: help;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    height: 100%;
}
.map-overlay-icon.campfire {
    animation: flicker 1.5s infinite alternate;
}
.map-overlay-icon.unlit-campfire {
    filter: grayscale(100%) brightness(0.7);
}
@keyframes flicker {
  0%, 18%, 22%, 25%, 53%, 57%, 100% {
    text-shadow:
      0 0 4px #fff,
      0 0 11px #fff,
      0 0 19px #fff,
      0 0 40px #f09,
      0 0 80px #f09,
      0 0 90px #f09,
      0 0 100px #f09,
      0 0 150px #f09;
  }
  20%, 24%, 55% { text-shadow: none; }
}

.entity-icon {
    position: absolute;
    font-size: 24px;
    z-index: 40;
    text-shadow: 0 0 5px #000;
    pointer-events: all; /* Make icon hoverable */
    cursor: help;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    height: 100%;
}
.player-icon {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 24px;
  z-index: 50;
  text-shadow: 0 0 5px #000;
  pointer-events: none;
}
.player-icon.race-white { color: #f5f5dc; }
.player-icon.race-asian { color: #f7e7c6; }
.player-icon.race-black { color: #2e2621; }
.player-icon.race-middle-eastern { color: #8b5a2b; }

#playerDirectionArrow {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  border-left: 10px solid transparent;
  border-right: 10px solid transparent;
  border-bottom: 20px solid red;
  transform-origin: 50% 100%;
  z-index: 50;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s ease, transform 0.2s ease;
}
/* â–¼â–¼â–¼ ã“ã®2ã¤ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼ */
.status-line {
  margin-bottom: 6px;
  font-family: sans-serif;
  cursor: default;
  display: flex; /* â† Flexboxã‚’æœ‰åŠ¹åŒ– */
  align-items: center; /* â†è¦ç´ ã‚’ç¸¦æ–¹å‘ä¸­å¤®ã«æƒãˆã‚‹ */
}
.status-label {
  flex-basis: 90px; /* â† ãƒ©ãƒ™ãƒ«ã®åŸºæœ¬å¹…ã‚’90pxã«ç¢ºä¿ */
  flex-shrink: 0; /* â† ãƒ©ãƒ™ãƒ«ãŒç¸®ã¾ãªã„ã‚ˆã†ã«ã™ã‚‹ */
  font-weight: bold;
  color: #ccc;
}
/* â–²â–²â–² ç½®ãæ›ãˆã“ã“ã¾ã§ â–²â–²â–² */
.bar {
  display: inline-block;
  width: 150px;
  height: 10px;
  background: #333;
  margin-right: 6px;
  border-radius: 5px;
  vertical-align: middle;
  overflow: hidden;
}
.fill {
  height: 100%;
  background: lime;
  transition: width 0.3s ease;
}
/* --- Status Bar Colors --- */
.fill.status-high { background-color: #27ae60; } /* Green */
.fill.status-mid  { background-color: #f1c40f; } /* Yellow */
.fill.status-low  { background-color: #e74c3c; } /* Red */

/* --- Blinking Animation --- */
@keyframes blinking-bar-frame {
  0% { background-color: #333; }
  50% { background-color: #600; } /* æ¿ƒã„èµ¤è‰²ã«å…‰ã‚‹ */
  100% { background-color: #333; }
}
.bar.blinking {
  animation: blinking-bar-frame 1.5s infinite;
}
#log {
  background: #000;
  height: 100%; /* â† é«˜ã•ã‚’ãƒ‘ãƒãƒ«å…¨ä½“ã«åºƒã’ã‚‹ */
  overflow-y: auto;
  font-size: 12px;
  padding: 5px;
  margin: 0; /* â† ä¸Šéƒ¨ã®ä½™ç™½ã‚’å‰Šé™¤ */
  line-height: 1.3em;
  font-weight: normal;
  color: #888;
  box-sizing: border-box; /* â† ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’é«˜ã•ã«å«ã‚ã‚‹ */
}
#log div.new {
  color: #eee;
  font-weight: bold;
}
/* --- Item List & Scroll Fix --- */

/* å…¨ã¦ã®ãƒ‘ãƒãƒ«ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¨ãƒªã‚¢ã‚’Flexboxãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã«è¨­å®š */
.panel-content {
    display: flex;
    flex-direction: column;
    overflow: hidden;
    height: calc(100% - 22px);
}

/* å…¨ã¦ã®ã‚¢ã‚¤ãƒ†ãƒ ãƒªã‚¹ãƒˆã«é©ç”¨ã•ã‚Œã‚‹ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«è¨­å®š */
.item-list {
    flex-grow: 1;
    overflow-y: scroll;
    min-height: 0;
    background: #111;
    padding: 5px;
    box-sizing: border-box;
    font-family: sans-serif;
    color: #eee;
    margin-top: 6px;
}
/* â–²â–²â–² ç½®ãæ›ãˆã“ã“ã¾ã§ â–²â–²â–² */
.item {
  background: #333;
  padding: 5px;
  margin: 3px 0;
  cursor: pointer;
  font-size: 12px;
  border-radius: 4px;
}
.item:hover {
  background: #555;
}
.item button {
  background: #444;
  color: #eee;
  border: none;
  padding: 2px 5px;
  border-radius: 3px;
  cursor: pointer;
  opacity: 0.7;
 }
 .item button:hover {
  opacity: 1.0;
  background: #666;
 }

#currentLocationPanel .location-name {
  font-family: sans-serif;
  font-size: 1.2em;
  margin-bottom: 5px;
}

/* â–¼â–¼â–¼ ã“ã®å†…å®¹ã§ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼ */
#itemDetailPanel {
  position: absolute;
  /* â˜… background: #222; ã®è¡Œã‚’å‰Šé™¤ã—ã¾ã—ãŸ */
  border-radius: 6px;
  border: 1px solid #444;
  padding: 15px;
  box-shadow: 0 0 20px rgba(0,0,0,0.8);
  z-index: 1000;
  width: 300px;
  max-width: 90vw;
  font-family: sans-serif;
  display: none;
}
#itemDetailPanel .panel-header {
  font-size: 1.2em;
  border-bottom: 1px solid #555;
  padding-bottom: 8px;
  margin-bottom: 10px;
  cursor: grab;
}
#itemDetailPanel .item-detail-info {
  line-height: 1.6em;
  font-size: 14px;
}
#itemDetailPanel .item-detail-info strong {
  display: inline-block;
  width: 80px;
}
#itemDetailPanel .item-detail-actions {
  margin-top: 15px;
  text-align: right;
}
#itemDetailPanel button {
  background: #444;
  color: #eee;
  border: none;
  padding: 8px 15px;
  border-radius: 5px;
  cursor: pointer;
  margin-left: 5px;
}
#itemDetailPanel button:hover {
  background: #666;
}
.item-graphic-container {
  text-align: center;
  margin: 10px 0;
}
.item-graphic {
  font-size: 48px;
  line-height: 1;
}
.item-description {
  margin-bottom: 10px;
  border-bottom: 1px solid #555;
  padding-bottom: 10px;
}
.item-effect-positive { color: limegreen; }
.item-effect-negative { color: indianred; }
#statusPreview {
  position: fixed;
  background: rgba(34, 34, 34, 0.95);
  border: 1px solid #666;
  border-radius: 4px;
  padding: 8px;
  font-size: 12px;
  color: #eee;
  pointer-events: none;
  z-index: 9999;
  display: none;
  box-shadow: 0 2px 8px rgba(0,0,0,0.5);
  line-height: 1.5;
}
.preview-stat {
  margin: 2px 0;
  display: flex;
  align-items: center;
}
.preview-stat-name {
  width: 50px;
  display: inline-block;
}
.preview-change {
  margin-left: 5px;
  font-weight: bold;
}
.preview-change.positive { color: #27ae60; }
.preview-change.negative { color: #e74c3c; }
.preview-change.neutral { color: #95a5a6; }
.trait-pill {
    background: #444;
    color: #fff;
    padding: 3px 8px;
    margin-right: 4px;
    border-radius: 12px;
    font-size: 12px;
    display: inline-block;
    white-space: nowrap;
    cursor: help;
}
#physicalCondition {
  margin-top: 10px;
  font-family: sans-serif;
  font-size: 14px;
  line-height: 1.4;
  padding: 5px;
  border-top: 1px solid #555;
}
#physicalCondition span[onmouseenter] {
    cursor: help;
    text-decoration: underline dotted;
}
.condition-normal { color: #3498db; }
.condition-warning { color: #f1c40f; }
.condition-critical { color: #e74c3c; }

#physicalCondition strong {
  display: block;
  margin-bottom: 5px;
}
.panel.minimized {
  position: fixed !important;
  right: 10px;
  bottom: 10px;
  width: auto !important;
  height: auto !important;
  padding: 0;
  border: 1px solid #444;
  overflow: visible;
  z-index: 999 !important;
  min-width: 0 !important;
  max-width: none !important;
  max-height: none !important;
  transition: all 0.3s ease;
}
.panel.minimized .panel-header {
  border-bottom: none;
  padding: 5px 10px;
  margin: 0;
}
.panel.minimized .resize-handle {
  display: none;
}
.panel.minimized .panel-content,
.panel.minimized #map,
.panel.minimized #status,
.panel.minimized #turnInfoText,
.panel.minimized #log,
.panel.minimized .item-list,
.panel.minimized #craftingPanel .panel-content,
.panel.minimized #characterBasic,
.panel.minimized #charBody,
.panel.minimized #currentLocationBody {
  display: none;
}
.panel.minimized#itemDetailPanel {
  display: none !important;
}
/* â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ–°ã—ãè¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼ */
.interaction-locked {
    pointer-events: none; /* ãƒã‚¦ã‚¹æ“ä½œã‚’ã™ã¹ã¦ç„¡åŠ¹åŒ–ã™ã‚‹ */
    opacity: 0.7; /* åŠé€æ˜ã«ã—ã¦ã€æ“ä½œä¸å¯ã§ã‚ã‚‹ã“ã¨ã‚’è¦–è¦šçš„ã«ç¤ºã™ */
}
/* â–²â–²â–² è¿½åŠ ã¯ã“ã“ã¾ã§ â–²â–²â–² */
#turnInfoText {
  line-height: 1.6;
}
#craftingList .item button {
    float: right;
}
#craftingList .item.un-craftable {
    background: #2a2a2a;
    color: #777;
    cursor: not-allowed;
}
#craftingList .item.un-craftable button {
    display: none;
}
.recipe-ingredients {
    font-size: 10px;
    color: #aaa;
    margin-left: 15px;
}
.crafting-category-header {
    font-weight: bold;
    color: #f1c40f;
    margin-top: 10px;
    padding-bottom: 3px;
    border-bottom: 1px solid #555;
    cursor: pointer;
    user-select: none;
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.recipe-container.collapsed {
    display: none;
}

#damagePop {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(1);
  font-size: 6em;
  font-weight: bold;
  color: #e74c3c;
  text-shadow: 0 0 10px #000;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.5s ease-out, transform 0.5s ease-out;
  z-index: 9999;
}
#combatPanel {
    box-sizing: border-box;
    font-family: sans-serif;
}
#combatContent {
    display: flex;
    height: calc(100% - 30px);
    padding-top: 10px;
}
#combatPlayer, #combatEnemy {
    flex: 1;
    padding: 10px;
    text-align: center;
    position: relative;
    /* â–¼â–¼â–¼ ã“ã®2è¡Œã‚’æ–°ã—ãè¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼ */
    display: flex;
    flex-direction: column;
}
#combatLogContainer {
    flex: 2;
    display: flex;
    flex-direction: column;
    padding: 0 10px;
}
#combatLog {
    flex-grow: 1;
    background: #000;
    color: #eee;
    font-size: 12px;
    padding: 10px;
    overflow-y: auto;
    margin-bottom: 10px;
    border: 1px solid #444;
    border-radius: 4px;
}
#combatActions {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
}
#combatActions button {
    width: 100%;
    padding: 10px;
    background: #444;
    color: #eee;
    border: none;
    cursor: pointer;
    border-radius: 4px;
    font-size: 14px;
    transition: background 0.2s;
}
#combatActions button:hover:not(:disabled) {
    background: #666;
}
#combatActions button:disabled {
    background: #333;
    color: #777;
    cursor: not-allowed;
}
#combatActions button.fire-btn {
    background: #c0392b;
}
#combatActions button.fire-btn:hover:not(:disabled) {
    background: #e74c3c;
}

#combatPlayerEquipment, #combatEnemyEquipment {
    margin-top: 15px;
    text-align: left;
    font-size: 12px;
    border-top: 1px solid #555;
    padding-top: 10px;
}
#combatPlayerInjuries {
    margin-top: 10px;
    text-align: left;
    font-size: 12px;
    color: indianred;
    border-top: 1px solid #555;
    padding-top: 10px;
}
#combatEquipmentList, #combatEnemyEquipmentList {
    margin-top: 5px;
    line-height: 1.5;
}
#combatPlayerStats div {
    cursor: help;
}
#charBody {
  flex-grow: 1; /* ãƒ‘ãƒãƒ«å†…ã®ç©ºãã‚¹ãƒšãƒ¼ã‚¹ã‚’åŸ‹ã‚ã‚‹ã‚ˆã†ã«æ‹¡å¼µ */
  min-height: 150px; /* æœ€å°ã®é«˜ã•ã‚’ç¢ºä¿ */
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 10px; /* ç”»åƒã®å‘¨ã‚Šã«å°‘ã—ä½™ç™½ã‚’ä½œã‚‹ */
  box-sizing: border-box;
}

/* ä»–ã®è¦ç´ ã®ã‚¹ã‚¿ã‚¤ãƒ«ã¯åˆ†é›¢ã—ã¦ç¶­æŒ */
#locationAscii, #dialogueNpcAscii, .ascii-art-container {
  min-height: 100px;
  display: flex;
  justify-content: center;
  align-items: center;
}
#dialogueNpcAscii {
    min-height: 120px;
}
.ascii-art-container {
  font-size: 1em;
}

#charBody img {
  max-width: 100%; /* ã‚³ãƒ³ãƒ†ãƒŠã®å¹…ã«åˆã‚ã›ã¦æœ€å¤§ã‚µã‚¤ã‚ºã‚’åˆ¶é™ */
  max-height: 100%; /* ã‚³ãƒ³ãƒ†ãƒŠã®é«˜ã•ã«åˆã‚ã›ã¦æœ€å¤§ã‚µã‚¤ã‚ºã‚’åˆ¶é™ */
  object-fit: contain; /* ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒã—ãŸã¾ã¾ã‚³ãƒ³ãƒ†ãƒŠã«åã‚ã‚‹ */
  border: 3px solid transparent;
  box-sizing: border-box;
  border-radius: 5px;
  transition: border-color 0.5s ease;
}

/* ä¿®æ­£: imgè¦ç´ ã‹ã‚‰æ ç·šã®æŒ‡å®šã‚’å‰Šé™¤ */
#combatPlayerAscii img, #combatEnemyAscii img {
  border-radius: 3px; /* æ ç·šã®å†…å´ã«åã¾ã‚‹ã‚ˆã†ã«å°‘ã—ã ã‘è§’ã‚’ä¸¸ã‚ã‚‹ */
  /* ä»¥ä¸‹ã®ã‚¹ã‚¿ã‚¤ãƒ«ã¯å¤‰æ›´å‰ã®ã‚‚ã®ã‚’å¼•ãç¶™ãã¾ã™ */
  max-width: 100%;
  height: 100%;
  width: auto;
  object-fit: contain;
}
/* â–²â–²â–² ç½®ãæ›ãˆã“ã“ã¾ã§ â–²â–²â–² */
.hp-high { color: #eee; }
.hp-medium { color: #f1c40f; }
.hp-low { color: #e67e22; }
.hp-critical { color: #e74c3c; }


#comparisonModal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #333;
    color: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.6);
    z-index: 2001;
    font-family: sans-serif;
    width: 450px;
}
#comparisonModal h3 {
    text-align: center;
    margin-top: 0;
    margin-bottom: 15px;
    border-bottom: 1px solid #555;
    padding-bottom: 10px;
}
.comparison-container {
    display: flex;
    justify-content: space-between;
    margin-bottom: 20px;
}
.comparison-item {
    width: 48%;
    padding: 10px;
    box-sizing: border-box;
    background: #222;
    border-radius: 5px;
    text-align: center;
}
.comparison-item h4 {
    margin: 0 0 10px 0;
    font-size: 1em;
}
.comparison-item-graphic {
    font-size: 2.5em;
    margin-bottom: 10px;
}
.comparison-item-name {
    font-weight: bold;
    margin-bottom: 10px;
}
.comparison-stats {
    text-align: left;
    font-size: 0.9em;
}
.comparison-stats div {
    margin-bottom: 5px;
}
.stat-positive { color: limegreen; }
.stat-negative { color: indianred; }
.stat-neutral { color: #ccc; }
.comparison-actions {
    text-align: right;
}
.comparison-actions button {
    background: #444;
    color: #eee;
    border: none;
    padding: 8px 15px;
    border-radius: 5px;
    cursor: pointer;
    margin-left: 10px;
}
.comparison-actions button:hover {
    background: #666;
}
#dialoguePanel {
    width: 500px;
    height: 350px;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 1001;
}
#dialogueContent {
    display: flex;
    height: calc(100% - 30px);
    padding-top: 10px;
}
#dialogueNPC {
    flex: 1;
    text-align: center;
}
#dialogueNPC pre {
    font-size: 2.5em;
}
#dialogueTextContainer {
    flex: 2;
    display: flex;
    flex-direction: column;
    padding: 0 10px;
}
#dialogueText {
    flex-grow: 1;
    background: #111;
    padding: 10px;
    border: 1px solid #444;
    border-radius: 4px;
    margin-bottom: 10px;
    overflow-y: auto;
}
#dialogueActions {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
}
#dialogueActions button {
    padding: 10px;
    background-color: #444;
    color: #eee;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}
#dialogueActions button:hover {
    background: #666;
}
#tradePanel, #storagePanel {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 70vw;
    max-width: 750px;
    height: 90vh;
    max-height: 750px;
    z-index: 1002;
    display: flex;
    flex-direction: column;
}
.trade-main, .storage-main {
    display: flex;
    flex-grow: 1;
    gap: 10px;
    overflow: hidden;
}
.trade-column, .storage-column {
    flex: 1;
    display: flex;
    flex-direction: column;
    background: #333;
    padding: 10px;
    border-radius: 5px;
}
.trade-area {
    border: 2px dashed #555;
    min-height: 120px;
    flex-shrink: 0;
    padding: 5px;
    border-radius: 4px;
    overflow-y: auto;
}
.storage-area {
    flex-grow: 1;
    overflow-y: auto;
    border: 1px solid #555;
    padding: 5px;
    border-radius: 4px;
}
.trade-inventory, .storage-inventory {
    flex-grow: 1;
    overflow-y: auto;
    border-top: 1px solid #555;
    margin-top: 10px;
    padding-top: 10px;
}
.trade-footer, .storage-footer {
    padding-top: 10px;
    text-align: center;
}
.trade-footer button, .storage-footer button {
    padding: 10px 20px;
    margin: 0 5px;
}
.trade-value {
    font-weight: bold;
    margin: 5px 0;
}
#suicideBtn {
    width: 100%;
    padding: 8px;
    margin-top: 10px;
    background-color: #a04040;
    color: #eee;
    border: 1px solid #c06060;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
}
#suicideBtn:hover {
    background-color: #c0392b;
}
/* â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦è¿½åŠ  â–¼â–¼â–¼ */
#waitTurnBtn {
    width: 100%;
    padding: 8px;
    margin-top: 5px; /* ä¸Šã®ãƒœã‚¿ãƒ³ã¨ã®é–“éš”ã‚’èª¿æ•´ */
    background-color: #4a4a52;
    color: #eee;
    border: 1px solid #666;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
}
/* â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦CSSå†…ã«è¿½åŠ  â–¼â–¼â–¼ */
#sleepNowBtn {
    width: 100%;
    padding: 8px;
    margin-top: 5px;
    background-color: #4a4a52;
    color: #eee;
    border: 1px solid #666;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
}
#sleepNowBtn:hover {
    background-color: #6c6c74;
}
/* â–²â–²â–² ã“ã“ã¾ã§ â–²â–²â–² */
#waitTurnBtn:hover {
    background-color: #6c6c74;
}
/* â–²â–²â–² ã“ã“ã¾ã§ â–²â–²â–² */
#locationActions {
    margin-top: 10px;
    border-top: 1px solid #555;
    padding-top: 5px;
}
#locationActions button {
    width: 100%;
    padding: 6px;
    margin-top: 5px;
    background: #4a4a52;
    color: #eee;
    border: 1px solid #666;
    border-radius: 3px;
    cursor: pointer;
}
#locationActions button:hover:not(:disabled) {
    background: #6c6c74;
}
#locationActions button:disabled {
    background: #333;
    color: #777;
    cursor: not-allowed;
}
#movementControls {
    margin-top: 5px;
    display: flex;
    justify-content: space-between;
}
#movementControls button {
    flex-grow: 1;
    font-size: 10px;
    padding: 3px;
    margin: 0 1px;
    border: 1px solid #666;
    background: #4a4a52;
    color: #eee;
    cursor: pointer;
}
#movementControls button.active {
    background: #2ecc71;
    border-color: #27ae60;
    color: #111;
}

/* --- Weather Animation --- */
#weather-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 9998;
  overflow: hidden;
  display: none;
}

.drop {
  position: absolute;
  bottom: 100%;
  width: 2px;
  height: 80px;
  background: linear-gradient(to bottom, rgba(255, 255, 255, 0), rgba(170, 180, 200, 0.4));
  animation: fall linear infinite;
}

#weather-container.storm .drop {
    width: 3px;
    height: 120px;
    animation-name: fall-storm;
}

#lightning-flash {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: #fff;
    opacity: 0;
    z-index: 9999;
    pointer-events: none;
}

#lightning-flash.active {
    animation: lightning-strike 0.3s ease-out;
}

@keyframes fall {
  to {
    transform: translateY(120vh);
  }
}

@keyframes fall-storm {
  to {
    transform: translate(-30vw, 120vh); /* æ–œã‚ã«ç§»å‹• */
  }
}

@keyframes lightning-strike {
  0% { opacity: 0; }
  10% { opacity: 0.8; }
  15% { opacity: 0.2; }
  20% { opacity: 0.9; }
  100% { opacity: 0; }
}
/* --- Cloud Animation --- */
#cloud-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 9997; /* é›¨ã‚ˆã‚Šä¸‹ã€èƒŒæ™¯ã‚ˆã‚Šä¸Š */
  overflow: hidden;
  display: none; /* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯éè¡¨ç¤º */
}

.cloud {
  position: absolute;
  background: #d4d9de;
  border-radius: 100px;
  opacity: 0.25; /* ã†ã£ã™ã‚‰ã¨ã—ãŸé›² */
  animation: move-cloud linear infinite;
  width: 200px;
  height: 60px;
}
#version-display {
  position: fixed; /* ç”»é¢ã«å›ºå®šè¡¨ç¤º */
  bottom: 10px;    /* ç”»é¢ä¸‹ã‹ã‚‰10pxã®ä½ç½® */
  right: 10px;     /* ç”»é¢å³ã‹ã‚‰10pxã®ä½ç½® */
  font-family: monospace;
  font-size: 12px;
  color: #555;      /* ç›®ç«‹ã¡ã™ããªã„è‰² */
  z-index: 10001;  /* ãƒ¡ãƒ‹ãƒ¥ãƒ¼ç”»é¢ã‚ˆã‚Šæ‰‹å‰ã«è¡¨ç¤º */
}
/* é›²ã®ãµã‚ãµã‚ã—ãŸå½¢ã‚’ç–‘ä¼¼è¦ç´ ã§ä½œæˆ */
.cloud:before, .cloud:after {
  content: '';
  position: absolute;
  background: #d4d9de;
  width: 100px;
  height: 80px;
  top: -40px;
  left: 25px;
  border-radius: 100px;
  transform: rotate(30deg);
}

.cloud:after {
  width: 120px;
  height: 120px;
  top: -65px;
  left: auto;
  right: 15px;
}

@keyframes move-cloud {
  0% {
    transform: translateX(-300px); /* ç”»é¢å·¦å¤–ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆ */
  }
  100% {
    transform: translateX(110vw); /* ç”»é¢å³å¤–ã¸ç§»å‹• */
  }
}

/* --- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®éœ‡ãˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ --- */
@keyframes player-shake {
  0% {
    transform: translateX(0px);
  }
  25% {
    transform: translateX(-2px); /* å·¦ã«å°‘ã—ç§»å‹• */
  }
  50% {
    transform: translateX(0px);
  }
  75% {
    transform: translateX(2px); /* å³ã«å°‘ã—ç§»å‹• */
  }
  100% {
    transform: translateX(0px);
  }
}
/* --- ã‚¾ãƒ³ãƒ“ã®æ­©è¡Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ --- */
/* --- ã‚¾ãƒ³ãƒ“ã®æ­©è¡Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ --- */
@keyframes zombie-walk {
  /* ---> å³ã¸ç§»å‹• (å³å‘ãã«åè»¢) */
  0% {
    transform: translateX(0px) scaleX(-1) rotate(1deg);
  }
  25% {
    /* å°‘ã—æºã‚ŒãªãŒã‚‰ç§»å‹• */
    transform: translateX(50px) scaleX(-1) translateY(-4px) rotate(-2deg);
  }
  49.9% {
    /* æœ¨ã®æ‰‹å‰ã§åœæ­¢ */
    transform: translateX(100px) scaleX(-1) translateY(2px) rotate(2deg);
  }

  /* <--- å·¦ã¸ç§»å‹• (é€šå¸¸å‘ã) */
  50% {
    /* ç¬æ™‚ã«å‘ãã‚’æˆ»ã™ */
    transform: translateX(100px) scaleX(1) rotate(1deg);
  }
  75% {
    /* å°‘ã—æºã‚ŒãªãŒã‚‰ç§»å‹• */
    transform: translateX(50px) scaleX(1) translateY(-3px) rotate(2deg);
  }
  100% {
    transform: translateX(0px) scaleX(1) translateY(1px) rotate(-1deg);
  }
}

/* --- ç„šãç«ã®ãƒ¡ãƒ©ãƒ¡ãƒ©ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ --- */
@keyframes fire-flicker {
  0% {
    transform: scale(1);
    opacity: 1;
  }
  25% {
    transform: scale(1.02) translateY(-1px);
    opacity: 0.98;
  }
  50% {
    transform: scale(0.98) translateY(0px);
    opacity: 1.02;
  }
  75% {
    transform: scale(1.01) translateY(-1.5px);
    opacity: 0.95;
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}
/* â–¼â–¼â–¼ æ—¢å­˜ã®ç ”ç©¶UIé–¢é€£ã®CSSã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼ */
#researchPanel {
    top: 50px;
    left: 50%;
    transform: translateX(-50%);
    width: 850px;
    height: 600px;
}
#researchTreeContainer {
    flex-grow: 1;
    position: relative;
    overflow: auto;
    min-height: 0;
}
#researchTreeLines {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
}
#researchTreeLines path {
    stroke: #555;
    stroke-width: 2px;
    fill: none;
}
/* ç ”ç©¶ãƒ„ãƒªãƒ¼å…¨ä½“ã®ã‚³ãƒ³ãƒ†ãƒŠ */
#researchTreeNodes {
    position: relative;
    display: flex; /* â˜…Flexboxãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã«å¤‰æ›´ */
    gap: 80px;     /* â˜…ç ”ç©¶ãƒ„ãƒªãƒ¼ã®ã€Œæ¨ªã€ã®é–“éš” */
    padding: 50px;
    width: auto;   /* è‡ªå‹•å¹…ã« */
    height: auto;  /* è‡ªå‹•é«˜ã•ã« */
}

/* ç ”ç©¶é …ç›®ã®åˆ—ï¼ˆæ–°ã—ãè¿½åŠ ï¼‰ */
.research-column {
    display: flex;
    flex-direction: column;
    width: 320px; /* åˆ—ã®å¹…ã¯å›ºå®š */
}
/* å„ç ”ç©¶é …ç›® */
.research-node {
    /* â˜…position: absolute; ã¨ left, top ã‚’å‰Šé™¤ */
    width: 100%; /* è¦ªã®åˆ—ã«å¹…ã‚’åˆã‚ã›ã‚‹ */
    min-height: 150px;
    background: #2a2a2a;
    border: 2px solid #555;
    border-radius: 8px;
    padding: 10px;
    padding-bottom: 25px;
    box-sizing: border-box;
    transition: all 0.3s ease;
    cursor: default;
    display: flex;
    flex-direction: column;
    position: relative;
}

.research-node.locked {
    opacity: 0.5;
}
.research-node.available {
    border-color: #f1c40f;
    cursor: pointer;
}
.research-node.available:hover {
    background: #3a3a3a;
    transform: scale(1.02);
}
.research-node.in-progress {
    border-color: #3498db;
    box-shadow: 0 0 15px #3498db80;
}
.research-node.completed {
    border-color: #2ecc71;
    background: #233b23;
}
.research-node-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 5px;
    flex-shrink: 0;
}
.research-node-header h3 {
    margin: 0;
    font-size: 1.1em;
}
.research-node-cost {
    font-size: 0.85em;
    color: #aaa;
    flex-shrink: 0;
}
.research-node-desc {
    font-size: 0.8em;
    color: #ccc;
    margin-top: 8px;
    flex-shrink: 0;
}
.research-node-unlocks {
    margin-top: 10px;
    padding-top: 8px;
    border-top: 1px solid #444;
    flex-shrink: 0;
}
.research-node-unlocks strong {
    font-size: 0.85em;
    margin-bottom: 5px;
    display: block;
}
.research-unlock-icons {
    display: flex;
    gap: 4px;
    overflow-x: auto; /* ã‚¢ã‚¤ã‚³ãƒ³ãŒå¤šã„å ´åˆã¯æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ« */
    padding-bottom: 5px;
}
/* æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã®ã‚¹ã‚¿ã‚¤ãƒ« */
.research-unlock-icons::-webkit-scrollbar {
    height: 5px;
}
.research-unlock-icons::-webkit-scrollbar-track {
    background: #222;
}
.research-unlock-icons::-webkit-scrollbar-thumb {
    background: #555;
    border-radius: 2px;
}
.unlock-icon {
    width: 32px;
    height: 32px;
    background: rgba(0,0,0,0.3);
    border: 1px solid #555;
    border-radius: 4px;
    cursor: help;
    flex-shrink: 0;
}
.research-progress-bar-container {
    position: absolute;
    bottom: 10px; /* â˜…è¦ç´ ã®å†…å´ã«é…ç½®ã™ã‚‹ã‚ˆã†ã«å¤‰æ›´ */
    left: 10%;
    width: 80%;
    height: 8px;
    background: #111;
    border-radius: 4px;
    border: 1px solid #555;
    overflow: hidden;
}
.research-progress-bar {
    width: 0%;
    height: 100%;
    background: #3498db;
    transition: width 0.3s ease;
}
.research-completed-check {
    width: 24px;
    height: 24px;
    margin-left: auto;
    color: #2ecc71;
}
.research-conduct-btn {
    width: 100%;
    padding: 6px;
    margin-top: 10px;
    background-color: #3498db;
    color: #fff;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-weight: bold;
    transition: background-color 0.2s;
    font-size: 0.9em;
    flex-shrink: 0;
}
.research-conduct-btn:hover {
    background-color: #2980b9;
}
.panel-footer {
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px solid #555;
    text-align: right;
    flex-shrink: 0; /* ãƒ‘ãƒãƒ«ãŒç¸®ã‚“ã§ã‚‚ãƒ•ãƒƒã‚¿ãƒ¼ã®é«˜ã•ã‚’ç¶­æŒ */
}
.panel-footer button {
    background: #444;
    color: #eee;
    border: none;
    padding: 8px 15px;
    border-radius: 5px;
    cursor: pointer;
}
.panel-footer button:hover {
    background: #666;
}
/* â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’<style>ã‚¿ã‚°ã®æœ«å°¾ã«è¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼ */
@keyframes shake {
  10%, 90% { transform: translateX(-1px); }
  20%, 80% { transform: translateX(2px); }
  30%, 50%, 70% { transform: translateX(-4px); }
  40%, 60% { transform: translateX(4px); }
}

.shake-animation {
  animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
}
/* â–¼â–¼â–¼ èº«ä½“ç”»åƒãƒ‘ãƒãƒ«ã®ã‚¹ãƒ­ãƒƒãƒˆç”¨CSSã‚’è¿½åŠ  â–¼â–¼â–¼ */
.body-slot {
    position: absolute;
    width: 36px;
    height: 36px;
    background: rgba(0, 0, 0, 0.5);
    border: 2px dashed #555;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s;
}
.body-slot:hover {
    background: rgba(255, 255, 255, 0.1);
    border-style: solid;
}
/* â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼ */
/* --- èº«ä½“ãƒ‘ãƒãƒ«ã®ã‚¹ãƒ­ãƒƒãƒˆä½ç½® --- */
#bodySlotHead {
    top: 30px;
    left: 159px;
}
#bodySlotEyes {
    top: 30px;
    left: 209px;
}
#bodySlotBodyOuter {
    top: 142px;
    left: 179px;
}
#bodySlotBodyInner1 { /* ã‚¤ãƒ³ãƒŠãƒ¼2ã®å·¦éš£ */
    top: 194px;
    left: 131px;
}
#bodySlotBodyInner2 {
    top: 194px; 
    left: 179px;
}
#bodySlotBodyInner3 { /* ã‚¤ãƒ³ãƒŠãƒ¼2ã®å³éš£ */
    top: 194px;
    left: 227px;
}
#bodySlotBack {
    top: 123px;
    left: 129px;
}
#bodySlotPochette {
    top: 248px;
    left: 179px;
}
#bodySlotLegs {
    top: 385px;
    left: 250px;
}
#bodySlotLeftFoot { /* æ—§: è¶³ã‚¹ãƒ­ãƒƒãƒˆ */
    top: 537px;
    left: 152px;
}
#bodySlotRightFoot {
    top: 537px;
    left: 298px;
}
#bodySlotWrist {
    top: 233px;
    left: 83px;
}
#bodySlotMainHand { /* ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å³æ‰‹ */
    top: 281px;
    left: 304px;
}
#bodySlotOffHand { /* ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å·¦æ‰‹ */
    top: 281px;
    left: 83px;
}
#bodySlotLeftPalm { /* å·¦æ‰‹ã®å·¦éš£ */
    top: 281px;
    left: 35px;
}
#bodySlotRightPalm { /* å³æ‰‹ã®å³éš£ */
    top: 281px;
    left: 352px;
}
#bodySlotNeck {
    top: 78px;
    left: 159px;
}
#bodySlotMouth {
    top: 67px;
    left: 209px;
}
/* â–²â–²â–² ç½®ãæ›ãˆã¯ã“ã“ã¾ã§ â–²â–²â–² */
#bodyPanel .resize-handle {
    display: none;
}
/* â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’<style>ã‚¿ã‚°ã®æœ«å°¾ã«è¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼ */
#placedObjectsList {
    display: flex;
    flex-direction: row; /* æ¨ªæ–¹å‘ã«ä¸¦ã¹ã‚‹ */
    flex-wrap: wrap;     /* ã‚¹ãƒšãƒ¼ã‚¹ãŒãªã‘ã‚Œã°æŠ˜ã‚Šè¿”ã™ */
    gap: 8px;            /* ã‚¢ã‚¤ã‚³ãƒ³é–“ã®ã‚¹ãƒšãƒ¼ã‚¹ */
    margin-top: 8px;
    padding: 0;
    background: none;
    border-top: 1px solid #555; /* åŒºåˆ‡ã‚Šç·šã‚’è¿½åŠ  */
    padding-top: 8px;
}
.facility-slot-icon {
    width: 48px;
    height: 48px;
    background: rgba(0, 0, 0, 0.4);
    border: 2px solid #555;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s;
    object-fit: contain; /* ç”»åƒãŒæ å†…ã«åã¾ã‚‹ã‚ˆã†ã« */
    padding: 4px;
    box-sizing: border-box;
}
.facility-slot-icon:hover {
    background: rgba(255, 255, 255, 0.1);
    border-color: #888;
    transform: scale(1.05);
}
.status-value {
  white-space: nowrap; /* ãƒ†ã‚­ã‚¹ãƒˆãŒæŠ˜ã‚Šè¿”ã•ãªã„ã‚ˆã†ã«å¼·åˆ¶ã—ã¾ã™ */
}
/* --- æ¢ç´¢ãƒ‘ãƒãƒ«ã®å»ºç‰©è¡¨ç¤ºã‚¹ã‚¿ã‚¤ãƒ« --- */
.exploration-item {
    display: flex;
    flex-direction: column; /* ç”»åƒã¨ãƒ†ã‚­ã‚¹ãƒˆã‚’ç¸¦ã«ä¸¦ã¹ã‚‹ */
    align-items: center;   /* ä¸­å¤®æƒãˆ */
    cursor: pointer;
    padding: 5px;
    border-radius: 8px;
    transition: all 0.2s ease;
    width: 140px; /* ã‚³ãƒ³ãƒ†ãƒŠã®å¹…ã‚’å›ºå®š */
}
.exploration-item:hover {
    background: rgba(255, 255, 255, 0.1);
}
.exploration-item img {
    width: 128px;
    height: 128px;
    border: 3px solid #555;
    border-radius: 8px;
    object-fit: contain;
    background: rgba(0,0,0,0.3);
    image-rendering: pixelated;
}
.exploration-item p {
    margin-top: 5px; /* ç”»åƒã¨ãƒ†ã‚­ã‚¹ãƒˆã®é–“éš” */
    font-size: 14px;
    text-align: center;
    color: #eee;
    margin-bottom: 0;
}
/* æ¢ç´¢ãƒ‘ãƒãƒ«å†…ã®è¤‡æ•°ç”»åƒã®ã¼ã‚„ã‘ã‚’ä¿®æ­£ */
#explorationContent img {
    image-rendering: pixelated; /* ãƒ‰ãƒƒãƒˆçµµã‚’ã‚¯ãƒƒã‚­ãƒªè¡¨ç¤ºã•ã›ã‚‹è¨­å®š */
    width: 128px;
    height: 128px;
    border: 3px solid #555;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
    object-fit: contain;
    background: rgba(0,0,0,0.3);
}

/* æ¢ç´¢ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ‘ãƒãƒ«å†…ã®å˜ä¸€ç”»åƒã®ã¼ã‚„ã‘ã‚’ä¿®æ­£ */
#explorationPreviewImage {
    image-rendering: pixelated; /* ãƒ‰ãƒƒãƒˆçµµã‚’ã‚¯ãƒƒã‚­ãƒªè¡¨ç¤ºã•ã›ã‚‹è¨­å®š */
}
/* ã€ã“ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¿½åŠ ã€‘ */
#devItemList .item.selected {
    background: #2980b9;
    border: 1px solid #3498db;
}
/* â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ–°ã—ã<style>ã‚¿ã‚°å†…ã«è¿½åŠ  â–¼â–¼â–¼ */
#externalLinksContainer {
    position: fixed;
    bottom: 20px;
    right: 20px;
    text-align: right;
    font-family: sans-serif;
    z-index: 10001;
}

#externalLinksContainer h4 {
    margin: 0 0 5px 0;
    color: #888;
    font-weight: normal;
}

#externalLinksContainer a {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    margin: 8px 0;
    color: #ccc;
    text-decoration: none;
    transition: color 0.2s;
}

#externalLinksContainer a:hover {
    color: #fff;
    text-decoration: underline;
}

#externalLinksContainer img {
    width: 20px;
    height: 20px;
    margin-left: 10px;
}
/* æ–°ã—ãè¿½åŠ : ç”»åƒã‚’å›²ã¿ã€æ ç·šã‚’æ‹…å½“ã™ã‚‹ãƒ©ãƒƒãƒ‘ãƒ¼ */
.combat-image-wrapper {
    display: inline-flex; /* ä¸­ã®ç”»åƒã«åˆã‚ã›ã¦ã‚µã‚¤ã‚ºãŒç¸®ã¾ã‚‹ã‚ˆã†ã«ã™ã‚‹ */
    border: 3px solid transparent;
    border-radius: 5px;
    transition: border-color 0.5s ease;
    /* ã‚³ãƒ³ãƒ†ãƒŠã‹ã‚‰ç”»åƒãŒã¯ã¿å‡ºãªã„ã‚ˆã†ã«ã™ã‚‹ */
    max-width: 100%;
    max-height: 100%;
}
.dev-arrow {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  border-left: 10px solid transparent;
  border-right: 10px solid transparent;
  border-bottom-width: 20px;
  border-bottom-style: solid;
  transform-origin: 50% 100%;
  z-index: 49; /* ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚ˆã‚Šå°‘ã—å¾Œã‚ */
  display: none; /* é€šå¸¸ã¯éè¡¨ç¤º */
}
/* â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ–°ã—ãè¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼ */
#dev-arrow-labels {
  position: absolute;
  top: 60%;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.7);
  color: #fff;
  padding: 8px 12px;
  border-radius: 5px;
  font-family: monospace;
  font-size: 12px;
  line-height: 1.5;
  text-align: left;
  z-index: 100;
  pointer-events: none; /* ã“ã®ãƒ†ã‚­ã‚¹ãƒˆè‡ªä½“ã¯ã‚¯ãƒªãƒƒã‚¯ã§ããªã„ã‚ˆã†ã«ã™ã‚‹ */
  display: none; /* é€šå¸¸ã¯éè¡¨ç¤º */
}
/* æˆ¦é—˜ãƒ»ä¼šè©±ãƒ‘ãƒãƒ«ã®ãƒãƒ¼ãƒˆãƒ¬ãƒ¼ãƒˆç”»åƒç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« */
#combatPlayerAscii img, #combatEnemyAscii img, #dialogueNpcAscii img {
  max-width: 100%; /* ã‚³ãƒ³ãƒ†ãƒŠã®å¹…ã«åˆã‚ã›ã¦æœ€å¤§ã‚µã‚¤ã‚ºã‚’åˆ¶é™ */
  height: 100%; /* ã‚³ãƒ³ãƒ†ãƒŠã®é«˜ã•ä¸€æ¯ã«ç”»åƒã‚’å¼•ãä¼¸ã°ã™ */
  width: auto; /* é«˜ã•ã«åˆã‚ã›ã¦å¹…ã‚’è‡ªå‹•èª¿æ•´ã—ã€ç¸¦æ¨ªæ¯”ã‚’ç¶­æŒã™ã‚‹ */
  object-fit: contain; /* ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒã—ãŸã¾ã¾ã‚³ãƒ³ãƒ†ãƒŠã«åã‚ã‚‹ */
}

/* ãƒãƒ¼ãƒˆãƒ¬ãƒ¼ãƒˆç”»åƒã‚’å›²ã‚€ã‚³ãƒ³ãƒ†ãƒŠã‚’æ‹¡å¼µå¯èƒ½ã«ã™ã‚‹ */
#combatPlayerAscii, #combatEnemyAscii, #dialogueNpcAscii {
    flex-grow: 1; /* ç©ºãã‚¹ãƒšãƒ¼ã‚¹ã‚’åŸ‹ã‚ã‚‹ã‚ˆã†ã«æ‹¡å¼µ */
    min-height: 0; /* æœ€å°é«˜ã•ã®åˆ¶é™ã‚’è§£é™¤ */
}

/* æˆ¦é—˜ç”»é¢ã®ç”»åƒã‚³ãƒ³ãƒ†ãƒŠã«è¨­å®šã•ã‚ŒãŸmin-heightã‚’ä¸Šæ›¸ãã—ã¦é«˜ã•ã‚’æƒãˆã‚‹ */
#combatPlayerAscii, #combatEnemyAscii {
    min-height: auto;
}
/* â–²â–²â–² è¿½åŠ ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–² */
</style>
</head>
<body>
  <div id="background-layer-1" class="background-layer"></div>
  <div id="background-layer-2" class="background-layer"></div>
<div id="weather-container"></div>
<div id="lightning-flash"></div>
<div id="cloud-container"></div>

<div id="startScreen" style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; background-color: #000; color: #f0f0f0; font-family: 'Press Start 2P', cursive; text-align: center;">
    <h1 style="font-size: 3em; margin-bottom: 20px;" data-translate-key="game_title">Despair Survival</h1>
    
    <div id="startScreenImageContainer" style="position: relative; width: 80%; max-width: 800px; height: 150px; margin-bottom: 30px; overflow: hidden;">
        <img src="images/campfire_kit_title.png" style="position: absolute; bottom: 0; left: 40%; width: 50px; height: 50px; object-fit: contain; image-rendering: auto; z-index: 2; animation: fire-flicker 1.5s ease-in-out infinite alternate;">
        
        <img src="images/player_male_title.png" style="position: absolute; bottom: 0; left: 20%; width: 100px; height: 100px; object-fit: contain; image-rendering: auto; z-index: 2; animation: player-shake 0.3s ease-in-out infinite alternate;">
        
        <img id="animatedZombie" src="images/zombie_title.png" style="position: absolute; bottom: 0; left: 50%; width: 100px; height: 100px; object-fit: contain; image-rendering: auto; z-index: 2; animation: zombie-walk 15s linear infinite alternate;">
        
        <img id="animatedForest" src="images/forest_title.png" style="position: absolute; bottom: 0; right: 5%; width: 135px; height: 135px; object-fit: contain; image-rendering: auto; z-index: 1;">
    </div>
    <div style="display: flex; flex-direction: column; gap: 15px; width: 250px;">
        <button id="startGameBtn" class="menu-button" data-translate-key="btn_new_game">New Game</button>
        <button id="loadGameBtn" class="menu-button" data-translate-key="btn_load_game">Load Game</button>
        <button id="optionsBtn" class="menu-button" data-translate-key="btn_options">Options</button>
        <button id="exitGameBtn" class="menu-button" data-translate-key="btn_exit_game">Exit Game</button>
    </div>
    <div id="externalLinksContainer">
    <h4>Links:</h4>
    <a href="https://patreon.com/DespairSurvival?utm_medium=unknown&utm_source=join_link&utm_campaign=creatorshare_creator&utm_content=copyLink" target="_blank">
        Support game on Patreon
        <img src="images/patreon_logo.png" alt="Patreon">
    </a>
    <a href="https://molotov-cocktail-gaming.itch.io/despair-survival-en" target="_blank">
        Official itch.io page
        <img src="images/itchio_logo.png" alt="itch.io">
    </a>
    <a href="https://discord.gg/2t3fWcqN9r" target="_blank">
        Discord server
        <img src="images/discord_logo.png" alt="Discord">
    </a>
    <a href="https://x.com/DespairSurviva" target="_blank">
        X
        <img src="images/x_logo.png" alt="X">
    </a>
</div>
</div>

<div id="optionsScreen" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #111; color: #eee; z-index: 10000; flex-direction: column; justify-content: center; align-items: center; text-align: center; font-family: sans-serif;">
    <h1 data-translate-key="options_title">ã‚ªãƒ—ã‚·ãƒ§ãƒ³</h1>
<div style="margin-top: 25px; font-size: 1.2em; border-top: 1px solid #444; padding-top: 15px; width: 80%; max-width: 400px;">
    <label for="volumeSlider" data-translate-key="volume_control">ç’°å¢ƒéŸ³ã®éŸ³é‡</label>
    <div style="display: flex; align-items: center; justify-content: center; margin-top: 10px;">
        <span>ğŸ”‡</span>
        <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="0.4" style="width: 80%; margin: 0 10px;">
        <span>ğŸ”Š</span>
    </div>
</div>
<div style="margin-top: 25px; font-size: 1.2em; border-top: 1px solid #444; padding-top: 15px; width: 80%; max-width: 400px;">
        <label for="voiceVolumeSlider" data-translate-key="voice_volume_control">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å£°ã®éŸ³é‡</label>
        <div style="display: flex; align-items: center; justify-content: center; margin-top: 10px;">
            <span>ğŸ”‡</span>
            <input type="range" id="voiceVolumeSlider" min="0" max="1" step="0.01" value="0.7" style="width: 80%; margin: 0 10px;">
            <span>ğŸ”Š</span>
        </div>
    </div>
<div style="margin-top: 25px; font-size: 1.2em; border-top: 1px solid #444; padding-top: 15px; width: 80%; max-width: 400px;">
    <label for="combatBgmVolumeSlider" data-translate-key="combat_bgm_volume_control">æˆ¦é—˜BGMã®éŸ³é‡</label>
    <div style="display: flex; align-items: center; justify-content: center; margin-top: 10px;">
        <span>ğŸ”‡</span>
        <input type="range" id="combatBgmVolumeSlider" min="0" max="1" step="0.01" value="0.5" style="width: 80%; margin: 0 10px;">
        <span>ğŸ”Š</span>
    </div>
</div>
    <div style="margin-top: 25px; font-size: 1.2em; border-top: 1px solid #444; padding-top: 15px; width: 80%; max-width: 400px;">
        <label for="speechVolumeSlider" data-translate-key="speech_volume_control">Text-to-Speech Volume</label>
        <div style="display: flex; align-items: center; justify-content: center; margin-top: 10px;">
            <span>ğŸ”‡</span>
            <input type="range" id="speechVolumeSlider" min="0" max="1" step="0.01" value="0.8" style="width: 80%; margin: 0 10px;">
            <span>ğŸ”Š</span>
        </div>
    </div>

<div id="languageSwitcher" style="margin-top: 25px; border-top: 1px solid #444; padding-top: 15px;">
        <button id="langBtnJa">æ—¥æœ¬èª</button>
        <button id="langBtnEn">English</button>
        <button id="langBtnZh">ç®€ä½“ä¸­æ–‡</button>
    </div>

    <div id="options-footer-buttons" style="margin-top: 40px;">
        <button id="applySettingsBtn" data-translate-key="btn_apply" style="padding: 15px 30px; font-size: 1.5em; background: #27ae60; color: #fff; border: 1px solid #2ecc71; border-radius: 8px; cursor: pointer; margin: 0 10px;">é©ç”¨</button>
        <button id="backToMenuBtn" data-translate-key="btn_cancel" style="padding: 15px 30px; font-size: 1.5em; background: #333; color: #eee; border: 1px solid #555; border-radius: 8px; cursor: pointer; margin: 0 10px;">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
    </div>
</div>
<div id="gameClearScreen" style="display: none;">
    <pre id="gateArt" class="gate-art"></pre>
    <h2 id="clearHeader" data-translate-key="game_clear_header">GAME CLEAR</h2>
    <p id="clearMessage"></p>
    <button id="playAgainBtn" data-translate-key="btn_play_again">ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤</button>
</div>


<div id="mapPanel" class="panel" style="top:10px; left:10px; width:542px; height:572px; display:flex; flex-direction: column;">
  <div class="panel-header">
    <span data-translate-key="map_panel_title">ãƒãƒƒãƒ—</span>
    <span id="mapHeaderInfo"></span>
  </div>
  <div id="map" style="flex:1;"></div>
  <div id="playerDirectionArrow"></div>
  <div id="salvationCityArrow" class="dev-arrow" style="border-bottom-color: yellow;"></div>
  <div id="npcHintArrow" class="dev-arrow" style="border-bottom-color: cyan;"></div>
  <div id="residentialArrow" class="dev-arrow" style="border-bottom-color: #2ecc71;"></div>
  <div id="commercialArrow" class="dev-arrow" style="border-bottom-color: #3498db;"></div>
  <div id="industrialArrow" class="dev-arrow" style="border-bottom-color: #9b59b6;"></div>
  <div id="cabinArrow" class="dev-arrow" style="border-bottom-color: #e67e22;"></div>
  <div id="traderShopArrow" class="dev-arrow" style="border-bottom-color: #f1c40f;"></div>
  <div id="dev-arrow-labels"></div>
  <div class="resize-handle"></div>
</div>

<div id="statusPanel" class="panel" style="top:10px; left:460px; width:420px; height:auto;">
  <div class="panel-header" data-translate-key="status_panel_title">ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</div>
  <div id="status">

    <div class="status-line">
      <span class="status-label" data-translate-key="status_health">ä½“åŠ›</span>
      <div class="bar"><div id="healthBar" class="fill health"></div></div>
      <span id="healthVal" class="status-value"></span>
    </div>
    <div class="status-line">
      <span class="status-label" data-translate-key="status_hunger">ç©ºè…¹</span>
      <div class="bar"><div id="hungerBar" class="fill hunger"></div></div>
      <span id="hungerVal" class="status-value"></span>
    </div>
    <div class="status-line">
      <span class="status-label" data-translate-key="status_thirst">æ¸‡ã</span>
      <div class="bar"><div id="thirstBar" class="fill thirst"></div></div>
      <span id="thirstVal" class="status-value"></span>
    </div>
    <div class="status-line">
      <span class="status-label" data-translate-key="status_sleep">ç¡çœ </span>
      <div class="bar"><div id="sleepBar" class="fill sleep"></div></div>
      <span id="sleepVal" class="status-value"></span>
    </div>

    <div class="status-line">
      <span class="status-label" data-translate-key="status_morale">æ°—åŠ›</span>
      <div class="bar"><div id="moraleBar" class="fill morale"></div></div>
      <span id="moraleVal" class="status-value"></span>
    </div>
    <div id="bodyTempStatusLine" class="status-line" style="cursor: help;">
      <span class="status-label" data-translate-key="status_body_temp">ä½“æ¸©</span>
      <div class="bar"><div id="bodyTempBar" class="fill bodyTemp"></div></div>
      <span id="bodyTempVal" class="status-value"></span>
    </div>
    <div id="bodyOdorStatusLine" class="status-line" style="cursor: help;">
      <span class="status-label" data-translate-key="status_body_odor">ä½“è‡­</span>
      <div class="bar"><div id="bodyOdorBar" class="fill"></div></div>
      <span id="bodyOdorVal" class="status-value"></span>
    </div>
    <div class="status-line">
      <span class="status-label" data-translate-key="status_blood_level">è¡€æ¶²é‡</span>
      <div class="bar"><div id="bloodLevelBar" class="fill"></div></div>
      <span id="bloodLevelVal" class="status-value"></span>
    </div>
    <div class="status-line">
      <span class="status-label" data-translate-key="status_immune_system">å…ç–«ç³»</span>
      <div class="bar"><div id="immuneSystemBar" class="fill"></div></div>
      <span id="immuneSystemVal" class="status-value"></span>
    </div>
    <div class="status-line">
      <span class="status-label" data-translate-key="status_pain_tolerance">ç—›ã¿è€æ€§</span>
      <div class="bar"><div id="painToleranceBar" class="fill"></div></div>
      <span id="painToleranceVal" class="status-value"></span>
    </div>
    <div class="status-line">
      <span class="status-label" data-translate-key="status_carbs">ç‚­æ°´åŒ–ç‰©</span>
      <div class="bar"><div id="carbsBar" class="fill"></div></div>
      <span id="carbsVal" class="status-value"></span>
    </div>
    <div class="status-line">
      <span class="status-label" data-translate-key="status_protein">ã‚¿ãƒ³ãƒ‘ã‚¯è³ª</span>
      <div class="bar"><div id="proteinBar" class="fill"></div></div>
      <span id="proteinVal" class="status-value"></span>
    </div>
    <div class="status-line">
      <span class="status-label" data-translate-key="status_fat">è„‚è‚ª</span>
      <div class="bar"><div id="fatBar" class="fill"></div></div>
      <span id="fatVal" class="status-value"></span>
    </div>
    <div class="status-line">
      <span class="status-label" data-translate-key="status_vitamins">ãƒ“ã‚¿ãƒŸãƒ³</span>
      <div class="bar"><div id="vitaminsBar" class="fill"></div></div>
      <span id="vitaminsVal" class="status-value"></span>
    </div>

    <div class="status-line">
      <span class="status-label" data-translate-key="status_attack">æ”»æ’ƒåŠ›</span>
      <div class="bar"><div id="attackBar" class="fill attack"></div></div>
      <span id="attackVal" class="status-value"></span>
    </div>
    <div class="status-line">
      <span class="status-label" data-translate-key="status_defense">é˜²å¾¡åŠ›</span>
      <div class="bar"><div id="defenseBar" class="fill defense"></div></div>
      <span id="defenseVal" class="status-value"></span>
    </div>
    <div class="status-line">
      <span class="status-label" data-translate-key="status_weight">é‡ã•</span>
      <div class="bar"><div id="weightBar" class="fill weight"></div></div>
      <span id="weightVal" class="status-value"></span>
    </div>
    <div class="status-line">
        <span class="status-label" data-translate-key="status_volume">å®¹é‡</span>
        <div class="bar"><div id="volumeBar" class="fill volume"></div></div>
        <span id="volumeVal" class="status-value"></span>
    </div>

  </div>
  <div id="physicalCondition"></div>
  <div class="resize-handle"></div>
</div>

<div id="turnPanel" class="panel" style="top:435px; left:460px; width:160px; height:auto;">
  <div class="panel-header" data-translate-key="turn_panel_title">æ™‚é–“</div>
  <div id="turnInfoText"></div>
  <pre id="compass" style="text-align: center; margin-top: 5px; color: #aaa; font-size: 14px; line-height: 1.1;">   N
   |
 W-+-E
   |
   S</pre>
<div id="movementControls">
      <button id="moveWalkBtn" class="active" data-translate-key="move_walk">æ­©è¡Œ</button>
      <button id="moveRunBtn" data-translate-key="move_run">èµ°è¡Œ</button>
  </div>
  <div class="resize-handle"></div>
</div>

<div id="logPanel" class="panel" style="top:300px; left:460px; width:360px; height:125px; overflow-y:auto;">
  <div class="panel-header" data-translate-key="log_panel_title">æ—¥è¨˜</div>
  <div id="log"></div>
  <div class="resize-handle"></div>
</div>

<div id="inventoryPanel" class="panel" style="top:480px; left:10px; width:245px; height:250px; display:flex; flex-direction: column;">
  <div class="panel-header" data-translate-key="inventory_panel_title">æ‰€æŒå“</div>
  <div class="panel-content" style="height: calc(100% - 22px);">
      <div id="inventory" class="item-list"></div>
  </div>
  <div class="resize-handle"></div>
</div>

<div id="equipmentPanel" class="panel" style="top:480px; left:265px; width:245px; height:250px; display:none; flex-direction: column;">
  <div class="panel-header" data-translate-key="equipment_panel_title">è£…å‚™å“</div>
  <div class="panel-content" style="height: calc(100% - 22px);">
      <div id="equipment" class="item-list"></div>
  </div>
  <div class="resize-handle"></div>
</div>
<div id="craftingPanel" class="panel" style="top:480px; left: 520px; width: 300px; height: 250px; display:flex; flex-direction: column;">
    <div class="panel-header" data-translate-key="crafting_panel_title">ã‚¯ãƒ©ãƒ•ãƒˆ</div>
    <div class="panel-content" style="height: calc(100% - 22px);">
        <div id="craftingList" style="max-height: 100%;" class="item-list"></div>
    </div>
    <div class="resize-handle"></div>
</div>


<div id="characterPanel" class="panel" style="top:10px; left:830px; width:220px; height:auto;">
  <div class="panel-header" data-translate-key="character_panel_title">ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼æƒ…å ±</div>
  <div id="characterBasic">
    <div><strong data-translate-key="char_info_name">åå‰</strong>: <span id="charName"></span></div>
    <div><strong data-translate-key="char_info_age">å¹´é½¢</strong>: <span id="charAge"></span> <span data-translate-key="char_info_age_suffix">æ­³</span></div>
    <div><strong data-translate-key="char_info_gender">æ€§åˆ¥</strong>: <span id="charGender"></span></div>
    <div><strong data-translate-key="char_info_job">è·æ¥­</strong>: <span id="charJob"></span></div>
    <div style="margin-top: 5px;"><strong data-translate-key="char_info_race">äººç¨®</strong>: <span id="charRace"></span></div>
    <div style="margin-top: 5px;"><strong data-translate-key="char_info_traits">ç‰¹æ€§</strong>: <span id="charTraits"></span></div>
    <div id="memoryContainer" style="margin-top: 10px; border-top: 1px solid #555; padding-top: 5px;"></div>
  </div>
  <pre id="charBody" class="asciiBody"></pre>
  <button id="suicideBtn" data-translate-key="char_info_suicide_button">è‡ªã‚‰å‘½ã‚’çµ¶ã¤</button>
  <button id="waitTurnBtn" data-translate-key="char_info_wait_button">1ã‚¿ãƒ¼ãƒ³å¾…æ©Ÿ</button>
<button id="openResearchBtn" data-translate-key="btn_research" style="width:100%; padding: 8px; margin-top: 5px; background-color: #4a4a52; color: #eee; border: 1px solid #666; border-radius: 4px; cursor: pointer; font-weight: bold;">ç ”ç©¶</button>
  <button id="sleepNowBtn" data-translate-key="char_info_sleep_button">çœ ã‚‹</button>
<button id="saveGameBtn" data-translate-key="char_info_save_button" style="width:100%; padding: 8px; margin-top: 5px; background-color: #4a524b; color: #eee; border: 1px solid #666; border-radius: 4px; cursor: pointer; font-weight: bold;">ã‚»ãƒ¼ãƒ–</button>
  <button id="ingameOptionsBtn" data-translate-key="options" style="width:100%; padding: 8px; margin-top: 5px; background-color: #4a524b; color: #eee; border: 1px solid #666; border-radius: 4px; cursor: pointer; font-weight: bold;">ã‚ªãƒ—ã‚·ãƒ§ãƒ³</button>
  <button id="saveUILayoutBtn" data-translate-key="btn_save_layout" style="width:100%; padding: 8px; margin-top: 5px; background-color: #4a524b; color: #eee; border: 1px solid #666; border-radius: 4px; cursor: pointer; font-weight: bold;">UIãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’ä¿å­˜</button>
  <div class="resize-handle"></div>
</div>
 <div class="resize-handle"></div>
</div>

<div id="currentLocationPanel" class="panel" style="top:360px; left:830px; width:200px; height:400px; overflow: hidden; display:flex; flex-direction: column;">
  <div class="panel-header" data-translate-key="current_location_panel_title">ç¾åœ¨ã®å ´æ‰€</div>
  <div id="currentLocationBody" class="panel-content">
    <div id="locationName" class="location-name"></div>
<pre id="locationAscii" class="ascii-art"></pre>
    <div id="locationPlacedObjects" style="margin-top: 10px; border-top: 1px solid #555; padding-top: 5px; display: none;">
        <strong id="facilitiesHeader" data-translate-key="location_info_facilities">å°å±‹ã®ä¸­ã®è¨­å‚™:</strong>
        <div id="placedObjectsList" class="item-list" style="margin-top: 5px; background: none; padding: 0;"></div>
    </div>
    <div id="locationActions"></div>
  </div>
<div class="panel-content" style="flex-grow: 1; border-top: 1px solid #555; padding: 5px;">
    <strong data-translate-key="location_info_dropped_items" style="flex-shrink: 0; padding-bottom: 5px;">è½ã¡ã¦ã„ã‚‹ã‚¢ã‚¤ãƒ†ãƒ :</strong>
    <div id="droppedItemsList" class="item-list" style="margin-top: 0;"></div>
  </div>
  <div class="resize-handle"></div>
</div>

<div id="damagePop"></div>
<div id="statusPreview"></div>

<div id="minimapPanel" class="panel" style="top:10px; left:1060px; width:220px; height:240px; display:flex; flex-direction: column;">
  <div class="panel-header" style="display: flex; justify-content: space-between; align-items: center;">
    <span data-translate-key="minimap_panel_title">ãƒŸãƒ‹ãƒãƒƒãƒ—</span>
  </div>
  <div class="panel-content" style="padding: 5px; flex-grow: 1;">
    <canvas id="minimapCanvas" style="width: 100%; height: 100%; background: #000;"></canvas>
  </div>
</div>

<div id="itemDetailPanel" class="panel" style="top:50%; left:50%; transform: translate(-50%, -50%); width:300px; height:auto; display:none;">
  <div id="itemDetailHeader" class="panel-header"></div>
  <div class="item-graphic-container">
    <span id="itemDetailGraphic" class="item-graphic"></span>
  </div>
  <div id="itemDetailContent" class="item-detail-info"></div>
<div id="itemDetailActions" class="item-detail-actions">
    <button id="addToCartBtn" data-translate-key="btn_add_to_cart" style="display:none;">ã‚«ãƒ¼ãƒˆã«å…¥ã‚Œã‚‹</button>
    <button id="removeFromCartBtn" data-translate-key="btn_remove_from_cart" style="display:none;">ã‚«ãƒ¼ãƒˆã‹ã‚‰å¤–ã™</button>
    <button id="treatBleedingBtn" data-translate-key="btn_treat" style="display:none;">å‡¦ç½®ã™ã‚‹</button>
    <button id="pourToFilterBtn" data-translate-key="btn_pour_into_filter" style="display:none;">æµ„æ°´å™¨ã«æ³¨ã</button>
    <button id="addMeatBtn" data-translate-key="btn_add_meat" style="display:none;">è‚‰ã‚’è¨­ç½®ã™ã‚‹</button>
    <button id="takeDriedMeatBtn" data-translate-key="btn_take_dried_meat" style="display:none;">å¹²ã—è‚‰ã‚’å›åã™ã‚‹</button>
    <button id="dryMeatBtn" data-translate-key="btn_dry_meat" style="display:none;">ç”Ÿè‚‰ã‚’å¹²ã™</button>
    <button id="useItemBtn" data-translate-key="btn_use" style="display:none;">ä½¿ã†</button>
    <button id="conductResearchBtn" data-translate-key="btn_conduct_research" style="display:none;">ç ”ç©¶ã‚’ã™ã‚‹</button>
    <button id="placeObjectBtn" data-translate-key="btn_place" style="display:none;">è¨­ç½®ã™ã‚‹</button>
    <button id="eatItemBtn" data-translate-key="btn_eat" style="display:none;">é£Ÿã¹ã‚‹</button>
    <button id="throwItemBtn" data-translate-key="btn_throw" style="display:none;">æŠ•ã’ã‚‹</button>
    <button id="repairItemBtn" data-translate-key="btn_repair" style="display:none;">ä¿®ç†ã™ã‚‹</button>
    <button id="startFireBtn" data-translate-key="btn_start_fire" style="display:none;">ç«ã‚’ãŠã“ã™</button>
    <button id="openItemBtn" data-translate-key="btn_open" style="display:none;">é–‹ã‘ã‚‹</button>
    <button id="forceOpenItemBtn" data-translate-key="btn_force_open" style="display:none;">ç„¡ç†ã‚„ã‚Šé–‹ã‘ã‚‹</button>
    <button id="removeTrapBtn" data-translate-key="btn_remove_trap" style="display:none;">ç½ ã‚’å¤–ã™</button>
    <button id="emptyItemBtn" data-translate-key="btn_empty" style="display:none;">ç©ºã«ã™ã‚‹</button>
    <button id="drinkItemBtn" data-translate-key="btn_drink" style="display:none;">é£²ã‚€</button>
    <button id="fillItemBtn" data-translate-key="btn_fill" style="display:none;">æ±²ã‚€</button>
    <button id="cookItemBtn" data-translate-key="btn_cook" style="display:none;">ç„¼ã</button>
    <button id="plantSeedBtn" data-translate-key="btn_plant" style="display:none;">æ¤ãˆã‚‹</button>
    <button id="boilItemBtn" data-translate-key="btn_boil" style="display:none;">æ²¸ã‹ã™</button>
    <button id="addFuelBtn" data-translate-key="btn_add_fuel" style="display:none;">ãã¹ã‚‹</button>
    <button id="craftTorchBtn" data-translate-key="btn_craft_torch" style="display:none;">æ¾æ˜ã‚’ä½œã‚‹</button>
    <button id="wipeClothBtn" data-translate-key="btn_wipe_clothes" style="display:none;">æœã‚’æ‹­ã</button>
    <button id="wringClothBtn" data-translate-key="btn_wring" style="display:none;">çµã‚‹</button>
    <button id="equipItemBtn" data-translate-key="btn_equip" style="display:none;">è£…å‚™ã™ã‚‹</button>
    <button id="unequipItemBtn" data-translate-key="btn_unequip" style="display:none;">å¤–ã™</button>
    <button id="reloadGunBtn" data-translate-key="btn_reload" style="display:none;">è£…å¡«ã™ã‚‹</button>
    <button id="unloadGunBtn" data-translate-key="btn_unload" style="display:none;">è£…å¡«è§£é™¤</button>
    <button id="attachBayonetBtn" data-translate-key="btn_attach_bayonet" style="display:none;">ãƒŠã‚¤ãƒ•ã‚’è£…ç€</button>
    <button id="detachBayonetBtn" data-translate-key="btn_detach_bayonet" style="display:none;">ãƒŠã‚¤ãƒ•ã‚’å¤–ã™</button>
    <button id="dropItemBtn" data-translate-key="btn_drop" style="display:none;">è½ã¨ã™</button>
    <button id="pickupItemBtn" data-translate-key="btn_pickup" style="display:none;">æ‹¾ã†</button>
    <button id="butcherItemBtn" data-translate-key="btn_butcher" style="display:none;">è§£ä½“ã™ã‚‹</button>
    <button id="useWorkbenchBtn" data-translate-key="btn_use" style="display:none;">ä½¿ã†</button>
    <button id="searchCorpseBtn" data-translate-key="btn_search" style="display:none;">æ¼ã‚‹</button>
    <button id="dismantleBtn" data-translate-key="btn_dismantle" style="display:none;">è§£ä½“ã™ã‚‹</button>
    <button id="closeItemDetailBtn" data-translate-key="btn_close">é–‰ã˜ã‚‹</button>
</div>
  <div class="resize-handle"></div>
</div>

<div id="combatPanel" class="panel" style="display: none; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 1050px; height: 675px; z-index: 1001;">
  <div class="panel-header" data-translate-key="combat_panel_title">æˆ¦é—˜</div>
  <div id="combatContent">
<div id="combatPlayer">
  <h3 data-translate-key="combat_player_title">ã‚ãªãŸ</h3>
  <pre id="combatPlayerAscii" class="ascii-art-container"></pre>
<div id="combatPlayerStats" style="text-align: left; margin-left: 20px;">
      <div id="combatHealthContainer"><span data-translate-key="combat_health">ä½“åŠ›</span>: <span id="combatPlayerHealth"></span></div>
      <div id="combatAttackContainer" style="cursor: help;"><span data-translate-key="combat_attack">æ”»æ’ƒåŠ›</span>: <span id="combatPlayerAttack"></span></div>
      <div id="combatDefenseContainer" style="cursor: help;"><span data-translate-key="combat_defense">é˜²å¾¡åŠ›</span>: <span id="combatPlayerDefense"></span></div>
      <div><span data-translate-key="combat_stance">ç¾åœ¨ã®å§¿å‹¢</span>: <span id="combatPlayerStance"></span></div><div id="playerVisibilityStatus"></div></div>
  <div id="combatPlayerEquipment">
    <strong data-translate-key="combat_equipment">è£…å‚™:</strong>
    <div id="combatEquipmentList"></div>
  </div>
</div>
<div id="combatLogContainer">
    <div id="combatLog"></div>
<div id="combatInfoBar" style="display: flex; justify-content: space-around; align-items: center; margin-bottom: 10px; font-weight: bold; font-size: 1.1em;">
    <div id="combatDistanceDisplay"></div>
    <div style="display: flex; align-items: center; gap: 8px;">
        <span data-translate-key="combat_environment">ç’°å¢ƒ</span>:
        <div id="combatWeatherDisplay" style="cursor: help;"></div>
        <div id="combatDayStateDisplay" style="cursor: help;"></div>
    </div>
</div>
<div id="combatActions">
    <button id="attackMainBtn"></button>
    <button id="attackOffBtn"></button>
    <button id="heavyMeleeBtn" data-translate-key="btn_heavy_attack_melee" style="display: none;">å¤§æ”»æ’ƒ(è¿‘æ¥)</button>
    <button id="heavyMeleeOffBtn" data-translate-key="btn_heavy_attack_melee" style="display: none;">å¤§æ”»æ’ƒ(è¿‘æ¥)</button>
    <button id="heavyRangedBtn" data-translate-key="btn_heavy_attack_ranged" style="display: none;">å¤§æ”»æ’ƒ(é è·é›¢)</button>
    <button id="parryBtn" data-translate-key="btn_parry" style="display: none;">å—ã‘æµã—</button>
    <button id="legTripBtn" data-translate-key="btn_leg_trip" style="display: none;">è¶³æ‰•ã„</button>
    <button id="advanceBtn" data-translate-key="combat_advance">å…ˆé€²ã™ã‚‹</button>
    <button id="retreatBtn" data-translate-key="combat_retreat">å¾Œé€²ã™ã‚‹</button>
    <button id="dodgeBtn" data-translate-key="combat_dodge">å›é¿</button>
    <button id="aimBtn" data-translate-key="btn_aim" style="display: none;">ç‹™ã„ã‚’ã¤ã‘ã‚‹</button>
    <button id="searchOpponentBtn" data-translate-key="btn_search_opponent" style="display: none;">ç›¸æ‰‹ã‚’æ¢ã™</button>
    <button id="throwWeaponBtn" data-translate-key="btn_throw" style="display: none;">æŠ•ã’ã‚‹</button>
    <button id="fireBtn" class="fire-btn" data-translate-key="combat_fire">ç™ºç ²</button>
    <button id="proneBtn" data-translate-key="btn_prone">ä¼ã›ã‚‹</button>
    <button id="standUpBtn" data-translate-key="btn_stand_up" style="display: none;">ç«‹ã¤</button>
    <button id="forwardRollBtn" data-translate-key="btn_forward_roll" style="display: none;">å‰è»¢</button>
    <button id="backwardRollBtn" data-translate-key="btn_backward_roll" style="display: none;">å¾Œè»¢</button>
    <button id="sprintForwardBtn" data-translate-key="btn_sprint_forward" style="display: none;">å…¨é€ŸåŠ›ã§å‰é€²</button>
    <button id="sprintBackwardBtn" data-translate-key="btn_sprint_backward" style="display: none;">å…¨é€ŸåŠ›ã§å¾Œé€²</button>
    <button id="runBtn" data-translate-key="combat_run">é€ƒã’ã‚‹</button>
</div>
</div>
<div id="combatEnemy">
      <h3 id="combatEnemyName">ã‚¾ãƒ³ãƒ“</h3>

      <pre id="combatEnemyAscii" class="ascii-art-container"></pre>
      <div><span data-translate-key="combat_health">ä½“åŠ›</span>: <span id="combatEnemyHealth"></span></div>
      <div id="combatEnemyStanceContainer"><span data-translate-key="combat_stance">ç¾åœ¨ã®å§¿å‹¢</span>: <span id="combatEnemyStance"></span></div>
      <div id="enemyVisibilityStatus"></div>
<div id="combatEnemyEquipment" style="display: none;">
        <strong data-translate-key="combat_equipment">è£…å‚™:</strong>
        <div id="combatEnemyEquipmentList"></div>
      </div>
      <div id="combatEnemyInjuries" style="color: indianred; font-size: 12px; margin-top: 10px;"></div>
    </div>
  </div>
  <div class="resize-handle"></div>
</div>

<div id="dialoguePanel" class="panel" style="display: none;">
    <div class="panel-header" id="dialoguePanelHeader" data-translate-key="dialogue_panel_title">ç”Ÿå­˜è€…ã¨ã®é­é‡</div>
    <div id="dialogueContent">
        <div id="dialogueNPC">
            <h3 id="dialogueNpcName"></h3>
            <pre id="dialogueNpcAscii"></pre>
        </div>
        <div id="dialogueTextContainer">
            <div id="dialogueText"></div>
            <div id="dialogueActions">
                <button id="dialogueTradeBtn" data-translate-key="btn_trade">äº¤æ¸‰ã™ã‚‹</button>
                <button id="dialogueFightBtn" data-translate-key="btn_fight">æˆ¦é—˜ã™ã‚‹</button>
                <button id="dialogueLeaveBtn" data-translate-key="btn_leave">ç«‹ã¡å»ã‚‹</button>
                <button id="dialogueInfoBtn" data-translate-key="btn_ask_info" style="display:none;">æƒ…å ±ã‚’èã</button>
            </div>
        </div>
    </div>
</div>

<div id="tradePanel" class="panel" style="display: none;">
    <div class="panel-header" data-translate-key="trade_panel_title">äº¤æ¸‰</div>
    <div class="trade-main">
        <div class="trade-column">
            <h4 data-translate-key="trade_your_offer">ã‚ãªãŸã®æä¾›ã‚¢ã‚¤ãƒ†ãƒ </h4> (<span id="playerTradeValue">0</span>)
            <div id="playerOfferArea" class="trade-area"></div>
            <h5 data-translate-key="trade_your_inventory">ã‚ãªãŸã®æ‰€æŒå“</h5>
            <div id="playerTradeInventory" class="trade-inventory"></div>
            <h5 data-translate-key="trade_your_equipment">ã‚ãªãŸã®è£…å‚™å“</h5>
            <div id="playerTradeEquipment" class="trade-inventory"></div>
        </div>
        <div class="trade-column">
            <h4 data-translate-key="trade_npc_offer">ç›¸æ‰‹ã®æä¾›ã‚¢ã‚¤ãƒ†ãƒ </h4> (<span id="npcTradeValue">0</span>)
            <div id="npcOfferArea" class="trade-area"></div>
            <h5 data-translate-key="trade_npc_inventory">ç›¸æ‰‹ã®æ‰€æŒå“</h5>
            <div id="npcTradeInventory" class="trade-inventory"></div>
            <h5 data-translate-key="trade_npc_equipment">ç›¸æ‰‹ã®è£…å‚™å“</h5>
            <div id="npcTradeEquipment" class="trade-inventory"></div>
        </div>
    </div>
    <div class="trade-footer">
        <button id="executeTradeBtn" data-translate-key="trade_execute" disabled>äº¤æ¸‰æˆç«‹</button>
        <button id="cancelTradeBtn" data-translate-key="trade_cancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
    </div>
</div>

<div id="storagePanel" class="panel" style="display: none;">
    <div class="panel-header" id="storagePanelHeader" data-translate-key="storage_panel_title">æœ¨ç®±</div>
    <div class="storage-main">
        <div class="storage-column">
            <h4 id="storageBoxTitle">æœ¨ç®±ã®ä¸­èº« (0/10)</h4>
            <div id="storageBoxArea" class="storage-area"></div>
        </div>
        <div class="storage-column">
            <h4>ã‚ãªãŸã®æ‰€æŒå“</h4>
            <div id="storagePlayerInventory" class="storage-area"></div>
        </div>
    </div>
    <div class="storage-footer">
        <button id="pickupStorageBtn">æ‹¾ã†</button>
        <button id="closeStorageBtn">é–‰ã˜ã‚‹</button>
    </div>
</div>
<div id="workbenchPanel" class="panel" style="display: none; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 320px; height: 400px; z-index: 1003; flex-direction: column;">
    <div class="panel-header" data-translate-key="workbench_panel_title">ãƒ¯ãƒ¼ã‚¯ãƒ™ãƒ³ãƒ</div>
    <div class="panel-content" style="height: calc(100% - 62px);"> <div id="workbenchCraftingList" class="item-list" style="max-height: 100%;"></div>
    </div>
    <div class="panel-footer">
        <button id="closeWorkbenchBtn" data-translate-key="btn_close">é–‰ã˜ã‚‹</button>
    </div>
    <div class="resize-handle"></div>
</div>


<div id="version-display"></div>
<div id="researchPanel" class="panel" style="display: none;">
    <div class="panel-header" data-translate-key="research_panel_title">ç ”ç©¶ãƒ„ãƒªãƒ¼</div>
    <div id="researchTreeContainer" class="panel-content">
        <svg id="researchTreeLines"></svg>
        <div id="researchTreeNodes"></div>
    </div>
    <div class="panel-footer">
        <button id="researchPanelCloseBtn" data-translate-key="btn_close">é–‰ã˜ã‚‹</button>
    </div>
    <div class="resize-handle"></div>
</div>


<div id="bodyPanel" class="panel" style="display: flex; top: 50px; left: 50px; width: 473px; height: 630px;">
    <div class="panel-header" data-translate-key="body_panel_title">èº«ä½“ã®çŠ¶æ…‹</div>
<div class="panel-content" style="padding: 5px; align-items: center; justify-content: center; position: relative;">
    <img id="bodyImage" src="images/body_placeholder.png" alt="Body Status" style="max-width: 100%; max-height: 100%; object-fit: contain;">
    <div id="bodySlotHead" class="body-slot" title="é ­"></div>
    <div id="bodySlotEyes" class="body-slot" title="ç›®"></div>
    <div id="bodySlotBodyOuter" class="body-slot" title="ã‚¢ã‚¦ã‚¿ãƒ¼"></div>
    <div id="bodySlotBodyInner1" class="body-slot" title="ã‚¤ãƒ³ãƒŠãƒ¼1"></div>
    <div id="bodySlotBodyInner2" class="body-slot" title="ã‚¤ãƒ³ãƒŠãƒ¼2"></div>
    <div id="bodySlotBodyInner3" class="body-slot" title="ã‚¤ãƒ³ãƒŠãƒ¼3"></div>
    <div id="bodySlotBack" class="body-slot" title="èƒŒä¸­"></div>
    <div id="bodySlotPochette" class="body-slot" title="è…°"></div>
    <div id="bodySlotLegs" class="body-slot" title="è„š"></div>
    <div id="bodySlotLeftFoot" class="body-slot" title="å·¦è¶³"></div>
    <div id="bodySlotRightFoot" class="body-slot" title="å³è¶³"></div>
    <div id="bodySlotWrist" class="body-slot" title="æ‰‹é¦–"></div>
    <div id="bodySlotMainHand" class="body-slot" title="å³æ‰‹"></div>
    <div id="bodySlotOffHand" class="body-slot" title="å·¦æ‰‹"></div>
    <div id="bodySlotLeftPalm" class="body-slot" title="å·¦æ‰‹ã®ã²ã‚‰"></div>
    <div id="bodySlotRightPalm" class="body-slot" title="å³æ‰‹ã®ã²ã‚‰"></div>
    <div id="bodySlotNeck" class="body-slot" title="é¦–"></div>
    <div id="bodySlotMouth" class="body-slot" title="å£"></div>
</div>
    <div class="panel-footer">
        <button id="bodyPanelCloseBtn" data-translate-key="btn_close">é–‰ã˜ã‚‹</button>
    </div>
    <div class="resize-handle"></div>
</div>
<div id="explorationPanel" class="panel" style="display: none; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 600px; height: auto; z-index: 1005;">
    <div class="panel-header" data-translate-key="exploration_panel_title">æ–½è¨­å†…ã‚’æ¢ç´¢</div>
    <div id="explorationContent" class="panel-content" style="flex-direction: row; flex-wrap: wrap; justify-content: center; gap: 15px; padding: 15px;">
        </div>
    <div class="panel-footer">
        <button id="explorationCloseBtn" data-translate-key="btn_close">é–‰ã˜ã‚‹</button>
    </div>
</div>
<div id="explorationPreviewPanel" class="panel" style="display: none; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 400px; height: auto; z-index: 1006;">
    <div id="explorationPreviewHeader" class="panel-header">å»ºç‰©ã®æƒ…å ±</div>
    <div class="panel-content" style="padding: 15px;">
        <div style="text-align: center; margin-bottom: 15px;">
            <img id="explorationPreviewImage" src="" style="width: 96px; height: 96px; border: 2px solid #555; border-radius: 5px; background: rgba(0,0,0,0.3); image-rendering: pixelated;">
        </div>
        <div id="explorationPreviewDesc" style="margin-bottom: 15px; font-size: 14px; min-height: 40px;"></div>
        
        <div class="status-line">
            <span class="status-label" data-translate-key="preview_label_loot">ãƒ«ãƒ¼ãƒˆ</span>
            <div class="bar"><div id="lootBar" class="fill"></div></div>
        </div>
        <div class="status-line">
            <span class="status-label" data-translate-key="preview_label_safety">ã‚»ã‚¤ãƒ•ãƒ†ã‚£</span>
            <div class="bar"><div id="safetyBar" class="fill"></div></div>
        </div>
        <div class="status-line">
            <span class="status-label" data-translate-key="preview_label_sneak">ã‚¹ãƒ‹ãƒ¼ã‚¯</span>
            <div class="bar"><div id="sneakBar" class="fill"></div></div>
        </div>
    </div>
    <div class="panel-footer" style="text-align: center;">
        <button id="exploreConfirmBtn" data-translate-key="btn_explore">æ¢ç´¢ã™ã‚‹</button>
        <button id="exploreCancelBtn" data-translate-key="btn_cancel">ã‚„ã‚ã‚‹</button>
    </div>
</div>
<div id="devPanel" class="panel" style="display: none; top: 50px; left: 50%; transform: translateX(-50%); width: 500px; height: 70vh; z-index: 9999;">
    <div class="panel-header">é–‹ç™ºè€…ãƒ‘ãƒãƒ« (`ã‚­ãƒ¼ã§è¡¨ç¤º/éè¡¨ç¤º)</div>
    <div class="panel-content">
        <div id="devItemList" class="item-list" style="height: calc(100% - 150px);"></div>

        <div id="devControls" style="margin-top: 10px; display: flex; flex-direction: column; gap: 10px;">
            <input type="text" id="devItemSearch" data-translate-placeholder-key="dev_search_placeholder" style="width: 100%; padding: 8px; box-sizing: border-box; background: #111; color: #eee; border: 1px solid #555; border-radius: 4px;">
            <div style="display: flex; gap: 10px; align-items: center;">
                <span id="devSelectedItemName" style="flex-grow: 1; text-align: center; background: #111; padding: 5px; border-radius: 4px;">ã‚¢ã‚¤ãƒ†ãƒ ã‚’é¸æŠ...</span>
                <input type="number" id="devItemQuantity" value="1" min="1" max="100" style="width: 70px; padding: 5px; background: #333; color: #eee; border: 1px solid #555;">
                <button id="devSpawnBtn" style="padding: 5px 10px; background: #4a4a52; color: #eee; border: 1px solid #666; border-radius: 3px; cursor: pointer;">ç”Ÿæˆ</button>
            </div>
            
            <div style="font-size: 12px; display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                <label><input type="checkbox" id="devShowSCSArrow"> æ•‘æ¸ˆã®è¡—</label>
                <label><input type="checkbox" id="devShowNPCHintArrow"> ãƒ’ãƒ³ãƒˆNPC</label>
                <label><input type="checkbox" id="devShowResidentialArrow"> ä½å±…æ–½è¨­</label>
                <label><input type="checkbox" id="devShowCommercialArrow"> å•†æ¥­æ–½è¨­</label>
                <label><input type="checkbox" id="devShowIndustrialArrow"> å·¥æ¥­æ–½è¨­</label>
                <label><input type="checkbox" id="devShowCabinArrow"> å°å±‹</label>
                <label><input type="checkbox" id="devShowTraderShopArrow" data-translate-key="dev_arrow_trader_shop"> ãƒˆãƒ¬ãƒ¼ãƒ€ãƒ¼ã‚·ãƒ§ãƒƒãƒ—</label>
            </div>
<div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr 1fr; gap: 5px;">
                <button id="devAddFoodPoisoningBtn" class="dev-button" data-translate-key="dev_add_food_poisoning">é£Ÿä¸­æ¯’ã‚’ç™ºç”Ÿ</button>
                <button id="devAddDiarrheaBtn" class="dev-button" data-translate-key="dev_add_diarrhea">ä¸‹ç—¢ã‚’ç™ºç”Ÿ</button>
                <button id="devAddFeverBtn" class="dev-button" data-translate-key="dev_add_fever">ç™ºç†±ã‚’ç™ºç”Ÿ</button>
                <button id="devAddInfectionBtn" class="dev-button" data-translate-key="dev_add_infection">æ„ŸæŸ“ç—‡ã‚’ç™ºç”Ÿ</button>
                <button id="devAddItchBtn" class="dev-button" data-translate-key="dev_add_itch">ã‹ã‚†ã¿ã‚’ç™ºç”Ÿ</button>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px;">
                <button id="devAddBleedingBtn" class="dev-button">å‡ºè¡€ã‚’è² ã†</button>
                <button id="devAddBruiseBtn" class="dev-button">æ‰“æ’²ã‚’è² ã†</button>
                <button id="devAddFractureBtn" class="dev-button">éª¨æŠ˜ã‚’è² ã†</button>
            </div>
        </div>
    </div>
</div>
<script>

const { ipcRenderer } = require('electron');
// â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’<script>ã‚¿ã‚°å†…ã«è¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
const injuryCoordinates = {
'bleeding': [
{ x: 205, y: 98 }, // é ­
{ x: 131, y: 223 }, // è…•
{ x: 180, y: 252 }, // èƒ´ä½“
{ x: 260, y: 377 } // è„š
],

'bruise': [
Â  Â  { x: 205, y: 98 }, // é ­
{ x: 131, y: 223 }, // è…•
{ x: 180, y: 252 }, // èƒ´ä½“
{ x: 260, y: 377 } // è„š
],

'fracture': [
{ x: 278, y: 219 }, // è…•
{ x: 181, y: 452 } // è„š
],

'splinted': [
Â  Â  { x: 278, y: 219 }, // è…•
{ x: 181, y: 452 } // è„š
]
};
// <script>ã‚¿ã‚°å†…ã®å†’é ­ã«è¿½åŠ 
const bodyParts = ['head', 'torso', 'rightArm', 'leftArm', 'rightLeg', 'leftLeg'];
let devSelectedItem = null; // é–‹ç™ºè€…ãƒ‘ãƒãƒ«ã§é¸æŠã•ã‚Œã¦ã„ã‚‹ã‚¢ã‚¤ãƒ†ãƒ ã‚’ä¿æŒ
let ambientPreviewNode = null;
let activeBgLayer = 1; // ç¾åœ¨è¡¨ç¤ºä¸­ã®èƒŒæ™¯ãƒ¬ã‚¤ãƒ¤ãƒ¼ç•ªå· (1 or 2)
let currentTimeOfDayClass = ''; // ç¾åœ¨ã®æ™‚é–“å¸¯ã‚¯ãƒ©ã‚¹å
let voicePreviewTimeout = null;
let speechPreviewTimeout = null;
let itchTimer = null; // ã‹ã‚†ã¿éŸ³ã®ã‚¿ã‚¤ãƒãƒ¼ã‚’ç®¡ç†ã™ã‚‹å¤‰æ•°
const MAX_COMBAT_DISTANCE = 20; // â† ã“ã®è¡Œã‚’è¿½åŠ 
const MELEE_BASE_MISS_CHANCE = 0.10; // â† ã“ã®è¡Œã‚’è¿½åŠ 
const CURRENT_GAME_VERSION = "1.1.8"; // ç¾åœ¨ã®ã‚²ãƒ¼ãƒ ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’å®šæ•°ã¨ã—ã¦å®šç¾©

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let soundBuffers = {}; // èª­ã¿è¾¼ã¿æ¸ˆã¿ã®ã‚µã‚¦ãƒ³ãƒ‰ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆä¿å­˜ï¼‰ã—ã¦ãŠãå ´æ‰€
let criticalHealthHeartbeatNode = null; // ä½ä½“åŠ›æ™‚ã®å¿ƒéŸ³BGMãƒãƒ¼ãƒ‰ã‚’ç®¡ç†
let combatBgmSourceNode = null; // <<< ã“ã®è¡Œã‚’æ–°ã—ãè¿½åŠ 
let combatBgmGainNode = null; // â† ã“ã®è¡Œã‚’è¿½åŠ 
let rainSourceNodes = [];
let stormSourceNodes = [];
let birdsSourceNodes = []; // â† ã“ã®è¡Œã‚’è¿½åŠ 
let windSourceNodes = [];  // â† ã“ã®è¡Œã‚’è¿½åŠ 
// ... æ—¢å­˜ã®å¤‰æ•°å®šç¾©ã®ä¸‹ã«è¿½åŠ  ...
let lowHealthBGMSourceNode = null; // BGMã®å†ç”Ÿãƒãƒ¼ãƒ‰ã‚’ç®¡ç†
let isLowHealthBGMPlaying = false; // BGMãŒå†ç”Ÿä¸­ã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°
let lowHealthBGMTimeout = null;    // æ¬¡ã®BGMå†ç”Ÿã¾ã§ã®ã‚¿ã‚¤ãƒãƒ¼ã‚’ç®¡ç†
// â–²â–²â–² å¤‰æ›´ã“ã“ã¾ã§ â–²â–²â–²
let bgm;
/**
 * ã‚µã‚¦ãƒ³ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã™ã‚‹é–¢æ•°
 * @param {string} filePath - sounds/ã‹ã‚‰ã®ãƒ‘ã‚¹
 */
async function loadSound(filePath) {
    // ã™ã§ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ã‚ã‚Œã°ã€ãã‚Œã‚’ä½¿ç”¨
    if (soundBuffers[filePath]) return soundBuffers[filePath];
    try {
        const response = await fetch(filePath);
        const arrayBuffer = await response.arrayBuffer();
        const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
        soundBuffers[filePath] = audioBuffer; // èª­ã¿è¾¼ã‚“ã éŸ³ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜
        return audioBuffer;
    } catch(e) { 
        console.error(`ã‚µã‚¦ãƒ³ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ${filePath}`, e);
    }
}

/**
 * åŠ¹æœéŸ³ã‚’å†ç”Ÿã™ã‚‹é–¢æ•°
 * @param {string} filePath - sounds/ã‹ã‚‰ã®ãƒ‘ã‚¹
 * @param {number} [volume=1.0] - éŸ³é‡ (0.0 to 1.0)
 */
function playSoundFile(filePath, volume = 1.0) {
    // æœ€åˆã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œãŒã‚ã‚‹ã¾ã§éŸ³å£°å†ç”Ÿã‚’è©¦ã¿ãªã„ã‚ˆã†ã«ã™ã‚‹
    if (audioCtx.state === 'suspended') {
        audioCtx.resume();
    }

    const sound = soundBuffers[filePath];
    if (sound) {
        const source = audioCtx.createBufferSource();
        source.buffer = sound;
        const gainNode = audioCtx.createGain();
        gainNode.gain.value = volume;
        source.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        source.start(0);
    } else {
        // åˆã‚ã¦å†ç”Ÿã™ã‚‹éŸ³ã®å ´åˆã¯ã€èª­ã¿è¾¼ã‚“ã§ã‹ã‚‰å†ç”Ÿ
        loadSound(filePath).then(buffer => {
            if(buffer) playSoundFile(filePath, volume);
        });
    }
}
// index.htmlã®<script>ã‚¿ã‚°å†…


/**
 * ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å£°ã«é–¢ã™ã‚‹åŠ¹æœéŸ³ã‚’ã€ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã¨éŸ³é‡è¨­å®šã‚’è€ƒæ…®ã—ã¦å†ç”Ÿã™ã‚‹
 * @param {string} soundPath - sounds/ã‹ã‚‰ã®ãƒ‘ã‚¹
 * @param {number} volume - ã“ã®éŸ³å£°ã®ç›¸å¯¾çš„ãªéŸ³é‡
 */
function playPlayerVoice(soundPath, volume) {
    const now = Date.now();
    // ç¾åœ¨æ™‚åˆ»ãŒã€å‰å›ã®å†ç”Ÿæ™‚åˆ» + ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³æ™‚é–“ã‚ˆã‚Šã‚‚å¾Œã§ã‚ã‚Œã°å†ç”Ÿã™ã‚‹
    if (now - lastPlayerVoiceTime > PLAYER_VOICE_COOLDOWN) {
        // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒå¤‰æ›´ç®‡æ‰€ã§ã™ â–¼â–¼â–¼

        // 1. ã‚ªãƒ—ã‚·ãƒ§ãƒ³ç”»é¢ã®ã€Œãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å£°ã€ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’å–å¾—
        const voiceVolumeSlider = document.getElementById('voiceVolumeSlider');
        // 2. ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®å€¤ã‚’å–å¾—ï¼ˆè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤0.7ã‚’ä½¿ç”¨ï¼‰
        const masterVoiceVolume = voiceVolumeSlider ? parseFloat(voiceVolumeSlider.value) : 0.7;

        // 3. ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®éŸ³é‡ã¨ã€å„éŸ³å£°å›ºæœ‰ã®éŸ³é‡ã‚’æ›ã‘åˆã‚ã›ã¦æœ€çµ‚çš„ãªéŸ³é‡ã‚’æ±ºå®š
        playSoundFile(soundPath, volume * masterVoiceVolume);
        
        // â–²â–²â–² å¤‰æ›´ã“ã“ã¾ã§ â–²â–²â–²

        lastPlayerVoiceTime = now; // å†ç”Ÿæ™‚åˆ»ã‚’æ›´æ–°
    }
}
// â–¼â–¼â–¼ `updateWeatherAudio` é–¢æ•°ã‚’ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
async function updateWeatherAudio() {
    // â˜…ä¿®æ­£ç‚¹: currentWeather.name ã§ã¯ãªã currentWeather.id ã‚’ä½¿ç”¨
    const newAmbientSoundId = currentWeather.id;

    // æ—¢ã«åŒã˜ç’°å¢ƒéŸ³ãŒå†ç”Ÿä¸­ã®å ´åˆã¯ã€éŸ³é‡èª¿æ•´ã®ã¿è¡Œã†
    if (newAmbientSoundId === currentAmbientSound) {
        const volumeSlider = document.getElementById('volumeSlider');
        const volume = volumeSlider ? parseFloat(volumeSlider.value) : 0.4;
        if (ambientGainNode) {
            ambientGainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
        }
        return;
    }

    // ç¾åœ¨ã®å¤©å€™éŸ³ã‚’åœæ­¢
    stopWeatherAudio();

    const volumeSlider = document.getElementById('volumeSlider');
    const volume = volumeSlider ? parseFloat(volumeSlider.value) : 0.4;

    if (ambientGainNode) {
        ambientGainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
    }

    let soundPath = null;
    let sourceNodesArray = null;

    // â˜…ä¿®æ­£ç‚¹: æ–°ã—ã„å¤©å€™IDã«åŸºã¥ã„ã¦ã‚µã‚¦ãƒ³ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ
    switch (newAmbientSoundId) {
        case 'sunny':
            soundPath = 'sounds/birds_loop.wav';
            sourceNodesArray = birdsSourceNodes;
            break;
        case 'cloudy':
            soundPath = 'sounds/wind_loop.wav';
            sourceNodesArray = windSourceNodes;
            break;
        case 'rainy':
            soundPath = 'sounds/rain_loop.wav';
            sourceNodesArray = rainSourceNodes;
            break;
        case 'stormy':
            soundPath = 'sounds/storm_loop.wav';
            sourceNodesArray = stormSourceNodes;
            break;
    }

    if (!soundPath) {
        currentAmbientSound = null;
        return;
    }

    const audioBuffer = await loadSound(soundPath);
    if (!audioBuffer) return;

    const sourceNode = audioCtx.createBufferSource();
    sourceNode.buffer = audioBuffer;
    sourceNode.loop = true;
    sourceNode.connect(ambientGainNode);
    sourceNode.start(0);

    if (sourceNodesArray) {
        sourceNodesArray.push(sourceNode);
    }

    // â˜…ä¿®æ­£ç‚¹: ç¾åœ¨å†ç”Ÿä¸­ã®éŸ³ã®IDã‚’è¨˜æ†¶
    currentAmbientSound = newAmbientSoundId;
}
// â–²â–²â–² ç½®ãæ›ãˆã“ã“ã¾ã§ â–²â–²â–²

/**
 * ã‚¢ã‚¤ã‚³ãƒ³ã®ãƒ‘ã‚¹ã‚„çµµæ–‡å­—ã‹ã‚‰ã€è¡¨ç¤ºç”¨ã®HTMLã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°
 * @param {string} iconSource - ç”»åƒãƒ‘ã‚¹ã¾ãŸã¯çµµæ–‡å­—
 * @param {number} [size=16] - è¡¨ç¤ºã‚µã‚¤ã‚ºï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰
 * @returns {string} - <img>ã‚¿ã‚°ã¾ãŸã¯<span>ã‚¿ã‚°ã®HTMLæ–‡å­—åˆ—
 */
// index.htmlã®<script>ã‚¿ã‚°å†…

// â–¼â–¼â–¼ æ—¢å­˜ã®`getIconHTML`é–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function getIconHTML(iconSource, size = 16) {
    if (typeof iconSource !== 'string' || iconSource === '') {
        return '';
    }

    // ã‚¢ã‚¤ãƒ†ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãã®ã‚‚ã®ãŒæ¸¡ã•ã‚ŒãŸå ´åˆã®å¯¾å¿œã‚’è¿½åŠ 
    if (typeof iconSource === 'object' && iconSource !== null && iconSource.graphic) {
        iconSource = getItemGraphic(iconSource);
    }
  
    if (iconSource.startsWith('images/')) {
        return `<img src="${iconSource}" alt="" style="width: ${size}px; height: ${size}px; image-rendering: pixelated; vertical-align: middle;">`;
    }
  
    return `<span style="font-size: ${size}px; vertical-align: middle;">${iconSource}</span>`;
}

// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’æ–°ã—ãè¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
function getItemGraphic(item) {
    if (item && typeof item.getGraphic === 'function') {
        // ã‚‚ã—ã‚¢ã‚¤ãƒ†ãƒ ã«getGraphicé–¢æ•°ãŒã‚ã‚Œã°ã€ãã‚Œã‚’å®Ÿè¡Œã—ã¦ç”»åƒåã‚’å–å¾—
        return item.getGraphic();
    }
    // ãªã‘ã‚Œã°ã€é€šå¸¸ã®graphicãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¿”ã™
    return item ? item.graphic : '';
}
// index.htmlã®<script>ã‚¿ã‚°å†…

// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’æ–°ã—ãè¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
/**
 * ã‚¢ã‚¤ãƒ†ãƒ ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‹ã‚‰ã€ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆé–¢æ•°ï¼‰ã‚’å¤±ã‚ãšã«æ–°ã—ã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã™ã‚‹
 * @param {object} template - itemsé…åˆ—å†…ã®ã‚¢ã‚¤ãƒ†ãƒ å®šç¾©
 * @returns {object} - ãƒ¡ã‚½ãƒƒãƒ‰ãŒç¶­æŒã•ã‚ŒãŸæ–°ã—ã„ã‚¢ã‚¤ãƒ†ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
 */
function createItemInstance(template) {
    if (!template) return null;
    
    // ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰æ§‹æ–‡ã§ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ï¼ˆã“ã‚Œã«ã‚ˆã‚Šé–¢æ•°ã‚‚ã‚³ãƒ”ãƒ¼ã•ã‚Œã‚‹ï¼‰
    const instance = { ...template };

    // ãƒã‚¹ãƒˆã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚å€‹åˆ¥ã«ã‚³ãƒ”ãƒ¼ã—ã¦ã€å‚ç…§ãŒå…±æœ‰ã•ã‚Œãªã„ã‚ˆã†ã«ã™ã‚‹
    if (template.effects) {
        instance.effects = { ...template.effects };
    }
    if (template.nutrients) {
        instance.nutrients = { ...template.nutrients };
    }
    // ã‚³ãƒ³ãƒ†ãƒŠã®ä¸­èº«ã¯nullã§åˆæœŸåŒ–
    if (template.type === 'container') {
        instance.content = null;
    }
    // éŠƒã®è£…å¼¾æ•°ã‚’åˆæœŸåŒ–
    if (template.ammoCapacity) {
        instance.loadedAmmo = 0;
    }

    return instance;
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’æ–°ã—ãè¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
/**
 * è¦–èªã•ã‚Œã¦ã„ãªã„ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«å¯¾ã™ã‚‹å‘½ä¸­ç‡è£œæ­£ï¼ˆãƒŸã‚¹ç‡ã®æ¸›å°‘å€¤ï¼‰ã‚’è¿”ã™
 * @param {boolean} isTargetPlayer - æ”»æ’ƒå¯¾è±¡ãŒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã©ã†ã‹
 * @returns {number} - ãƒŸã‚¹ç‡ã‹ã‚‰å¼•ãè£œæ­£å€¤ï¼ˆä¾‹: -0.3ï¼‰
 */
function getUnseenTargetModifier(isTargetPlayer) {
    if (isTargetPlayer) {
        // æ•µãŒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æ”»æ’ƒã™ã‚‹å ´åˆ
        if (!playerSeesEnemy) {
            return -0.30; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒè¦‹ãˆã¦ã„ãªã„ã®ã§ã€æ•µã®æ”»æ’ƒãŒå½“ãŸã‚Šã‚„ã™ã„
        }
    } else {
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæ•µã‚’æ”»æ’ƒã™ã‚‹å ´åˆ
        if (!enemySeesPlayer) {
            return -0.30; // æ•µãŒè¦‹ãˆã¦ã„ãªã„ã®ã§ã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ”»æ’ƒãŒå½“ãŸã‚Šã‚„ã™ã„
        }
    }
    return 0; // é€šå¸¸ã®çŠ¶æ³ã§ã¯è£œæ­£ãªã—
}
function getAccuracyModifier() {
    let penalty = 0.0;
    const hour = currentTime.getHours();

    // æ™‚é–“å¸¯ã«ã‚ˆã‚‹ãƒšãƒŠãƒ«ãƒ†ã‚£ (ç·©å’Œç‰ˆ)
    if ((hour >= 18 && hour < 21) || (hour >= 6 && hour < 8)) { // å¤•æ–¹/æœ
        penalty += 0.05; // 5% ãƒšãƒŠãƒ«ãƒ†ã‚£ (å¤‰æ›´å‰: 15%)
    } else if (hour >= 21 || hour < 6) { // å¤œ
        penalty += 0.15; // 15% ãƒšãƒŠãƒ«ãƒ†ã‚£ (å¤‰æ›´å‰: 30%)
    }

    // å¤©å€™ã«ã‚ˆã‚‹ãƒšãƒŠãƒ«ãƒ†ã‚£ (ç·©å’Œç‰ˆ)
    if (currentWeather.id === 'rainy') {
        penalty += 0.05; // 5% ãƒšãƒŠãƒ«ãƒ†ã‚£ (å¤‰æ›´å‰: 10%)
    } else if (currentWeather.id === 'stormy') {
        penalty += 0.15; // 15% ãƒšãƒŠãƒ«ãƒ†ã‚£ (å¤‰æ›´å‰: 25%)
    }

    return penalty;
}
// â–²â–²â–² ç½®ãæ›ãˆã“ã“ã¾ã§ â–²â–²â–²
function getGameState() {
  // ã‚»ãƒ¼ãƒ–ç”¨ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆã—ã€å¾ªç’°å‚ç…§ã‚’è§£æ¶ˆã™ã‚‹
  const entitiesForSave = entities.map((entity, index) => {
    const newEntity = { ...entity };
    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæƒ…å ±ã‚’ä¸€æ™‚çš„ãªå½¢å¼ã«å¤‰æ›
    if (newEntity.target) {
      if (newEntity.target === player) {
        newEntity.target = { isPlayer: true }; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®å ´åˆ
      } else {
        const targetIndex = entities.findIndex(e => e === newEntity.target);
        if (targetIndex !== -1) {
          newEntity.target = { isEntity: true, index: targetIndex }; // ä»–ã®ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãŒã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®å ´åˆ
        } else {
          newEntity.target = null;
        }
      }
    }
    return newEntity;
  });

  return {
    saveVersion: CURRENT_GAME_VERSION,
    player: player,
    map: map,
    entities: entitiesForSave, // å¾ªç’°å‚ç…§ã‚’è§£æ¶ˆã—ãŸã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒªã‚¹ãƒˆã‚’ä½¿ç”¨
    placedObjects: placedObjects,
    droppedItems: droppedItems,
    turn: turn,
    currentTime: currentTime,
    character: character,
    salvationCityCoords: salvationCityCoords,
    salvationCityDiscovered: salvationCityDiscovered,
    currentWeather: currentWeather,
    currentTemperature: currentTemperature,
    currentSeason: currentSeason,
    uiSettings: getUISettings() // â˜…ã“ã®è¡Œã‚’è¿½åŠ 
  };
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’ getIconHTML ã®ä¸‹ã«è¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
/**
 * ä½“åŠ›ã®å‰²åˆã«å¿œã˜ã¦ã€ç·‘ -> é»„ -> èµ¤ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³è‰²ã‚’è¨ˆç®—ã—ã¦è¿”ã™
 * @param {number} currentHealth - ç¾åœ¨ã®ä½“åŠ›
 * @param {number} maxHealth - æœ€å¤§ä½“åŠ›
 * @returns {string} - 'rgb(r,g,b)' å½¢å¼ã®CSSã‚«ãƒ©ãƒ¼æ–‡å­—åˆ—
 */
function getHealthColor(currentHealth, maxHealth) {
  if (maxHealth <= 0) return '#e74c3c'; // ã‚¼ãƒ­é™¤ç®—ã‚’é¿ã‘ã‚‹
  const percent = Math.max(0, Math.min(1, currentHealth / maxHealth));

  let r, g, b;

  if (percent >= 0.5) {
    // 100% (ç·‘) ã‹ã‚‰ 50% (é»„) ã¸ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    const scale = (percent - 0.5) * 2; // ã“ã®ç¯„å›²ã§ã®å‰²åˆã‚’0.0-1.0ã«å¤‰æ›
    const startR = 241, startG = 196, startB = 15;   // é»„è‰² (#f1c40f)
    const endR = 39,   endG = 174,  endB = 96;    // ç·‘ (#27ae60)
    r = Math.round(startR + (endR - startR) * scale);
    g = Math.round(startG + (endG - startG) * scale);
    b = Math.round(startB + (endB - startB) * scale);
  } else {
    // 50% (é»„) ã‹ã‚‰ 0% (èµ¤) ã¸ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    const scale = percent * 2; // ã“ã®ç¯„å›²ã§ã®å‰²åˆã‚’0.0-1.0ã«å¤‰æ›
    const startR = 231, startG = 76,  startB = 60;    // èµ¤ (#e74c3c)
    const endR = 241,   endG = 196,  endB = 15;    // é»„è‰² (#f1c40f)
    r = Math.round(startR + (endR - startR) * scale);
    g = Math.round(startG + (endG - startG) * scale);
    b = Math.round(startB + (endB - startB) * scale);
  }
  return `rgb(${r},${g},${b})`;
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°å…¨ä½“ã‚’ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function applyGameState(state) {
    if (!state) return;

    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒè¿½åŠ ã™ã‚‹ä¿®æ­£ãƒ–ãƒ­ãƒƒã‚¯ã§ã™ â–¼â–¼â–¼
    // å¤ã„ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã«æ–°ã—ã„ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒãªã„å ´åˆã€åˆæœŸå€¤ã‚’100ã«è¨­å®šã™ã‚‹
    if (state.player) {
        if (state.player.bloodLevel === undefined) {
            console.log("å¤ã„ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œå‡ºï¼š`bloodLevel`ã‚’100ã«åˆæœŸåŒ–ã—ã¾ã™ã€‚");
            state.player.bloodLevel = 100;
        }
        if (state.player.immuneSystem === undefined) {
            console.log("å¤ã„ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œå‡ºï¼š`immuneSystem`ã‚’100ã«åˆæœŸåŒ–ã—ã¾ã™ã€‚");
            state.player.immuneSystem = 100;
        }
        if (state.player.painTolerance === undefined) {
            console.log("å¤ã„ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œå‡ºï¼š`painTolerance`ã‚’100ã«åˆæœŸåŒ–ã—ã¾ã™ã€‚");
            state.player.painTolerance = 100;
        }
    }
    // â–²â–²â–² è¿½åŠ ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²

    // â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
    // ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿å†…ã®å…¨ã¦ã®ã€ŒçŸ³ã€ã«è€ä¹…å€¤ãŒãªã‘ã‚Œã°ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤(50)ã‚’è¿½åŠ ã™ã‚‹
    const checkAndAddDurability = (item) => {
        if (item.name === 'çŸ³' && item.durability === undefined) {
            item.durability = 50;
        }
    };
    if (state.player) {
        if (state.player.inventory) state.player.inventory.forEach(checkAndAddDurability);
        if (state.player.equipment) state.player.equipment.forEach(checkAndAddDurability);
    }
    if (state.droppedItems) {
        Object.values(state.droppedItems).forEach(itemList => itemList.forEach(checkAndAddDurability));
    }
    // â–²â–²â–² è¿½åŠ ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²

    // â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
    // ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿å†…ã®ã€Œæã€ã«è€ä¹…å€¤ãŒãªã‘ã‚Œã°ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤(100)ã‚’è¿½åŠ ã™ã‚‹
    if (state.player && state.player.inventory) {
        state.player.inventory.forEach(item => {
            if (item.name === 'æ' && item.durability === undefined) {
                item.durability = 100;
            }
        });
    }
    // â–²â–²â–² è¿½åŠ ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²

  // å¤ã„ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã«å„ç¨®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å€¤ãŒãªã„å ´åˆã€åˆæœŸå€¤ã‚’è¨­å®šã™ã‚‹
  if (state.player.bodyOdor === undefined) {
      console.log("å¤ã„ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œå‡ºï¼š`bodyOdor`ã‚’0ã«åˆæœŸåŒ–ã—ã¾ã™ã€‚");
      state.player.bodyOdor = 0;
  }
  if (state.player.carbs === undefined) {
      console.log("å¤ã„ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œå‡ºï¼šæ „é¤Šç´ ã‚’50ã«åˆæœŸåŒ–ã—ã¾ã™ã€‚");
      state.player.carbs = 50;
      state.player.protein = 50;
      state.player.fat = 50;
      state.player.vitamins = 50;
  }
  if (!state.player.research || !state.player.research.progress) {
      state.player.research = { completed: [], currentProjectId: null, progress: {} };
  }
    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â–¼â–¼â–¼
    if (state.player.barefootTurns === undefined) {
        state.player.barefootTurns = 0;
        state.player.nextSoreFeetTurn = -1;
        state.player.nextInjuredFeetTurn = -1;
    }
    // â–²â–²â–² ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²

  const loadedVersion = state.saveVersion || "1.0.0"; 

  if (loadedVersion < "1.2.0" && state.player.stamina === undefined) {
      console.log(`v${loadedVersion}ã‹ã‚‰v1.2.0ã¸ã®ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ç§»è¡Œå‡¦ç†ã‚’å®Ÿè¡Œ...`);
      state.player.stamina = 100;
  }
  
  player = state.player; 
  map = state.map; 
  entities = state.entities; 
  placedObjects = state.placedObjects; 
  droppedItems = state.droppedItems; 
  turn = state.turn; 
  currentTime = new Date(state.currentTime); 
  character = state.character; 
  salvationCityCoords = state.salvationCityCoords; 
  salvationCityDiscovered = state.salvationCityDiscovered; 
  if (typeof state.currentWeather === 'string') {
      const weatherIdMap = { 'å¿«æ™´': 'sunny', 'æ›‡ã‚Š': 'cloudy', 'é›¨': 'rainy', 'åµ': 'stormy' };
      const weatherId = weatherIdMap[state.currentWeather] || 'sunny';
      currentWeather = { ...weatherTypes[weatherId], id: weatherId };
  } else {
      currentWeather = state.currentWeather;
  }

  currentTemperature = state.currentTemperature; 
  currentSeason = state.currentSeason;
  
  calculateMaxStats();
  if (state.uiSettings) {
      applyUISettings(state.uiSettings);
  }

  updateTurnInfo(); 
  drawMap(); 
  drawMinimap(); 
  updateStatus(); 
  updateItemPanels(); 
  updateCharacterBody(); 
  updateCharacterInfo(); 
  updateCurrentLocationPanel(false); 
  updateBackgroundColor();
  log(getString("log_data_loaded"));
  updateBodyPanel();
  updateMovementButtons();
}
// â–²â–²â–² `applyGameState` é–¢æ•°ã®ç½®ãæ›ãˆã“ã“ã¾ã§ â–²â–²â–²
/**
 * UIã¨ã‚ªãƒ—ã‚·ãƒ§ãƒ³è¨­å®šã‚’å–å¾—ã—ã¦ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦è¿”ã™é–¢æ•°
 */
function getUISettings() {
    const options = {
        ambientVolume: document.getElementById('volumeSlider').value,
        voiceVolume: document.getElementById('voiceVolumeSlider').value,
        speechVolume: document.getElementById('speechVolumeSlider').value, // ä¿®æ­£
        combatBgmVolume: document.getElementById('combatBgmVolumeSlider').value, // â† ã“ã®è¡Œã‚’è¿½åŠ 
        language: currentLanguage
    };

    const panelStates = {};
    // â–¼â–¼â–¼ ã“ã®ãƒªã‚¹ãƒˆã« "bodyPanel" ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
const panelIds = ["mapPanel", "statusPanel", "turnPanel", "logPanel", "inventoryPanel", "equipmentPanel", "craftingPanel", "characterPanel", "currentLocationPanel", "minimapPanel", "itemDetailPanel", "bodyPanel"];
    
    panelIds.forEach(id => {
        const panel = document.getElementById(id);
        if (panel) {
            panelStates[id] = {
                left: panel.style.left,
                top: panel.style.top,
                width: panel.style.width,
                height: panel.style.height,
                zIndex: panel.style.zIndex,
                isMinimized: panel.classList.contains('minimized')
            };
        }
    });

    return { options, panelStates };
}

/**
 * ä¿å­˜ã•ã‚ŒãŸUIã¨ã‚ªãƒ—ã‚·ãƒ§ãƒ³è¨­å®šã‚’ã‚²ãƒ¼ãƒ ã«é©ç”¨ã™ã‚‹é–¢æ•°
 */
async function applyUISettings(settings) {
    if (!settings) return;

    // ã‚ªãƒ—ã‚·ãƒ§ãƒ³è¨­å®šã‚’é©ç”¨
    if (settings.options) {
        document.getElementById('volumeSlider').value = settings.options.ambientVolume;
        document.getElementById('voiceVolumeSlider').value = settings.options.voiceVolume;
        document.getElementById('speechVolumeSlider').value = settings.options.speechVolume; // ä¿®æ­£
        document.getElementById('combatBgmVolumeSlider').value = settings.options.combatBgmVolume || 0.5; // â† ã“ã®è¡Œã‚’è¿½åŠ 
        // è¨€èªè¨­å®šã‚’é©ç”¨ã—ã€UIã®ç¿»è¨³ã‚’æ›´æ–°
        if (currentLanguage !== settings.options.language) {
            await loadLanguage(settings.options.language);
        }
    }

    // ãƒ‘ãƒãƒ«ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’é©ç”¨
    if (settings.panelStates) {
        let maxLoadedZIndex = 10;
        for (const panelId in settings.panelStates) {
            const panel = document.getElementById(panelId);
            const state = settings.panelStates[panelId];
            if (panel && state) {
                panel.style.left = state.left;
                panel.style.top = state.top;
                panel.style.width = state.width;
                panel.style.height = state.height;
                panel.style.zIndex = state.zIndex;

                if (state.isMinimized) {
                    panel.classList.add('minimized');
                } else {
                    panel.classList.remove('minimized');
                }

                if (parseInt(state.zIndex) > maxLoadedZIndex) {
                    maxLoadedZIndex = parseInt(state.zIndex);
                }
            }
        }
        maxZIndex = maxLoadedZIndex;
    }
}
async function saveGame() {
  const gameState = getGameState();
  await ipcRenderer.invoke('save-game', gameState);
  log(getString("log_game_saved"), true);
}
/**
 * ç¾åœ¨ã®UIãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜ã™ã‚‹é–¢æ•°
 */
/**
 * ç¾åœ¨ã®UIãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜ã™ã‚‹é–¢æ•° (ãƒ‡ãƒãƒƒã‚°ã‚³ãƒ¼ãƒ‰è¿½åŠ ç‰ˆ)
 */
async function saveUILayout() {
  console.log("--- UIãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆä¿å­˜é–‹å§‹ ---"); // â˜…ãƒ‡ãƒãƒƒã‚°
  const uiSettings = getUISettings();

  // â˜…ãƒ‡ãƒãƒƒã‚°: å–å¾—ã—ãŸUIè¨­å®šãƒ‡ãƒ¼ã‚¿ãŒæ­£ã—ã„ã‹ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«å‡ºåŠ›
  console.log("å–å¾—ã—ãŸUIè¨­å®š:", uiSettings);

  if (!uiSettings || Object.keys(uiSettings.panelStates).length === 0) {
    console.error("ã‚¨ãƒ©ãƒ¼: UIè¨­å®šã®å–å¾—ã«å¤±æ•—ã—ãŸã‹ã€å¯¾è±¡ãƒ‘ãƒãƒ«ãŒã‚ã‚Šã¾ã›ã‚“ã€‚");
    log("UIãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
    return;
  }

  // ãƒ¡ã‚¤ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ã«ãƒ‡ãƒ¼ã‚¿ã‚’é€ã‚‹
  const result = await ipcRenderer.invoke('save-ui-layout', uiSettings);

  // â˜…ãƒ‡ãƒãƒƒã‚°: ãƒ¡ã‚¤ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰ã®å¿œç­”ã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«å‡ºåŠ›
  console.log("ãƒ¡ã‚¤ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰ã®å¿œç­”:", result);

  if (result && result.success) {
    log(getString("log_ui_layout_saved"), true);
  } else {
    log("UIãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
    // â˜…ãƒ‡ãƒãƒƒã‚°: ã‚¨ãƒ©ãƒ¼ã®è©³ç´°ã‚’å‡ºåŠ›
    console.error("ä¿å­˜å¤±æ•—ã®ç†ç”±:", result ? result.error : "ä¸æ˜ãªã‚¨ãƒ©ãƒ¼");
  }
  console.log("--- UIãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆä¿å­˜çµ‚äº† ---"); // â˜…ãƒ‡ãƒãƒƒã‚°
}
async function loadGame() {
  stopMenuBGM(); // â† ã“ã®è¡Œã‚’è¿½åŠ 
  isLoading = true;
  try {
    const gameState = await ipcRenderer.invoke('load-game');
    if (gameState) {
      document.getElementById('startScreen').style.display = 'none';
      const panels = ["mapPanel", "statusPanel", "turnPanel", "logPanel", "inventoryPanel", "craftingPanel", "characterPanel", "currentLocationPanel", "minimapPanel", "bodyPanel"];
      panels.forEach(id => {
          const panel = document.getElementById(id);
          if (panel) {
              panel.style.display = 'block';
               if (['mapPanel', 'inventoryPanel', 'minimapPanel', 'craftingPanel', 'currentLocationPanel'].includes(panel.id)) {
                 panel.style.display = 'flex';
               }
          }
      });
      isGameRunning = true; 
      applyGameState(gameState);
    } else {
      log(getString("log_save_not_found"));
    }
  } finally {
    isLoading = false;
    // â–¼â–¼â–¼ ã“ã®è¡Œã‚’æ–°ã—ãè¿½åŠ  â–¼â–¼â–¼
    isInteractionActive = false; // ãƒ­ãƒ¼ãƒ‰å®Œäº†æ™‚ã«ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ­ãƒƒã‚¯ã‚’å¼·åˆ¶è§£é™¤
  }
}

// ã“ã“ã‹ã‚‰ä¸‹ãŒå…ƒã€…ã®ã‚²ãƒ¼ãƒ ã‚³ãƒ¼ãƒ‰ã§ã™
let availableVoices = []; // â† ã“ã®è¡Œã‚’è¿½åŠ 
let targetingState = {
    active: false,
    item: null,
    itemIndex: -1,
    source: '',
    range: 0,
    callback: null
};

let mapIconIntervals = []; 
let isLoading = false; // â† ã“ã®è¡Œã‚’è¿½åŠ 
let currentLanguage = 'en'; // ç¾åœ¨é¸æŠã•ã‚Œã¦ã„ã‚‹è¨€èªã‚³ãƒ¼ãƒ‰ã‚’ä¿æŒ (åˆæœŸå€¤: è‹±èª)
let stringTable = {};     // èª­ã¿è¾¼ã‚“ã ç¿»è¨³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¿æŒã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
let maxZIndex = 10;
let tempSettings = {}; // â˜…ã“ã®è¡Œã‚’è¿½åŠ 
let minimapZoomLevel = 2;
const minimizedPanels = [];
let logSpeechQueue = []; 
let currentItemDetail = null;
// â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã«ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
let lightningTimeout = null;

// å¤©å€™ã‚·ã‚¹ãƒ†ãƒ ã®å®šç¾©
const weatherTypes = {
  'sunny':  { nameKey: 'weather_sunny',  icon: 'images/icons/weather_sunny.png', tempMod: 2 },
  'cloudy': { nameKey: 'weather_cloudy', icon: 'images/icons/weather_cloudy.png', tempMod: 0 },
  'rainy':  { nameKey: 'weather_rainy',  icon: 'images/icons/weather_rain.png',   tempMod: -3 },
  'stormy': { nameKey: 'weather_stormy', icon: 'images/icons/weather_storm.png', tempMod: -5 }
};
const weatherTransitions = {
  'sunny':  [ { next: 'sunny', weight: 80 }, { next: 'cloudy', weight: 20 } ],
  'cloudy': [ { next: 'sunny', weight: 25 }, { next: 'cloudy', weight: 50 }, { next: 'rainy', weight: 25 } ],
  'rainy':  [ { next: 'cloudy', weight: 60 }, { next: 'rainy', weight: 30 }, { next: 'stormy', weight: 10 } ],
  'stormy': [ { next: 'rainy', weight: 90 },  { next: 'stormy', weight: 10 } ]
};
let currentWeather = { ...weatherTypes['sunny'], id: 'sunny' };

let currentTemperature = 25;
let isInteractionActive = false;
let currentEnemy = null;
let combatDistance = 0;
let currentNPC = null;
// â–²â–²â–² ç½®ãæ›ãˆã¯ã“ã“ã¾ã§ â–²â–²â–²
let playerStatsBeforeAction = {};
let salvationCityCoords = { x: -1, y: -1 };
let salvationCityDiscovered = false;
let entities = [];
let currentSoundLevel = 0;
let currentPlayerSmell = 0;
let previousPlayerSmell = 0;
let previousSoundLevel = 0;
let placedObjects = []; 

const salvationCityLocation = {
    nameKey: "location_salvation_city",
    icon: "ğŸŒŸ",
    loot: 0,
    zombie: 0,
    ascii: `
  /\\||/\\
 | (++) |
  \\||||/
   ||||
   ||||`
};

function bringToFront(elm) {
  maxZIndex++;
  elm.style.zIndex = maxZIndex;
}

function togglePanelSize(elm) {
  const header = elm.querySelector(".panel-header");
  const headerHeight = header.offsetHeight + 10;
  const margin = 10;

  if (elm.classList.contains("minimized")) {
    elm.classList.remove("minimized");
    elm.style.removeProperty("right");
    elm.style.removeProperty("bottom");
    elm.style.width = elm.dataset.originalWidth;
    elm.style.height = elm.dataset.originalHeight;
    elm.style.left = elm.dataset.originalLeft;
    elm.style.top = elm.dataset.originalTop;
    elm.querySelector(".resize-handle").style.display = "block";
    elm.style.overflow = "";
    const index = minimizedPanels.indexOf(elm);
    if (index > -1) {
      minimizedPanels.splice(index, 1);
    }
    restackMinimizedPanels();
    bringToFront(elm);
  } else {
    elm.dataset.originalWidth = elm.style.width;
    elm.dataset.originalHeight = elm.style.height;
    elm.dataset.originalLeft = elm.style.left;
    elm.dataset.originalTop = elm.style.top;
    elm.classList.add("minimized");
    elm.style.width = `${elm.offsetWidth}px`;
    elm.style.height = `${headerHeight}px`;
    elm.style.left = '';
    elm.style.top = '';
    elm.querySelector(".resize-handle").style.display = "none";
    elm.style.overflow = "hidden";
    minimizedPanels.push(elm);
    restackMinimizedPanels();
    bringToFront(elm);
  }
}

function restackMinimizedPanels() {
  const margin = 10;
  let totalWidth = 0;
  for (let i = minimizedPanels.length - 1; i >= 0; i--) {
    const panel = minimizedPanels[i];
    panel.style.right = `${margin + totalWidth}px`;
    panel.style.bottom = `${margin}px`;
    totalWidth += panel.offsetWidth + margin;
  }
}
// index.htmlã®<script>ã‚¿ã‚°å†…

// â–¼â–¼â–¼ æ—¢å­˜ã®`handleNpcItemLogic`é–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
/**
 * NPCãŒåœ°é¢ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’è©•ä¾¡ã—ã€æ‹¾ã£ã¦è£…å‚™ã™ã‚‹å‡¦ç†
 * @param {object} entity - å¯¾è±¡ã®NPCã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
 */
function handleNpcItemLogic(entity) {
    const locationKey = `${entity.x},${entity.y}`;
    const itemsOnGround = droppedItems[locationKey];
    if (!itemsOnGround || itemsOnGround.length === 0) return;

    let itemsToConsider = [...itemsOnGround];
    let pickedUpSomething = false;

    itemsToConsider.forEach(item => {
        let desirability = 0;
        let targetSlot = item.slot;
        let currentlyEquipped = null;

        // æ­¦å™¨ã®è©•ä¾¡
        if (item.attack) {
            const currentWeapon = entity.equipment.find(e => e.slot === 'weapon' || e.slot === 'main_hand' || e.handedness === 'two');
            currentlyEquipped = currentWeapon;
            desirability = (item.attack || 0) - (currentWeapon ? (currentWeapon.attack || 0) : 0);
        }
        // é˜²å…·ã®è©•ä¾¡
        else if (item.defense) {
            currentlyEquipped = entity.equipment.find(e => e.slot === targetSlot);
            desirability = (item.defense || 0) - (currentlyEquipped ? (currentlyEquipped.defense || 0) : 0);
        }
        // ä¾¡å€¤ã®é«˜ã„æ¶ˆè²»ã‚¢ã‚¤ãƒ†ãƒ ã®è©•ä¾¡ (ä¾‹: æ•‘æ€¥ã‚­ãƒƒãƒˆ)
        else if (item.value > 50 && item.type === 'consumable') {
            desirability = 5; // é«˜ã„å„ªå…ˆåº¦
        }

        // æ‹¾ã†ä¾¡å€¤ãŒã‚ã‚‹ã‹åˆ¤æ–­
        if (desirability > 0 && (entity.weight + (item.weight || 0) <= entity.maxWeight) && (entity.volume + (item.volume || 0) <= entity.maxVolume)) {
            const itemIndexOnGround = droppedItems[locationKey].findIndex(i => i === item);
            if (itemIndexOnGround > -1) {
                const pickedUpItem = droppedItems[locationKey].splice(itemIndexOnGround, 1)[0];
                entity.inventory.push(pickedUpItem);
                
                const npcName = getString(`item_${entity.name}_name`) || entity.name;
                
                // â–¼â–¼â–¼ ä¿®æ­£ç‚¹1: ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ‹¾ã£ãŸéš›ã®ãƒ­ã‚°ã‚’ç„¡åŠ¹åŒ– â–¼â–¼â–¼
                // log(getString("log_npc_pickup_item", { npcName: npcName, itemName: getItemDisplayName(pickedUpItem) }));
                
                // è£…å‚™ã§ãã‚‹ã‚¢ã‚¤ãƒ†ãƒ ãªã‚‰ã€è£…å‚™ã‚‚è©¦ã¿ã‚‹
                if (pickedUpItem.slot) {
                    const newEquipIndex = entity.inventory.length - 1;
                    if (currentlyEquipped) {
                        const oldEquipIndex = entity.equipment.findIndex(e => e === currentlyEquipped);
                        if (oldEquipIndex > -1) {
                            entity.inventory.push(entity.equipment.splice(oldEquipIndex, 1)[0]);
                        }
                    }
                    entity.equipment.push(entity.inventory.splice(newEquipIndex, 1)[0]);
                    
                    // â–¼â–¼â–¼ ä¿®æ­£ç‚¹2: ã‚¢ã‚¤ãƒ†ãƒ ã‚’è£…å‚™ã—ãŸéš›ã®ãƒ­ã‚°ã‚’ç„¡åŠ¹åŒ– â–¼â–¼â–¼
                    // log(getString("log_npc_equip_item", { npcName: npcName, itemName: getItemDisplayName(pickedUpItem) }));
                }
                
                updateNpcStats(entity);
                pickedUpSomething = true;
            }
        }
    });

    if (pickedUpSomething) {
        updateCurrentLocationPanel(false);
    }
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’æ–°ã—ãè¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
/**
 * NPCã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’è£…å‚™ã«åŸºã¥ã„ã¦å†è¨ˆç®—ã™ã‚‹
 * @param {object} npc - å¯¾è±¡ã®NPCã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
 */
function updateNpcStats(npc) {
    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’åŸºæœ¬å€¤ã«ãƒªã‚»ãƒƒãƒˆ
    npc.attack = npc.baseAttack;
    npc.defense = npc.baseDefense;
    npc.insulation = 0;
    npc.maxWeight = 20; // NPCã®åŸºæœ¬æœ€å¤§é‡é‡
    npc.maxVolume = 20; // NPCã®åŸºæœ¬æœ€å¤§å®¹é‡

    let totalWeight = 0;
    let totalVolume = 0;

    // è£…å‚™å“ã®åŠ¹æœã‚’åˆè¨ˆ
    npc.equipment.forEach(item => {
        const durabilityFactor = (item.durability === undefined ? 100 : item.durability) / 100;
        npc.attack += (item.attack || 0) * durabilityFactor;
        npc.defense += (item.defense || 0) * durabilityFactor;
        npc.insulation += (item.insulation || 0) * durabilityFactor;
        if (item.effects) {
            if (item.effects.maxWeight) npc.maxWeight += item.effects.maxWeight;
            if (item.effects.maxVolume) npc.maxVolume += item.effects.maxVolume;
        }
    });

    // æœ€çµ‚çš„ãªã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’æ•´æ•°ã«ä¸¸ã‚ã‚‹
    npc.attack = Math.floor(npc.attack);
    npc.defense = Math.floor(npc.defense);

    // ç¾åœ¨ã®é‡é‡ã¨å®¹é‡ã‚’å†è¨ˆç®—
    npc.weight = [...npc.inventory, ...npc.equipment].reduce((sum, item) => sum + (item.weight || 0), 0);
    npc.volume = npc.inventory.reduce((sum, item) => sum + (item.volume || 0), 0);
}
function makeDraggable(elm) {
  const header = elm.querySelector(".panel-header");
  if (!header) return;
  header.style.cursor = "grab";
  let startX, startY, initialLeft, initialTop;
  const dragMouseDown = (e) => {
    e.preventDefault();
    if(elm.classList.contains("minimized")) return;

    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ãƒ–ãƒ­ãƒƒã‚¯ã§ã™ â–¼â–¼â–¼
    // æœ€åˆã«ç¾åœ¨ã®è¦‹ãŸç›®ã®ä½ç½®ã‚’ãƒ”ã‚¯ã‚»ãƒ«å˜ä½ã§å–å¾—ã—ã¾ã™
    const rect = elm.getBoundingClientRect();
    
    // transformã‚’è§£é™¤ã—ã€å–å¾—ã—ãŸãƒ”ã‚¯ã‚»ãƒ«ä½ç½®ã‚’top/leftã«è¨­å®šã—ç›´ã—ã¾ã™
    // ã“ã‚Œã«ã‚ˆã‚Šã€è¦‹ãŸç›®ã®ä½ç½®ã‚’å¤‰ãˆãšã«ãƒ‰ãƒ©ãƒƒã‚°ã‚’é–‹å§‹ã§ãã¾ã™
    elm.style.transform = 'none'; 
    elm.style.left = rect.left + 'px';
    elm.style.top = rect.top + 'px';
    // â–²â–²â–² ä¿®æ­£ãƒ–ãƒ­ãƒƒã‚¯ã“ã“ã¾ã§ â–²â–²â–²

    bringToFront(elm);
    startX = e.clientX;
    startY = e.clientY;
    initialLeft = parseFloat(getComputedStyle(elm).left);
    initialTop = parseFloat(getComputedStyle(elm).top);
    header.style.cursor = "grabbing";
    window.addEventListener("mousemove", elementDrag);
    window.addEventListener("mouseup", closeDragElement);
  };
  const elementDrag = (e) => {
    e.preventDefault();
    let deltaX = e.clientX - startX;
    let deltaY = e.clientY - startY;
    let newLeft = initialLeft + deltaX;
    let newTop = initialTop + deltaY;
    newTop = Math.max(0, newTop);
    newLeft = Math.max(0, newLeft);
    newTop = Math.min(window.innerHeight - elm.offsetHeight, newTop);
    newLeft = Math.min(window.innerWidth - elm.offsetWidth, newLeft);
    elm.style.left = newLeft + "px";
    elm.style.top = newTop + "px";
  };
  const closeDragElement = () => {
    header.style.cursor = "grab";
    window.removeEventListener("mousemove", elementDrag);
    window.removeEventListener("mouseup", closeDragElement);
  };
  header.addEventListener("mousedown", dragMouseDown);
}
// â–¼â–¼â–¼ ã“ã®3ã¤ã®é–¢æ•°ã‚’æ–°ã—ãè¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼

/**
 * ç¾åœ¨ã®è¨­å®šã‚’ä¸€æ™‚å¤‰æ•°ã«ä¿å­˜ã—ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ç”»é¢ã‚’é–‹ãé–¢æ•°
 */
function openOptionsAndCaptureState() {
    // ç¾åœ¨ã®å„è¨­å®šå€¤ã‚’tempSettingsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ä¿å­˜
    tempSettings = {
        ambientVolume: document.getElementById('volumeSlider').value,
        voiceVolume: document.getElementById('voiceVolumeSlider').value,
        // â–¼â–¼â–¼ ã“ã®è¡Œã‚’ä¿®æ­£ â–¼â–¼â–¼
        speechVolume: document.getElementById('speechVolumeSlider').value,
        combatBgmVolume: document.getElementById('combatBgmVolumeSlider').value, // â† ã“ã®è¡Œã‚’è¿½åŠ 
        language: currentLanguage
    };
    
    // è¨€èªãƒœã‚¿ãƒ³ã®è¡¨ç¤ºã‚’ç¾åœ¨ã®è¨€èªã«åˆã‚ã›ã‚‹
    document.querySelectorAll('#languageSwitcher button').forEach(btn => {
        btn.classList.remove('active');
        if (btn.id === `langBtn${tempSettings.language.charAt(0).toUpperCase() + tempSettings.language.slice(1)}` || (tempSettings.language === 'zh-CN' && btn.id === 'langBtnZh')) {
            btn.classList.add('active');
        }
    });

    // ã‚ªãƒ—ã‚·ãƒ§ãƒ³ç”»é¢ã‚’è¡¨ç¤º
    document.getElementById('optionsScreen').style.display = 'flex';
}

/**
 * ã‚ªãƒ—ã‚·ãƒ§ãƒ³ç”»é¢ã®è¨­å®šã‚’é©ç”¨ã—ã€æ°¸ç¶šçš„ã«ä¿å­˜ã™ã‚‹é–¢æ•°
 */
async function applyAndSaveSettings() {
    const newLang = Array.from(document.querySelectorAll('#languageSwitcher button')).find(btn => btn.classList.contains('active')).id.replace('langBtn', '').toLowerCase();

    // 1. è¨­å®šå€¤ã‚’UIã‹ã‚‰å–å¾—
    const newSettings = {
        ambientVolume: document.getElementById('volumeSlider').value,
        voiceVolume: document.getElementById('voiceVolumeSlider').value,
        // â–¼â–¼â–¼ ä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
        speechVolume: document.getElementById('speechVolumeSlider').value,
        combatBgmVolume: document.getElementById('combatBgmVolumeSlider').value, // â† ã“ã®è¡Œã‚’è¿½åŠ 
        language: (newLang === 'zh') ? 'zh-CN' : newLang
    };

    // 2. ã‚²ãƒ¼ãƒ ã«è¨­å®šã‚’é©ç”¨
    // â–¼â–¼â–¼ ä¸è¦ã«ãªã£ãŸè¡Œã‚’å‰Šé™¤ â–¼â–¼â–¼
    // isSpeechEnabled = newSettings.speechEnabled; 

    updateWeatherAudio();

    // è¨€èªãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆã®ã¿ã€è¨€èªãƒ•ã‚¡ã‚¤ãƒ«ã‚’å†èª­ã¿è¾¼ã¿
    if (currentLanguage !== newSettings.language) {
        await loadLanguage(newSettings.language);
    }
    
    // 3. mainãƒ—ãƒ­ã‚»ã‚¹ã«è¨­å®šã®ä¿å­˜ã‚’ä¾é ¼
    ipcRenderer.invoke('save-settings', newSettings);
    
    // 4. ã‚ªãƒ—ã‚·ãƒ§ãƒ³ç”»é¢ã‚’é–‰ã˜ã‚‹
    document.getElementById('optionsScreen').style.display = 'none';
    if (!isGameRunning) {
        document.getElementById('startScreen').style.display = 'flex';
    }
}

/**
 * ã‚ªãƒ—ã‚·ãƒ§ãƒ³ç”»é¢ã§ã®å¤‰æ›´ã‚’ç ´æ£„ã—ã€å…ƒã®è¨­å®šã«æˆ»ã—ã¦ç”»é¢ã‚’é–‰ã˜ã‚‹é–¢æ•°
 */
function cancelSettingsChanges() {
    // UIã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚’ã€ç”»é¢ã‚’é–‹ã„ãŸæ™‚ã®çŠ¶æ…‹ï¼ˆtempSettingsï¼‰ã«æˆ»ã™
    document.getElementById('volumeSlider').value = tempSettings.ambientVolume;
    document.getElementById('voiceVolumeSlider').value = tempSettings.voiceVolume;
    // â–¼â–¼â–¼ ã“ã®è¡Œã‚’ä¿®æ­£ â–¼â–¼â–¼
    document.getElementById('speechVolumeSlider').value = tempSettings.speechVolume;
    document.getElementById('combatBgmVolumeSlider').value = tempSettings.combatBgmVolume; // â† ã“ã®è¡Œã‚’è¿½åŠ 
    // ã‚ªãƒ—ã‚·ãƒ§ãƒ³ç”»é¢ã‚’é–‰ã˜ã‚‹
    document.getElementById('optionsScreen').style.display = 'none';
    if (!isGameRunning) {
        document.getElementById('startScreen').style.display = 'flex';
    }
}

// â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²
function makeResizable(elm) {
  const handle = elm.querySelector(".resize-handle");
  if (!handle) return;
  let pos = {x:0, y:0, w:0, h:0};
  const resizeMouseDown = (e) => {
    e.preventDefault();
    if(elm.classList.contains("minimized")) return;
    bringToFront(elm);
    pos.x = e.clientX;
    pos.y = e.clientY;
    pos.w = elm.offsetWidth;
    pos.h = elm.offsetHeight;
    window.addEventListener("mousemove", elementResize);
    window.addEventListener("mouseup", closeResizeElement);
  };
  const elementResize = (e) => {
    e.preventDefault();
    let dx = e.clientX - pos.x;
    let dy = e.clientY - pos.y;
    let newW = pos.w + dx;
    let newH = pos.h + dy;
    if (newW < 100) newW = 100;
    if (newH < 80) newH = 80;
    elm.style.width = newW + "px";
    elm.style.height = newH + "px";
    if (elm.id === "mapPanel") {
      drawMap();
    }
    if (elm.id === "minimapPanel") {
        drawMinimap();
    }
    // â–¼â–¼â–¼ ã“ã®ifæ–‡ã‚’è¿½åŠ  â–¼â–¼â–¼
    if (elm.id === "currentLocationPanel") {
        updateLocationPanelImageSize();
    }
    // â–²â–²â–² è¿½åŠ ã¯ã“ã“ã¾ã§ â–²â–²â–²
  };
  const closeResizeElement = () => {
    window.removeEventListener("mousemove", elementResize);
    window.removeEventListener("mouseup", closeResizeElement);
  };
  handle.addEventListener("mousedown", resizeMouseDown);
}

// â–¼â–¼â–¼ ã“ã®é…åˆ—ã‚’ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼

// index.htmlå†…
// index.htmlå†…

// index.htmlå†…

const characterTraits = [
  { id: "tough_body", effects: { health: 20, maxWeight: 5 } },
  { id: "frail", effects: { health: -20, maxWeight: -5, morale: -15 } },
  { id: "strong_willed", effects: { morale: 30, sleep: -10 } },
  { id: "insomniac", effects: { sleep: 40, morale: -20 } },
  { id: "good_eyesight", effects: { vision: 1 } },
  { id: "bad_eyesight", effects: { vision: -1 } },
  { id: "fast_learner", effects: { morale: 20 } },
  { id: "big_eater", effects: { hunger: -20 } },
  { id: "optimist", effects: { morale: 15 } },
  { id: "pessimist", effects: { morale: -15 } },
  { id: "deft_hands", effects: {} },
  { id: "clumsy_hands", effects: {} },
  { id: "cowardly", effects: { morale: -20 } }
];

let character = {
  fullNameKey: "",
  age: 0,
  gender: "",
  job: "",
  race: "",
  traits: [],
  salvationCityHint: ""
};

// index.html å†…

const characterProfiles = [
    // Asian
    { nameKey: "char_name_akira_nakayama", genderKey: "gender_male", raceKey: "race_asian" },
    { nameKey: "char_name_ryoko_tanaka", genderKey: "gender_female", raceKey: "race_asian" },
    { nameKey: "char_name_kenji_sato", genderKey: "gender_male", raceKey: "race_asian" },
    { nameKey: "char_name_masashi_ishida", genderKey: "gender_male", raceKey: "race_asian" },
    { nameKey: "char_name_miki_suzuki", genderKey: "gender_female", raceKey: "race_asian" },
    // White
    { nameKey: "char_name_john_smith", genderKey: "gender_male", raceKey: "race_white" },
    { nameKey: "char_name_emily_jones", genderKey: "gender_female", raceKey: "race_white" },
    { nameKey: "char_name_michael_brown", genderKey: "gender_male", raceKey: "race_white" },
    { nameKey: "char_name_sarah_davis", genderKey: "gender_female", raceKey: "race_white" },
    { nameKey: "char_name_chris_wilson", genderKey: "gender_male", raceKey: "race_white" },
    // Middle-Eastern
    { nameKey: "char_name_ahmad_hassan", genderKey: "gender_male", raceKey: "race_middle_eastern" },
    { nameKey: "char_name_fatima_khan", genderKey: "gender_female", raceKey: "race_middle_eastern" },
    { nameKey: "char_name_yusuf_ali", genderKey: "gender_male", raceKey: "race_middle_eastern" },
    { nameKey: "char_name_zainab_abbas", genderKey: "gender_female", raceKey: "race_middle_eastern" },
    { nameKey: "char_name_rashid_saeed", genderKey: "gender_male", raceKey: "race_middle_eastern" },
    // Black
    { nameKey: "char_name_jamal_williams", genderKey: "gender_male", raceKey: "race_black" },
    { nameKey: "char_name_aliya_jackson", genderKey: "gender_female", raceKey: "race_black" },
    { nameKey: "char_name_caleb_johnson", genderKey: "gender_male", raceKey: "race_black" },
    { nameKey: "char_name_iman_adebayo", genderKey: "gender_female", raceKey: "race_black" }
];

const jobs = [
  "job_ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢", "job_åŒ»å¸«", "job_è»äºº", "job_æ•™å¸«", "job_ã‚¢ã‚¹ãƒªãƒ¼ãƒˆ",
  "job_è­¦å¯Ÿå®˜", "job_çœ‹è­·å¸«", "job_ã‚·ã‚§ãƒ•", "job_å­¦ç”Ÿ", "job_ä¼šç¤¾å“¡"
];
// â–¼â–¼â–¼ ã“ã®3ã¤ã®ãƒ–ãƒ­ãƒƒã‚¯ã§æ—¢å­˜ã®seasonInfoã¨weatherInfoã‚’ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼

const seasonInfo = {
    'æ˜¥': { icon: 'images/icons/season_spring.png' },
    'å¤': { icon: 'images/icons/season_summer.png' },
    'ç§‹': { icon: 'images/icons/season_autumn.png' },
    'å†¬': { icon: 'images/icons/season_winter.png' }
};

const weatherInfo = {
    'å¿«æ™´': { icon: 'images/icons/weather_sunny.png' },
    'æ›‡ã‚Š': { icon: 'images/icons/weather_cloudy.png' },
    'é›¨': { icon: 'images/icons/weather_rain.png' },
    'åµ': { icon: 'images/icons/weather_storm.png' }
};

// æ–°ã—ãè¿½åŠ 
const dayStateInfo = {
    'æœ': { icon: 'images/icons/time_morning.png' },
    'æ˜¼': { icon: 'images/icons/time_day.png' },
    'å¤•æ–¹': { icon: 'images/icons/time_evening.png' },
    'å¤œ': { icon: 'images/icons/time_night.png' }
};

// â–²â–²â–² ç½®ãæ›ãˆã“ã“ã¾ã§ â–²â–²â–²

function generateRandomCharacter() {
  const profile = randChoice(characterProfiles);
  character.fullNameKey = profile.nameKey;
  character.gender = profile.genderKey;
  character.race = profile.raceKey;
  character.age = Math.floor(Math.random() * 43) + 18;
  character.job = randChoice(jobs);
  
  const opposites = {
    "tough_body": "frail", "frail": "tough_body",
    "good_eyesight": "bad_eyesight", "bad_eyesight": "good_eyesight",
    "strong_willed": "cowardly", "cowardly": "strong_willed",
    "optimist": "pessimist", "pessimist": "optimist",
    "deft_hands": "clumsy_hands", "clumsy_hands": "deft_hands"
  };

  let traitPool = [...characterTraits];
  const selectedTraits = [];
  const numberOfTraits = Math.random() < 0.5 ? 1 : 2;
  
  for (let i = 0; i < numberOfTraits; i++) {
    if (traitPool.length === 0) break;
    
    const traitIndex = Math.floor(Math.random() * traitPool.length);
    const selected = traitPool.splice(traitIndex, 1)[0];
    selectedTraits.push(selected.id); // 'name' ã§ã¯ãªã 'id' ã‚’ä¿å­˜

    const oppositeTrait = opposites[selected.id];
    if (oppositeTrait) {
      traitPool = traitPool.filter(t => t.id !== oppositeTrait);
    }
  }
  
  character.traits = selectedTraits;
  character.salvationCityHint = "";
}

const mapSize = 200;
const viewportSize = 13;
let maxStats = {};
const baseMaxStat = 100;
// index.htmlå†…

function calculateMaxStats() {
  if (!character || !character.traits) {
    maxStats = {
      hunger: baseMaxStat, thirst: baseMaxStat, health: baseMaxStat, morale: baseMaxStat, sleep: baseMaxStat,
      // â–¼â–¼â–¼ ä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
      bodyTemp: 41, maxWeight: 12.0, maxVolume: 10.0, vision: 5, bodyOdor: 100,
      bloodLevel: 100,       // â˜…ã“ã®è¡Œã‚’è¿½åŠ 
      immuneSystem: 100,   // â˜…ã“ã®è¡Œã‚’è¿½åŠ 
      painTolerance: 100,  // â˜…ã“ã®è¡Œã‚’è¿½åŠ 
      // â–²â–²â–² ä¿®æ­£ã“ã“ã¾ã§ â–²â–²â–²
      carbs: 100, protein: 100, fat: 100, vitamins: 100
    };
    return;
  }

  const age = character.age;
  const gender = character.gender;
  const job = character.job;
  const race = character.race;
  const traits = character.traits;
  
  maxStats = {
    hunger: baseMaxStat,
    thirst: baseMaxStat,
    health: baseMaxStat,
    morale: baseMaxStat,
    sleep: baseMaxStat,
    maxResearchPoints: 1000, 
    bodyTemp: 41,
    // â–¼â–¼â–¼ ä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
    maxWeight: 12.0, // ææ¡ˆã—ãŸåŸºæœ¬å€¤
    maxVolume: 10.0, // ææ¡ˆã—ãŸåŸºæœ¬å€¤
    // â–²â–²â–² ä¿®æ­£ã“ã“ã¾ã§ â–²â–²â–²
    vision: 5,
    bodyOdor: 100,
    bloodLevel: 100,       // â˜…æ–°ã—ã„ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
    immuneSystem: 100,   // â˜…æ–°ã—ã„ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
    painTolerance: 100,  // â˜…æ–°ã—ã„ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
    carbs: 100, 
    protein: 100, 
    fat: 100, 
    vitamins: 100
  };
  
  if (job === 'è»äºº' || job === 'ã‚¢ã‚¹ãƒªãƒ¼ãƒˆ') maxStats.maxWeight += 8;
  if (job === 'ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢' || job === 'ã‚·ã‚§ãƒ•') maxStats.maxWeight += 3;
  if (job === 'å­¦ç”Ÿ' || job === 'æ•™å¸«') maxStats.maxWeight -= 2;

  if (gender === "ç”·æ€§") maxStats.maxWeight += 4;

  if (age < 20) {
    maxStats.health += 20; maxStats.sleep += 15; maxStats.morale -= 10;
  } else if (age >= 20 && age < 40) {
    maxStats.health += 10;
  } else if (age >= 40 && age < 60) {
    maxStats.health -= 15; maxStats.morale += 15;
  } else {
    maxStats.health -= 30; maxStats.sleep -= 20; maxStats.morale += 10;
  }
  
  if (gender === "ç”·æ€§") {
    maxStats.health += 10; maxStats.hunger += 10;
  } else if (gender === "å¥³æ€§") {
    maxStats.morale += 10; maxStats.sleep += 5;
  }
  
  traits.forEach(traitId => {
      const trait = characterTraits.find(t => t.id === traitId);
      if (trait && trait.effects) {
        for(const stat in trait.effects){
            if(stat === 'maxWeight' || stat === 'vision') {
                 maxStats[stat] = (maxStats[stat] || 0) + trait.effects[stat];
            } else {
                 maxStats[stat] = (maxStats[stat] || baseMaxStat) + trait.effects[stat];
            }
        }
      }
  });

  Object.keys(maxStats).forEach(stat => {
    // â˜…ä¿®æ­£ç‚¹: æ–°ã—ã„ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒ50æœªæº€ã«åˆ‡ã‚Šè©°ã‚ã‚‰ã‚Œãªã„ã‚ˆã†ã«ã€é™¤å¤–ãƒªã‚¹ãƒˆã«è¿½åŠ 
    const excludedStats = ['bodyTemp', 'maxWeight', 'vision', 'maxVolume', 'bodyOdor', 'bloodLevel', 'immuneSystem', 'painTolerance'];
    if (!excludedStats.includes(stat)) {
      maxStats[stat] = Math.max(50, Math.min(200, maxStats[stat]));
    }
  });
}

const fieldLocation = { nameKey: "location_untilled_field", icon: "images/field.png", loot: 40, zombie: 2, ascii: `~~~~~~\n #####\n~# * #~\n #####\n~~~~~~` };
const biomeLocations = {
    Plains: [
        { nameKey: "location_plains", icon: "images/plains.png", loot: 5, zombie: 8, ascii: `  ~~~~~\n ~     ~\n~   "   ~\n ~     ~\n  ~~~~~`, blocksVision: false },
        { nameKey: "location_plains", icon: "images/plains.png", loot: 5, zombie: 8, ascii: `  ~~~~~\n ~     ~\n~   "   ~\n ~     ~\n  ~~~~~`, blocksVision: false },
        { nameKey: "location_plains", icon: "images/plains.png", loot: 5, zombie: 8, ascii: `  ~~~~~\n ~     ~\n~   "   ~\n ~     ~\n  ~~~~~`, blocksVision: false },
        { nameKey: "location_plains", icon: "images/plains.png", loot: 5, zombie: 8, ascii: `  ~~~~~\n ~     ~\n~   "   ~\n ~     ~\n  ~~~~~`, blocksVision: false },
        { nameKey: "location_plains", icon: "images/plains.png", loot: 5, zombie: 8, ascii: `  ~~~~~\n ~     ~\n~   "   ~\n ~     ~\n  ~~~~~`, blocksVision: false },
        { nameKey: "location_plains", icon: "images/plains.png", loot: 5, zombie: 8, ascii: `  ~~~~~\n ~     ~\n~   "   ~\n ~     ~\n  ~~~~~`, blocksVision: false },
        { nameKey: "location_plains", icon: "images/plains.png", loot: 5, zombie: 8, ascii: `  ~~~~~\n ~     ~\n~   "   ~\n ~     ~\n  ~~~~~`, blocksVision: false },
        { nameKey: "location_pond", icon: "images/pond.png", loot: 2, zombie: 2, ascii: `  ~~~~~\n /     \\\n|  ~ ~  |\n \\_____/`, blocksVision: false },
        { nameKey: "location_rock", icon: "images/rock_terrain.png", loot: 3, zombie: 3, ascii: `   /\\ \n  /  \\ \n /____\\`, blocksVision: false },
        { ...fieldLocation, icon: "images/field.png", blocksVision: false }
    ],
    Forest: [
        { nameKey: "location_forest", icon: "images/forest.png", loot: 15, zombie: 15, ascii: `   TT\n  T  T\n TTT\n   | |`, blocksVision: true },
        { nameKey: "location_cabin", icon: "images/cabin.png", loot: 40, zombie: 5, ascii: `   /\\\n  /  \\\n |----|\n |[]_ |\n |____|`, blocksVision: false },
        { nameKey: "location_rock", icon: "images/rock_terrain.png", loot: 3, zombie: 3, ascii: `   /\\ \n  /  \\ \n /____\\`, blocksVision: false },
        { ...fieldLocation, icon: "images/field.png", blocksVision: false }
    ],
    // â–¼â–¼â–¼ "Town" ã‚’å‰Šé™¤ã—ã€ä»¥ä¸‹ã®3ã¤ã®åœ°åŒºã«ç½®ãæ›ãˆã¾ã™ â–¼â–¼â–¼
    Commercial: [
        { nameKey: "location_commercial", icon: "images/commercial.png", loot: 65, zombie: 35, ascii: ` _______\n|  ___  |\n| |[_]| |\n| |[_]| |\n|_______|`, blocksVision: false }
    ],
    Industrial: [
        { nameKey: "location_industrial", icon: "images/industrial.png", loot: 55, zombie: 40, ascii: `/\\/\\/\\/\\\n|'------'|\n| [__] o |\n|________|`, blocksVision: false }
    ],
    Residential: [
        { nameKey: "location_residential", icon: "images/residential.png", loot: 35, zombie: 25, ascii: `   /\\\n  /--\\\n |'--'|\n | [] |\n |____|`, blocksVision: false }
    ],
    // â–²â–²â–² ç½®ãæ›ãˆã“ã“ã¾ã§ â–²â–²â–²
    Road: [ { nameKey: "location_road", icon: "images/road.png", loot: 15, zombie: 3, ascii: `|       |\n|-------|\n|   |   |\n|-------|\n|       |`, blocksVision: false} ],
    TraderShop: { nameKey: "location_trader_shop", icon: "images/store.png", loot: 0, zombie: 0, ascii: ` _______\n| TRADE |\n|  $$$  |\n|_______|\n|  [] ||`, isShop: true, blocksVision: false }
};
const buildingLootTables = {
    // Commercial
    location_car: [ { name: 'é‰„ããš', chance: 0.6 }, { name: 'å¸ƒåˆ‡ã‚Œ', chance: 0.4 }, { name: 'æ•‘æ€¥ã‚­ãƒƒãƒˆ', chance: 0.1 } ],
    location_office: [ { name: 'æœ¬', chance: 0.5 }, { name: 'ãƒšãƒƒãƒˆãƒœãƒˆãƒ«', chance: 0.4 }, { name: 'ãƒã‚µãƒŸ', chance: 0.3 } ],
    location_apartment: [ { name: 'ç¼¶è©°(è±†)', chance: 0.4 }, { name: 'å¸ƒåˆ‡ã‚Œ', chance: 0.7 }, { name: 'åŒ…å¸¯', chance: 0.3 } ],
    location_warehouse: [ { name: 'ä¸¸å¤ª', chance: 0.3 }, { name: 'é‰„ããš', chance: 0.5 }, { name: 'ãƒ€ã‚¯ãƒˆãƒ†ãƒ¼ãƒ—', chance: 0.4 } ],
    location_restaurant: [ { name: 'åŒ…ä¸', chance: 0.2 }, { name: 'ç¼¶è©°(è±†)', chance: 0.6 }, { name: 'æ±šã‚ŒãŸæ°´', chance: 0.5 } ],
    location_hotel: [ { name: 'ã‚¿ã‚ªãƒ«', chance: 0.5 }, { name: 'ãã‚Œã„ãªæ°´', chance: 0.3 }, { name: 'å¯è¢‹', chance: 0.1 } ],
    // Industrial
    location_factory_small: [ { name: 'é‰„ããš', chance: 0.7 }, { name: 'ãƒ„ãƒ¼ãƒ«ãƒ™ãƒ«ãƒˆ', chance: 0.2 }, { name: 'ãƒ€ã‚¯ãƒˆãƒ†ãƒ¼ãƒ—', chance: 0.3 } ],
    location_truck: [ { name: 'é‰„ããš', chance: 0.5 }, { name: 'ã‚¬ã‚½ãƒªãƒ³', chance: 0.3 }, { name: 'ãƒ­ãƒ¼ãƒ—', chance: 0.4 } ],
    location_gas_station: [ { name: 'ã‚¬ã‚½ãƒªãƒ³', chance: 0.6 }, { name: 'ã‚¨ãƒŠã‚¸ãƒ¼ãƒ‰ãƒªãƒ³ã‚¯', chance: 0.3 }, { name: 'ãƒ©ã‚¤ã‚¿ãƒ¼', chance: 0.2 } ],
    location_bus: [ { name: 'é‰„ããš', chance: 0.8 }, { name: 'å¸ƒåˆ‡ã‚Œ', chance: 0.5 } ],
    location_factory_large: [ { name: 'é‰„ããš', chance: 0.8 }, { name: 'å®‰å…¨ãƒ˜ãƒ«ãƒ¡ãƒƒãƒˆ', chance: 0.3 }, { name: 'ãƒ¯ãƒ¼ã‚¯ãƒ™ãƒ³ãƒã‚­ãƒƒãƒˆ', chance: 0.1 } ],
    // Residential
    location_house_large: [ { name: 'ç¼¶è©°(è±†)', chance: 0.5 }, { name: 'ãã‚Œã„ãªæ°´', chance: 0.4 }, { name: 'ãƒãƒƒã‚¯ãƒ‘ãƒƒã‚¯', chance: 0.15 } ],
    location_house_small: [ { name: 'ãƒ‘ãƒ³', chance: 0.4 }, { name: 'å¸ƒåˆ‡ã‚Œ', chance: 0.6 }, { name: 'åŒ…å¸¯', chance: 0.25 } ],
    location_motorcycle: [ { name: 'é‰„ããš', chance: 0.4 }, { name: 'ã‚¬ã‚½ãƒªãƒ³', chance: 0.2 } ],
    location_church: [ { name: 'æœ¬', chance: 0.6 }, { name: 'å¸ƒåˆ‡ã‚Œ', chance: 0.3 } ],
    location_school: [ { name: 'æœ¬', chance: 0.7 }, { name: 'ã‚¸ãƒ£ãƒ¼ã‚¸', chance: 0.2 }, { name: 'æ•‘æ€¥ã‚­ãƒƒãƒˆ', chance: 0.1 } ]
};

const buildingDangerEvents = {
    // Commercial
    location_car: [ { type: 'trap', chance: 0.3 } ],
    location_office: [ { type: 'zombie', chance: 0.4 } ],
    location_apartment: [ { type: 'zombie', chance: 0.6 } ],
    location_warehouse: [ { type: 'raider', chance: 0.2 }, { type: 'trap', chance: 0.2 } ],
    location_restaurant: [ { type: 'zombie', chance: 0.5 } ],
    location_hotel: [ { type: 'survivor', chance: 0.1 }, { type: 'raider', chance: 0.1 } ],
    // Industrial
    location_factory_small: [ { type: 'zombie', chance: 0.6 }, { type: 'trap', chance: 0.2 } ],
    location_truck: [ { type: 'raider', chance: 0.2 } ],
    location_gas_station: [ { type: 'zombie', chance: 0.4 } ],
    location_bus: [ { type: 'survivor', chance: 0.2 } ],
    location_factory_large: [ { type: 'zombie', chance: 0.7 }, { type: 'raider', chance: 0.1 } ],
    // Residential
    location_house_large: [ { type: 'zombie', chance: 0.5 } ],
    location_house_small: [ { type: 'zombie', chance: 0.3 } ],
    location_motorcycle: [ { type: 'trap', chance: 0.1 } ],
    location_church: [ { type: 'survivor', chance: 0.3 } ],
    location_school: [ { type: 'zombie', chance: 0.4 } ]
};
// â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ä¸¸ã”ã¨è¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
const buildingExplorationPools = {
    // Commercial
    location_commercial: [
        { nameKey: "location_car", icon: "images/building_car.png" },
        { nameKey: "location_office", icon: "images/building_office.png" },
        { nameKey: "location_apartment", icon: "images/building_apartment.png" },
        { nameKey: "location_warehouse", icon: "images/building_warehouse.png" },
        { nameKey: "location_restaurant", icon: "images/building_restaurant.png" },
        { nameKey: "location_hotel", icon: "images/building_hotel.png" }
    ],
    // Industrial
    location_industrial: [
        { nameKey: "location_factory_small", icon: "images/building_factory_small.png" },
        { nameKey: "location_truck", icon: "images/building_truck.png" },
        { nameKey: "location_gas_station", icon: "images/building_gas_station.png" },
        { nameKey: "location_bus", icon: "images/building_bus.png" },
        { nameKey: "location_factory_large", icon: "images/building_factory_large.png" }
    ],
    // Residential
    location_residential: [
        { nameKey: "location_house_large", icon: "images/building_house_large.png" },
        { nameKey: "location_house_small", icon: "images/building_house_small.png" },
        { nameKey: "location_car", icon: "images/building_car.png" },
        { nameKey: "location_motorcycle", icon: "images/building_motorcycle.png" },
        { nameKey: "location_church", icon: "images/building_church.png" },
        { nameKey: "location_school", icon: "images/building_school.png" }
    ]
};
// â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
const buildingLootPools = {
    // Commercial
    location_car: ['æ•‘æ€¥ã‚­ãƒƒãƒˆ', 'ãƒšãƒƒãƒˆãƒœãƒˆãƒ«', 'é‰„ããš', 'å¸ƒåˆ‡ã‚Œ', 'ãƒ©ã‚¤ã‚¿ãƒ¼', 'ã‚¨ãƒŠã‚¸ãƒ¼ãƒ‰ãƒªãƒ³ã‚¯', 'ç©ºãç¼¶', 'ç©ºãç¼¶', 'ãƒ€ã‚¯ãƒˆãƒ†ãƒ¼ãƒ—', 'ç°¡å˜ãªåŒ…å¸¯', 'ã‚¿ã‚ªãƒ«', 'plastic_bag'],
    location_office: ['ãƒã‚µãƒŸ', 'ã‚¹ãƒ¼ãƒ„ã®ã‚¸ãƒ£ã‚±ãƒƒãƒˆ', 'leather_shoes_left', 'leather_shoes_right', 'ãƒšãƒƒãƒˆãƒœãƒˆãƒ«', 'ç©ºãç¼¶', 'Tã‚·ãƒ£ãƒ„', 'ãƒãƒƒã‚¯ãƒ‘ãƒƒã‚¯', 'ãƒ©ã‚¤ã‚¿ãƒ¼', 'å¸ƒåˆ‡ã‚Œ', 'ç°¡å˜ãªåŒ…å¸¯'],
    location_apartment: ['ç¼¶è©°(è±†)', 'å¸ƒåˆ‡ã‚Œ', 'åŒ…å¸¯', 'Tã‚·ãƒ£ãƒ„', 'ã‚¿ã‚ªãƒ«', 'åŒ…ä¸', 'ç¼¶åˆ‡ã‚Š', 'ãƒšãƒƒãƒˆãƒœãƒˆãƒ«', 'ã‚ºãƒœãƒ³', 'ãƒ‘ãƒ³', 'ãã‚Œã„ãªæ°´', 'plastic_bag'],
    location_warehouse: ['ãƒ€ã‚¯ãƒˆãƒ†ãƒ¼ãƒ—', 'ä½œæ¥­ç€', 'æœ¨ç®±', 'é‰„ããš', 'ä¸¸å¤ª', 'work_boots_left', 'work_boots_right', 'å®‰å…¨ãƒ˜ãƒ«ãƒ¡ãƒƒãƒˆ', 'é‡çƒã®ãƒãƒƒãƒˆ', 'ãƒ„ãƒ¼ãƒ«ãƒ™ãƒ«ãƒˆ', 'å¸ƒåˆ‡ã‚Œ'],
    location_restaurant: ['åŒ…ä¸', 'ç¼¶è©°(è±†)', 'ãƒ©ã‚¤ã‚¿ãƒ¼', 'ã‚³ãƒƒã‚¯ã‚³ãƒ¼ãƒˆ', 'ç©ºãç¼¶', 'ãƒšãƒƒãƒˆãƒœãƒˆãƒ«', 'ç”Ÿè‚‰', 'ã‚­ãƒã‚³', 'ã‚¸ãƒ£ã‚¬ã‚¤ãƒ¢', 'ç¼¶åˆ‡ã‚Š', 'plastic_bag'],
    location_hotel: ['å¯è¢‹', 'ã‚¿ã‚ªãƒ«', 'æ•‘æ€¥ã‚­ãƒƒãƒˆ', 'å¸ƒåˆ‡ã‚Œ', 'ãƒšãƒƒãƒˆãƒœãƒˆãƒ«', 'ç©ºãç¼¶', 'ç¼¶è©°(è±†)', 'ã‚¹ãƒ¼ãƒ„ã®ã‚¸ãƒ£ã‚±ãƒƒãƒˆ', 'leather_shoes_left', 'leather_shoes_right', 'åŒ…å¸¯'],
    // Industrial
    location_factory_small: ['é‰„ããš', 'ãƒ„ãƒ¼ãƒ«ãƒ™ãƒ«ãƒˆ', 'ãƒ€ã‚¯ãƒˆãƒ†ãƒ¼ãƒ—', 'ä½œæ¥­ç€', 'å®‰å…¨ãƒ˜ãƒ«ãƒ¡ãƒƒãƒˆ', 'work_boots_left', 'work_boots_right', 'ç©ºãç¼¶', 'ãƒšãƒƒãƒˆãƒœãƒˆãƒ«', 'çŸ³', 'ç°¡å˜ãªåŒ…å¸¯'],
    location_truck: ['é‰„ããš', 'ãƒ€ã‚¯ãƒˆãƒ†ãƒ¼ãƒ—', 'ä½œæ¥­ç€', 'work_boots_left', 'work_boots_right', 'ã‚¨ãƒŠã‚¸ãƒ¼ãƒ‰ãƒªãƒ³ã‚¯', 'ç¼¶è©°(è±†)', 'ä¸¸å¤ª', 'æ•‘æ€¥ã‚­ãƒƒãƒˆ', 'ãƒšãƒƒãƒˆãƒœãƒˆãƒ«', 'ãƒ„ãƒ¼ãƒ«ãƒ™ãƒ«ãƒˆ'],
    location_gas_station: ['ãƒ©ã‚¤ã‚¿ãƒ¼', 'ã‚¨ãƒŠã‚¸ãƒ¼ãƒ‰ãƒªãƒ³ã‚¯', 'ç¼¶è©°(è±†)', 'é‰„ããš', 'ãƒšãƒƒãƒˆãƒœãƒˆãƒ«', 'ç©ºãç¼¶', 'ãƒ€ã‚¯ãƒˆãƒ†ãƒ¼ãƒ—', 'æ•‘æ€¥ã‚­ãƒƒãƒˆ', 'ã‚¿ã‚ªãƒ«', 'å¸ƒåˆ‡ã‚Œ', 'plastic_bag'],
    location_bus: ['é‰„ããš', 'å¸ƒåˆ‡ã‚Œ', 'ãƒãƒƒã‚¯ãƒ‘ãƒƒã‚¯', 'ãƒšãƒƒãƒˆãƒœãƒˆãƒ«', 'ç©ºãç¼¶', 'Tã‚·ãƒ£ãƒ„', 'sneakers_left', 'sneakers_right', 'ç¼¶è©°(è±†)', 'ãƒ€ã‚¯ãƒˆãƒ†ãƒ¼ãƒ—', 'ç°¡å˜ãªåŒ…å¸¯'],
    location_factory_large: ['ãƒ¯ãƒ¼ã‚¯ãƒ™ãƒ³ãƒã‚­ãƒƒãƒˆ', 'å®‰å…¨ãƒ˜ãƒ«ãƒ¡ãƒƒãƒˆ', 'é‰„ããš', 'ä½œæ¥­ç€', 'ä¸¸å¤ª', 'work_boots_left', 'work_boots_right', 'ãƒ€ã‚¯ãƒˆãƒ†ãƒ¼ãƒ—', 'ãƒ„ãƒ¼ãƒ«ãƒ™ãƒ«ãƒˆ', 'å¤§ããªãƒãƒƒã‚¯ãƒ‘ãƒƒã‚¯', 'æ•‘æ€¥ã‚­ãƒƒãƒˆ'],
    // Residential
    location_house_large: ['å¤§ããªãƒãƒƒã‚¯ãƒ‘ãƒƒã‚¯', 'ã‚³ãƒ¼ãƒˆ', 'ç¼¶è©°(è±†)', 'æ•‘æ€¥ã‚­ãƒƒãƒˆ', 'ãã‚Œã„ãªæ°´', 'ã‚ºãƒœãƒ³', 'åŒ…ä¸', 'å¯è¢‹', 'ç¼¶åˆ‡ã‚Š', 'åŒ…å¸¯', 'plastic_bag'],
    location_house_small: ['ãƒ‘ãƒ³', 'Tã‚·ãƒ£ãƒ„', 'åŒ…å¸¯', 'æ±šã‚ŒãŸæ°´', 'ãƒšãƒƒãƒˆãƒœãƒˆãƒ«', 'ç©ºãç¼¶', 'ã‚ºãƒœãƒ³', 'åŒ…ä¸', 'å¸ƒåˆ‡ã‚Œ', 'çŸ³', 'plastic_bag'],
    location_motorcycle: ['é‰„ããš', 'ãƒ€ã‚¯ãƒˆãƒ†ãƒ¼ãƒ—', 'ãƒ„ãƒ¼ãƒ«ãƒ™ãƒ«ãƒˆ', 'ãƒ©ã‚¤ã‚¿ãƒ¼', 'ã‚¨ãƒŠã‚¸ãƒ¼ãƒ‰ãƒªãƒ³ã‚¯', 'ç©ºãç¼¶', 'å¸ƒåˆ‡ã‚Œ', 'ç°¡å˜ãªåŒ…å¸¯', 'ãƒšãƒƒãƒˆãƒœãƒˆãƒ«', 'çŸ³'],
    location_church: ['å¸ƒåˆ‡ã‚Œ', 'ãã‚Œã„ãªæ°´', 'åŒ…å¸¯', 'ç°¡å˜ãªåŒ…å¸¯', 'ãƒ©ã‚¤ã‚¿ãƒ¼', 'ã‚¿ã‚ªãƒ«', 'ç©ºãç¼¶', 'ã‚­ãƒã‚³', 'çŸ³', 'æ'],
    location_school: ['æ•‘æ€¥ã‚­ãƒƒãƒˆ', 'é‡çƒã®ãƒãƒƒãƒˆ', 'ã‚¸ãƒ£ãƒ¼ã‚¸', 'sneakers_left', 'sneakers_right', 'ãƒãƒƒã‚¯ãƒ‘ãƒƒã‚¯', 'ãƒã‚µãƒŸ', 'ãƒšãƒƒãƒˆãƒœãƒˆãƒ«', 'åŒ…å¸¯', 'Tã‚·ãƒ£ãƒ„', 'ã‚ºãƒœãƒ³']
};
// â–²â–²â–² ç½®ãæ›ãˆã¯ã“ã“ã¾ã§ â–²â–²â–²

// åœ°åŒºã”ã¨ã«æ¢ç´¢å¯èƒ½ãªå»ºç‰©ã®ãƒªã‚¹ãƒˆ
const facilityExplorationPools = {
    location_commercial: [
        { nameKey: "location_car", icon: "images/building_car.png" },
        { nameKey: "location_office", icon: "images/building_office.png" },
        { nameKey: "location_apartment", icon: "images/building_apartment.png" },
        { nameKey: "location_warehouse", icon: "images/building_warehouse.png" },
        { nameKey: "location_restaurant", icon: "images/building_restaurant.png" },
        { nameKey: "location_hotel", icon: "images/building_hotel.png" }
    ],
    location_industrial: [
        { nameKey: "location_factory_small", icon: "images/building_factory_small.png" },
        { nameKey: "location_truck", icon: "images/building_truck.png" },
        { nameKey: "location_gas_station", icon: "images/building_gas_station.png" },
        { nameKey: "location_bus", icon: "images/building_bus.png" },
        { nameKey: "location_factory_large", icon: "images/building_factory_large.png" }
    ],
    location_residential: [
        { nameKey: "location_house_large", icon: "images/building_house_large.png" },
        { nameKey: "location_house_small", icon: "images/building_house_small.png" },
        { nameKey: "location_car", icon: "images/building_car.png" },
        { nameKey: "location_motorcycle", icon: "images/building_motorcycle.png" },
        { nameKey: "location_church", icon: "images/building_church.png" },
        { nameKey: "location_school", icon: "images/building_school.png" }
    ]
};
const playerAsciiStates = {
    high: `  O\n /|\\\n / \\`,
    medium: `  o\n /|\\\n / >`,
    low: `  o\n /|~\n / \\`,
    critical: `  x\n _|_ \n / \\ `
}, charBodyDead = `   \n   X\n <--- \n / \\ `;

// â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
const zombieAscii = {
    high: `  _._\n /| |\\\n /  |`,
    medium: `  ~.~\n /| |~\n /  |`,
    low: `  >_<\n /|_ | \n /  `,
    critical: `  x_x\n  |   \n  /  `
};
// â–²â–²â–² ç½®ãæ›ãˆã“ã“ã¾ã§ â–²â–²â–²

const HANDMADE_TAG = "handmade";
const NO_LOOT_TAG = "no_loot";

// â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã§itemsé…åˆ—ã®å®šç¾©ã‚’ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
const items = [
    // === NEW ITEMS (ENGINEER) ===
    { name: "ä½œæ¥­ç€", desc: "item_ä½œæ¥­ç€_desc", type: "clothing", slot: "body_outer", defense: 4, insulation: 2.5, durability: 100, weight: 1.8, volume: 4.0, graphic: "images/work_clothes.png", value: 50, wetness: 'dry' },
    { name: "å®‰å…¨ãƒ˜ãƒ«ãƒ¡ãƒƒãƒˆ", desc: "item_å®‰å…¨ãƒ˜ãƒ«ãƒ¡ãƒƒãƒˆ_desc", type: "equipment", slot: "head", defense: 8, insulation: 0.5, durability: 100, weight: 1.2, volume: 4.0, graphic: "images/safety_helmet.png", value: 30 },
    { name: "ãƒ„ãƒ¼ãƒ«ãƒ™ãƒ«ãƒˆ", desc: "item_ãƒ„ãƒ¼ãƒ«ãƒ™ãƒ«ãƒˆ_desc", type: "equipment", slot: "pochette", durability: 80, weight: 0.8, volume: 1.5, graphic: "images/tool_belt.png", value: 45, effects: { maxWeight: 5, maxVolume: 5 } },
    { name: "ãƒ€ã‚¯ãƒˆãƒ†ãƒ¼ãƒ—", desc: "item_ãƒ€ã‚¯ãƒˆãƒ†ãƒ¼ãƒ—_desc", type: "consumable", useAction: 'repairItem', weight: 0.3, volume: 0.8, graphic: "images/duct_tape.png", value: 25 },
    
    // === NEW WEAPONS (HANDMADE) ===
    { name: "handmade_sling", desc: "item_handmade_sling_desc", type: "equipment", slot: "weapon", handedness: "one", fireDamage: 8, durability: 40, weight: 0.2, volume: 0.5, graphic: "images/sling.png", value: 15, ammoType: 'stone', ammoCapacity: 1, loadedAmmo: 0, reach: 1, accuracy: 55, tags: [HANDMADE_TAG, NO_LOOT_TAG] },
    { name: "handmade_bow", desc: "item_handmade_bow_desc", type: "equipment", slot: "weapon", handedness: "two", fireDamage: 15, durability: 50, weight: 1.0, volume: 5.0, graphic: "images/bow.png", value: 35, ammoType: 'arrow', ammoCapacity: 1, loadedAmmo: 0, reach: 1, accuracy: 65, tags: [HANDMADE_TAG, NO_LOOT_TAG] },
    { name: "handmade_arrow", desc: "item_handmade_arrow_desc", type: "ammo", ammoType: "arrow", weight: 0.1, volume: 0.3, graphic: "images/arrow.png", value: 4, tags: [HANDMADE_TAG, NO_LOOT_TAG] },
    
    // === NEW ITEMS (DOCTOR/NURSE) ===
    { name: "ãƒ¡ã‚¹", desc: "item_ãƒ¡ã‚¹_desc", type: "equipment", slot: "weapon", handedness: "one", attack: 13, defense: 0, durability: 40, weight: 0.1, volume: 0.2, graphic: "images/scalpel.png", value: 20, isBlade: true, reach: 1, accuracy: 55 },
    { name: "ç™½è¡£", desc: "item_ç™½è¡£_desc", type: "clothing", slot: "body_outer", defense: 1, insulation: 1.0, durability: 80, weight: 0.7, volume: 2.5, graphic: "images/lab_coat.png", value: 20, wetness: 'dry' },
    { name: "ãƒã‚¹ã‚¯", desc: "item_ãƒã‚¹ã‚¯_desc", type: "clothing", slot: "mouth", defense: 0, insulation: 0.2, durability: 100, weight: 0.05, volume: 0.1, graphic: "images/mask.png", value: 5, wetness: 'dry' },
    { name: "æ•‘æ€¥ã‚­ãƒƒãƒˆ", desc: "item_æ•‘æ€¥ã‚­ãƒƒãƒˆ_desc", type: "consumable", effects: { health: 50 }, weight: 0.8, volume: 2.0, graphic: "images/first_aid_kit.png", value: 80 },
    { name: "èƒƒè…¸è–¬", desc: "item_èƒƒè…¸è–¬_desc", type: "consumable", useAction: 'cureFoodPoisoning', weight: 0.1, volume: 0.2, graphic: "images/medicine.png", value: 50 },
    { name: "ãƒã‚µãƒŸ", desc: "item_ãƒã‚µãƒŸ_desc", type: "equipment", slot: "weapon", handedness: "one", attack: 12, defense: 0, durability: 60, weight: 0.2, volume: 0.3, graphic: "images/scissors.png", value: 10, isBlade: true, reach: 1, accuracy: 50 },
    
    // === NEW ITEMS (SOLDIER) ===
    { name: "ã‚³ãƒ³ãƒãƒƒãƒˆãƒŠã‚¤ãƒ•", desc: "item_ã‚³ãƒ³ãƒãƒƒãƒˆãƒŠã‚¤ãƒ•_desc", type: "equipment", slot: "weapon", handedness: "one", attack: 25, defense: 0, durability: 100, weight: 0.5, volume: 0.5, graphic: "images/combat_knife.png", value: 60, isBlade: true, reach: 1, accuracy: 95 },
    
    // === NEW ITEMS (TEACHER / STUDENT) ===
    { name: "ãƒ¢ãƒƒãƒ—", desc: "item_ãƒ¢ãƒƒãƒ—_desc", type: "equipment", slot: "weapon", handedness: "two", attack: 9, defense: 0, durability: 50, weight: 1.0, volume: 8.0, graphic: "images/mop.png", value: 10, reach: 2, accuracy: 60 },
    { name: "ã‚¸ãƒ£ãƒ¼ã‚¸", desc: "item_ã‚¸ãƒ£ãƒ¼ã‚¸_desc", type: "clothing", slot: "body_outer", defense: 2, insulation: 1.8, durability: 90, weight: 0.8, volume: 3.0, graphic: "images/tracksuit.png", value: 25, wetness: 'dry' },
    { name: "ãƒãƒƒã‚¯ãƒ‘ãƒƒã‚¯", desc: "item_ãƒãƒƒã‚¯ãƒ‘ãƒƒã‚¯_desc", type: "equipment", slot: "back", durability: 100, weight: 1.5, volume: 5.0, graphic: "images/backpack.png", value: 60, effects: { maxWeight: 15, maxVolume: 20 } },
    
    // === NEW ITEMS (ATHLETE) ===
    { name: "ãƒ†ãƒ‹ã‚¹ãƒ©ã‚±ãƒƒãƒˆ", desc: "item_ãƒ†ãƒ‹ã‚¹ãƒ©ã‚±ãƒƒãƒˆ_desc", type: "equipment", slot: "weapon", handedness: "one", attack: 11, defense: 0, durability: 25, weight: 0.4, volume: 4.0, graphic: "images/tennis_racket.png", value: 15, reach: 1, accuracy: 60 },
    { name: "é‡çƒã®ãƒãƒƒãƒˆ", desc: "item_é‡çƒã®ãƒãƒƒãƒˆ_desc", type: "equipment", slot: "weapon", handedness: "two", attack: 21, defense: 0, durability: 80, weight: 1.4, volume: 5.0, graphic: "images/baseball_bat.png", value: 40, reach: 1, accuracy: 85 },
    { name: "ã‚¨ãƒŠã‚¸ãƒ¼ãƒ‰ãƒªãƒ³ã‚¯", desc: "item_ã‚¨ãƒŠã‚¸ãƒ¼ãƒ‰ãƒªãƒ³ã‚¯_desc", type: "consumable", effects: { hunger: 5, thirst: 20, sleep: 5 }, nutrients: { carbs: 15, protein: 0, fat: 0, vitamins: 5, water: 25 }, weight: 0.4, volume: 0.8, graphic: "images/energy_drink.png", value: 18 },
    { name: "ãƒ—ãƒ­ãƒ†ã‚¤ãƒ³ãƒãƒ¼", desc: "item_ãƒ—ãƒ­ãƒ†ã‚¤ãƒ³ãƒãƒ¼_desc", type: "consumable", effects: { hunger: 30 }, nutrients: { carbs: 10, protein: 50, fat: 8, vitamins: 2, water: 0 }, weight: 0.1, volume: 0.3, graphic: "images/protein_bar.png", value: 22 },
    
    // === NEW ITEMS (POLICE OFFICER) ===
    { name: "è­¦æ£’", desc: "item_è­¦æ£’_desc", type: "equipment", slot: "weapon", handedness: "one", attack: 23, defense: 0, durability: 100, weight: 0.8, volume: 1.0, graphic: "images/baton.png", value: 45, reach: 1, accuracy: 90 },
    
    // === NEW ITEMS (CHEF) ===
    { name: "åŒ…ä¸", desc: "item_åŒ…ä¸_desc", type: "equipment", slot: "weapon", handedness: "one", attack: 18, defense: 0, durability: 80, weight: 0.4, volume: 0.5, graphic: "images/kitchen_knife.png", value: 40, isBlade: true, reach: 1, accuracy: 80 },
    { name: "ã‚³ãƒƒã‚¯ã‚³ãƒ¼ãƒˆ", desc: "item_ã‚³ãƒƒã‚¯ã‚³ãƒ¼ãƒˆ_desc", type: "clothing", slot: "body_outer", defense: 2, insulation: 1.2, durability: 100, weight: 1.0, volume: 3.0, graphic: "images/chef_coat.png", value: 28, wetness: 'dry' },
    
    // === NEW ITEMS (OFFICE WORKER) ===
    { name: "ã‚¹ãƒ¼ãƒ„ã®ã‚¸ãƒ£ã‚±ãƒƒãƒˆ", desc: "item_ã‚¹ãƒ¼ãƒ„ã®ã‚¸ãƒ£ã‚±ãƒƒãƒˆ_desc", type: "clothing", slot: "body_outer", defense: 1, insulation: 1.5, durability: 70, weight: 1.1, volume: 3.5, graphic: "images/suit_jacket.png", value: 20, wetness: 'dry' },

    // === EXISTING ITEMS (with potential ID changes) ===
    { name: "åŒ…å¸¯", desc: "item_åŒ…å¸¯_desc", type: "consumable", weight: 0.2, volume: 0.5, graphic: "images/bandage.png", value: 20 },
    { name: "simple_bandage", desc: "item_simple_bandage_desc", type: "consumable", weight: 0.1, volume: 0.2, graphic: "images/bandage.png", value: 8, tags: [HANDMADE_TAG, NO_LOOT_TAG] },
    { name: "ãƒ‘ãƒ³", desc: "item_ãƒ‘ãƒ³_desc", type: "consumable", effects: { hunger: 25 }, nutrients: { carbs: 40, protein: 5, fat: 2, vitamins: 0, water: 5 }, freshness: 100, weight: 0.5, volume: 1.5, graphic: "images/bread.png", value: 15, smell: 2 },
    { name: "ç”Ÿè‚‰", desc: "item_ç”Ÿè‚‰_desc", type: "consumable", effects: { hunger: 10 }, foodPoisoningOnEat: 0.9, nutrients: { carbs: 0, protein: 15, fat: 10, vitamins: 2, water: 10 }, freshness: 100, weight: 0.8, volume: 1.0, graphic: "images/raw_meat.png", value: 8, tags: [NO_LOOT_TAG], smell: 10 },
    { name: "ç„¼ã„ãŸè‚‰", desc: "item_ç„¼ã„ãŸè‚‰_desc", type: "consumable", effects: { hunger: 40, morale: 5 }, bodyTempBoost: 0.5, nutrients: { carbs: 0, protein: 35, fat: 18, vitamins: 1, water: 0 }, freshness: 100, weight: 0.7, volume: 1.0, graphic: "images/cooked_meat.png", value: 25, tags: [NO_LOOT_TAG], smell: 5 },
    { name: "ç„¼ã„ãŸã‚­ãƒ£ãƒ™ãƒ„", desc: "item_ç„¼ã„ãŸã‚­ãƒ£ãƒ™ãƒ„_desc", type: "consumable", effects: { hunger: 20, morale: 2 }, bodyTempBoost: 0.5, nutrients: { carbs: 8, protein: 2, fat: 0, vitamins: 6, water: 0 }, weight: 0.4, volume: 1.2, graphic: "images/cabbage.png", value: 15, tags: [NO_LOOT_TAG], smell: 3 },
    { name: "ç¼¶è©°(è±†)", desc: "item_canned_beans_desc", type: "consumable", isSealed: true, sealedEffects: { hunger: 30 }, nutrients: { carbs: 25, protein: 15, fat: 2, vitamins: 5, water: 15 }, freshness: 1000, weight: 0.5, volume: 1.0, graphic: "images/canned_beans.png", value: 20 },
    
    { name: "æ•´è…¸å‰¤", desc: "item_antidiarrheal_desc", type: "consumable", useAction: 'cureFoodPoisoning', weight: 0.1, volume: 0.2, graphic: "images/medicine.png", value: 50 },
    { name: "ã‚¢ãƒ­ã‚¨", desc: "item_ã‚¢ãƒ­ã‚¨_desc", type: "material", weight: 0.2, volume: 0.5, graphic: "images/aloe.png", value: 10, tags: [NO_LOOT_TAG] },
    { name: "ã‚¢ãƒ­ã‚¨ã‚¸ã‚§ãƒ«", desc: "item_ã‚¢ãƒ­ã‚¨ã‚¸ã‚§ãƒ«_desc", type: "consumable", useAction: 'cureItch', weight: 0.1, volume: 0.2, graphic: "images/aloe_vera.png", value: 15, tags: [HANDMADE_TAG, NO_LOOT_TAG] },
    { name: "ä¸‹ç—¢æ­¢ã‚", desc: "item_antidiarrheal_desc", type: "consumable", useAction: 'cureDiarrhea', weight: 0.1, volume: 0.2, graphic: "images/medicine.png", value: 50 },
    { name: "è§£ç†±å‰¤", desc: "item_antipyretic_desc", type: "consumable", useAction: 'cureFever', weight: 0.1, volume: 0.2, graphic: "images/medicine.png", value: 60 },
    { name: "æŠ—ç”Ÿç‰©è³ª", desc: "item_æŠ—ç”Ÿç‰©è³ª_desc", type: "consumable", useAction: 'cureInfection', weight: 0.1, volume: 0.2, graphic: "images/medicine.png", value: 100 },
{ 
    name: "é®ç—›å‰¤", 
    desc: "item_é®ç—›å‰¤_desc", 
    type: "consumable", 
    useAction: 'takePainkiller', 
    weight: 0.1, 
    volume: 0.2, 
    graphic: "images/medicine.png", 
    value: 40 
},
    { name: "ã‚­ãƒã‚³", desc: "item_mushroom_desc", type: "consumable", effects: { hunger: 8 }, nutrients: { carbs: 2, protein: 2, fat: 0, vitamins: 10, water: 10 }, riskOfSickness: 0.3, weight: 0.1, volume: 0.5, graphic: "images/mushroom.png", value: 6, tags: [NO_LOOT_TAG], smell: 1 },
    { name: "ç„¼ã„ãŸã‚­ãƒã‚³", desc: "item_cooked_mushroom_desc", type: "consumable", effects: { hunger: 15, morale: 3 }, bodyTempBoost: 0.5, nutrients: { carbs: 3, protein: 3, fat: 0, vitamins: 5, water: 0 }, weight: 0.1, volume: 0.5, graphic: "images/mushroom.png", value: 12, tags: [NO_LOOT_TAG], smell: 3 },
    { name: "ãƒˆã‚¦ãƒ¢ãƒ­ã‚³ã‚·", desc: "item_corn_desc", type: "consumable", effects: { hunger: 10 }, nutrients: { carbs: 20, protein: 3, fat: 1, vitamins: 8, water: 15 }, riskOfSickness: 0.2, weight: 0.4, volume: 1.2, graphic: "images/corn.png", value: 8, tags: [NO_LOOT_TAG], smell: 1 },
    { name: "ç„¼ã„ãŸãƒˆã‚¦ãƒ¢ãƒ­ã‚³ã‚·", desc: "item_cooked_corn_desc", type: "consumable", effects: { hunger: 25, morale: 5 }, bodyTempBoost: 0.5, nutrients: { carbs: 30, protein: 4, fat: 2, vitamins: 4, water: 0 }, weight: 0.4, volume: 1.2, graphic: "images/corn.png", value: 16, tags: [NO_LOOT_TAG], smell: 4 },
    { name: "ã‚¸ãƒ£ã‚¬ã‚¤ãƒ¢", desc: "item_potato_desc", type: "consumable", effects: { hunger: 8 }, nutrients: { carbs: 25, protein: 2, fat: 0, vitamins: 5, water: 10 }, riskOfSickness: 0.25, weight: 0.3, volume: 0.8, graphic: "images/potato.png", value: 5, tags: [NO_LOOT_TAG], smell: 1 },
    { name: "ç„¼ã„ãŸã‚¸ãƒ£ã‚¬ã‚¤ãƒ¢", desc: "item_baked_potato_desc", type: "consumable", effects: { hunger: 20, morale: 4 }, bodyTempBoost: 0.5, nutrients: { carbs: 35, protein: 3, fat: 0, vitamins: 2, water: 0 }, weight: 0.3, volume: 0.8, graphic: "images/potato.png", value: 10, tags: [NO_LOOT_TAG], smell: 3 },
    { name: "ãƒ‹ãƒ³ã‚¸ãƒ³", desc: "item_carrot_desc", type: "consumable", effects: { hunger: 6 }, nutrients: { carbs: 8, protein: 1, fat: 0, vitamins: 15, water: 10 }, riskOfSickness: 0.1, weight: 0.2, volume: 0.6, graphic: "images/carrot.png", value: 5, tags: [NO_LOOT_TAG], smell: 1 },
    { name: "ç„¼ã„ãŸãƒ‹ãƒ³ã‚¸ãƒ³", desc: "item_cooked_carrot_desc", type: "consumable", effects: { hunger: 12, morale: 2 }, bodyTempBoost: 0.5, nutrients: { carbs: 12, protein: 1, fat: 0, vitamins: 8, water: 0 }, weight: 0.2, volume: 0.6, graphic: "images/carrot.png", value: 10, tags: [NO_LOOT_TAG], smell: 3 },
    { name: "ã‚­ãƒ£ãƒ™ãƒ„", desc: "item_cabbage_desc", type: "consumable", effects: { hunger: 10 }, nutrients: { carbs: 5, protein: 2, fat: 0, vitamins: 12, water: 20 }, weight: 0.5, volume: 1.5, graphic: "images/cabbage.png", value: 10, tags: [NO_LOOT_TAG], smell: 1 },

    { name: "junk_research_bench_kit", desc: "item_junk_research_bench_kit_desc", type: "tool", useAction: 'placeResearchBench', weight: 4.0, volume: 8.0, graphic: "images/workbench.png", value: 10, tags: [HANDMADE_TAG, NO_LOOT_TAG] },

    { name: "ãã‚Œã„ãªæ°´", desc: "item_ãã‚Œã„ãªæ°´_desc", type: "consumable", effects: { thirst: 40 }, nutrients: { carbs: 0, protein: 0, fat: 0, vitamins: 0, water: 40 }, freshness: 100, weight: 0, volume: 0, graphic: "images/clean_water.png", value: 8, tags: [NO_LOOT_TAG] },
    { name: "ç¶ºéº—ãªãŠæ¹¯", desc: "item_ç¶ºéº—ãªãŠæ¹¯_desc", type: "consumable", effects: { thirst: 35 }, bodyTempBoost: 1.0, nutrients: { carbs: 0, protein: 0, fat: 0, vitamins: 0, water: 35 }, weight: 0, volume: 0, graphic: "images/hot_water.png", value: 12, tags: [NO_LOOT_TAG] },

    { name: "campfire_kit", desc: "item_campfire_kit_desc", type: "tool", useAction: 'placeUnlitCampfire', weight: 1.5, volume: 5.0, graphic: "images/campfire_kit.png", value: 30, uses: 5, tags: [HANDMADE_TAG, NO_LOOT_TAG] },
    { name: "sleeping_bag", desc: "item_sleeping_bag_desc", type: "tool", useAction: 'placeSleepingBag', weight: 1.0, volume: 4.0, graphic: "images/sleeping_bag.png", value: 40, tags: [HANDMADE_TAG] },
    { name: "ç¼¶åˆ‡ã‚Š", desc: "item_can_opener_desc", type: "tool", durability: 100, weight: 0.3, volume: 0.5, graphic: "images/can_opener.png", value: 15 },
    { name: "è…•æ™‚è¨ˆ", desc: "item_è…•æ™‚è¨ˆ_desc", type: "equipment", slot: "wrist", durability: 80, weight: 0.1, volume: 0.1, graphic: "images/watch.png", value: 40 },
    { name: "ãƒ©ã‚¤ã‚¿ãƒ¼", desc: "item_lighter_desc", type: "tool", useAction: 'startFire', weight: 0.1, volume: 0.2, graphic: "images/lighter.png", value: 40, durability: 100 },
    { name: "ç«æ‰“çŸ³", desc: "item_flint_desc", type: "tool", useAction: 'startFire', durability: 100, weight: 0.4, volume: 0.5, graphic: "images/flint.png", value: 25 },
    { name: "fire_starter", desc: "item_fire_starter_desc", type: "tool", useAction: 'startFire', weight: 0.8, volume: 3.0, graphic: "images/fire_starter.png", value: 15, durability: 100, tags: [HANDMADE_TAG, NO_LOOT_TAG] },
    { name: "splint", desc: "item_splint_desc", type: "consumable", useAction: 'applySplint', weight: 0.5, volume: 1.5, graphic: "images/splint.png", value: 15, tags: [HANDMADE_TAG, NO_LOOT_TAG] },
    { name: "ã‚¿ã‚ªãƒ«", desc: "item_towel_desc", type: "tool", useAction: 'wipeClothes', weight: 0.4, volume: 1.5, graphic: "images/towel.png", value: 18 },
    { name: "handmade_hoe", desc: "item_handmade_hoe_desc", type: "tool", useAction: 'tillSoil', durability: 60, weight: 1.8, volume: 4.0, graphic: "images/hoe.png", value: 20, tags: [HANDMADE_TAG, NO_LOOT_TAG] },

    { name: "æ°´ç­’", desc: "item_canteen_desc", type: "container", capacity: 2, durability: 100, weight: 0.5, volume: 2.0, graphic: "images/canteen.png", value: 15, content: null },
    { name: "handmade_waterskin", desc: "item_handmade_waterskin_desc", type: "container", capacity: 2, durability: 70, weight: 0.4, volume: 2.0, graphic: "images/waterskin.png", value: 12, tags: [HANDMADE_TAG, NO_LOOT_TAG], content: null },
    { name: "ãƒšãƒƒãƒˆãƒœãƒˆãƒ«", desc: "item_plastic_bottle_desc", type: "container", capacity: 1, durability: 50, weight: 0.1, volume: 1.5, graphic: "images/plastic_bottle.png", value: 5, content: null },
    { name: "ç©ºãç¼¶", desc: "item_empty_can_desc", type: "container", capacity: 1, durability: 30, weight: 0.1, volume: 1.0, graphic: "images/empty_can.png", value: 2, content: null, canBoil: true },
    { name: "æ±šã‚ŒãŸæ°´", desc: "item_dirty_water_desc", type: "water_source", weight: 0, volume: 0, graphic: "images/pond.png", value: 0, tags: [NO_LOOT_TAG]},

    { name: "ãƒŠã‚¤ãƒ•", desc: "item_knife_desc", type: "equipment", slot: "weapon", handedness: "one", attack: 19, defense: 0, durability: 100, weight: 0.3, volume: 0.4, graphic: "images/kitchen_knife.png", value: 40, isBlade: true, reach: 1, accuracy: 85 },
    { name: "stone_axe", desc: "item_stone_axe_desc", type: "equipment", slot: "weapon", handedness: "one", attack: 17, defense: 0, durability: 50, weight: 1.8, volume: 3.5, graphic: "images/stone_axe.png", value: 25, tags: [HANDMADE_TAG, NO_LOOT_TAG], isBlade: true, isAxe: true, reach: 1, accuracy: 75 },
    { name: "handmade_stone_knife", desc: "item_handmade_stone_knife_desc", type: "equipment", slot: "weapon", handedness: "one", attack: 8, defense: 0, durability: 30, weight: 0.4, volume: 0.4, graphic: "images/stone_knife.png", value: 10, tags: [HANDMADE_TAG, NO_LOOT_TAG], isBlade: true, reach: 1, accuracy: 65 },
    { name: "handmade_spear", desc: "item_handmade_spear_desc", type: "equipment", slot: "weapon", handedness: "two", attack: 16, defense: 0, durability: 40, weight: 1.2, volume: 7.0, graphic: "images/spear.png", value: 12, tags: [HANDMADE_TAG, NO_LOOT_TAG], reach: 2, accuracy: 70 },
    { name: "æ¾æ˜", desc: "item_torch_desc", type: "equipment", slot: "weapon", handedness: "one", attack: 6, defense: 0, durability: 100, weight: 0.6, volume: 2.0, graphic: "images/torch.png", value: 10, tags: [HANDMADE_TAG, NO_LOOT_TAG], duration: 6, isTorch: true, useAction: 'startFire', reach: 1, accuracy: 50 },
    
    { name: "ãƒ”ã‚¹ãƒˆãƒ«", desc: "item_pistol_desc", type: "equipment", slot: "weapon", handedness: "one", attack: 7, fireDamage: 40, durability: 100, weight: 1.2, volume: 1.5, graphic: "images/pistol.png", value: 150, ammoType: 'pistol', ammoCapacity: 7, loadedAmmo: 0, reach: 1, accuracy: 85 },
    { name: "ã‚·ãƒ§ãƒƒãƒˆã‚¬ãƒ³", desc: "item_shotgun_desc", type: "equipment", slot: "weapon", handedness: "two", attack: 7, fireDamage: 65, durability: 100, weight: 3.5, volume: 8.0, graphic: "images/shotgun.png", value: 200, ammoType: 'shotgun', ammoCapacity: 5, loadedAmmo: 0, reach: 1, accuracy: 70 },
    { 
    name: "ãƒ©ã‚¤ãƒ•ãƒ«", 
    desc: "item_rifle_desc", 
    type: "equipment", 
    slot: "weapon", 
    handedness: "two", 
    attack: 7, 
    fireDamage: 55, 
    durability: 100, 
    weight: 4.5, 
    volume: 10.0, 
    graphic: "images/rifle.png",
    value: 220, 
    ammoType: 'rifle', 
    ammoCapacity: 5, 
    loadedAmmo: 0, 
    bayonetAttached: null,
    attachedBayonetName: null,
    reach: 1, 
    accuracy: 95,
    getGraphic: function() {
        return this.bayonetAttached ? 'images/rifle_bayonet.png' : 'images/rifle.png';
    }
    },
    
    { name: "ãƒ”ã‚¹ãƒˆãƒ«ã®å¼¾", desc: "item_ammo_pistol_desc", type: "ammo", ammoType: "pistol", weight: 0.02, volume: 0.1, graphic: "images/ammo_pistol.png", value: 8 },
    { name: "ã‚·ãƒ§ãƒƒãƒˆã‚¬ãƒ³ã®å¼¾", desc: "item_ammo_shotgun_desc", type: "ammo", ammoType: "shotgun", weight: 0.05, volume: 0.2, graphic: "images/ammo_shotgun.png", value: 12 },
    { name: "ãƒ©ã‚¤ãƒ•ãƒ«ã®å¼¾", desc: "item_ammo_rifle_desc", type: "ammo", ammoType: "rifle", weight: 0.03, volume: 0.1, graphic: "images/ammo_rifle.png", value: 10 },

    { name: "ãƒ˜ãƒ«ãƒ¡ãƒƒãƒˆ", desc: "item_helmet_desc", type: "equipment", slot: "head", defense: 10, durability: 100, insulation: 1.5, weight: 1.5, volume: 4.0, graphic: "images/helmet.png", value: 35 },
    { name: "ãƒ¡ã‚¬ãƒ", desc: "item_glasses_desc", type: "equipment", slot: "eyes", durability: 60, weight: 0.1, volume: 0.2, graphic: "images/glasses.png", value: 30 },

    { name: "handmade_pouch", desc: "item_handmade_pouch_desc", type: "equipment", slot: "pochette", weight: 0.4, volume: 1.0, graphic: "images/handmade_pouch.png", value: 20, tags: [HANDMADE_TAG, NO_LOOT_TAG], effects: { maxWeight: 3, maxVolume: 5 }, durability: 80 },
    { name: "å¤§ããªãƒãƒƒã‚¯ãƒ‘ãƒƒã‚¯", desc: "item_backpack_large_desc", type: "equipment", slot: "back", durability: 100, weight: 2.5, volume: 8.0, graphic: "images/backpack_large.png", value: 90, effects: { maxWeight: 20, maxVolume: 25 } },
    
    { name: "Tã‚·ãƒ£ãƒ„", desc: "item_tshirt_desc", type: "clothing", slot: "body_inner", defense: 1, durability: 100, insulation: 0.5, weight: 0.3, volume: 1.0, graphic: "images/tshirt.png", value: 10, wetness: 'dry' },
    
    { name: "ã‚³ãƒ¼ãƒˆ", desc: "item_coat_desc", type: "clothing", slot: "body_outer", defense: 3, durability: 100, insulation: 4.0, weight: 2.2, volume: 5.0, graphic: "images/coat.png", value: 60, wetness: 'dry' },
    { name: "é˜²å¼¾ãƒ™ã‚¹ãƒˆ", desc: "item_bulletproof_vest_desc", type: "clothing", slot: "body_outer", defense: 25, durability: 100, insulation: 1.0, weight: 10.0, volume: 4.0, graphic: "images/bulletproof_vest.png", value: 120, wetness: 'dry' },
    { name: "ã‚ºãƒœãƒ³", desc: "item_pants_desc", type: "clothing", slot: "legs", defense: 2, durability: 100, insulation: 2.0, weight: 0.8, volume: 2.5, graphic: "images/pants.png", value: 25, wetness: 'dry' },
    { name: "å¸½å­", desc: "item_cap_desc", type: "clothing", slot: "head", defense: 0, durability: 100, insulation: 1.2, weight: 0.1, volume: 0.6, graphic: "images/cap.png", value: 15, wetness: 'dry' },
    { name: "handmade_hat", desc: "item_handmade_hat_desc", type: "clothing", slot: "head", defense: 0, durability: 70, insulation: 1.0, weight: 0.2, volume: 0.8, graphic: "images/handmade_hat.png", value: 18, tags: [HANDMADE_TAG, NO_LOOT_TAG], wetness: 'dry' },
    { name: "handmade_clothes", desc: "item_handmade_clothes_desc", type: "clothing", slot: "body_inner", defense: 1, durability: 60, insulation: 1.5, weight: 0.6, volume: 1.5, graphic: "images/handmade_clothes.png", value: 25, tags: [HANDMADE_TAG, NO_LOOT_TAG], wetness: 'dry' },
    { name: "handmade_pants", desc: "item_handmade_pants_desc", type: "clothing", slot: "legs", defense: 1, durability: 60, insulation: 1.2, weight: 0.7, volume: 2.0, graphic: "images/handmade_pants.png", value: 25, tags: [HANDMADE_TAG, NO_LOOT_TAG], wetness: 'dry' },
    { name: "handmade_coat", desc: "item_handmade_coat_desc", type: "clothing", slot: "body_outer", defense: 2, durability: 50, insulation: 3.0, weight: 2.5, volume: 6.0, graphic: "images/coat.png", value: 50, tags: [HANDMADE_TAG, NO_LOOT_TAG], wetness: 'dry' },
    { name: "shelter", desc: "item_shelter_desc", type: "tool", useAction: 'placeShelter', weight: 4.0, volume: 10.0, graphic: "images/shelter.png", value: 30, tags: [HANDMADE_TAG, NO_LOOT_TAG] },

// â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã§12å€‹ã®é´ã‚¢ã‚¤ãƒ†ãƒ å®šç¾©ã‚’ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
    // --- SHOES (LEFT & RIGHT) ---
    { name: "sneakers_left", desc: "item_sneakers_left_desc", type: "clothing", slot: "left_foot", defense: 2, insulation: 0.5, soundModifier: 0.8, durability: 80, weight: 0.4, volume: 1.0, value: 10, wetness: 'dry', graphic: "images/sneakers_left.png" },
    { name: "sneakers_right", desc: "item_sneakers_right_desc", type: "clothing", slot: "right_foot", defense: 2, insulation: 0.5, soundModifier: 0.8, durability: 80, weight: 0.4, volume: 1.0, value: 10, wetness: 'dry', graphic: "images/sneakers_right.png" },
    { name: "leather_shoes_left", desc: "item_leather_shoes_left_desc", type: "clothing", slot: "left_foot", defense: 3, insulation: 0.8, soundModifier: 1.5, durability: 70, weight: 0.6, volume: 1.2, value: 12, wetness: 'dry', graphic: "images/leather_shoes_left.png" },
    { name: "leather_shoes_right", desc: "item_leather_shoes_right_desc", type: "clothing", slot: "right_foot", defense: 3, insulation: 0.8, soundModifier: 1.5, durability: 70, weight: 0.6, volume: 1.2, value: 12, wetness: 'dry', graphic: "images/leather_shoes_right.png" },
    { name: "work_boots_left", desc: "item_work_boots_left_desc", type: "clothing", slot: "left_foot", defense: 8, insulation: 1.5, soundModifier: 2.0, durability: 100, weight: 1.1, volume: 1.7, value: 25, wetness: 'dry', graphic: "images/work_boots_left.png" },
    { name: "work_boots_right", desc: "item_work_boots_right_desc", type: "clothing", slot: "right_foot", defense: 8, insulation: 1.5, soundModifier: 2.0, durability: 100, weight: 1.1, volume: 1.7, value: 25, wetness: 'dry', graphic: "images/work_boots_right.png" },
    { name: "hiking_boots_left", desc: "item_hiking_boots_left_desc", type: "clothing", slot: "left_foot", defense: 6, insulation: 2.0, soundModifier: 1.2, durability: 90, weight: 0.8, volume: 1.5, value: 30, wetness: 'dry', graphic: "images/hiking_boots_left.png" },
    { name: "hiking_boots_right", desc: "item_hiking_boots_right_desc", type: "clothing", slot: "right_foot", defense: 6, insulation: 2.0, soundModifier: 1.2, durability: 90, weight: 0.8, volume: 1.5, value: 30, wetness: 'dry', graphic: "images/hiking_boots_right.png" },
    { name: "combat_boots_left", desc: "item_combat_boots_left_desc", type: "clothing", slot: "left_foot", defense: 7, insulation: 1.8, soundModifier: 1.0, durability: 100, weight: 0.9, volume: 1.5, value: 42, wetness: 'dry', graphic: "images/combat_boots_left.png" },
    { name: "combat_boots_right", desc: "item_combat_boots_right_desc", type: "clothing", slot: "right_foot", defense: 7, insulation: 1.8, soundModifier: 1.0, durability: 100, weight: 0.9, volume: 1.5, value: 42, wetness: 'dry', graphic: "images/combat_boots_right.png" },
    { name: "handmade_sandals_left", desc: "item_handmade_sandals_left_desc", type: "clothing", slot: "left_foot", defense: 1, insulation: 0.2, soundModifier: 1.1, durability: 40, weight: 0.1, volume: 0.2, value: 4, wetness: 'dry', graphic: "images/handmade_sandals_left.png", tags: [HANDMADE_TAG, NO_LOOT_TAG] },
    { name: "handmade_sandals_right", desc: "item_handmade_sandals_right_desc", type: "clothing", slot: "right_foot", defense: 1, insulation: 0.2, soundModifier: 1.1, durability: 40, weight: 0.1, volume: 0.2, value: 4, wetness: 'dry', graphic: "images/handmade_sandals_right.png", tags: [HANDMADE_TAG, NO_LOOT_TAG] },
// â–²â–²â–² ç½®ãæ›ãˆã¯ã“ã“ã¾ã§ â–²â–²â–²
// â–¼â–¼â–¼ itemsé…åˆ—ã®å¥½ããªå ´æ‰€ã«è¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
   { 
    name: "plastic_bag", 
    desc: "item_plastic_bag_desc", 
    type: "equipment", 
    slot: "weapon", 
    handedness: "one", 
    defense: 0, 
    durability: 20, 
    weight: 0.01, 
    volume: 0.1, 
    graphic: "images/plastic_bag.png", 
    value: 2, 
    effects: { maxWeight: 5, maxVolume: 5 } 
   },
// â–¼â–¼â–¼ itemsé…åˆ—ã®å¥½ããªå ´æ‰€ã«è¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
{ name: "cloth_scarf", desc: "item_cloth_scarf_desc", type: "clothing", slot: "neck", defense: 0, insulation: 0.8, durability: 60, weight: 0.1, volume: 0.2, value: 5, wetness: 'dry', graphic: "images/cloth_scarf.png", tags: [HANDMADE_TAG, NO_LOOT_TAG] },
// â–¼â–¼â–¼ itemsé…åˆ—ã®å¥½ããªå ´æ‰€ã«è¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
{ name: "cloth_gloves_left", desc: "item_cloth_gloves_left_desc", type: "clothing", slot: "left_palm", defense: 0, insulation: 0.5, durability: 40, weight: 0.05, volume: 0.1, value: 3, wetness: 'dry', graphic: "images/cloth_gloves_left.png", tags: [HANDMADE_TAG, NO_LOOT_TAG] },
{ name: "cloth_gloves_right", desc: "item_cloth_gloves_right_desc", type: "clothing", slot: "right_palm", defense: 0, insulation: 0.5, durability: 40, weight: 0.05, volume: 0.1, value: 3, wetness: 'dry', graphic: "images/cloth_gloves_right.png", tags: [HANDMADE_TAG, NO_LOOT_TAG] },
    // --- MATERIALS ---
    { name: "çŸ³", desc: "item_stone_desc", type: "equipment", slot: "weapon", handedness: "one", attack: 7, throwDamage: 8, isThrowable: true, accuracy: 65, durability: 50, weight: 1.0, volume: 0.5, graphic: "images/stone.png", value: 5, ammoType: 'stone', reach: 1 },
    { name: "æ", desc: "item_branch_desc", type: "tool", durability: 100, weight: 0.5, volume: 2.0, graphic: "images/branch.png", value: 3 },
    { name: "å¸ƒåˆ‡ã‚Œ", desc: "item_cloth_scrap_desc", type: "material", useAction: 'wipeClothes', weight: 0.1, volume: 0.2, graphic: "images/cloth_scrap.png", value: 4 },
    { name: "æ¯›çš®", desc: "item_fur_desc", type: "material", weight: 0.8, volume: 0.8, graphic: "images/fur.png", value: 15, tags: [NO_LOOT_TAG] },
    { name: "å¤§ããªè‘‰", desc: "item_leaf_large_desc", type: "material", weight: 0.1, volume: 1.5, graphic: "images/leaf_large.png", value: 4 },
    { name: "wooden_box", desc: "item_wooden_box_desc", type: "tool", useAction: 'placeWoodenBox', weight: 5.0, volume: 15.0, graphic: "images/wooden_box.png", value: 60, tags: [HANDMADE_TAG, NO_LOOT_TAG] },
    { name: "ä¸¸å¤ª", desc: "item_log_desc", type: "material", weight: 4.0, volume: 5.0, graphic: "images/log.png", value: 15 },
    { name: "ãƒãƒªã‚±ãƒ¼ãƒ‰", desc: "item_barricade_desc", type: "tool", useAction: 'placeBarricadeItem', weight: 4.0, volume: 5.0, graphic: "images/barricade.png", value: 45, tags: ["no_loot", "handmade"] },
    { name: "ãƒ‹ãƒ³ã‚¸ãƒ³ã®ç¨®", desc: "item_carrot_seeds_desc", type: "tool", useAction: 'plantSeed', plantResult: 'ãƒ‹ãƒ³ã‚¸ãƒ³', weight: 0.1, volume: 0.1, graphic: "images/seeds.png", value: 8, tags: [NO_LOOT_TAG]},
    { name: "ã‚­ãƒ£ãƒ™ãƒ„ã®ç¨®", desc: "item_cabbage_seeds_desc", type: "tool", useAction: 'plantSeed', plantResult: 'ã‚­ãƒ£ãƒ™ãƒ„', weight: 0.1, volume: 0.1, graphic: "images/seeds.png", value: 8, tags: [NO_LOOT_TAG]},
    { name: "ãƒ™ã‚¢ãƒˆãƒ©ãƒƒãƒ—ã‚­ãƒƒãƒˆ", desc: "item_ãƒ™ã‚¢ãƒˆãƒ©ãƒƒãƒ—ã‚­ãƒƒãƒˆ_desc", type: "tool", useAction: 'placeBearTrap', weight: 3.0, volume: 4.0, graphic: "images/beartrap_kit.png", value: 40, tags: [HANDMADE_TAG, NO_LOOT_TAG] },
    { 
        name: "drying_rack_kit", 
        desc: "item_drying_rack_kit_desc", 
        type: "tool", 
        useAction: 'placeDryingRack', 
        weight: 1.5, 
        volume: 4.0, 
        graphic: "images/drying_rack.png",
        value: 15, 
        tags: [HANDMADE_TAG, NO_LOOT_TAG] 
    },
    { 
        name: "dried_meat", 
        desc: "item_dried_meat_desc", 
        type: "consumable", 
        effects: { hunger: 25, thirst: -5, morale: 2 }, 
        nutrients: { carbs: 0, protein: 30, fat: 15, vitamins: 1, water: 0 }, 
        freshness: 500,
        weight: 0.2, 
        volume: 0.5, 
        graphic: "images/dried_meat.png",
        value: 20, 
        tags: [NO_LOOT_TAG], 
        smell: 3 
    },
    { name: "ã‚¸ãƒ£ã‚¬ã‚¤ãƒ¢ã®ç¨®", desc: "item_potato_seeds_desc", type: "tool", useAction: 'plantSeed', plantResult: 'ã‚¸ãƒ£ã‚¬ã‚¤ãƒ¢', weight: 0.1, volume: 0.1, graphic: "images/seeds.png", value: 8, tags: [NO_LOOT_TAG]},
    { 
        name: "primitive_tshirt", 
        desc: "item_primitive_tshirt_desc", 
        type: "clothing", 
        slot: "body_inner", 
        defense: 0, 
        insulation: 0.2, 
        durability: 30, 
        weight: 0.1, 
        volume: 0.5, 
        value: 1, 
        wetness: 'dry', 
        graphic: "images/primitive_tshirt.png",
        tags: ["handmade", "no_loot"] 
    },
    { 
        name: "primitive_pants", 
        desc: "item_primitive_pants_desc", 
        type: "clothing", 
        slot: "legs", 
        defense: 1, 
        insulation: 0.5, 
        durability: 30, 
        weight: 0.2, 
        volume: 0.8, 
        value: 1, 
        wetness: 'dry', 
        graphic: "images/primitive_pants.png",
        tags: ["handmade", "no_loot"] 
    },
    { 
        name: "primitive_hat", 
        desc: "item_primitive_hat_desc", 
        type: "clothing", 
        slot: "head", 
        defense: 0, 
        insulation: 0.3, 
        durability: 25, 
        weight: 0.1, 
        volume: 0.3, 
        value: 1, 
        wetness: 'dry', 
        graphic: "images/primitive_hat.png",
        tags: ["handmade", "no_loot"] 
    },
    { 
        name: "primitive_coat", 
        desc: "item_primitive_coat_desc", 
        type: "clothing", 
        slot: "body_outer", 
        defense: 1, 
        insulation: 1.0, 
        durability: 35, 
        weight: 0.5, 
        volume: 2.0, 
        value: 2, 
        wetness: 'dry', 
        graphic: "images/primitive_coat.png",
        tags: ["handmade", "no_loot"] 
    },
    { 
        name: "ç‚­", 
        desc: "item_ç‚­_desc",
        type: "material", 
        weight: 0.1, 
        volume: 0.2, 
        graphic: "images/charcoal.png", 
        value: 5, 
        tags: ["no_loot"] 
    },
    { 
        name: "ç°", 
        desc: "item_ç°_desc", 
        type: "material", 
        weight: 0.1, 
        volume: 0.1, 
        graphic: "images/ash.png", 
        value: 1, 
        tags: ["no_loot"] 
    },
    { 
        name: "æ‰‹ä½œã‚Šæµ„æ°´å™¨ã‚­ãƒƒãƒˆ", 
        desc: "item_æ‰‹ä½œã‚Šæµ„æ°´å™¨ã‚­ãƒƒãƒˆ_desc",
        type: "tool", 
        useAction: 'placeWaterFilter', 
        weight: 1.0, 
        volume: 2.0, 
        graphic: "images/water_filter_kit.png", 
        value: 25, 
        tags: ["handmade", "no_loot"] 
    }
];
// â–²â–²â–² ç½®ãæ›ãˆã¯ã“ã“ã¾ã§ â–²â–²â–²

const cookingMap = {
    "ç”Ÿè‚‰": "ç„¼ã„ãŸè‚‰",
    "ã‚­ãƒã‚³": "ç„¼ã„ãŸã‚­ãƒã‚³",
    "ãƒˆã‚¦ãƒ¢ãƒ­ã‚³ã‚·": "ç„¼ã„ãŸãƒˆã‚¦ãƒ¢ãƒ­ã‚³ã‚·",
    "ã‚¸ãƒ£ã‚¬ã‚¤ãƒ¢": "ç„¼ã„ãŸã‚¸ãƒ£ã‚¬ã‚¤ãƒ¢",
    "ãƒ‹ãƒ³ã‚¸ãƒ³": "ç„¼ã„ãŸãƒ‹ãƒ³ã‚¸ãƒ³",
    "ã‚­ãƒ£ãƒ™ãƒ„": "ç„¼ã„ãŸã‚­ãƒ£ãƒ™ãƒ„" // â† ã“ã®è¡Œã‚’è¿½åŠ 
};

const recipes = [
    // --- ç ”ç©¶ãŒå¿…è¦ãªãƒ¬ã‚·ãƒ” ---
    { result: "stone_axe", ingredients: [{ name: "çŸ³", count: 1 }, { name: "æ", count: 1 }], requiredResearch: "primitive_weapons" },
    { result: "handmade_stone_knife", ingredients: [{ name: "çŸ³", count: 2 }] },
    { result: "handmade_spear", ingredients: [{ name: "æ", count: 2 }] },
    { result: "fire_starter", ingredients: [{ name: "æ", count: 2 }] },
    { result: "campfire_kit", ingredients: [{ name: "çŸ³", count: 1 }, { name: "æ", count: 1 }] },
    { result: "simple_bandage", ingredients: [{ name: "å¸ƒåˆ‡ã‚Œ", count: 2 }] },
    { result: "handmade_pouch", ingredients: [{ name: "æ¯›çš®", count: 1 }], requiredResearch: "primitive_armor" },
    { result: "handmade_hat", ingredients: [{ name: "æ¯›çš®", count: 2 }], requiredResearch: "primitive_armor" },
    { result: "handmade_waterskin", ingredients: [{ name: "æ¯›çš®", count: 2 }] },
    { result: "handmade_clothes", ingredients: [{ name: "æ¯›çš®", count: 3 }], requiredResearch: "primitive_armor" },
    { result: "handmade_pants", ingredients: [{ name: "æ¯›çš®", count: 3 }], requiredResearch: "primitive_armor" },
    { result: "handmade_coat", ingredients: [{ name: "æ¯›çš®", count: 5 }], requiredResearch: "primitive_armor" },
    { result: "wooden_box", ingredients: [{ name: "æ", count: 5 }], requiredResearch: "primitive_tools" },
    { result: "sleeping_bag", ingredients: [{ name: "å¤§ããªè‘‰", count: 2 }] },
    { result: "splint", ingredients: [{ name: "æ", count: 3 }], requiredResearch: "primitive_medicine" },
    { result: "handmade_hoe", ingredients: [{ name: "æ", count: 1 }, { name: "çŸ³", count: 1 }], requiredResearch: "primitive_tools" },
    { result: "handmade_sling", ingredients: [{ name: "å¸ƒåˆ‡ã‚Œ", count: 2 }], requiredResearch: "primitive_weapons" },
    { result: "handmade_bow", ingredients: [{ name: "æ", count: 1 }, { name: "å¸ƒåˆ‡ã‚Œ", count: 1 }], requiredResearch: "primitive_weapons" },
    { result: "shelter", ingredients: [{ name: "æ", count: 2 }, { name: "çŸ³", count: 2 }] },
    { result: "handmade_arrow", ingredients: [{ name: "æ", count: 1 }, { name: "çŸ³", count: 1 }], requiredResearch: "primitive_weapons" },
    { result: "ã‚¢ãƒ­ã‚¨ã‚¸ã‚§ãƒ«", ingredients: [{ name: "ã‚¢ãƒ­ã‚¨", count: 1 }] },
    { result: "junk_research_bench_kit", ingredients: [{ name: "æ", count: 1 }, { name: "çŸ³", count: 1 }] },
    { result: "æ", count: 3, ingredients: [{ name: "ä¸¸å¤ª", count: 1 }], requiredTool: 'axe' },
// â–¼â–¼â–¼ ã“ã®6è¡Œã‚’è¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
{ result: "handmade_sandals_left", ingredients: [{ name: "å¤§ããªè‘‰", count: 1 }] },
{ result: "handmade_sandals_right", ingredients: [{ name: "å¤§ããªè‘‰", count: 1 }] },
{ result: "handmade_sandals_left", ingredients: [{ name: "å¸ƒåˆ‡ã‚Œ", count: 2 }] },
{ result: "handmade_sandals_right", ingredients: [{ name: "å¸ƒåˆ‡ã‚Œ", count: 2 }] },
{ result: "handmade_sandals_left", ingredients: [{ name: "æ¯›çš®", count: 1 }] },
{ result: "handmade_sandals_right", ingredients: [{ name: "æ¯›çš®", count: 1 }] },
    // â–¼â–¼â–¼ ã“ã“ã«ä¹¾ç‡¥ãƒ©ãƒƒã‚¯ã®ãƒ¬ã‚·ãƒ”ã‚’è¿½åŠ ã—ã¾ã—ãŸ â–¼â–¼â–¼
// â–¼â–¼â–¼ recipesé…åˆ—ã®å¥½ããªå ´æ‰€ã«è¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
{ result: "cloth_scarf", ingredients: [{ name: "å¸ƒåˆ‡ã‚Œ", count: 1 }] },
// â–¼â–¼â–¼ recipesé…åˆ—ã®å¥½ããªå ´æ‰€ã«è¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
{ result: "cloth_gloves_left", ingredients: [{ name: "å¸ƒåˆ‡ã‚Œ", count: 1 }] },
{ result: "cloth_gloves_right", ingredients: [{ name: "å¸ƒåˆ‡ã‚Œ", count: 1 }] },
    { result: "drying_rack_kit", ingredients: [{ name: "æ", count: 2 }] },
    { result: "primitive_tshirt", ingredients: [{ name: "å¤§ããªè‘‰", count: 1 }] },
    { result: "primitive_tshirt", ingredients: [{ name: "å¸ƒåˆ‡ã‚Œ", count: 1 }] },
    { result: "primitive_pants", ingredients: [{ name: "å¤§ããªè‘‰", count: 1 }] },
    { result: "primitive_pants", ingredients: [{ name: "å¸ƒåˆ‡ã‚Œ", count: 1 }] },
    { result: "primitive_hat", ingredients: [{ name: "å¤§ããªè‘‰", count: 1 }] },
    { result: "primitive_hat", ingredients: [{ name: "å¸ƒåˆ‡ã‚Œ", count: 1 }] },
    { result: "primitive_coat", ingredients: [{ name: "å¤§ããªè‘‰", count: 1 }] },
    { result: "primitive_coat", ingredients: [{ name: "å¸ƒåˆ‡ã‚Œ", count: 1 }] },
    // ã€è¿½åŠ ã™ã‚‹ãƒ¬ã‚·ãƒ”ã€‘
    { result: "æ‰‹ä½œã‚Šæµ„æ°´å™¨ã‚­ãƒƒãƒˆ", ingredients: [{ name: "ç‚­", count: 1 }, { name: "ãƒšãƒƒãƒˆãƒœãƒˆãƒ«", count: 1 }] },
    { result: "æ‰‹ä½œã‚Šæµ„æ°´å™¨ã‚­ãƒƒãƒˆ", ingredients: [{ name: "ç‚­", count: 1 }, { name: "ç©ºãç¼¶", count: 1 }] }
];

items.push(
    { 
        name: "ãƒ¯ãƒ¼ã‚¯ãƒ™ãƒ³ãƒã‚­ãƒƒãƒˆ", 
        desc: "item_workbench_kit_desc", 
        type: "tool", 
        useAction: 'placeWorkbench', 
        weight: 8.0, 
        volume: 20.0, 
        graphic: "images/workbench.png", 
        value: 100, 
        tags: [HANDMADE_TAG, NO_LOOT_TAG] 
    }
);

const workbenchRecipes = [
    { result: "ãƒ”ã‚¹ãƒˆãƒ«", ingredients: [{ name: "é‰„ããš", count: 15 }, { name: "æ", count: 5 }] },
    { result: "ã‚·ãƒ§ãƒƒãƒˆã‚¬ãƒ³", ingredients: [{ name: "é‰„ããš", count: 25 }, { name: "ä¸¸å¤ª", count: 2 }] },
    { result: "ãƒ©ã‚¤ãƒ•ãƒ«", ingredients: [{ name: "é‰„ããš", count: 30 }, { name: "ä¸¸å¤ª", count: 3 }] },
    { result: "ãƒ”ã‚¹ãƒˆãƒ«ã®å¼¾", ingredients: [{ name: "é‰„ããš", count: 2 }] },
    { result: "ã‚·ãƒ§ãƒƒãƒˆã‚¬ãƒ³ã®å¼¾", ingredients: [{ name: "é‰„ããš", count: 3 }] },
    { result: "ãƒ©ã‚¤ãƒ•ãƒ«ã®å¼¾", ingredients: [{ name: "é‰„ããš", count: 3 }] },
    { result: "é˜²å¼¾ãƒ™ã‚¹ãƒˆ", ingredients: [{ name: "é‰„ããš", count: 20 }, { name: "æ¯›çš®", count: 5 }] },
    { result: "å¤§ããªãƒãƒƒã‚¯ãƒ‘ãƒƒã‚¯", ingredients: [{ name: "æ¯›çš®", count: 6 }, { name: "å¸ƒåˆ‡ã‚Œ", count: 4 }] },
    { result: "ãƒ™ã‚¢ãƒˆãƒ©ãƒƒãƒ—ã‚­ãƒƒãƒˆ", ingredients: [{ name: "é‰„ããš", count: 2 }, { name: "æ", count: 1 }] },
    { result: "ãƒãƒªã‚±ãƒ¼ãƒ‰", ingredients: [{ name: "ä¸¸å¤ª", count: 1 }] }
];
items.push(
    { name: "é‰„ããš", desc: "item_scrap_metal_desc", type: "material", weight: 0.5, volume: 0.2, graphic: "images/scrap_metal.png", value: 8 }
);

// â–²â–²â–² ã“ã“ã¾ã§ â–²â–²â–²

const dismantleRecipes = {
    "åŒ…å¸¯": [{ name: "å¸ƒåˆ‡ã‚Œ", count: 1 }],
    "Tã‚·ãƒ£ãƒ„": [{ name: "å¸ƒåˆ‡ã‚Œ", count: 1 }],
    "ã‚ºãƒœãƒ³": [{ name: "å¸ƒåˆ‡ã‚Œ", count: 1 }],
    "æ·»ãˆæœ¨": [{ name: "æ", count: 1 }],
    "ãƒ¢ãƒƒãƒ—": [{ name: "æ", count: 1 }],
    "ãƒ†ãƒ‹ã‚¹ãƒ©ã‚±ãƒƒãƒˆ": [{ name: "æ", count: 1 }],
    "é‡çƒã®ãƒãƒƒãƒˆ": [{ name: "æ", count: 1 }],
    "ä½œæ¥­ç€": [{ name: "å¸ƒåˆ‡ã‚Œ", count: 2 }],
    "ç™½è¡£": [{ name: "å¸ƒåˆ‡ã‚Œ", count: 2 }],
    "ã‚¹ãƒ¼ãƒ„ã®ã‚¸ãƒ£ã‚±ãƒƒãƒˆ": [{ name: "å¸ƒåˆ‡ã‚Œ", count: 2 }],
    "ã‚¸ãƒ£ãƒ¼ã‚¸": [{ name: "å¸ƒåˆ‡ã‚Œ", count: 2 }],
    "ã‚³ãƒƒã‚¯ã‚³ãƒ¼ãƒˆ": [{ name: "å¸ƒåˆ‡ã‚Œ", count: 2 }],
    "ã‚³ãƒ¼ãƒˆ": [{ name: "å¸ƒåˆ‡ã‚Œ", count: 2 }],
    "ãƒ„ãƒ¼ãƒ«ãƒ™ãƒ«ãƒˆ": [{ name: "æ¯›çš®", count: 1 }],
    "æ‰‹ä½œã‚Šã®ãƒã‚·ã‚§ãƒƒãƒˆ": [{ name: "æ¯›çš®", count: 1 }],
    "æ‰‹ä½œã‚Šã®æœ": [{ name: "æ¯›çš®", count: 1 }],
    "æ‰‹ä½œã‚Šã®ã‚ºãƒœãƒ³": [{ name: "æ¯›çš®", count: 1 }],
    "ãƒãƒƒã‚¯ãƒ‘ãƒƒã‚¯": [{ name: "æ¯›çš®", count: 1 }, { name: "å¸ƒåˆ‡ã‚Œ", count: 2 }],
    "å¤§ããªãƒãƒƒã‚¯ãƒ‘ãƒƒã‚¯": [{ name: "æ¯›çš®", count: 2 }, { name: "å¸ƒåˆ‡ã‚Œ", count: 3 }],
    "é˜²å¼¾ãƒ™ã‚¹ãƒˆ": [{ name: "æ¯›çš®", count: 2 }, { name: "å¸ƒåˆ‡ã‚Œ", count: 3 }],
    "æ‰‹ä½œã‚Šã®ã‚³ãƒ¼ãƒˆ": [{ name: "æ¯›çš®", count: 2 }],
    "ã‚¿ã‚ªãƒ«": [{ name: "å¸ƒåˆ‡ã‚Œ", count: 1 }]
};


// NEW: Starting equipment pools for each job
const jobStartingPools = {
    "ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢": ["ä½œæ¥­ç€", "å®‰å…¨ãƒ˜ãƒ«ãƒ¡ãƒƒãƒˆ", "ãƒ„ãƒ¼ãƒ«ãƒ™ãƒ«ãƒˆ", "ãƒ€ã‚¯ãƒˆãƒ†ãƒ¼ãƒ—"],
    "åŒ»å¸«": ["ãƒ¡ã‚¹", "ç™½è¡£", "ãƒã‚¹ã‚¯", "æ•‘æ€¥ã‚­ãƒƒãƒˆ", "åŒ…å¸¯", "è§£ç†±å‰¤", "ä¸‹ç—¢æ­¢ã‚", "èƒƒè…¸è–¬"],
    "è»äºº": ["ã‚³ãƒ³ãƒãƒƒãƒˆãƒŠã‚¤ãƒ•", "ãƒ˜ãƒ«ãƒ¡ãƒƒãƒˆ", "æ°´ç­’"],
    "æ•™å¸«": ["ãƒ¢ãƒƒãƒ—", "ã‚¸ãƒ£ãƒ¼ã‚¸", "æ•‘æ€¥ã‚»ãƒƒãƒˆ"],
    "ã‚¢ã‚¹ãƒªãƒ¼ãƒˆ": ["ãƒ†ãƒ‹ã‚¹ãƒ©ã‚±ãƒƒãƒˆ", "é‡çƒã®ãƒãƒƒãƒˆ", "ã‚¸ãƒ£ãƒ¼ã‚¸", "ã‚¨ãƒŠã‚¸ãƒ¼ãƒ‰ãƒªãƒ³ã‚¯", "ãƒ—ãƒ­ãƒ†ã‚¤ãƒ³ãƒãƒ¼"],
    "è­¦å¯Ÿå®˜": ["ãƒ”ã‚¹ãƒˆãƒ«", "è­¦æ£’", "é˜²å¼¾ãƒ™ã‚¹ãƒˆ", "ãƒ”ã‚¹ãƒˆãƒ«ã®å¼¾"],
    "çœ‹è­·å¸«": ["ãƒã‚µãƒŸ", "ç™½è¡£", "æ•‘æ€¥ã‚­ãƒƒãƒˆ", "åŒ…å¸¯", "è§£ç†±å‰¤", "ä¸‹ç—¢æ­¢ã‚", "èƒƒè…¸è–¬"],
    "ã‚·ã‚§ãƒ•": ["åŒ…ä¸", "ã‚³ãƒƒã‚¯ã‚³ãƒ¼ãƒˆ", "ç¼¶è©°(è±†)", "ç”Ÿè‚‰", "ãƒ©ã‚¤ã‚¿ãƒ¼"],
    "å­¦ç”Ÿ": ["ãƒ¢ãƒƒãƒ—", "é‡çƒã®ãƒãƒƒãƒˆ", "ã‚¸ãƒ£ãƒ¼ã‚¸", "ãƒãƒƒã‚¯ãƒ‘ãƒƒã‚¯"],
    "ä¼šç¤¾å“¡": ["ãƒã‚µãƒŸ", "ã‚¹ãƒ¼ãƒ„ã®ã‚¸ãƒ£ã‚±ãƒƒãƒˆ", "æ°´ç­’", "ç¼¶è©°(è±†)"]
};


/**
 * ç—›ã¿ã«ã‚ˆã‚‹è¡Œå‹•ä¸èƒ½æ™‚ã«ã€ã‚¿ãƒ¼ãƒ³ã‚’æ¶ˆè²»ã—ã€å…¨ã¦ã®UIã‚’æ›´æ–°ã™ã‚‹
 */
function stunAndAdvanceTurn() {
    advanceTurn();
    refreshGameState(); // ç”»é¢å…¨ä½“ã®UIã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
    processSpeechQueue();
}
function randChoice(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

let map = [];
const turnOrder = ['trader', 'survivor', 'raider', 'animal', 'zombie'];
let currentNpcPhaseIndex = 0;
let turn = 0;
let currentSeason = 'æ˜¥';
let isNight = false;
let currentTime = new Date();
let droppedItems = {};

const seasons = ['æ˜¥', 'å¤', 'ç§‹', 'å†¬'];
// â–¼â–¼â–¼ æ—¢å­˜ã® `researchProjects` ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
const researchProjects = {
    'primitive_weapons': {
        nameKey: 'research_primitive_weapons_name',
        descKey: 'research_primitive_weapons_desc',
        unlocksKey: 'research_primitive_weapons_unlocks',
        cost: 2,
        icon: 'images/stone_axe.png',
        prerequisites: [],
        unlocks: ['handmade_sling', 'stone_axe', 'handmade_bow', 'handmade_arrow']
    },
    'primitive_tools': {
        nameKey: 'research_primitive_tools_name',
        descKey: 'research_primitive_tools_desc',
        unlocksKey: 'research_primitive_tools_unlocks',
        cost: 2,
        icon: 'images/hoe.png',
        prerequisites: [],
        unlocks: ['handmade_hoe', 'wooden_box']
    },
    'primitive_medicine': {
        nameKey: 'research_primitive_medicine_name',
        descKey: 'research_primitive_medicine_desc',
        unlocksKey: 'research_primitive_medicine_unlocks',
        cost: 2,
        icon: 'images/splint.png',
        prerequisites: [],
        unlocks: ['splint']
    },
    'primitive_armor': {
        nameKey: 'research_primitive_armor_name',
        descKey: 'research_primitive_armor_desc',
        unlocksKey: 'research_primitive_armor_unlocks',
        cost: 2,
        icon: 'images/handmade_clothes.png',
        prerequisites: [],
        unlocks: ['handmade_coat', 'handmade_pants', 'handmade_pouch', 'handmade_clothes', 'handmade_hat']
    }
};
// â–²â–²â–² ç½®ãæ›ãˆã“ã“ã¾ã§ â–²â–²â–²
let player = {
  x: 0, y: 0, hunger: 0, thirst: 0, health: 0, morale: 0, sleep: 0,
  bloodLevel: 100, immuneSystem: 100, painTolerance: 100, // â˜…ã“ã®è¡Œã‚’è¿½åŠ 
  research: { completed: [], currentProjectId: null, progress: {} },
  barefootTurns: 0, // â–¼â–¼â–¼ ã“ã®è¡Œã‚’è¿½åŠ  â–¼â–¼â–¼
  nextSoreFeetTurn: -1,    // æ¬¡ã«ã€Œè¶³ãŒç—›ãã€ãªã‚‹ã‚¿ãƒ¼ãƒ³æ•°ã‚’è¨˜éŒ²
  nextInjuredFeetTurn: -1, // æ¬¡ã«ã€Œæ€ªæˆ‘ã€ã«ãªã‚‹ã‚¿ãƒ¼ãƒ³æ•°ã‚’è¨˜éŒ²
  direction: 0,
  bodyTemp: 36.5, weight: 0, maxWeight: 10, volume: 0, maxVolume: 10, bodyOdor: 0,
  vision: 2, inventory: [], equipment: [], injuries: [], sicknesses: [], hypothermiaTurns: 0, feverImmunityTurns: 0,
  baseAttack: 5, baseDefense: 5, attack: 5, defense: 5, insulation: 0,
  isInside: false,
  isInShelter: false,
  movementMode: 'walk',
  isDodging: false,
  carbs: 0, protein: 0, fat: 0, vitamins: 0,
  isParrying: false,
  stance: 'standing',
  vulnerableTurns: 0,
  stunnedTurns: 0,
  heavyAttackCooldown: 0,
  isAiming: false, // â˜…ã“ã®è¡Œã‚’è¿½åŠ 
  painkillerEffectTurns: 0, // â˜…â˜…â˜… ã“ã®è¡Œã‚’è¿½åŠ  â˜…â˜…â˜…
  painStunCycle: 0, // â˜…â˜…â˜… ã“ã®è¡Œã‚’è¿½åŠ  â˜…â˜…â˜…
  painStunSchedule: [], // â˜…â˜…â˜… ã“ã®è¡Œã‚’è¿½åŠ  â˜…â˜…â˜…
  hypovolemicShockTimer: -1, // â˜…â˜…â˜… ã“ã®è¡Œã‚’è¿½åŠ  â˜…â˜…â˜…
  reach: 1
};

function snapshotStats() {
    playerStatsBeforeAction = JSON.parse(JSON.stringify(player));
}

function speak(text, onEndCallback) {
    const speechVolumeSlider = document.getElementById('speechVolumeSlider');
    const speechVolume = speechVolumeSlider ? parseFloat(speechVolumeSlider.value) : 0.8;

    if (speechVolume <= 0) {
        if (onEndCallback) {
            setTimeout(onEndCallback, 100);
        }
        return;
    }

    if ('speechSynthesis' in window && text) {
        const utter = new SpeechSynthesisUtterance(text);
        utter.rate = 2.5;
        utter.volume = speechVolume; // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®å€¤ã‚’éŸ³é‡ã«è¨­å®š

        if (currentLanguage === 'ja') {
            utter.lang = 'ja-JP';
        } else if (currentLanguage === 'zh-CN') {
            utter.lang = 'zh-CN';
        } else {
            utter.lang = 'en-US';
        }

        if (onEndCallback) { utter.onend = onEndCallback; }
        // speechSynthesis.cancel(); // ã“ã®è¡Œã‚’å‰Šé™¤ã¾ãŸã¯ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã—ã¾ã™
        speechSynthesis.speak(utter);
    } else if (onEndCallback) {
        setTimeout(onEndCallback, 500);
    }
}
function speakQueuedLogs() {
    // logé–¢æ•°ã§å³æ™‚èª­ã¿ä¸Šã’ã‚’è¡Œã†ãŸã‚ã€ã“ã®é–¢æ•°ã¯ä¸è¦ã«ãªã‚Šã¾ã—ãŸã€‚
    // å¿µã®ãŸã‚ã‚­ãƒ¥ãƒ¼ã‚’ç©ºã«ã™ã‚‹å‡¦ç†ã ã‘æ®‹ã—ã¾ã™ã€‚
    logSpeechQueue = [];
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function placeWorkbench(item, itemIndex, source) {
    let isBlocked = false;
    const outdoorBlockers = ['workbench', 'junk_research_bench', 'barricade', 'shelter', 'wooden_box', 'sleeping_bag'];

    if (player.isInside || player.isInShelter) {
        // å±‹å†…ã§ã¯ã€æ—¢ã«ãƒ¯ãƒ¼ã‚¯ãƒ™ãƒ³ãƒãŒã‚ã‚‹å ´åˆã®ã¿ãƒ–ãƒ­ãƒƒã‚¯
        isBlocked = placedObjects.some(o => o.x === player.x && o.y === player.y && o.type === 'workbench');
    } else {
        // å±‹å¤–ã§ã¯ã€ä»–ã®ä¸»è¦ãªè¨­ç½®ç‰©ãŒã‚ã‚Œã°ãƒ–ãƒ­ãƒƒã‚¯
        isBlocked = placedObjects.some(o => o.x === player.x && o.y === player.y && outdoorBlockers.includes(o.type));
    }

    if (isBlocked) {
        log(getString("log_workbench_blocked"));
        return;
    }

    snapshotStats();

    const sourceArray = source === 'inventory' ? player.inventory : droppedItems[`${player.x},${player.y}`];
    const removedItem = sourceArray.splice(itemIndex, 1)[0];

    if (source === 'inventory') {
        player.weight -= removedItem.weight;
        player.volume -= removedItem.volume;
    }

    log(getString("log_workbench_placed"));
    placedObjects.push({ 
        x: player.x, 
        y: player.y, 
        type: 'workbench', 
        name: 'ãƒ¯ãƒ¼ã‚¯ãƒ™ãƒ³ãƒ', 
        graphic: 'images/workbench.png'
    });
    
    drawMap();
    updateItemPanels();
    updateStatus();
    hideItemDetail();
}
function openWorkbenchPanel() {
    const panel = document.getElementById('workbenchPanel');
    const listDiv = document.getElementById('workbenchCraftingList');
    listDiv.innerHTML = "";

    workbenchRecipes.forEach(recipe => {
        const resultItem = items.find(i => i.name === recipe.result);
        if (!resultItem) return;

        const isCraftable = canCraftItem(recipe);
        const div = document.createElement("div");
        div.className = isCraftable ? "item" : "item un-craftable";
        
        // â˜…â˜…â˜… ã“ã“ã‹ã‚‰3è¡Œã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ ã—ã¾ã—ãŸ â˜…â˜…â˜…
        div.addEventListener('mouseenter', (e) => showRecipeTooltip(resultItem, e));
        div.addEventListener('mouseleave', hideStatusPreview);
        div.addEventListener('mousemove', (e) => updatePreviewPosition(e));
        
        let ingredientsHtml = recipe.ingredients.map(ing => `${getString(`item_${ing.name}_name`)} x${ing.count}`).join(', ');
        div.innerHTML = `<button>${getString("btn_craft")}</button><span style="margin-right: 5px;">${getIconHTML(resultItem.graphic, 16)}</span>${getString(`item_${resultItem.name}_name`)}<div class="recipe-ingredients">${ingredientsHtml}</div>`;
        
        if (isCraftable) {
            div.querySelector("button").onclick = () => craftWorkbenchItem(recipe);
        }
        listDiv.appendChild(div);
    });

    panel.style.display = 'flex';
    bringToFront(panel);
}

function closeWorkbenchPanel() {
    document.getElementById('workbenchPanel').style.display = 'none';
}

function craftWorkbenchItem(recipe) {
    if (isStunnedByPain()) { return; }
    if (!canCraftItem(recipe)) { log("ææ–™ãŒè¶³ã‚Šã¾ã›ã‚“ã€‚"); return; }
    
    snapshotStats();
    recipe.ingredients.forEach(ingredient => {
        for (let i = 0; i < ingredient.count; i++) {
            const invIndex = player.inventory.findIndex(invItem => invItem.name === ingredient.name);
            if (invIndex > -1) {
                const removedItem = player.inventory.splice(invIndex, 1)[0];
                player.weight -= removedItem.weight || 0;
                player.volume -= removedItem.volume || 0;
            } else {
                const groundItems = droppedItems[`${player.x},${player.y}`] || [];
                const groundIndex = groundItems.findIndex(gItem => gItem.name === ingredient.name);
                if (groundIndex > -1) groundItems.splice(groundIndex, 1);
            }
        }
    });

    const resultItemTemplate = items.find(item => item.name === recipe.result);
    if (resultItemTemplate) {
        const newItem = { ...resultItemTemplate };
        if (newItem.durability !== undefined) {
            newItem.durability = Math.floor(Math.random() * 30) + 70;
        }

        // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ãƒ–ãƒ­ãƒƒã‚¯ã§ã™ â–¼â–¼â–¼
        if (player.weight + newItem.weight > player.maxWeight || player.volume + (newItem.volume || 0) > player.maxVolume) {
            log(getString("craft_success_grounded", { itemName: getItemDisplayName(newItem) }), true);
            const locationKey = `${player.x},${player.y}`;
            if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
            droppedItems[locationKey].push(newItem);
            updateCurrentLocationPanel(false);
        } else {
            player.inventory.push(newItem);
            player.weight += newItem.weight || 0;
            player.volume += newItem.volume || 0;
        }

        log(getString("craft_success", { itemName: getItemDisplayName(newItem) }), true);
        createSound(player.x, player.y, 5);
        // â–²â–²â–² ä¿®æ­£ãƒ–ãƒ­ãƒƒã‚¯ã“ã“ã¾ã§ â–²â–²â–²
    }
    
    updateItemPanels();
    updateStatus();
    openWorkbenchPanel();
}

// â–²â–²â–² ã“ã“ã¾ã§ â–²â–²â–²

function speakAndAlert(text) { speak(text); showModal(text); }

function speakAndConfirm(text, onConfirm, onCancel) {
    // Create a temporary element to strip HTML for speech synthesis
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = text;
    const plainText = tempDiv.textContent || tempDiv.innerText || "";
    speak(plainText); // Speak the plain text version
    showConfirmationModal(text, onConfirm, onCancel); // Show the HTML version in the modal
}

function showModal(message, onOkCallback) {
  const existingModal = document.getElementById("simpleModal");
  if (existingModal) existingModal.remove();

  const modalDiv = document.createElement("div");
  modalDiv.id = "simpleModal";
  modalDiv.style.cssText = `position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #333; color: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.5); z-index: 2000;`;
  modalDiv.innerHTML = `<p>${message}</p><button id="modalOkBtn">${getString("btn_ok")}</button>`;
  document.body.appendChild(modalDiv);

  document.getElementById("modalOkBtn").onclick = () => {
      modalDiv.remove();
      if (onOkCallback) {
          onOkCallback();
      }
  };
}

function showConfirmationModal(message, onConfirm, onCancel) {
  isInteractionActive = true;
  const modalDiv = document.createElement("div");
  modalDiv.style.cssText = `position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #333; color: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.5); z-index: 2000;`;
  modalDiv.innerHTML = `<p>${message}</p><button id="confirmYes" style="margin-right: 10px;">${getString("btn_yes")}</button><button id="confirmNo">${getString("btn_no")}</button>`;
  document.body.appendChild(modalDiv);
  modalDiv.querySelector("#confirmYes").onclick = () => { modalDiv.remove(); isInteractionActive = false; if(onConfirm) onConfirm(); };
  modalDiv.querySelector("#confirmNo").onclick = () => { modalDiv.remove(); isInteractionActive = false; if(onCancel) onCancel(); };
}

function showItemComparisonModal(newItem, oldItem, onConfirm, onCancel) {
    isInteractionActive = true;
    const existingModal = document.getElementById("comparisonModal");
    if (existingModal) existingModal.remove();

    const modalDiv = document.createElement("div");
    modalDiv.id = "comparisonModal";
    
const renderItem = (item, type) => {
        let statsHtml = '';
        const otherItem = type === 'new' ? oldItem : newItem;

        // --- æ”»æ’ƒåŠ›é–¢é€£ã®è¡¨ç¤ºã‚’ä¿®æ­£ ---
        if (item.attack !== undefined || otherItem.attack !== undefined) {
            const val = item.attack === undefined ? '-' : item.attack;
            const otherVal = otherItem.attack === undefined ? '-' : otherItem.attack;
            let statClass = 'stat-neutral';
            if (val !== '-' && otherVal !== '-') {
                if (val > otherVal) statClass = 'stat-positive';
                if (val < otherVal) statClass = 'stat-negative';
            }
            statsHtml += `<div class="${statClass}">${getString('detail_label_attack_melee')}: ${val}</div>`;
        }
        if (item.fireDamage !== undefined || otherItem.fireDamage !== undefined) {
            const val = item.fireDamage === undefined ? '-' : item.fireDamage;
            const otherVal = otherItem.fireDamage === undefined ? '-' : otherItem.fireDamage;
            let statClass = 'stat-neutral';
            if (val !== '-' && otherVal !== '-') {
                if (val > otherVal) statClass = 'stat-positive';
                if (val < otherVal) statClass = 'stat-negative';
            }
            statsHtml += `<div class="${statClass}">${getString('detail_label_attack_ranged')}: ${val}</div>`;
        }

        // --- ãã®ä»–ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º ---
        const otherStats = ['defense', 'insulation', 'weight', 'volume'];
        otherStats.forEach(stat => {
            const val = item[stat] === undefined ? '-' : item[stat];
            const otherVal = otherItem[stat] === undefined ? '-' : otherItem[stat];
            let statClass = 'stat-neutral';
            
            if(val !== '-' && otherVal !== '-') {
                let a = (stat === 'weight' || stat === 'volume') ? otherVal : val;
                let b = (stat === 'weight' || stat === 'volume') ? val : otherVal;
                if (a > b) statClass = 'stat-positive';
                if (a < b) statClass = 'stat-negative';
            }
            statsHtml += `<div class="${statClass}">${getString(`detail_label_${stat}`)}: ${val}</div>`;
        });
        
        const durability = item.durability !== undefined ? `<div>${getString("detail_label_durability")}: ${item.durability.toFixed(0)}%</div>` : '';
        const headerText = type === 'new' ? getString("compare_equip_new") : getString("compare_equip_current");

        return `<div class="comparison-item"><h4>${headerText}</h4><div class="comparison-item-graphic">${getIconHTML(item.graphic, 48)}</div><div class="comparison-item-name">${getItemDisplayName(item)}</div><div class="comparison-stats">${statsHtml}${durability}</div></div>`;
    };

    modalDiv.innerHTML = `<h3>${getString("compare_equip_title")}</h3><div class="comparison-container">${renderItem(newItem, 'new')}${renderItem(oldItem, 'old')}</div><div class="comparison-actions"><button id="confirmSwapBtn">${getString("btn_yes")}</button><button id="cancelSwapBtn">${getString("btn_no")}</button></div>`;

    document.body.appendChild(modalDiv);
    document.getElementById("confirmSwapBtn").onclick = () => { modalDiv.remove(); isInteractionActive = false; if (onConfirm) onConfirm(); };
    document.getElementById("cancelSwapBtn").onclick = () => { modalDiv.remove(); isInteractionActive = false; if (onCancel) onCancel(); };
}


function generateBackstory() {
  const { fullNameKey, age, gender, job, race, traits } = character;
  const translatedFullName = getString(fullNameKey);
  let story = getString("backstory_intro", {
    fullName: translatedFullName,
    age: age,
    gender: getString(gender)
  });

  story += " " + getString(`backstory_${job}`);
  story += " " + getString(`backstory_${race}`);

  if (traits.length > 0) {
    story += " " + getString("backstory_traits_intro");
    traits.forEach((trait, index) => {
      story += getString(`trait_${trait}_name`);
      if (index < traits.length - 1) {
        story += getString("backstory_traits_separator");
      }
    });
    story += "ã€‚";
  }
  story += " " + getString("backstory_outro");
  return story;
}

// â–¼â–¼â–¼ æ—¢å­˜ã®`generateInitialCorpses`é–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function generateInitialCorpses() {
    const numCorpses = Math.floor(mapSize * mapSize * 0.015);
    
    for (let i = 0; i < numCorpses; i++) {
        let x, y, locationKey;
        do {
            x = Math.floor(Math.random() * mapSize);
            y = Math.floor(Math.random() * mapSize);
            locationKey = `${x},${y}`;
        } while ((x === player.x && y === player.y) || placedObjects.some(p => p.x === x && p.y === y));

        const isHuman = Math.random() < 0.5;

        if (isHuman) {
            let corpseLoot = [];
            const numItems = Math.floor(Math.random() * 3) + 1;
            const lootableItems = items.filter(item => !item.tags || (!item.tags.includes(NO_LOOT_TAG) && !item.tags.includes(HANDMADE_TAG)));
            for (let j = 0; j < numItems; j++) {
                if (lootableItems.length === 0) break;
                
                // â–¼â–¼â–¼ ä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
                let newItem = createItemInstance(randChoice(lootableItems));
                // â–²â–²â–² ä¿®æ­£ã“ã“ã¾ã§ â–²â–²â–²

                if (newItem.freshness !== undefined) newItem.freshness = Math.floor(Math.random() * 40);
                if (newItem.durability !== undefined) newItem.durability = Math.floor(Math.random() * 50) + 10;
                corpseLoot.push(newItem);
            }

            if (corpseLoot.length > 0) {
                const corpse = {
                    x: x, y: y, type: 'corpse', name: 'å¤ã„æ­»ä½“',
                    graphic: HUMAN_CORPSE_IMG,
                    duration: Math.floor(Math.random() * 24) + 24,
                    isHumanCorpse: true, unsearched: true, potentialLoot: corpseLoot
                };
                placedObjects.push(corpse);
            }
        } else { // Animal corpse
            const corpse = {
                x: x, y: y, type: 'corpse', name: 'å‹•ç‰©ã®æ­»éª¸',
                graphic: ANIMAL_CARCASS_IMG,
                duration: Math.floor(Math.random() * 24) + 48,
                isAnimalCorpse: true, unbutchered: true,
                potentialLoot: { 
                    meat: Math.floor(Math.random() * 3) + 1, 
                    fur: Math.floor(Math.random() * 2)
                }
            };
            placedObjects.push(corpse);
        }
    }
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
async function loadLanguage(lang) {
    try {
        // main.jsã«è¨€èªãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã‚’ä¾é ¼ã™ã‚‹
        const loadedStrings = await ipcRenderer.invoke('load-language-file', lang);

        if (loadedStrings) {
            stringTable = loadedStrings;
            currentLanguage = lang;
            console.log(`${lang.toUpperCase()} ã®è¨€èªãƒ•ã‚¡ã‚¤ãƒ«ã‚’é©ç”¨ã—ã¾ã—ãŸã€‚`);
            applyTranslations(); // èª­ã¿è¾¼ã‚“ã ãƒ†ã‚­ã‚¹ãƒˆã‚’ç”»é¢ã«é©ç”¨
        } else {
            // ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ãŸå ´åˆ
            throw new Error(`ipcRendererã‹ã‚‰nullãŒè¿”ã•ã‚Œã¾ã—ãŸã€‚`);
        }

    } catch (error) {
        console.error(`è¨€èªãƒ•ã‚¡ã‚¤ãƒ«(${lang}.json)ã®å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:`, error);
        // å¤±æ•—ã—ãŸå ´åˆã€å®‰å…¨ã®ãŸã‚ã«æ—¥æœ¬èªã‚’å†èª­ã¿è¾¼ã¿
        if (lang !== 'ja') {
            await loadLanguage(currentLanguage);
        }
    }
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
/**
 * ã‚­ãƒ¼ã«å¯¾å¿œã™ã‚‹ç¿»è¨³æ–‡å­—åˆ—ã‚’å–å¾—ã—ã€ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã‚’ç½®æ›ã™ã‚‹
 * @param {string} key - ç¿»è¨³ã‚­ãƒ¼
 * @param {object} [replacements={}] - ç½®æ›ã™ã‚‹å€¤ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (ä¾‹: { itemName: 'çŸ³' })
 * @returns {string} - ç¿»è¨³ãƒ»ç½®æ›ã•ã‚ŒãŸæ–‡å­—åˆ—
 */
function getString(key, replacements = {}) {
    let text = (stringTable && stringTable[key]) ? stringTable[key] : key;
    if (text === key) {
        console.warn(`Translation key not found: ${key}`);
    }
    // æ¸¡ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚­ãƒ¼ã‚’ä½¿ã£ã¦ã€{key} å½¢å¼ã®ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã‚’å…¨ã¦ç½®æ›ã™ã‚‹
    for (const placeholder in replacements) {
        text = text.replace(new RegExp(`{${placeholder}}`, 'g'), replacements[placeholder]);
    }
    return text;
}
// ã€ã“ã®æ–°ã—ã„é–¢æ•°ã‚’è¿½åŠ ã€‘
function applyPlaceholderTranslations() {
    document.querySelectorAll('[data-translate-placeholder-key]').forEach(element => {
        const key = element.getAttribute('data-translate-placeholder-key');
        if (stringTable[key]) {
            element.placeholder = stringTable[key];
        }
    });
}
function applyTranslations() {
    if (!stringTable || Object.keys(stringTable).length === 0) {
        console.log("ç¿»è¨³ãƒ‡ãƒ¼ã‚¿ãŒã¾ã èª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚");
        return;
    }

    // data-translate-keyå±æ€§ã‚’æŒã¤å…¨ã¦ã®HTMLè¦ç´ ã‚’å–å¾—ã—ã¦ã€ãƒ†ã‚­ã‚¹ãƒˆã‚’ç½®ãæ›ãˆã‚‹
    document.querySelectorAll('[data-translate-key]').forEach(element => {
        const key = element.getAttribute('data-translate-key');
        if (stringTable[key]) {
            element.textContent = stringTable[key];
        }
    });

    // è¨€èªåˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’æ›´æ–°
    if (document.getElementById('langBtnJa')) {
        // å…¨ã¦ã®ãƒœã‚¿ãƒ³ã‹ã‚‰ä¸€æ—¦activeã‚¯ãƒ©ã‚¹ã‚’å‰Šé™¤
        document.getElementById('langBtnJa').classList.remove('active');
        document.getElementById('langBtnEn').classList.remove('active');
        document.getElementById('langBtnZh').classList.remove('active');

        // ç¾åœ¨ã®è¨€èªã«å¯¾å¿œã™ã‚‹ãƒœã‚¿ãƒ³ã«activeã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ 
        if (currentLanguage === 'ja') {
            document.getElementById('langBtnJa').classList.add('active');
        } else if (currentLanguage === 'zh-CN') {
            document.getElementById('langBtnZh').classList.add('active');
        } else { // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯è‹±èª
            document.getElementById('langBtnEn').classList.add('active');
        }
    }
    
if (map && map.length > 0) {
    updateCharacterInfo();
    updateItemPanels();
    updateCurrentLocationPanel(false);
    updateStatus(); // â† ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ‘ãƒãƒ«å…¨ä½“ã‚’æ›´æ–°ã™ã‚‹ãŸã‚ã«ã“ã®è¡Œã‚’è¿½åŠ 
    updateTurnInfo(); // â† æ™‚é–“æƒ…å ±ã¨ãƒãƒƒãƒ—ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’æ›´æ–°ã™ã‚‹ãŸã‚ã«ã“ã®è¡Œã‚’è¿½åŠ 
}
    // â–²â–²â–² ä¿®æ­£ã“ã“ã¾ã§ â–²â–²â–²

    console.log("ç¿»è¨³ã‚’é©ç”¨ã—ã¾ã—ãŸã€‚");
    applyPlaceholderTranslations(); // â˜…ã“ã®è¡Œã‚’è¿½åŠ 
}
// index.htmlã®<script>ã‚¿ã‚°å†…

// â–¼â–¼â–¼ ã“ã®é…åˆ—ã‚’ä¿®æ­£ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
const npcTemplates = [
    { type: 'Trader', name: 'å•†äºº', icon: 'images/trader.png', portraitIcon: 'images/trader_portrait.png', health: 70, baseAttack: 5, baseDefense: 10, visionRange: 3, knowsSalvationCity: false, willSteal: 0.1, // â† portraitIcon ã‚’è¿½åŠ 
        ascii: {
            // ...
        },
        dialogue: { greeting: "npc_trader_greeting", fight: "npc_trader_fight", leave: "npc_trader_leave" }
    },
    { type: 'Survivor', name: 'ç”Ÿå­˜è€…', icon: 'images/survivor.png', portraitIcon: 'images/survivor_portrait.png', health: 50, baseAttack: 8, baseDefense: 3, visionRange: 3, willSteal: 0.3, // â† portraitIcon ã‚’è¿½åŠ 
        ascii: {
            // ...
        },
        dialogue: { greeting: "npc_survivor_greeting", fight: "npc_survivor_fight", leave: "npc_survivor_leave" }
    },
    { type: 'Raider', name: 'ç•¥å¥ªè€…', icon: 'images/raider.png', portraitIcon: 'images/raider_portrait.png', health: 80, baseAttack: 12, baseDefense: 5, visionRange: 3, willSteal: 1.0, // â† portraitIcon ã‚’è¿½åŠ 
        ascii: {
            // ...
        },
        dialogue: { greeting: "npc_raider_greeting", fight: "npc_raider_fight", leave: "npc_raider_leave" }
    }
];
// index.htmlã®<script>ã‚¿ã‚°å†…

// â–¼â–¼â–¼ ã“ã®é…åˆ—ã‚’ä¿®æ­£ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
const wildlifeTemplates = [
    { type: 'Bear', name: 'ç†Š', icon: 'images/bear.png', portraitIcon: 'images/bear_portrait.png', health: 120, attack: 20, defense: 40, visionRange: 5, isAnimal: true, 
        ascii: {
            high: ` (\\_(-_-)_/)\n   _\\_â€_/_  \n  /___â€___\\`,
            medium: ` (\\_(-o-)_/)\n   _\\_â€_/_  \n  /__ â€__ \\`,
            low: ` (\\_(>_<)_/)\n   _\\_â€_/_  \n  /  â€   \\`,
            critical: ` (\\_(x_x)_/)\n   _\\_â€_/_  `
        }, 
        loot: { meat: 8, fur: 5 }, 
        biomes: ['Forest'] 
    },
    { type: 'Wolf', name: 'ç‹¼', icon: 'images/wolf.png', portraitIcon: 'images/wolf_portrait.png', health: 60, attack: 15, defense: 10, visionRange: 6, isAnimal: true, 
        ascii: {
            high: `  /\\_/\\ \n ( o.o ) \n > ^ <`,
            medium: `  /\\_/\\ \n ( o.o ) \n > ~ <`,
            low: `  /\\_/\\ \n ( >.< ) \n > ~ <`,
            critical: `  /\\_/\\ \n ( x.x ) \n > , <`
        }, 
        loot: { meat: 4, fur: 3 }, 
        biomes: ['Forest', 'Plains'] 
    },
    { type: 'Deer', name: 'é¹¿', icon: 'images/deer.png', portraitIcon: 'images/deer_portrait.png', health: 40, attack: 5, defense: 2, visionRange: 7, isAnimal: true, flees: true, 
        ascii: {
            high: `  Y Y  \n (o.o) \n  > <`,
            medium: `  Y Y  \n (o.o) \n  > ~`,
            low: `  Y Y  \n (>.<) \n  > ,`,
            critical: `  Y Y  \n (x.x) `
        }, 
        loot: { meat: 5, fur: 2 }, 
        biomes: ['Plains', 'Forest'] 
    },
    { type: 'Rabbit', name: 'ã‚¦ã‚µã‚®', icon: 'images/rabbit.png', portraitIcon: 'images/rabbit_portrait.png', health: 15, attack: 1, defense: 0, visionRange: 6, isAnimal: true, flees: true, 
        ascii: {
            high: `  /\\ /\\ \n ( o.o ) \n c(___)"`,
            medium: `  /\\ /\\ \n ( o.o ) \n c(___)'`,
            low: `  /\\ /\\ \n ( >.< ) \n c(___)'`,
            critical: `  /\\ /\\ \n ( x.x )`
        }, 
        loot: { meat: 1, fur: 1 }, 
        biomes: ['Plains'] 
    }
];
// â–¼â–¼â–¼ æ—¢å­˜ã®`genMap`é–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function genMap() {
    generateRandomCharacter();
    calculateMaxStats();
    map = []; entities = []; placedObjects = [];
    droppedItems = {};
    let biomeMap = Array(mapSize).fill(null).map(() => Array(mapSize).fill('Plains'));
    let allClusters = [];

    const MIN_DISTANCE_BETWEEN_CLUSTERS = 20;

    const generateClusters = (biomeType, count, clusterSizeRange) => {
        for (let i = 0; i < count; i++) {
            const currentCluster = [];
            const clusterSize = Math.floor(Math.random() * (clusterSizeRange.max - clusterSizeRange.min + 1)) + clusterSizeRange.min;
            let startX, startY, attempts = 0;
            
            do {
                startX = Math.floor(Math.random() * (mapSize - 10)) + 5;
                startY = Math.floor(Math.random() * (mapSize - 10)) + 5;
                attempts++;
                if (attempts > 100) break;
            } while (allClusters.flat().some(tile => getDistance(startX, startY, tile.x, tile.y) < MIN_DISTANCE_BETWEEN_CLUSTERS));
            
            if (attempts > 100) continue;

            biomeMap[startY][startX] = biomeType;
            currentCluster.push({ x: startX, y: startY });

            for (let j = 1; j < clusterSize; j++) {
                const lastTile = randChoice(currentCluster);
                const directions = [{dx:0, dy:1}, {dx:0, dy:-1}, {dx:1, dy:0}, {dx:-1, dy:0}];
                for(let k=0; k<4; k++) {
                    const dir = randChoice(directions);
                    directions.splice(directions.indexOf(dir), 1);
                    const nextX = lastTile.x + dir.dx;
                    const nextY = lastTile.y + dir.dy;
                    if (nextX > 0 && nextX < mapSize - 1 && nextY > 0 && nextY < mapSize - 1 && biomeMap[nextY][nextX] === 'Plains') {
                        biomeMap[nextY][nextX] = biomeType;
                        currentCluster.push({ x: nextX, y: nextY });
                        break;
                    }
                }
            }
            allClusters.push({type: biomeType, tiles: currentCluster});
        }
    };

    generateClusters('Commercial', Math.floor(Math.random() * 3) + 5, {min: 1, max: 2});
    generateClusters('Industrial', Math.floor(Math.random() * 3) + 5, {min: 1, max: 2});
    generateClusters('Residential', Math.floor(Math.random() * 2) + 5, {min: 1, max: 2});
    generateClusters('Forest', Math.floor(mapSize / 15), {min: 15, max: 25});
    
    const clusterCenters = allClusters.filter(c => c.type !== 'Forest').map(cluster => {
        const sum = cluster.tiles.reduce((acc, tile) => ({ x: acc.x + tile.x, y: acc.y + tile.y }), { x: 0, y: 0 });
        return { x: Math.round(sum.x / cluster.tiles.length), y: Math.round(sum.y / cluster.tiles.length) };
    });

    if (clusterCenters.length > 1) {
        const inTree = new Set([0]);
        const edges = [];
        
        while (inTree.size < clusterCenters.length) {
            let minEdge = { from: -1, to: -1, dist: Infinity };
            inTree.forEach(fromIndex => {
                for (let toIndex = 0; toIndex < clusterCenters.length; toIndex++) {
                    if (!inTree.has(toIndex)) {
                        const dist = getDistance(clusterCenters[fromIndex].x, clusterCenters[fromIndex].y, clusterCenters[toIndex].x, clusterCenters[toIndex].y);
                        if (dist < minEdge.dist) {
                            minEdge = { from: fromIndex, to: toIndex, dist: dist };
                        }
                    }
                }
            });
            edges.push(minEdge);
            inTree.add(minEdge.to);
        }

        edges.forEach(edge => {
            let start = clusterCenters[edge.from], end = clusterCenters[edge.to], current = {...start};
            while(current.x !== end.x || current.y !== end.y) {
                if (Math.abs(end.x - current.x) > Math.abs(end.y - current.y)) current.x += Math.sign(end.x - current.x);
                else current.y += Math.sign(end.y - current.y);
                if (!['Commercial', 'Industrial', 'Residential'].includes(biomeMap[current.y][current.x])) {
                    biomeMap[current.y][current.x] = 'Road';
                }
            }
        });
    }

    let cabinCoords = []; 
    const MIN_CABIN_DISTANCE = 18; 

    for(let y=0; y<mapSize; y++) {
        const row = [];
        for(let x=0; x<mapSize; x++) {
            const biome = biomeMap[y][x];
            let loc;
            
            if (biomeLocations[biome]) {
                if (biome === 'Forest') {
                    const isTooCloseToCabin = cabinCoords.some(coord => getDistance(x, y, coord.x, coord.y) < MIN_CABIN_DISTANCE);
                    if (isTooCloseToCabin) {
                        const nonCabinForestLocations = biomeLocations.Forest.filter(l => l.nameKey !== "location_cabin");
                        loc = randChoice(nonCabinForestLocations);
                    } else {
                        loc = randChoice(biomeLocations.Forest);
                        if (loc.nameKey === "location_cabin") {
                            cabinCoords.push({x: x, y: y});
                        }
                    }
                } else {
                    loc = randChoice(biomeLocations[biome]);
                }
            } else {
                loc = randChoice(biomeLocations.Plains);
            }

            const tileData = { loc: {...loc}, explored: false, biome: biome, searched: false };
            if (tileData.loc.nameKey === 'location_forest') {
                tileData.logSupply = Math.floor(Math.random() * 3) + 1;
            }
            row.push(tileData);
        }
        map.push(row);
    }
    
    allClusters.filter(c => c.type !== 'Forest').forEach(cluster => {
        if (Math.random() < 0.3) {
            const shopTileCoords = randChoice(cluster.tiles);
            map[shopTileCoords.y][shopTileCoords.x].loc = biomeLocations.TraderShop;
        }
    });
    
    do {
        player.x = Math.floor(Math.random() * mapSize);
        player.y = Math.floor(Math.random() * mapSize);
    } while (['Commercial', 'Industrial', 'Residential'].includes(map[player.y][player.x].biome));
    
    generateInitialCorpses(); 
    
    let scX, scY;
    do { 
        scX = Math.floor(Math.random() * mapSize); 
        scY = Math.floor(Math.random() * mapSize);
    } while (['Commercial', 'Industrial', 'Residential'].includes(map[scY][scX].biome) || getDistance(scX, scY, player.x, player.y) <= 20);

    salvationCityCoords = { x: scX, y: scY };
    map[scY][scX] = { loc: salvationCityLocation, explored: false, biome: 'Plains', searched: false };
    salvationCityDiscovered = false;

    const numEntities = mapSize * mapSize * 0.05;
    for (let i = 0; i < numEntities; i++) {
        let x, y;
        do {
            x = Math.floor(Math.random() * mapSize);
            y = Math.floor(Math.random() * mapSize);
        } while (getDistance(x, y, player.x, player.y) <= 2 || entities.some(e => e.x === x && e.y === y));
        
        const biome = map[y][x].biome;
        const entityTypeRoll = Math.random();
        
        let health = 50 + Math.floor(Math.random() * 30);
        
        if (['Commercial', 'Industrial', 'Residential'].includes(biome)) {
            let npc;
            if (entityTypeRoll < 0.50) {
                entities.push({ type: 'Zombie', name: 'ã‚¾ãƒ³ãƒ“', icon: 'images/zombie.png', portraitIcon: 'images/zombie_portrait.png', x, y, health: health, maxHealth: health, /* ... */ }); // â† portraitIcon ã‚’è¿½åŠ 
            } else if (entityTypeRoll < 0.60) {
                npc = generateNPC('Raider');
                npc.x = x; npc.y = y; entities.push(npc);
            } else {
                npc = generateNPC(['Survivor', 'Trader']);
                npc.x = x; npc.y = y; entities.push(npc);
            }
        } else {
            let npc;
            if (entityTypeRoll < 0.15) {
                entities.push({ type: 'Zombie', name: 'ã‚¾ãƒ³ãƒ“', icon: 'images/zombie.png', portraitIcon: 'images/zombie_portrait.png', x, y, health: health, maxHealth: health, attack: 8 + Math.floor(Math.random() * 8), defense: 2 + Math.floor(Math.random() * 3), visionRange: 3, isZombie: true, aiState: 'wandering', target: null, investigationTarget: null, stance: 'standing', isDodging: false, vulnerableTurns: 0, stunnedTurns: 0, heavyAttackCooldown: 0 });
            } else if (entityTypeRoll < 0.25) {
                const possibleWildlife = wildlifeTemplates.filter(w => w.biomes.includes(biome) && !w.flees);
                if (possibleWildlife.length > 0) {
                    const newWildlife = { ...JSON.parse(JSON.stringify(randChoice(possibleWildlife))), x, y, aiState: 'wandering', target: null, investigationTarget: null, stance: 'standing', isDodging: false, vulnerableTurns: 0, stunnedTurns: 0, heavyAttackCooldown: 0 };
                    newWildlife.health = Math.floor(newWildlife.health * (0.8 + Math.random() * 0.4));
                    newWildlife.attack = Math.floor(newWildlife.attack * (0.8 + Math.random() * 0.4));
                    newWildlife.defense = Math.floor(newWildlife.defense * (0.8 + Math.random() * 0.4));
                    newWildlife.maxHealth = newWildlife.health;
                    entities.push(newWildlife);
                }
            } else if (entityTypeRoll < 0.45) {
                const possibleWildlife = wildlifeTemplates.filter(w => w.biomes.includes(biome) && w.flees);
                if (possibleWildlife.length > 0) {
                    const newWildlife = { ...JSON.parse(JSON.stringify(randChoice(possibleWildlife))), x, y, aiState: 'wandering', target: null, investigationTarget: null, stance: 'standing', isDodging: false, vulnerableTurns: 0, stunnedTurns: 0, heavyAttackCooldown: 0 };
                    newWildlife.health = Math.floor(newWildlife.health * (0.8 + Math.random() * 0.4));
                    newWildlife.attack = Math.floor(newWildlife.attack * (0.8 + Math.random() * 0.4));
                    newWildlife.defense = Math.floor(newWildlife.defense * (0.8 + Math.random() * 0.4));
                    newWildlife.maxHealth = newWildlife.health;
                    entities.push(newWildlife);
                }
            } else if (entityTypeRoll < 0.55) {
                npc = generateNPC('Raider');
                npc.x = x; npc.y = y; npc.stunnedTurns = 0;
                npc.aiState = 'wandering'; npc.target = null; npc.investigationTarget = null;
                entities.push(npc);
            } else {
                npc = generateNPC(['Survivor', 'Trader']);
                npc.x = x; npc.y = y; npc.stunnedTurns = 0;
                npc.aiState = 'wandering'; npc.target = null; npc.investigationTarget = null;
                entities.push(npc);
            }
        }
    }

    ensureKnowledgeableTrader();
    
    generateInitialDroppedItems();
    
    turn = 0;
    const seasons = ['æ˜¥', 'å¤', 'ç§‹', 'å†¬'];
    currentSeason = seasons[Math.floor(Math.random() * seasons.length)];
    const startingWeatherIds = Object.keys(weatherTypes);
    const randomStartId = startingWeatherIds[Math.floor(Math.random() * startingWeatherIds.length)];
    currentWeather = { ...weatherTypes[randomStartId], id: randomStartId };
    currentTime = new Date();
    currentTime.setHours(8, 0, 0, 0);
    isNight = false;
 
    player.hunger = Math.floor(maxStats.hunger * (0.6 + Math.random() * 0.3));
    player.thirst = Math.floor(maxStats.thirst * (0.7 + Math.random() * 0.2));
    player.health = Math.floor(maxStats.health * (0.8 + Math.random() * 0.15));
    player.morale = Math.floor(maxStats.morale * (0.4 + Math.random() * 0.4));
    player.sleep = Math.floor(maxStats.sleep * (0.5 + Math.random() * 0.3));
    // â–¼â–¼â–¼ ã“ã®3è¡Œã‚’è¿½åŠ  â–¼â–¼â–¼
    player.bloodLevel = maxStats.bloodLevel;
    player.immuneSystem = maxStats.immuneSystem;
    player.painTolerance = maxStats.painTolerance;
    // â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²
    player.carbs = Math.floor(maxStats.carbs * (0.5 + Math.random() * 0.3));
    player.protein = Math.floor(maxStats.protein * (0.5 + Math.random() * 0.3));
    player.fat = Math.floor(maxStats.fat * (0.5 + Math.random() * 0.3));
    player.vitamins = Math.floor(maxStats.vitamins * (0.5 + Math.random() * 0.3));
    player.research = { completed: [], currentProjectId: null, progress: {} };
    player.bodyTemp = 36.5 + (Math.random() * 0.4 - 0.2);
    player.bodyOdor = 0;
    player.weight = 0;
    player.maxWeight = maxStats.maxWeight;
    player.volume = 0;
    player.maxVolume = maxStats.maxVolume;
    player.vision = maxStats.vision || 2;
    player.inventory = []; player.equipment = []; player.injuries = []; player.sicknesses = [];
    player.baseAttack = 5; player.baseDefense = 5; player.attack = 5; defense: 5;
    
    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â–¼â–¼â–¼
    player.barefootTurns = 0;
    player.nextSoreFeetTurn = -1;
    player.nextInjuredFeetTurn = -1;
    // â–²â–²â–² ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²

    const startingItemPool = jobStartingPools[character.job];
    if (startingItemPool) {
        const itemName = randChoice(startingItemPool);
        const itemTemplate = items.find(i => i.name === itemName);
        if (itemTemplate) {
            const newItem = createItemInstance(itemTemplate);
            player.inventory.push(newItem);
        }
    }
    updateEquippedStats();
    updateExploration();
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’æ–°ã—ãè¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
/**
 * ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«ã€ãƒãƒƒãƒ—å…¨ä½“ã®åœ°é¢ã«ãƒ‰ãƒ­ãƒƒãƒ—ã‚¢ã‚¤ãƒ†ãƒ ã‚’äº‹å‰ç”Ÿæˆã™ã‚‹
 */
function generateInitialDroppedItems() {
    console.log("Initializing dropped items across the map...");
    droppedItems = {}; // æ—¢å­˜ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’ãƒªã‚»ãƒƒãƒˆ

    for (let y = 0; y < mapSize; y++) {
        for (let x = 0; x < mapSize; x++) {
            const tile = map[y][x];
            const locationKey = `${x},${y}`;
            let itemsFound = [];

   const itemReference = {
    stone: items.find(i => i.name === 'çŸ³'), branch: items.find(i => i.name === 'æ'),
    leaf: items.find(i => i.name === 'å¤§ããªè‘‰'), mushroom: items.find(i => i.name === 'ã‚­ãƒã‚³'),
    corn: items.find(i => i.name === 'ãƒˆã‚¦ãƒ¢ãƒ­ã‚³ã‚·'), potato: items.find(i => i.name === 'ã‚¸ãƒ£ã‚¬ã‚¤ãƒ¢'),
    carrot: items.find(i => i.name === 'ãƒ‹ãƒ³ã‚¸ãƒ³'), carrotSeeds: items.find(i => i.name === 'ãƒ‹ãƒ³ã‚¸ãƒ³ã®ç¨®'),
    cabbageSeeds: items.find(i => i.name === 'ã‚­ãƒ£ãƒ™ãƒ„ã®ç¨®'), potatoSeeds: items.find(i => i.name === 'ã‚¸ãƒ£ã‚¬ã‚¤ãƒ¢ã®ç¨®'),
    clothScrap: items.find(i => i.name === 'å¸ƒåˆ‡ã‚Œ'), aloe: items.find(i => i.name === 'ã‚¢ãƒ­ã‚¨'),
    emptyCan: items.find(i => i.name === 'ç©ºãç¼¶'),
    flint: items.find(i => i.name === 'ç«æ‰“çŸ³') // â˜…ã“ã®è¡Œã‚’è¿½åŠ 
  };

// --- è‡ªç„¶ç’°å¢ƒã§ã®ã‚¢ã‚¤ãƒ†ãƒ ç™ºè¦‹ãƒ­ã‚¸ãƒƒã‚¯ ---
if (tile.loc.nameKey === 'location_rock') {
    // çŸ³ã®å‡ºç¾ç¢ºç‡ã‚’95%ã«å¼•ãä¸Šã’ã¾ã™
    if (Math.random() < 0.95) {
        const newStone = { ...itemReference.stone };
        // çŸ³ã«ã‚‚è€ä¹…å€¤ãŒã‚ã‚‹ã®ã§ãƒ©ãƒ³ãƒ€ãƒ åŒ–ã—ã¾ã™
        newStone.durability = Math.floor(Math.random() * 80) + 20;
        itemsFound.push(newStone);
    }
    // æã®å‡ºç¾ç¢ºç‡ã‚’ã€éå¸¸ã«ä½ã„5%ã«è¨­å®šã—ã¾ã™
    if (Math.random() < 0.05) {
        const newBranch = { ...itemReference.branch };
        newBranch.durability = Math.floor(Math.random() * 80) + 20;
        itemsFound.push(newBranch);
    }
    // ä»–ã®ã‚¢ã‚¤ãƒ†ãƒ ã®ç¢ºç‡ã¯å¤‰æ›´ã‚ã‚Šã¾ã›ã‚“
    if (Math.random() < 0.10) itemsFound.push({ ...itemReference.emptyCan });
    if (Math.random() < 0.4) itemsFound.push({ ...itemReference.flint });
} else if (tile.loc.nameKey === 'location_pond') {
    if (Math.random() < 0.20) itemsFound.push({ ...itemReference.emptyCan });
} else if (tile.loc.nameKey === 'location_untilled_field') {
    if (Math.random() < 0.3) itemsFound.push({ ...itemReference.corn });
    if (Math.random() < 0.3) itemsFound.push({ ...itemReference.potato });
    if (Math.random() < 0.3) itemsFound.push({ ...itemReference.carrot });
    if (Math.random() < 0.1) itemsFound.push({ ...itemReference.carrotSeeds });
    if (Math.random() < 0.1) itemsFound.push({ ...itemReference.cabbageSeeds });
    if (Math.random() < 0.1) itemsFound.push({ ...itemReference.potatoSeeds });
    if (Math.random() < 0.4) itemsFound.push({ ...itemReference.branch }); // â˜…è¿½åŠ : ç•‘ã«æ
} else if (tile.biome === 'Forest') {
    if (Math.random() < 0.7) itemsFound.push({ ...itemReference.leaf });
    if (Math.random() < 0.8) itemsFound.push({ ...itemReference.branch }); // â˜…å¤‰æ›´: æã®å‡ºç¾ç‡ã‚’ 0.6 -> 0.8
    if (Math.random() < 0.4) {
    const newStone = { ...itemReference.stone };
    newStone.durability = Math.floor(Math.random() * 80) + 20;
    itemsFound.push(newStone);
}
    if (Math.random() < 0.2) itemsFound.push({ ...itemReference.mushroom });
    if (Math.random() < 0.15) itemsFound.push({ ...itemReference.emptyCan });
} else if (tile.biome === 'Plains') {
    if (Math.random() < 0.4) itemsFound.push({ ...itemReference.leaf });
    if (Math.random() < 0.5) {
    const newBranch = { ...itemReference.branch };
    newBranch.durability = Math.floor(Math.random() * 80) + 20; // è€ä¹…å€¤ã‚’20-99ã«è¨­å®š
    itemsFound.push(newBranch);
}
    if (Math.random() < 0.2) {
    const newStone = { ...itemReference.stone };
    newStone.durability = Math.floor(Math.random() * 80) + 20;
    itemsFound.push(newStone);
}
    if (itemReference.aloe && Math.random() < 0.05) itemsFound.push({ ...itemReference.aloe });
    if (Math.random() < 0.10) itemsFound.push({ ...itemReference.emptyCan });
}

            // --- å…¨ã¦ã®ã‚¿ã‚¤ãƒ«ã§ä½ç¢ºç‡ã§ä¸€èˆ¬çš„ãªã‚¢ã‚¤ãƒ†ãƒ ãŒè¦‹ã¤ã‹ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ ---
            if (Math.random() * 100 < tile.loc.loot) {
                let lootableItems = items.filter(i => (!i.tags || !i.tags.includes(NO_LOOT_TAG)) && i.type !== 'ammo');
                if (lootableItems.length > 0) {
                    let newItem = {...randChoice(lootableItems)};
                    if (newItem.type === 'container') {
                        newItem.content = null;
                    } else if (newItem.type === "consumable" && newItem.freshness !== undefined) {
                        newItem.freshness = Math.max(10, Math.floor(Math.random() * 90) + 10);
                    } else if ((newItem.type === "equipment" || newItem.type === "clothing" || newItem.type === "tool") && newItem.durability !== undefined) {
                        newItem.durability = Math.max(10, Math.floor(Math.random() * 90) + 10);
                    }
                    itemsFound.push(newItem);
                }
            }
            
            if (itemsFound.length > 0) {
                droppedItems[locationKey] = itemsFound;
            }
        }
    }
}
/**
 * æŒ‡å®šã•ã‚ŒãŸã‚¿ã‚¤ãƒ—ã®ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’ãƒãƒƒãƒ—ä¸Šã®ãƒ©ãƒ³ãƒ€ãƒ ãªå®‰å…¨ãªå ´æ‰€ã«ä¸€ä½“ãƒªã‚¹ãƒãƒ¼ãƒ³ã•ã›ã‚‹
 * @param {string} entityType - 'Bear', 'Survivor' ãªã©ã®ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®ã‚¿ã‚¤ãƒ—å
 */
function respawnEntity(entityType) {
    let x, y, attempts = 0;
    const MAX_ATTEMPTS = 500;

    do {
        x = Math.floor(Math.random() * mapSize);
        y = Math.floor(Math.random() * mapSize);
        attempts++;
        if (attempts > MAX_ATTEMPTS) {
            console.error(`${entityType}ã®ãƒªã‚¹ãƒãƒ¼ãƒ³ã«å¤±æ•—ã—ã¾ã—ãŸã€‚å®‰å…¨ãªå ´æ‰€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚`);
            return;
        }
    } while (
        getDistance(player.x, player.y, x, y) < viewportSize || // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¦–ç•Œå†…ã¯é¿ã‘ã‚‹
        entities.some(e => e.x === x && e.y === y) || // ä»–ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®ä¸Šã¯é¿ã‘ã‚‹
        placedObjects.some(p => p.x === x && p.y === y) // è¨­ç½®ç‰©ã®ä¸Šã¯é¿ã‘ã‚‹
    );

    let newEntity;
    const wildlifeTemplate = wildlifeTemplates.find(t => t.type === entityType);
    const npcTemplate = npcTemplates.find(t => t.type === entityType);

    if (wildlifeTemplate) {
        newEntity = { ...JSON.parse(JSON.stringify(wildlifeTemplate)), x, y, aiState: 'wandering', target: null, investigationTarget: null, stance: 'standing', isDodging: false, vulnerableTurns: 0, stunnedTurns: 0, heavyAttackCooldown: 0 };
        newEntity.health = Math.floor(newEntity.health * (0.8 + Math.random() * 0.4));
        newEntity.maxHealth = newEntity.health;
        entities.push(newEntity);
    } else if (npcTemplate) {
        newEntity = generateNPC(entityType);
        newEntity.x = x;
        newEntity.y = y;
        entities.push(newEntity);
    }
}
/**
 * [ãƒ‡ãƒãƒƒã‚°ç”¨] è¦–ç•Œç¯„å›²ã‚’è¨ˆç®—ã—ã€ãã®éç¨‹ã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«å‡ºåŠ›ã™ã‚‹é–¢æ•°
 * @returns {number} - æœ€çµ‚çš„ãªè¦–ç•Œç¯„å›²
 */
// â–¼â–¼â–¼ getVisionRangeé–¢æ•°ã‚’ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function getVisionRange() {
    if (player.isInside || player.isInShelter) return 0;

    let finalVision = player.vision;

    // â˜…ä¿®æ­£ç‚¹ï¼šç‰¹æ€§IDã‚’ "bad_eyesight" ã«ä¿®æ­£
    if (character.traits.includes("bad_eyesight") && player.equipment.some(e => e.name === 'ãƒ¡ã‚¬ãƒ')) {
        finalVision++;
    }

    const hasTorch = player.equipment.some(e => e.isTorch);
    if (!currentTime) return 0;
    const hour = currentTime.getHours();
    const isEvening = hour >= 18 && hour < 21;
    const isDeepNight = hour >= 21 || hour < 6;

    if (isDeepNight) {
        let nightVision = 0;
        if (hasTorch) nightVision = Math.max(nightVision, 1);
        // â˜…ä¿®æ­£ç‚¹ï¼šç‰¹æ€§IDã‚’ "good_eyesight" ã«ä¿®æ­£
        if (character.traits.includes("good_eyesight")) nightVision = Math.max(nightVision, 1);
        finalVision = nightVision;

        if (finalVision === 0) return 0;

    } else if (isEvening) {
        finalVision = Math.max(1, finalVision - 3);
    }

    if (player.vitamins < 25) {
        finalVision = Math.max(0, finalVision - 1);
    }

    // â˜…ä¿®æ­£ç‚¹ï¼šcurrentWeather.name ã§ã¯ãªã currentWeather.id ã§åˆ¤å®šã™ã‚‹ã‚ˆã†ã«å¤‰æ›´
    if (!currentWeather || !currentWeather.id) return 0;
    if (currentWeather.id === 'rainy') finalVision *= 0.75;
    if (currentWeather.id === 'stormy') finalVision *= 0.5;

    return Math.max(0, Math.round(finalVision));
}
// â–²â–²â–² ç½®ãæ›ãˆã“ã“ã¾ã§ â–²â–²â–²

function getEntityVisionRange(entity) {
    let baseVision;
    const hour = currentTime.getHours();

    const isEvening = hour >= 18 && hour < 21;
    const isDeepNight = hour >= 21 || hour < 6;
    const isMorning = hour >= 6 && hour < 8;
    const isDay = hour >= 8 && hour < 18;

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãã®æ™‚é–“å¸¯ã§ã®åŸºæœ¬è¦–é‡ã‚’ã¾ãšè¨ˆç®—
    let playerCurrentVision;
    const hasTorch = player.equipment.some(e => e.isTorch);
    if (isMorning) {
        playerCurrentVision = 3;
    } else if (isDay) {
        playerCurrentVision = 3;
    } else if (isEvening) {
        playerCurrentVision = 1;
    } else { // isDeepNight
        playerCurrentVision = 0;
        if (hasTorch) playerCurrentVision = 1;
        if (character.traits.includes("ç›®ãŒã„ã„")) playerCurrentVision = Math.max(playerCurrentVision, 1);
    }
    
    if (entity.isAnimal) {
        // é‡ç”Ÿå‹•ç‰©ã¯å¸¸ã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¦–ç•Œ+1
        baseVision = playerCurrentVision + 1;
    } else { 
        // NPCã¨ã‚¾ãƒ³ãƒ“ã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¦–ç•Œã¨åŒã˜
        baseVision = playerCurrentVision;
        if (isDeepNight) {
            const hasGoodEyesight = entity.traits && entity.traits.includes("ç›®ãŒã„ã„");
            if (hasGoodEyesight) {
                baseVision = Math.max(baseVision, 1);
            }
        }
    }
    
    if (currentWeather.name === 'é›¨') baseVision *= 0.75;
    if (currentWeather.name === 'åµ') baseVision *= 0.5;

    return Math.max(0, Math.round(baseVision));
}


// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function updateExploration() {
    const visionRange = getVisionRange();
    const FOV = 90; // Field of View: 90åº¦ã®æ‰‡å½¢

    for (let y = Math.max(0, player.y - visionRange); y <= Math.min(mapSize - 1, player.y + visionRange); y++) {
        for (let x = Math.max(0, player.x - visionRange); x <= Math.min(mapSize - 1, player.x + visionRange); x++) {
            const distance = Math.sqrt(Math.pow(player.x - x, 2) + Math.pow(player.y - y, 2));
            if (distance <= visionRange) {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰ã‚¿ã‚¤ãƒ«ã¸ã®è§’åº¦ã‚’è¨ˆç®—
                let angleToTile = Math.atan2(y - player.y, x - player.x) * 180 / Math.PI;
                // JavaScriptã®è§’åº¦(ä¸ŠãŒ-90)ã‚’CSSã®è§’åº¦(ä¸ŠãŒ0)ã«å¤‰æ›
                angleToTile = (angleToTile + 450) % 360;

                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘ãã¨ã‚¿ã‚¤ãƒ«ã¸ã®è§’åº¦ã®å·®ã‚’è¨ˆç®— (360åº¦ã®ãƒ©ãƒƒãƒ—ã‚¢ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’è€ƒæ…®)
                let angleDiff = Math.abs(angleToTile - player.direction);
                if (angleDiff > 180) {
                    angleDiff = 360 - angleDiff;
                }

                // è§’åº¦ã®å·®ãŒè¦–é‡è§’ã®åŠåˆ†ä»¥å†…ã‹ãƒã‚§ãƒƒã‚¯
                if (angleDiff <= FOV / 2) {
                    if (hasLineOfSight(player.x, player.y, x, y) && !map[y][x].explored) {
                        map[y][x].explored = true;
                        if(x === salvationCityCoords.x && y === salvationCityCoords.y && !salvationCityDiscovered) {
                            salvationCityDiscovered = true; playSound('victory'); log(getString("log_salvation_city_discovered"));
                        }
                    }
                }
            }
        }
    }
    if (isNight) {
        const campfire = placedObjects.find(obj => obj.type === 'campfire' && Math.abs(player.x - obj.x) <= 1 && Math.abs(player.y - obj.y) <= 1);
        if (campfire) {
            for (let y = Math.max(0, campfire.y - 1); y <= Math.min(mapSize - 1, campfire.y + 1); y++) {
                for (let x = Math.max(0, campfire.x - 1); x <= Math.min(mapSize - 1, campfire.x + 1); x++) {
                    map[y][x].explored = true;
                }
            }
        }
    }
}

function triggerRandomEvent() {
    const movementMode = player.movementMode;

    if (movementMode === 'run') {
        // èµ°è¡Œæ™‚: 25%ã®ç¢ºç‡ã§ã‚¤ãƒ™ãƒ³ãƒˆç™ºç”Ÿ
        if (Math.random() < 0.05) {
            // ã•ã‚‰ã«ã€ãã®ä¸­ã§25%ãŒã‚¢ã‚¤ãƒ†ãƒ ç´›å¤±ã€75%ãŒè£…å‚™ç ´æ
            if (Math.random() < 0.25) {
                event_loseItem(); // ã‚¢ã‚¤ãƒ†ãƒ ã‚’è½ã¨ã™ã‚¤ãƒ™ãƒ³ãƒˆ
            } else {
                event_damageEquipment(); // ã‚¢ã‚¤ãƒ†ãƒ ã®è€ä¹…å€¤ãŒä¸‹ãŒã‚‹ã‚¤ãƒ™ãƒ³ãƒˆ
            }
        }
    } else if (movementMode === 'walk') {
        // æ­©è¡Œæ™‚: 3%ã®ç¢ºç‡ã§è£…å‚™ç ´æã‚¤ãƒ™ãƒ³ãƒˆã®ã¿ç™ºç”Ÿ
        if (Math.random() < 0.01) {
            event_damageEquipment();
        }
    }
    // ãã®ä»–ã®ç§»å‹•ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã‚¤ãƒ™ãƒ³ãƒˆã¯ç™ºç”Ÿã—ãªã„
}

function event_loseItem() {
    // æ‰€æŒå“ãŒãªã„å ´åˆã¯ä½•ã‚‚ã—ãªã„
    if (player.inventory.length === 0) {
        return;
    }
    // æ‰€æŒå“ã®ä¸­ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ãªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’é¸ã¶
    const itemIndex = Math.floor(Math.random() * player.inventory.length);
    const lostItem = player.inventory[itemIndex];

    // é¸ã°ã‚ŒãŸã‚¢ã‚¤ãƒ†ãƒ ã‚’æ‰€æŒå“ã‹ã‚‰å‰Šé™¤
    player.inventory.splice(itemIndex, 1);

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é‡é‡ã¨å®¹é‡ã‚’æ›´æ–°
    player.weight -= lostItem.weight || 0;
    player.volume -= lostItem.volume || 0;

    const eventMessage = `ç§»å‹•ä¸­ã«ä½•ã‹ã‚’è½ã¨ã—ã¦ã—ã¾ã£ãŸã‚ˆã†ã ...ï¼<span style="color: indianred;">ï¼ˆ${getItemDisplayName(lostItem)}ã‚’ç´›å¤±ï¼‰</span>`;
    log(eventMessage, true);
    showModal(eventMessage); // Pop-up is displayed
    updateItemPanels();
    updateStatus();
}
function event_damageEquipment() {
    // è£…å‚™å“ã¨æ‰€æŒå“ã®ä¸­ã‹ã‚‰ã€è€ä¹…åº¦ã‚’æŒã¤ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã™ã¹ã¦ãƒªã‚¹ãƒˆã‚¢ãƒƒãƒ—
    const damageableItems = [...player.equipment, ...player.inventory].filter(item => 
        item.durability !== undefined && 
        (item.type === 'clothing' || item.type === 'equipment') &&
        item.slot !== 'weapon'
    );
    
    // å¯¾è±¡ã‚¢ã‚¤ãƒ†ãƒ ãŒãªã„å ´åˆã¯ä½•ã‚‚ã—ãªã„
    if (damageableItems.length === 0) {
        return;
    }

    // â–¼â–¼â–¼ ã‚µã‚¦ãƒ³ãƒ‰å†ç”Ÿã‚’è¿½åŠ  â–¼â–¼â–¼
    playSoundFile('sounds/branch_snag.wav');
    // â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²

    // å¯¾è±¡ã‚¢ã‚¤ãƒ†ãƒ ã®ä¸­ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«1ã¤é¸ã¶
    const targetItem = randChoice(damageableItems);
    const damageAmount = Math.floor(Math.random() * 30) + 20; // 20ã‹ã‚‰49ã®ãƒ€ãƒ¡ãƒ¼ã‚¸
const wasDestroyed = reduceItemDurability(targetItem, damageAmount, true); // trueã§ç ´å£Šæ™‚ã®è‡ªå‹•ãƒ­ã‚°ã‚’æŠ‘åˆ¶

let eventMessage;
if (wasDestroyed) {
    // ç ´å£Šã•ã‚ŒãŸå ´åˆã¯ã€ã‚ˆã‚Šå…·ä½“çš„ãªã‚¤ãƒ™ãƒ³ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ãƒ­ã‚°ã«å‡ºåŠ›
    eventMessage = getString("log_event_equip_damage_break", { itemName: getBaseItemName(targetItem) });
} else {
    // ç ´æã—ãŸãŒç ´å£Šã•ã‚Œãªã‹ã£ãŸå ´åˆã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
    eventMessage = getString("log_event_equip_damage_minor", { itemName: getBaseItemName(targetItem) });
}

log(eventMessage, true);
showModal(eventMessage);
}
function handleTileClick(targetX, targetY) {
    if (isStunnedByPain()) { return; } // â˜…â˜…â˜… ã“ã®è¡Œã‚’è¿½åŠ  â˜…â˜…â˜…
    closeWorkbenchPanel();
    if (isInteractionActive || targetingState.active) {
        if (targetingState.active) handleTargetingClick(targetX, targetY);
        return;
    }

    if (player.isInside || player.isInShelter) {
        if (turn > 0) interruptAndClearSpeech();
        const locationName = player.isInside ? getString("location_cabin") : getString("item_æ‰‹ä½œã‚Šã‚·ã‚§ãƒ«ã‚¿ãƒ¼_name");
        log(getString("log_movement_fail_exit_required"));
        processSpeechQueue();
        return;
    }

    const dx = targetX - player.x;
    const dy = targetY - player.y;
    const dist = Math.max(Math.abs(dx), Math.abs(dy));

    if (player.movementMode && player.movementMode.trim() === 'walk') {
        if (dist === 0) {
            if (turn > 0) interruptAndClearSpeech();
            const placedObject = placedObjects.find(p => p.x === player.x && p.y === player.y);
            if (placedObject) {
                if (placedObject.type === 'wooden_box') openStoragePanel(placedObject);
                else showPlacedObjectDetail(placedObject);
            } else {
                speakAndConfirm(getString("confirm_wait_turn"), waitOneTurn);
            }
            return;
        }

        if (dist !== 1) {
            if (turn > 0) interruptAndClearSpeech();
            log(getString("log_walk_mode_error"));
            processSpeechQueue();
            return;
        }

        // â–¼â–¼â–¼ ä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
        // ã“ã®å ´æ‰€ã«ã‚ã£ãŸ interruptAndClearSpeech(); ã®å‘¼ã³å‡ºã—ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚
        let targetAngle = (Math.atan2(dy, dx) * 180 / Math.PI + 450) % 360;

        if (player.direction !== targetAngle) {
            // 1å›ç›®ã®ã‚¯ãƒªãƒƒã‚¯ï¼šæ–¹å‘è»¢æ›ã®ã¿ã€‚ã“ã“ã§ã¯èª­ã¿ä¸Šã’ã‚’ä¸­æ–­ã—ãªã„ã€‚
            player.direction = targetAngle;
            updatePlayerDirectionArrow();
            updateExploration();
            drawMap();
            drawMinimap();
        } else {
            // 2å›ç›®ã®ã‚¯ãƒªãƒƒã‚¯ï¼šç§»å‹•å‡¦ç†ã€‚ã“ã“ã§åˆã‚ã¦èª­ã¿ä¸Šã’ã‚’ä¸­æ–­ã™ã‚‹ã€‚
            if (turn > 0) interruptAndClearSpeech(); 

            const barricade = placedObjects.find(o => o.x === targetX && o.y === targetY && o.type === 'barricade' && o.health > 0);
            if (barricade) {
                log(getString("log_barricade_blocks"));
                processSpeechQueue();
                return;
            }

            closeExplorationPanel();
            snapshotStats();
            player.x = targetX;
            player.y = targetY;
            
            playSoundFile('sounds/walk.wav', 0.6);
            
            map[player.y][player.x].explored = true;

            updateExploration();
            createSound(targetX, targetY, 2);
            
            if (player.x === salvationCityCoords.x && player.y === salvationCityCoords.y) {
                triggerGameClear();
                return;
            }
exploreTile();
triggerRandomEvent();

const isBarefoot = !player.equipment.some(e => e.slot === 'feet');
if (isBarefoot) {
    player.barefootTurns = (player.barefootTurns || 0) + 1;
}

const hasInjuredFeet = player.injuries.some(i => i.type === 'injured_feet');
const hasFracture = player.injuries.some(i => i.type === 'fracture'); // â˜…è¿½åŠ : éª¨æŠ˜ã—ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯

endPlayerTurn(); // â˜…â˜…â˜… ã“ã®è¡Œã‚’å¤‰æ›´ â˜…â˜…â˜…
            if (hasInjuredFeet) {
                // è¶³ã«æ€ªæˆ‘ã‚’è² ã£ã¦ã„ã‚‹å ´åˆã€è¿½åŠ ã®ã‚¿ãƒ¼ãƒ³æ¶ˆè²»ã¯checkStatsã§å‡¦ç†ã™ã‚‹ã®ãŒæœ›ã¾ã—ã„ã§ã™ãŒã€
                // ã“ã“ã§ã¯å˜ç´”åŒ–ã®ãŸã‚ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã—ã¾ã™ã€‚å¿…è¦ã«å¿œã˜ã¦ãƒ­ã‚¸ãƒƒã‚¯ã‚’å†è¨­è¨ˆã—ã¾ã™ã€‚
                // advanceTurn(); 
            }

            if (hasFracture) {
                log(getString("log_fracture_move_slow"));
                // éª¨æŠ˜ã«ã‚ˆã‚‹è¿½åŠ ã‚¿ãƒ¼ãƒ³ã‚‚åŒæ§˜ã«ã€ä¸€æ—¦ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã—ã¾ã™ã€‚
                // advanceTurn();
            }

updateTurnInfo();
            drawMap();
            drawMinimap();
            updateStatus();
            updateItemPanels();
            updateCharacterBody();
            updateCharacterInfo();
            checkGameOver();
            processSpeechQueue();
        }
        // â–²â–²â–² ä¿®æ­£ã“ã“ã¾ã§ â–²â–²â–²
        return;
    }

    // --- èµ°è¡Œãƒ¢ãƒ¼ãƒ‰ ---
    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰3è¡Œã‚’è¿½åŠ  â–¼â–¼â–¼
    if (player.injuries.some(i => i.type === 'injured_feet')) {
        log(getString("log_feet_injured_cant_run"));
        return;
    }
    if (dist === 0) {
        if (turn > 0) interruptAndClearSpeech();
        speakAndConfirm(getString("confirm_wait_turn"), waitOneTurn);
        return;
    }
    
    if (dist === 1) {
        let targetAngle = (Math.atan2(dy, dx) * 180 / Math.PI + 450) % 360;
        if (player.direction !== targetAngle) {
            player.direction = targetAngle;
            updatePlayerDirectionArrow();
            updateExploration();
            drawMap();
            drawMinimap();
        }
        return;
    }

    if (dist === 2) {
        if (turn > 0) interruptAndClearSpeech();
        const isStraightLineRun = (Math.abs(dx) === 2 && dy === 0) || (dx === 0 && Math.abs(dy) === 2) || (Math.abs(dx) === 2 && Math.abs(dy) === 2);
        if (!isStraightLineRun) {
            log(getString("log_run_mode_error"));
            processSpeechQueue();
            return;
        }
            
        // â–¼â–¼â–¼ å¤‰æ›´ç®‡æ‰€ï¼šã“ã“ã‹ã‚‰6è¡Œã‚’ä¿®æ­£ â–¼â–¼â–¼
        let angleToTile = (Math.atan2(dy, dx) * 180 / Math.PI + 450) % 360;
        
        if (angleToTile !== player.direction) {
            log(getString("log_run_direction_mismatch")); // æ–°ã—ã„ãƒ­ã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚­ãƒ¼ï¼ˆå¾Œã§è¿½åŠ ã—ã¾ã™ï¼‰
            processSpeechQueue();
            return;
        }
        // â–²â–²â–² å¤‰æ›´ã“ã“ã¾ã§ â–²â–²â–²

        const midX = player.x + Math.sign(targetX - player.x);
        const midY = player.y + Math.sign(targetY - player.y);
        const blockingEntity = entities.find(e => e.x === midX && e.y === midY);

        if (blockingEntity) {
            const entityName = getString(`item_${blockingEntity.name}_name`) || blockingEntity.name;
            log(getString("log_run_blocked_by_entity", { entityName: entityName }));
            processSpeechQueue();
            return;
        }
        
        isInteractionActive = true;
        closeExplorationPanel();
        
        player.x = midX;
        player.y = midY;
        drawMap();
        
        setTimeout(() => {
            map[midY][midX].explored = true;

            player.x = targetX;
            player.y = targetY;
            
            playSoundFile('sounds/run.wav', 0.8);
            
            map[player.y][player.x].explored = true;

            drawMap();
            isInteractionActive = false;
            snapshotStats();
            player.hunger -= 2;
            player.thirst -= 4;
            createSound(targetX, targetY, 8);
            log(getString("log_moved_run"));

            if (player.x === salvationCityCoords.x && player.y === salvationCityCoords.y) {
                triggerGameClear();
                return;
            }
            exploreTile();
            triggerRandomEvent();
            endPlayerTurn(); // â˜…â˜…â˜… ã“ã®è¡Œã‚’å¤‰æ›´ â˜…â˜…â˜…
            updateTurnInfo();
            drawMinimap();
            updateStatus();
            updateItemPanels();
            updateCharacterBody();
            updateCharacterInfo();
            checkGameOver();
            processSpeechQueue();
        }, 150);

    } else {
        if (turn > 0) interruptAndClearSpeech();
        log(getString("log_run_mode_error"));
        processSpeechQueue();
    }
}
function isStunnedByPain() {
    if (player.painStunSchedule.includes(player.painStunCycle)) {
        // ... (çœç•¥) ...
        
        const message = getString("log_pain_stun");
        log(message, true);
        
        // â˜…â˜…â˜…ã“ã“ãŒä¿®æ­£ç®‡æ‰€ã§ã™â˜…â˜…â˜…
        // OKãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚ŒãŸã‚‰ã€æ–°ã—ã„ stunAndAdvanceTurn é–¢æ•°ã‚’å®Ÿè¡Œã™ã‚‹ã‚ˆã†ã«å¤‰æ›´
        showModal(message, stunAndAdvanceTurn);
        
        return true; // è¡Œå‹•ä¸èƒ½ãŒç™ºç”Ÿã—ãŸã“ã¨ã‚’ç¤ºã™
    }
    return false; // è¡Œå‹•ä¸èƒ½ã¯ç™ºç”Ÿã—ãªã‹ã£ãŸ
}
function updatePlayerDirectionArrow() {
    const arrow = document.getElementById('playerDirectionArrow');
    if (arrow) {
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘ãã«åˆã‚ã›ã¦çŸ¢å°ã‚’å›è»¢ã•ã›ã‚‹
        arrow.style.transform = `translate(-50%, -100%) rotate(${player.direction}deg)`;
        arrow.style.opacity = '1'; // çŸ¢å°ã‚’è¡¨ç¤º
    }
}
// â–¼â–¼â–¼ ä»¥ä¸‹ã®æ–°ã—ã„é–¢æ•°ã‚’ <script> ã‚¿ã‚°å†…ã«ä¸¸ã”ã¨è¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
function takePainkiller(item, itemIndex, source) {
    snapshotStats();
    
    // ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ¶ˆè²»
    const sourceArray = source === 'inventory' ? player.inventory : droppedItems[`${player.x},${player.y}`];
    const removedItem = sourceArray.splice(itemIndex, 1)[0];
    if (source === 'inventory') {
        player.weight -= removedItem.weight || 0;
        player.volume -= removedItem.volume || 0;
    }

    // åŠ¹æœã‚’é©ç”¨ï¼ˆåŠ¹æœã¯3ã‚¿ãƒ¼ãƒ³æŒç¶šï¼‰
    player.painkillerEffectTurns = 3; 

    log(getString("log_took_painkiller"), true);
    
    // UIã‚’æ›´æ–°
    hideItemDetail();
    updateItemPanels();
    updateStatus();
    processSpeechQueue();
}
function drawMap() {
    if (!map || map.length === 0 || !player) return;
    
    updatePlayerDirectionArrow();

    // â–¼â–¼â–¼ ã“ã®2è¡Œã‚’æ–°ã—ãè¿½åŠ  â–¼â–¼â–¼
    const labelsContainer = document.getElementById('dev-arrow-labels');
    const labels = [];
    // â–²â–²â–² è¿½åŠ ã¯ã“ã“ã¾ã§ â–²â–²â–²
    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â–¼â–¼â–¼
    const scsArrow = document.getElementById('salvationCityArrow');
    const npcArrow = document.getElementById('npcHintArrow');
    const showSCS = document.getElementById('devShowSCSArrow')?.checked;
    const showNPC = document.getElementById('devShowNPCHintArrow')?.checked;

    // ã‚µãƒ«ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ã‚·ãƒ†ã‚£ã¸ã®çŸ¢å°
    if (showSCS && salvationCityCoords.x !== -1) {
        let angle = (Math.atan2(salvationCityCoords.y - player.y, salvationCityCoords.x - player.x) * 180 / Math.PI + 450) % 360;
        scsArrow.style.transform = `translate(-50%, -100%) rotate(${angle}deg)`;
        scsArrow.style.display = 'block';

        const distance = Math.round(getDistance(player.x, player.y, salvationCityCoords.x, salvationCityCoords.y));
        labels.push(`<span style="color:yellow;">â– </span> ${getString('location_salvation_city')}: ${getString('dev_arrow_distance_prefix')}${distance}${getString('dev_arrow_distance_suffix')}`);
        
    } else {
        scsArrow.style.display = 'none';
    }

    // ãƒ’ãƒ³ãƒˆNPCã¸ã®çŸ¢å°
    const hintNPC = entities.find(e => e.knowsSalvationCity);
    if (showNPC && hintNPC) {
        let angle = (Math.atan2(hintNPC.y - player.y, hintNPC.x - player.x) * 180 / Math.PI + 450) % 360;
        npcArrow.style.transform = `translate(-50%, -100%) rotate(${angle}deg)`;
        npcArrow.style.display = 'block';

        const distance = Math.round(getDistance(player.x, player.y, hintNPC.x, hintNPC.y));
        labels.push(`<span style="color:cyan;">â– </span> ${getString('dev_arrow_npc_hint')}: ${getString('dev_arrow_distance_prefix')}${distance}${getString('dev_arrow_distance_suffix')}`);

    } else {
        npcArrow.style.display = 'none';
    }

    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒæ–°ã—ã„æ©Ÿèƒ½ã®è¿½åŠ éƒ¨åˆ†ã§ã™ â–¼â–¼â–¼
    
    // æŒ‡å®šã•ã‚ŒãŸç¨®é¡ã®æ–½è¨­ã§æœ€ã‚‚è¿‘ã„å ´æ‰€ã‚’æ¢ã™ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
    function findNearestLocation(checkFunction) {
        let nearest = null;
        let minDistance = Infinity;
        for (let y = 0; y < mapSize; y++) {
            for (let x = 0; x < mapSize; x++) {
                if (checkFunction(map[y][x])) {
                    const distance = getDistance(player.x, player.y, x, y);
                    if (distance > 0 && distance < minDistance) {
                        minDistance = distance;
                        nearest = { x, y };
                    }
                }
            }
        }
        return nearest;
    }

    // å„çŸ¢å°ã®è¨­å®š
    const arrowConfigs = [
        { id: 'residentialArrow', color: '#2ecc71', nameKey: 'dev_arrow_residential', checkId: 'devShowResidentialArrow', checkFunc: tile => tile.biome === 'Residential' },
        { id: 'commercialArrow',  color: '#3498db', nameKey: 'dev_arrow_commercial',  checkId: 'devShowCommercialArrow',  checkFunc: tile => tile.biome === 'Commercial' },
        { id: 'industrialArrow',  color: '#9b59b6', nameKey: 'dev_arrow_industrial',  checkId: 'devShowIndustrialArrow',  checkFunc: tile => tile.biome === 'Industrial' },
        { id: 'cabinArrow',       color: '#e67e22', nameKey: 'dev_arrow_cabin',       checkId: 'devShowCabinArrow',       checkFunc: tile => tile.loc.nameKey === 'location_cabin' },
        { id: 'traderShopArrow',  color: '#f1c40f', nameKey: 'dev_arrow_trader_shop', checkId: 'devShowTraderShopArrow', checkFunc: tile => tile.loc.isShop === true }
    ];

    arrowConfigs.forEach(config => {
        const arrow = document.getElementById(config.id);
        const checkbox = document.getElementById(config.checkId);
        if (!arrow || !checkbox) return;

        if (checkbox.checked) {
            const coords = findNearestLocation(config.checkFunc);
            if (coords) {
                let angle = (Math.atan2(coords.y - player.y, coords.x - player.x) * 180 / Math.PI + 450) % 360;
                arrow.style.transform = `translate(-50%, -100%) rotate(${angle}deg)`;
                arrow.style.display = 'block';

                const distance = Math.round(getDistance(player.x, player.y, coords.x, coords.y));
                labels.push(`<span style="color:${config.color};">â– </span> ${getString(config.nameKey)}: ${getString('dev_arrow_distance_prefix')}${distance}${getString('dev_arrow_distance_suffix')}`);

            } else {
                arrow.style.display = 'none';
            }
        } else {
            arrow.style.display = 'none';
        }
    });
    // â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ–°ã—ãè¿½åŠ  â–¼â–¼â–¼
    // labelsé…åˆ—ã«ä½•ã‹è¿½åŠ ã•ã‚Œã¦ã„ãŸã‚‰ã€ã‚³ãƒ³ãƒ†ãƒŠã‚’è¡¨ç¤ºã—ã¦å†…å®¹ã‚’æ›¸ãå‡ºã™
    if (labels.length > 0) {
        labelsContainer.innerHTML = labels.join('<br>');
        labelsContainer.style.display = 'block';
    } else {
        labelsContainer.style.display = 'none';
    }

    mapIconIntervals.forEach(clearInterval);
    mapIconIntervals = [];

    const mapDiv = document.getElementById("map");
    mapDiv.style.gridTemplateColumns = `repeat(${viewportSize}, 40px)`;
    mapDiv.innerHTML = "";
    const halfView = Math.floor(viewportSize / 2),
        startX = player.x - halfView,
        startY = player.y - halfView;
        
    for (let yOffset = 0; yOffset < viewportSize; yOffset++) {
        for (let xOffset = 0; xOffset < viewportSize; xOffset++) {
            const x = startX + xOffset,
                y = startY + yOffset;
            let div = document.createElement("div");
            div.className = "tile";
            
            if (x < 0 || y < 0 || x >= mapSize || y >= mapSize) {
                div.classList.add("unexplored");
                div.style.background = "#111";
                mapDiv.appendChild(div);
                continue;
            }
            
            const tile = map[y][x];
            const isPlayerOnTile = (player.x === x && player.y === y);

            if (targetingState.active && getDistance(player.x, player.y, x, y) <= targetingState.range) {
                if (hasLineOfSight(player.x, player.y, x, y)) {
                    div.classList.add("targeting");
                }
            }

            if (tile.explored) {
                const visionRange = getVisionRange();
                const FOV = 90;
                const distance = getDistance(player.x, player.y, x, y);
                let angleToTile = (Math.atan2(y - player.y, x - player.x) * 180 / Math.PI + 450) % 360;
                let angleDiff = Math.abs(angleToTile - player.direction);
                if (angleDiff > 180) angleDiff = 360 - angleDiff;
                
                const isInFOV = angleDiff <= FOV / 2;
                const isInSight = (distance <= visionRange && isInFOV && hasLineOfSight(player.x, player.y, x, y)) || isPlayerOnTile;

                if (isInSight) {
                    div.classList.add("explored");
                    if (tile.loc.nameKey === 'location_road') div.classList.add('road-tile');
                    
                    const entityOnTile = entities.find(e => e.x === x && e.y === y);
                    const placedObjectsOnTile = placedObjects.filter(c => c.x === x && c.y === y);

                    div.innerHTML = ''; 
                    const htmlElements = [];
                    htmlElements.push(`<img src="${tile.loc.icon}" class="tile-img tile-terrain" style="width:40px; height:40px;">`);

               if (entityOnTile) {
                        // â˜…â˜…â˜…ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™â˜…â˜…â˜…
                        let entityClass = "tile-img tile-entity";
                        if (entityOnTile.justMoved) {
                        console.log("ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¯ãƒ©ã‚¹é©ç”¨:", entityOnTile.name); // ã“ã®ãƒ­ã‚°ãŒå‡ºåŠ›ã•ã‚Œã‚‹ã‹ç¢ºèª
                            entityClass += " entity-move-animation";
                        }
                        htmlElements.push(`<img src="${entityOnTile.icon}" class="${entityClass}" style="width:40px; height:40px;">`);
                        // â˜…â˜…â˜…ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™â˜…â˜…â˜…
                    }
                    
                    placedObjectsOnTile.forEach(pObj => {
                        if (pObj.graphic) {
                            let objectStyle = 'width:40px; height:40px;';
                            if (pObj.type === 'unlit_campfire') {
                                objectStyle += 'filter: grayscale(1); opacity: 0.8;';
                            }
                            htmlElements.push(`<img src="${pObj.graphic}" class="tile-img tile-object" style="${objectStyle}">`);
                        }
                    });

                    div.innerHTML = htmlElements.join('');

                    const showCombinedTooltip = (e) => {
                        const preview = document.getElementById("statusPreview");
                        let contentHtml = '';

                        contentHtml += `<strong>${getString(tile.loc.nameKey)}</strong>`;
                        if (tile.loc.blocksVision) {
                            contentHtml += `<div style="color: indianred; font-size: 0.9em;">(${getString("info_blocks_vision")})</div>`;
                        }

                        if (entityOnTile) {
                            const entityName = getString(`item_${entityOnTile.name}_name`) || entityOnTile.name;
                            contentHtml += `<div style='border-top: 1px solid #555; margin-top:5px; padding-top:5px;'><strong>${entityName}</strong><br/>${getString("tooltip_entity_health")}: ${entityOnTile.health.toFixed(0)}`;
                            
                            let awarenessText = '';
                            let awarenessColor = '';
                            switch (entityOnTile.aiState) {
                                case 'attacking':
                                    if (entityOnTile.target === player) {
                                        awarenessText = getString("tooltip_awareness_hostile");
                                        awarenessColor = '#e74c3c';
                                    } else {
                                        awarenessText = getString("tooltip_awareness_unaware");
                                        awarenessColor = '#95a5a6';
                                    }
                                    break;
                                case 'investigating':
                                    awarenessText = getString("tooltip_awareness_investigating");
                                    awarenessColor = '#f1c40f';
                                    break;
                                case 'fleeing':
                                    awarenessText = getString("tooltip_awareness_fleeing");
                                    awarenessColor = '#3498db';
                                    break;
                                default:
                                    awarenessText = getString("tooltip_awareness_unaware");
                                    awarenessColor = '#27ae60';
                                    break;
                            }
                            contentHtml += `<br/>${getString("tooltip_awareness_label")}: <span style="color: ${awarenessColor}; font-weight: bold;">${awarenessText}</span>`;
                            
                            if (!entityOnTile.isZombie && !entityOnTile.isAnimal && entityOnTile.equipment && entityOnTile.equipment.length > 0) {
                                contentHtml += `<br/>${getString("combat_equipment")}: `;
                                const equipmentNames = entityOnTile.equipment.map(eq => `${getIconHTML(eq.graphic, 12)} ${getBaseItemName(eq)}`).join(', ');
                                contentHtml += equipmentNames;
                            }
                            contentHtml += `</div>`;
                        }

                        // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â–¼â–¼â–¼
                        placedObjectsOnTile.forEach(pObj => {
                            const objectName = getPlacedObjectDisplayName(pObj);
                            contentHtml += `<div style='border-top: 1px solid #555; margin-top:5px; padding-top:5px;'><strong>${objectName}</strong>`;
                            if (pObj.type === 'barricade') {
                                 contentHtml += `<br/>${getString("combat_health")}: ${pObj.health.toFixed(0)} / ${pObj.maxHealth.toFixed(0)}`;
                            } else if (pObj.type === 'campfire') {
                                 contentHtml += `<br/>${getString("info_remaining_turns_compact", { duration: pObj.duration })}`;
                            } else if (pObj.isAnimalCorpse) {
                                contentHtml += `<br/>${pObj.unbutchered ? getString("tooltip_corpse_animal_unbutchered") : getString("tooltip_corpse_animal_butchered")}`;
                            } else if (pObj.isHumanCorpse) {
                                contentHtml += `<br/>${pObj.unsearched ? getString("tooltip_corpse_human_unsearched") : getString("tooltip_corpse_human_searched")}`;
                            }
                            contentHtml += `</div>`;
                        });
                        // â–²â–²â–² ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²

                        if (isPlayerOnTile) {
                            contentHtml += `<div style='border-top: 1px solid #555; margin-top:5px; padding-top:5px;'><strong>${getString("you")}</strong><br/>${getString(character.fullNameKey)}</div>`;
                        }
                        
                        preview.innerHTML = contentHtml;
                        preview.style.display = 'block';
                        updatePreviewPosition(e);
                    };

                    div.addEventListener('mouseenter', showCombinedTooltip);
                    div.addEventListener('mouseleave', hideStatusPreview);
                    div.addEventListener('mousemove', (e) => updatePreviewPosition(e));

                } else {
                    div.classList.add("memorized-tile");
                    const memorableObjectTypes = ['shelter', 'sleeping_bag', 'campfire', 'unlit_campfire', 'wooden_box', 'barricade', 'workbench', 'tilled_field', 'junk_research_bench', 'drying_rack', 'bear_trap_armed', 'bear_trap_sprung'];
                    const memorableObject = placedObjects.find(p => p.x === x && p.y === y && memorableObjectTypes.includes(p.type));

                    if (memorableObject) {
                        div.innerHTML = getIconHTML(memorableObject.graphic, 40);
                        div.title = `${getPlacedObjectDisplayName(memorableObject)} (${getString("info_memorized")})`;
                    } else {
                        div.innerHTML = getIconHTML(tile.loc.icon, 40);
                        div.title = `${getString(tile.loc.nameKey)} (${getString("info_memorized")})`;
                    }
                }

            } else {
                div.classList.add("unexplored");
                div.textContent = "?";
                div.title = getString("info_unexplored");
            }
            
            div.addEventListener("click", () => handleTileClick(x, y));
            mapDiv.appendChild(div);
        }
    }

    const playerTile = mapDiv.children[Math.floor(viewportSize * viewportSize / 2)];
    if (playerTile) {
        playerTile.classList.add("player-tile");
        const playerIconPath = (character.gender === "gender_male") ? "images/player_male.png" : "images/player_female.png";
        
        playerTile.insertAdjacentHTML('beforeend', `<img src="${playerIconPath}" class="tile-img tile-player" style="width:40px; height:40px;">`);
    }
}
function updatePlayerSmell() {
    let totalSmell = 0;

    // 1. æ‰€æŒå“ã«ã‚ˆã‚‹è‡­ã„
    const smellyItems = [...player.inventory, ...player.equipment].filter(item => item.smell);
    if (smellyItems.length > 0) {
        totalSmell += smellyItems.reduce((sum, item) => sum + item.smell, 0);
    }

    // 2. çŠ¶æ…‹ã«ã‚ˆã‚‹è‡­ã„ï¼ˆä¾‹ï¼šå‡ºè¡€ï¼‰
    if (player.injuries.some(i => i.type === 'bleeding')) {
        totalSmell += 15;
    }

    // 3. ä½“è‡­ã«ã‚ˆã‚‹è‡­ã„
    totalSmell += Math.floor(player.bodyOdor / 5);

    currentPlayerSmell = totalSmell;
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’æ–°ã—ãè¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼

/**
 * ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘¨å›²2ãƒã‚¹ä»¥å†…ã«ã„ã‚‹AIã®æ°—é…ã‚’æ¤œçŸ¥ã—ã€ãƒ­ã‚°ã«è¨˜éŒ²ã™ã‚‹ã€‚
 * ãƒ­ã‚°ã®é‡è¤‡ã‚’é˜²ããŸã‚ã€ä¸€åº¦æ¤œçŸ¥ã—ãŸAIã¯ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã¦ç®¡ç†ã™ã‚‹ã€‚
 */
function checkNearbyPresences() {
    let presenceWasDetectedThisTurn = false;

    entities.forEach(entity => {
        // AIã¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è·é›¢ã‚’è¨ˆç®—ï¼ˆç¸¦æ¨ªæ–œã‚ã‚’1ãƒã‚¹ã¨ã‚«ã‚¦ãƒ³ãƒˆï¼‰
        const distance = Math.max(Math.abs(player.x - entity.x), Math.abs(player.y - entity.y));

        // å¿µã®ãŸã‚ã€ãƒ•ãƒ©ã‚°ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯åˆæœŸåŒ–
        if (entity.presenceReported === undefined) {
            entity.presenceReported = false;
        }

        if (distance <= 2) {
            // 2ãƒã‚¹ä»¥å†…ã«ã„ã¦ã€ã¾ã å ±å‘Šã•ã‚Œã¦ã„ãªã„å ´åˆ
            if (!entity.presenceReported) {
                entity.presenceReported = true;
                presenceWasDetectedThisTurn = true;
            }
        } else {
            // ç¯„å›²å¤–ã«å‡ºãŸã‚‰ã€å ±å‘Šãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
            entity.presenceReported = false;
        }
    });

if (presenceWasDetectedThisTurn) {
        log(getString("log_presence_detected"), true);
        playSoundFile('sounds/presence_detected.wav', 0.6); // â† ã“ã®è¡Œã‚’è¿½åŠ 
    }
}

function advanceTurn() {
    if (isLoading) return;
    
    // ã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ã«è¡Œã‚ã‚Œã¦ã„ãŸä¸€éƒ¨ã®å‡¦ç†ï¼ˆtorchã®ç‡ƒç„¼ãªã©ï¼‰ã¯ã“ã“ã«æ®‹ã—ã¾ã™
    const torch = player.equipment.find(e => e.isTorch);
    if (torch) {
        torch.duration--;
        if (torch.duration <= 0) {
            log(getString("log_torch_extinguished"));
            const torchIndex = player.equipment.findIndex(e => e.isTorch);
            if(torchIndex > -1) {
                const removedItem = player.equipment.splice(torchIndex, 1)[0];
                player.weight -= removedItem.weight || 0;
                player.volume -= removedItem.volume || 0;
            }
        }
    }
    
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¿ãƒ¼ãƒ³ã‚’çµ‚äº†ã—ã€NPCã®ã‚¿ãƒ¼ãƒ³é€²è¡Œã‚’é–‹å§‹ã™ã‚‹
    endPlayerTurn();
}
/**
 * Dateã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å—ã‘å–ã‚Šã€å­£ç¯€ã®åå‰ã‚’è¿”ã™é–¢æ•°
 * @param {Date} date - åˆ¤å®šã™ã‚‹æ—¥ä»˜
 * @returns {string} - 'æ˜¥', 'å¤', 'ç§‹', 'å†¬' ã®ã„ãšã‚Œã‹
 */
/**
 * Dateã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å—ã‘å–ã‚Šã€å­£ç¯€ã®åå‰ã‚’è¿”ã™é–¢æ•°
 * @param {Date} date - åˆ¤å®šã™ã‚‹æ—¥ä»˜
 * @returns {string} - 'æ˜¥', 'å¤', 'ç§‹', 'å†¬' ã®ã„ãšã‚Œã‹
 */
/**
 * ç·ã‚¿ãƒ¼ãƒ³æ•°ã«åŸºã¥ã„ã¦ç¾åœ¨ã®å­£ç¯€ã‚’è¿”ã™é–¢æ•°
 * @returns {string} - 'æ˜¥', 'å¤', 'ç§‹', 'å†¬' ã®ã„ãšã‚Œã‹
 */
function getSeasonFromTurn() {
    const turnsInYear = 1440; // 1ã‚·ãƒ¼ã‚ºãƒ³ã®ã‚¿ãƒ¼ãƒ³æ•°(360) * 4
    const currentTurnInCycle = turn % turnsInYear;

    if (currentTurnInCycle < 360) {
        return 'æ˜¥'; // 0-359ã‚¿ãƒ¼ãƒ³
    } else if (currentTurnInCycle < 720) {
        return 'å¤'; // 360-719ã‚¿ãƒ¼ãƒ³
    } else if (currentTurnInCycle < 1080) {
        return 'ç§‹'; // 720-1079ã‚¿ãƒ¼ãƒ³
    } else {
        return 'å†¬'; // 1080-1439ã‚¿ãƒ¼ãƒ³
    }
}
function getSeasonFromDate(date) {
    const month = date.getMonth(); // 0 (1æœˆ) ã‹ã‚‰ 11 (12æœˆ)
    const day = date.getDate();

    // æœˆã¨æ—¥ã‹ã‚‰å­£ç¯€ã‚’åˆ¤å®š (ä¿®æ­£ç‰ˆ)
    if ((month > 1 && month < 5) || (month === 1 && day >= 21) || (month === 5 && day < 21)) {
        return 'æ˜¥'; // 2æœˆ21æ—¥ï½5æœˆ20æ—¥
    } else if ((month > 4 && month < 8) || (month === 4 && day >= 21) || (month === 8 && day < 22)) {
        return 'å¤'; // 5æœˆ21æ—¥ï½8æœˆ21æ—¥
    } else if ((month > 7 && month < 11) || (month === 7 && day >= 22) || (month === 11 && day < 21)) {
        return 'ç§‹'; // 8æœˆ22æ—¥ï½11æœˆ20æ—¥
    } else {
        return 'å†¬'; // 11æœˆ21æ—¥ï½2æœˆ20æ—¥
    }
}
// index.htmlã®<script>ã‚¿ã‚°å†…

// â–¼â–¼â–¼ æ—¢å­˜ã®`updateEntities`é–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function updateEntities(entitiesToUpdate) {
    const activeEntities = [...entitiesToUpdate];
    activeEntities.forEach(entity => {
        if (entity.approachCooldown > 0) {
            entity.approachCooldown--;
        }

        if (!entities.includes(entity) || entity.stunnedTurns > 0) {
            if (entity.stunnedTurns > 0) entity.stunnedTurns--;
            return;
        }

        if (entity.isZombie) {
            const moveChance = 0.8; 
            if (Math.random() > moveChance) {
                return;
            }
        }

        // â˜…â˜…â˜… ã“ã“ã‹ã‚‰ãŒä»Šå›ã®ä¿®æ­£ç®‡æ‰€ã§ã™ â˜…â˜…â˜…
        // æˆ¦é—˜ä¸­ã§ãªãã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¿‘ãã«ã„ã‚‹äººé–“NPCã®å ´åˆã€ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ¢ã™ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè¡Œ
        if (!entity.isZombie && !entity.isAnimal && entity.aiState !== 'attacking' && entity.aiState !== 'fleeing') {
            if (getDistance(entity.x, entity.y, player.x, player.y) <= 5) {
                handleNpcItemLogic(entity);
            }
        }
        // â˜…â˜…â˜… ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â˜…â˜…â˜…

        let visualTarget = null;
        let closestTargetDist = Infinity;
        const visionRange = getEntityVisionRange(entity);

        const distToPlayer = getDistance(entity.x, entity.y, player.x, player.y);
        if (distToPlayer <= visionRange && hasLineOfSight(entity.x, entity.y, player.x, player.y)) {
            visualTarget = player;
            closestTargetDist = distToPlayer;
        }

        activeEntities.forEach(otherEntity => {
            if (entity === otherEntity || otherEntity === player) return;
            const distToOther = getDistance(entity.x, entity.y, otherEntity.x, otherEntity.y);
            if (distToOther < closestTargetDist && distToOther <= visionRange) {
                let isHostile = false;
                if (entity.isZombie || entity.type === 'Raider') {
                    if (!otherEntity.isZombie) isHostile = true;
                } else if (entity.isAnimal && !entity.flees) {
                    if (!otherEntity.isZombie && (!otherEntity.isAnimal || entity.type !== otherEntity.type)) {
                        isHostile = true;
                    }
                }
                
                if (isHostile && hasLineOfSight(entity.x, entity.y, otherEntity.x, otherEntity.y)) {
                    visualTarget = otherEntity;
                    closestTargetDist = distToOther;
                }
            }
        });

        if (visualTarget) {
            entity.target = visualTarget;
            entity.investigationTarget = null;
            if (entity.isZombie || entity.type === 'Raider' || (entity.isAnimal && !entity.flees)) {
                entity.aiState = 'attacking';
            } else if (entity.flees || entity.type === 'Survivor' || entity.type === 'Trader') {
                if ((entity.type === 'Survivor' || entity.type === 'Trader') && entity.isCurious && entity.target === player && entity.approachCooldown === 0) {
                    entity.aiState = 'approaching';
                } else {
                    entity.aiState = 'fleeing';
                    entity.fleeingTurns = 5;
                }
            }
        } else {
            if (entity.fleeingTurns > 0) {
                entity.fleeingTurns--;
                entity.aiState = 'fleeing';
            } else {
                entity.target = null;
                if (entity.aiState === 'attacking' || entity.aiState === 'fleeing' || entity.aiState === 'approaching') {
                    entity.aiState = 'wandering';
                }
            }
            
            if (entity.aiState !== 'fleeing' && (entity.isZombie || (entity.isAnimal && !entity.flees)) && currentPlayerSmell > 0) {
                const smellDetectionChance = currentPlayerSmell / 50;
                const distanceToPlayer = getDistance(entity.x, entity.y, player.x, player.y);
                if (distanceToPlayer <= 10 && Math.random() < smellDetectionChance) {
                    entity.investigationTarget = { x: player.x, y: player.y };
                    entity.aiState = 'investigating';
                    if (getDistance(player.x, player.y, entity.x, entity.y) <= getVisionRange()) {
                        log(`${entity.name}ãŒä½•ã‹ã®è‡­ã„ã‚’å—…ãã¤ã‘ãŸã‚ˆã†ã ...`);
                    }
                }
            }
        }

        switch (entity.aiState) {
            case 'attacking':
                if (entity.target === player && (player.isInside || player.isInShelter)) {
                    entity.aiState = 'wandering';
                    entity.target = null;
                    if (Math.random() < 0.3) {
                        let newX = entity.x + randChoice([-1, 0, 1]);
                        let newY = entity.y + randChoice([-1, 0, 1]);
                        moveEntityTo(entity, newX, newY);
                    }
                    break;
                }
                if (entity.target && getDistance(entity.x, entity.y, entity.target.x, entity.target.y) <= 1) {
                    if (entity.target === player) {
                        resolveEntityCombat(entity, player);
                    } else {
                        resolveEntityCombat(entity, entity.target);
                    }
                } else if (entity.target) {
                    moveEntityTowards(entity, entity.target.x, entity.target.y);
                }
                break;

            case 'approaching':
                if (entity.target && getDistance(entity.x, entity.y, entity.target.x, entity.target.y) > 1) {
                    moveEntityTowards(entity, entity.target.x, entity.target.y);
                } else {
                    entity.aiState = 'fleeing';
                    entity.fleeingTurns = 5;
                    entity.approachCooldown = 20;
                }
                break;

            case 'fleeing':
                if (entity.target) {
                    if (entity.fleeingTurns <= 3 && Math.random() < 0.3) {
                        break; 
                    }
                    moveEntityAwayFrom(entity, entity.target.x, entity.target.y);
                }
                break;

            case 'investigating':
                if (entity.investigationTarget && entity.x === entity.investigationTarget.x && entity.y === entity.investigationTarget.y) {
                    entity.aiState = 'wandering';
                    entity.investigationTarget = null;
                } else if (entity.investigationTarget) {
                    moveEntityTowards(entity, entity.investigationTarget.x, entity.investigationTarget.y);
                }
                break;

            case 'wandering':
            case 'alert':
                if (Math.random() < 0.3) {
                    let newX = entity.x + randChoice([-1, 0, 1]);
                    let newY = entity.y + randChoice([-1, 0, 1]);
                    moveEntityTo(entity, newX, newY);
                }
                break;
        }

        entity.x = Math.max(0, Math.min(mapSize - 1, entity.x));
        entity.y = Math.max(0, Math.min(mapSize - 1, entity.y));
    });
}
/**
 * NPCã®å„ãƒ•ã‚§ãƒ¼ã‚ºã‚’é †ç•ªã«å‡¦ç†ã™ã‚‹
 */
// index.htmlå†…

// index.htmlã®<script>ã‚¿ã‚°å†…

function processNpcTurns() {
    if (isLoading) return;

    if (currentNpcPhaseIndex >= turnOrder.length) {
        // å…¨ã¦ã®NPCãƒ•ã‚§ãƒ¼ã‚ºãŒå®Œäº†ã—ãŸå ´åˆ
        isInteractionActive = false;
        currentNpcPhaseIndex = 0;

        drawMap();
        
        entities.forEach(e => {
            if (e.justMoved) e.justMoved = false;
        });

        // ã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ã®æœ€çµ‚å‡¦ç†
        checkStats();
        updatePlayerSmell();
        updateBackgroundColor();
        drawMinimap();
        
        player.painStunCycle = (player.painStunCycle + 1) % 5;
        if (player.painStunCycle === 0) {
            player.painStunSchedule = [];
            const painTolerancePercent = (player.painTolerance / maxStats.painTolerance) * 100;
            let turnsToLose = 0;
            if (painTolerancePercent < 33.3) { turnsToLose = 2; } 
            else if (painTolerancePercent < 66.7) { turnsToLose = 1; }
            if (turnsToLose > 0) {
                const possibleTurns = [0, 1, 2, 3, 4];
                for (let i = 0; i < turnsToLose; i++) {
                    const randomIndex = Math.floor(Math.random() * possibleTurns.length);
                    player.painStunSchedule.push(possibleTurns.splice(randomIndex, 1)[0]);
                }
            }
        }
        
        refreshGameState();
        return;
    }

    const currentPhase = turnOrder[currentNpcPhaseIndex];
    let entitiesToUpdate = [];

    switch(currentPhase) {
        case 'trader':
            entitiesToUpdate = entities.filter(e => e.type === 'Trader');
            break;
        case 'survivor':
            entitiesToUpdate = entities.filter(e => e.type === 'Survivor');
            break;
        case 'raider':
            entitiesToUpdate = entities.filter(e => e.type === 'Raider');
            break;
        case 'animal':
            entitiesToUpdate = entities.filter(e => e.isAnimal);
            break;
        case 'zombie':
            entitiesToUpdate = entities.filter(e => e.isZombie);
            break;
    }

    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä»Šå›ã®ä¿®æ­£ç®‡æ‰€ã§ã™ â–¼â–¼â–¼
    const isAnyEntityVisible = entitiesToUpdate.some(entity => 
        getDistance(player.x, player.y, entity.x, entity.y) <= getVisionRange() &&
        hasLineOfSight(player.x, player.y, entity.x, entity.y)
    );

    // è¦‹ãˆã¦ã„ã‚‹NPCãŒã„ã¦ã€ã‹ã¤è¶³éŸ³ãŒå†ç”Ÿä¸­ã§ãªã„å ´åˆã®ã¿éŸ³ã‚’å†ç”Ÿ
    if (isAnyEntityVisible && !isNpcFootstepPlaying) {
        isNpcFootstepPlaying = true; // è¶³éŸ³ãƒ­ãƒƒã‚¯ã‚’ã‹ã‘ã‚‹

        let soundPath = 'sounds/footstep.wav';
        if (currentPhase === 'zombie') {
            soundPath = 'sounds/zombie_shuffle.wav';
        }
        playSoundFile(soundPath, 0.4);

        // 500ãƒŸãƒªç§’å¾Œã«ãƒ­ãƒƒã‚¯ã‚’è§£é™¤ã™ã‚‹
        setTimeout(() => {
            isNpcFootstepPlaying = false;
        }, 500);
    }
    // â–²â–²â–² ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²

    if (entitiesToUpdate.length > 0) {
        updateEntities(entitiesToUpdate);
    }
    
    currentNpcPhaseIndex++;
    setTimeout(processNpcTurns, 150); 
}

/**
 * ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¿ãƒ¼ãƒ³ã‚’çµ‚äº†ã—ã€NPCã®ã‚¿ãƒ¼ãƒ³é€²è¡Œã‚’é–‹å§‹ã™ã‚‹
 */
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’æ¢ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
function endPlayerTurn() {
    console.log(`DEBUG: endPlayerTurnãŒæ“ä½œã‚’ãƒ­ãƒƒã‚¯ã—ã¾ã—ãŸã€‚ æ™‚åˆ»: ${new Date().toLocaleTimeString()}`);
    isInteractionActive = true; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ“ä½œã‚’ãƒ­ãƒƒã‚¯
    currentNpcPhaseIndex = 0;   // NPCãƒ•ã‚§ãƒ¼ã‚ºã‚’æœ€åˆã‹ã‚‰é–‹å§‹
    
    // ã‚¿ãƒ¼ãƒ³æ•°ã‚„æ™‚é–“ãªã©ã€å³æ™‚æ›´æ–°ãŒå¿…è¦ãªã‚‚ã®ã‚’å…ˆã«å‡¦ç†
    turn++;
    previousSoundLevel = currentSoundLevel;
    previousPlayerSmell = currentPlayerSmell;
    currentSoundLevel = 0;
    currentTime.setHours(currentTime.getHours() + 1);

    const newSeason = getSeasonFromTurn();
    if (newSeason !== currentSeason) {
        currentSeason = newSeason;
        const translatedSeason = getString(`season_${newSeason}`);
        log(getString("log_season_changed", { seasonName: translatedSeason }));
    }
    isNight = (currentTime.getHours() >= 18 || currentTime.getHours() < 6);

    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ä¸‹ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ã€ã“ã®å ´æ‰€ã«ä¸¸ã”ã¨è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„ â–¼â–¼â–¼
    // è¨­ç½®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ™‚é–“çµŒéã‚¤ãƒ™ãƒ³ãƒˆï¼ˆæ­»ä½“ã®è…æ•—/ã‚¾ãƒ³ãƒ“åŒ–ãªã©ï¼‰ã‚’å‡¦ç†
    for (let i = placedObjects.length - 1; i >= 0; i--) {
        const obj = placedObjects[i];
        let mapNeedsRedrawing = false;

        // ã‚¾ãƒ³ãƒ“åŒ–ã‚¿ã‚¤ãƒãƒ¼ã®å‡¦ç†
        if (obj.zombificationTimer !== undefined) {
            obj.zombificationTimer--;
            if (obj.zombificationTimer <= 0) {
                placedObjects.splice(i, 1);
                mapNeedsRedrawing = true;

                const newZombie = {
                    type: 'Zombie', name: 'ã‚¾ãƒ³ãƒ“', icon: 'images/zombie.png', portraitIcon: 'images/zombie_portrait.png',
                    x: obj.x, y: obj.y, health: Math.floor(Math.random() * 20) + 30, maxHealth: 50,
                    attack: 8 + Math.floor(Math.random() * 8), defense: 2 + Math.floor(Math.random() * 3),
                    visionRange: 3, isZombie: true, stunnedTurns: 0, stance: 'standing', isDodging: false,
                    vulnerableTurns: 0, heavyAttackCooldown: 0, aiState: 'wandering', target: null, investigationTarget: null
                };
                entities.push(newZombie);
                log(getString("log_zombie_arisen"), true);
                continue; // ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æ¶ˆæ»…ã—ãŸã®ã§ã€æ¬¡ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‡¦ç†ã«ç§»ã‚‹
            }
        }

        // è…æ•—ã‚¿ã‚¤ãƒãƒ¼ã®å‡¦ç†
        if (obj.decayTimer !== undefined) {
            obj.decayTimer--;
            if (obj.decayTimer <= 0) {
                obj.graphic = BONES_IMG;
                obj.name = 'éª¨';
                obj.unsearched = false;
                obj.unbutchered = false;
                delete obj.decayTimer;
                delete obj.potentialLoot;
                mapNeedsRedrawing = true;
            }
        }
    }
    // â–²â–²â–² è²¼ã‚Šä»˜ã‘ã¯ã“ã“ã¾ã§ â–²â–²â–²

    // NPCã®ã‚¿ãƒ¼ãƒ³é€²è¡Œã‚’é–‹å§‹
    processNpcTurns();
}

// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function resolveEntityCombat(attacker, defender) {
    if (defender === player) {
        if (getDistance(attacker.x, attacker.y, player.x, player.y) <= 1) {
            isInteractionActive = true; 
            attacker.x = player.x;
            attacker.y = player.y;
            drawMap();
            setTimeout(() => {
                log(getString("log_npc_encounter", { npcName: getString(`item_${attacker.name}_name`) || attacker.name }));
                startCombat(attacker, false);
            }, 500);
        }
        return;
    }
    if(attacker === player) return;
    const attackerDamage = Math.max(1, (attacker.attack || attacker.baseAttack || 5) - (defender.defense || defender.baseDefense || 0) + (Math.floor(Math.random() * 5) - 2));
    defender.health -= attackerDamage;
    const distanceToPlayer = getDistance(attacker.x, attacker.y, player.x, player.y);
    if(distanceToPlayer <= getVisionRange()) {
         const attackerName = getString(`item_${attacker.name}_name`) || attacker.name;
         const defenderName = getString(`item_${defender.name}_name`) || defender.name;
         log(getString("log_entity_attacked", { attackerName: attackerName, defenderName: defenderName }));
    }
    if (defender.health <= 0) {
        const defenderName = getString(`item_${defender.name}_name`) || defender.name;
        if(distanceToPlayer <= getVisionRange()) log(getString("log_entity_defeated", { entityName: defenderName }));
        if (defender.isAnimal && defender.loot) {
            // â–¼â–¼â–¼ ä¿®æ­£ â–¼â–¼â–¼
            const corpse = { x: defender.x, y: defender.y, type: 'corpse', name: `${defender.name}ã®æ­»ä½“`, graphic: ANIMAL_CARCASS_IMG, duration: 48, isAnimalCorpse: true, unbutchered: true, potentialLoot: defender.loot };
            placedObjects.push(corpse);
        } else if (!defender.isZombie) {
            // â–¼â–¼â–¼ ä¿®æ­£ â–¼â–¼â–¼
            const lootItems = [...(defender.inventory || []), ...(defender.equipment || [])];
            const corpse = { x: defender.x, y: defender.y, type: 'corpse', name: `${defender.name}ã®æ­»ä½“`, graphic: HUMAN_CORPSE_IMG, duration: 24, isHumanCorpse: true, unsearched: true, potentialLoot: lootItems };
            placedObjects.push(corpse);
        }
        const defenderIndex = entities.findIndex(e => e === defender);
        if (defenderIndex > -1) entities.splice(defenderIndex, 1);
    }
}

// â–¼â–¼â–¼ `generateWeatherAndTemperature` é–¢æ•°ã‚’ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function generateWeatherAndTemperature() {
    const hour = currentTime.getHours();
    let seasonBaseTemp;
    switch(currentSeason) {
        case 'å¤': seasonBaseTemp = 28; break;
        case 'æ˜¥': seasonBaseTemp = 18; break;
        case 'ç§‹': seasonBaseTemp = 15; break;
        case 'å†¬': seasonBaseTemp = 5; break;
        default: seasonBaseTemp = 15;
    }
    const currentBiome = map[player.y][player.x].biome;
    let biomeModifier = (currentBiome === 'Forest') ? -3 : (currentBiome === 'Town') ? 2 : 0;
    const timeOfDayModifier = (hour >= 6 && hour < 18) ? 5 : -5;
    let baseTemp = seasonBaseTemp + biomeModifier + timeOfDayModifier;

    if (Math.random() < 0.2 || turn === 1) {
        const currentId = currentWeather.id;
        const transitions = weatherTransitions[currentId];

        if (transitions) {
            const totalWeight = transitions.reduce((sum, t) => sum + t.weight, 0);
            let randomValue = Math.random() * totalWeight;

            for (const transition of transitions) {
                randomValue -= transition.weight;
                if (randomValue <= 0) {
                    const newWeather = { ...weatherTypes[transition.next], id: transition.next };
                    if (turn > 1 && currentWeather.id !== newWeather.id) {
                        const translatedWeather = getString(newWeather.nameKey);
                        log(getString("log_weather_changed", { weatherName: translatedWeather }));
                    }
                    currentWeather = newWeather;
                    break;
                }
            }
        }
    }

console.log(`Turn ${turn}: Weather check. Current weather ID is:`, currentWeather.id);
    if (currentWeather.id === 'rainy' || currentWeather.id === 'stormy') {
        stopClouds();
        startWeatherEffect(currentWeather.id);
    } else if (currentWeather.id === 'cloudy') {
        stopWeatherEffect();
        startClouds();
    } else {
        stopWeatherEffect();
        stopClouds();
    }

    baseTemp += currentWeather.tempMod;
    currentTemperature = baseTemp + (Math.random() - 0.5) * 4;

    updateWeatherAudio();
}

function checkStats() {
    // è¨­ç½®ç‰©ï¼ˆä¹¾ç‡¥ãƒ©ãƒƒã‚¯ãªã©ï¼‰ã®çŠ¶æ…‹ã‚’æ›´æ–°
    placedObjects.forEach(obj => {
        if (obj.type === 'drying_rack' && obj.content && obj.content.length > 0) {
            obj.content.forEach(meat => {
                if (meat.turnsLeft > 0) {
                    meat.turnsLeft--;
                }
            });
        }
    });

    let totalTurnDamage = 0;
    if (player.feverImmunityTurns > 0) player.feverImmunityTurns--;
    
    // åŸºæœ¬çš„ãªã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ¸›å°‘é‡
    let hungerLoss = 0.8, thirstLoss = 1.2, moraleLoss = 1, sleepLoss = 2.5;

    // çŠ¶æ…‹å¤‰åŒ–ã«ã‚ˆã‚‹åŠ¹æœéŸ³ã®å†ç”Ÿç®¡ç†
    const isCurrentlySleepy = (player.sleep / maxStats.sleep) * 100 < 50;
    const isCurrentlyHypothermic = player.bodyTemp < 35.5;
    const isCurrentlyThirsty = (player.thirst / maxStats.thirst) * 100 < 50;
    const isCurrentlyHungry = (player.hunger / maxStats.hunger) * 100 < 50;
    const isCurrentlyFeverish = player.sicknesses.some(s => s.type === 'fever');
    const isCurrentlyBleeding = player.injuries.some(i => i.type === 'bleeding');
    const isCurrentlyBruised = player.injuries.some(i => i.type === 'bruise');
    const isCurrentlyFractured = player.injuries.some(i => i.type === 'fracture');

    if (isCurrentlySleepy && !wasPreviouslySleepy) { playPlayerVoice('sounds/yawn.wav', 0.7); }
    if (isCurrentlyHypothermic && !wasPreviouslyHypothermic) { playPlayerVoice('sounds/shiver.wav', 0.6); }
    if (isCurrentlyThirsty && !wasPreviouslyThirsty) { playPlayerVoice('sounds/swallow.wav', 0.8); }
    if (isCurrentlyHungry && !wasPreviouslyHungry) { playPlayerVoice('sounds/rumble.wav', 0.5); }
    if (isCurrentlyFeverish && !wasPreviouslyFeverish) { playPlayerVoice('sounds/cough.wav', 0.7); }
    if (isCurrentlyBleeding && !wasPreviouslyBleeding) { playPlayerVoice('sounds/heartbeat.wav', 0.9); }
    if (isCurrentlyBruised && !wasPreviouslyBruised) { playPlayerVoice('sounds/grunt.wav', 0.8); }
    if (isCurrentlyFractured && !wasPreviouslyFractured) { playPlayerVoice('sounds/pain.wav', 0.9); }

    wasPreviouslySleepy = isCurrentlySleepy;
    wasPreviouslyHypothermic = isCurrentlyHypothermic;
    wasPreviouslyThirsty = isCurrentlyThirsty;
    wasPreviouslyHungry = isCurrentlyHungry;
    wasPreviouslyFeverish = isCurrentlyFeverish;
    wasPreviouslyBleeding = isCurrentlyBleeding;
    wasPreviouslyBruised = isCurrentlyBruised;
    wasPreviouslyFractured = isCurrentlyFractured;
    
    // --- è¶³ã®è² å‚·ã¨å›å¾©ã®ãƒ­ã‚¸ãƒƒã‚¯ ---
    const hasLeftShoe = player.equipment.some(e => e.slot === 'left_foot');
    const hasRightShoe = player.equipment.some(e => e.slot === 'right_foot');
    const isFullyShod = hasLeftShoe && hasRightShoe; // ä¸¡è¶³ã«é´ã‚’å±¥ã„ã¦ã„ã‚‹ã‹

    const hasSoreFeet = player.injuries.some(i => i.type === 'sore_feet');
    const hasInjuredFeet = player.injuries.some(i => i.type === 'injured_feet');

    if (!isFullyShod) { // ç‰‡è¶³ã§ã‚‚è£¸è¶³ã®å ´åˆ
        player.barefootTurns = (player.barefootTurns || 0) + 1;

        if (player.barefootTurns > 0) {
            if (!hasSoreFeet && !hasInjuredFeet) {
                if (player.nextSoreFeetTurn === -1) {
                    player.nextSoreFeetTurn = player.barefootTurns + (Math.floor(Math.random() * 4) + 4);
                }
                if (player.barefootTurns >= player.nextSoreFeetTurn) {
                    player.injuries.push({ type: 'sore_feet' });
                    log(getString("log_feet_sore"), true);
                    player.nextInjuredFeetTurn = player.barefootTurns + (Math.floor(Math.random() * 6) + 10);
                    player.nextSoreFeetTurn = -1;
                }
            } else if (hasSoreFeet && !hasInjuredFeet) {
                if (player.barefootTurns >= player.nextInjuredFeetTurn) {
                    player.injuries = player.injuries.filter(i => i.type !== 'sore_feet');
                    player.injuries.push({ type: 'injured_feet' });
                    log(getString("log_feet_injured"), true);
                    player.nextInjuredFeetTurn = -1;
                }
            }
        }
    } else { // ä¸¡è¶³ã«é´ã‚’å±¥ã„ã¦ã„ã‚‹å ´åˆ
        if (hasSoreFeet || hasInjuredFeet) {
            player.injuries = player.injuries.filter(i => i.type !== 'sore_feet' && i.type !== 'injured_feet');
            log(getString("log_feet_healed_by_shoes"), true);
        }
        // ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
        player.barefootTurns = 0;
        player.nextSoreFeetTurn = -1;
        player.nextInjuredFeetTurn = -1;
    }

    // æ€ªæˆ‘ã®ç¶™ç¶šå‡¦ç†
    const newInjuries = [];
    let isBleedingThisTurn = false; // â˜…ã“ã®ã‚¿ãƒ¼ãƒ³ã«å‡ºè¡€ã—ã¦ã„ã‚‹ã‹ã‚’åˆ¤å®šã™ã‚‹ãƒ•ãƒ©ã‚°
    player.injuries.forEach(injury => {
        let stillInjured = true;
        
if (injury.type === 'bleeding' && (!injury.treating_duration || injury.treating_duration <= 0)) {
             isBleedingThisTurn = true; // â˜…å‡ºè¡€ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
            if (injury.infectionRisk === undefined) injury.infectionRisk = 0;
            injury.infectionRisk += 5;
            // â˜…â˜…â˜…ã“ã®è¡Œã‚’ä¿®æ­£â˜…â˜…â˜…
            if (Math.random() < calculateSicknessChance(injury.infectionRisk / 100) && !player.sicknesses.some(s => s.type === 'infection')) {
                log(getString("log_infection_start"), true);
                player.sicknesses.push({ type: 'infection', duration: 72 });
                injury.infected = true;
            }
        }

switch (injury.type) {
            case 'bleeding':
                if (injury.treating_duration > 0) {
                    injury.treating_duration--;
                    if (injury.treating_duration <= 0) {
                        log(getString("log_bleeding_healed"), true);
                        stillInjured = false;
                    }
                }
                break;
            case 'bruise':
                moraleLoss += 2;
                injury.duration--;
                if (injury.duration <= 0) {
                    log(getString("log_bruise_healed"), true);
                    stillInjured = false;
                } else {
                    log(getString("log_bruise_morale"), false);
                }
                break;
            case 'fracture':
                moraleLoss += injury.splinted ? 4 : 10;
                injury.duration--;
                if (injury.duration <= 0) {
                    log(getString("log_fracture_healed"), true);
                    stillInjured = false;
                } else {
                    log(getString("log_fracture_morale"), false);
                }
                break;
        }
        if (stillInjured) newInjuries.push(injury);
    });
    player.injuries = newInjuries;

// â˜…â˜…â˜…ã“ã“ã‹ã‚‰ãŒè¡€æ¶²é‡ã¨å…ç–«ç³»ã«é–¢ã™ã‚‹æ–°ã—ã„ãƒ­ã‚¸ãƒƒã‚¯ã§ã™â˜…â˜…â˜…
    const bleedingWounds = player.injuries.filter(i => i.type === 'bleeding' && (!i.treating_duration || i.treating_duration <= 0));
    if (bleedingWounds.length > 0) {
        // --- å‡ºè¡€ã«ã‚ˆã‚‹è¡€æ¶²ã®æ¸›å°‘ ---
        const bloodLossPerWound = 3;
        player.bloodLevel -= bloodLossPerWound * bleedingWounds.length;
        log(getString("log_bleeding_damage"), false);
    } else {
        // --- å‡ºè¡€ã—ã¦ã„ãªã„å ´åˆã®è¡€æ¶²ã¨å…ç–«ç³»ã®å›å¾© ---
        const hasAnyBleeding = player.injuries.some(i => i.type === 'bleeding');
        if (!hasAnyBleeding) {
            // å›å¾©ç‡ã‚’æ±ºå®š (æº€è…¹ãªã‚‰2å€é€Ÿ)
            let recoveryRate = player.hunger > maxStats.hunger * 0.8 ? 1.0 : 0.5;

            // è¡€æ¶²é‡ã®å›å¾©
            if (player.bloodLevel < maxStats.bloodLevel) {
                player.bloodLevel += recoveryRate;
            }
            // å…ç–«ç³»ã®å›å¾©
            if (player.immuneSystem < maxStats.immuneSystem) {
                player.immuneSystem += recoveryRate;
            }
        }
    }
    // â˜…â˜…â˜…è¡€æ¶²é‡ãƒ­ã‚¸ãƒƒã‚¯ã“ã“ã¾ã§â˜…â˜…â˜…

// ä½“æ¸©ä½ä¸‹ã«ã‚ˆã‚‹ç™ºç†±åˆ¤å®š
    if (player.hypothermiaTurns > 4 && !player.sicknesses.some(s => s.type === 'fever') && player.feverImmunityTurns <= 0) {
        // â˜…â˜…â˜…ã“ã®è¡Œã‚’ä¿®æ­£â˜…â˜…â˜…
        if (Math.random() < calculateSicknessChance(0.6)) {
            log(getString("log_hypothermia_fever"), true);
            player.sicknesses.push({ type: 'fever', duration: 48 });
            player.hypothermiaTurns = 0;
        }
    }

// â˜…â˜…â˜…ã“ã“ã‹ã‚‰ãŒæ•—è¡€ç—‡ã®ç™ºç—‡åˆ¤å®šã§ã™â˜…â˜…â˜…
    const hasUntreatedBleeding = player.injuries.some(i => i.type === 'bleeding' && !i.treating_duration);
    const hasInfection = player.sicknesses.some(s => s.type === 'infection');
    const hasSepsis = player.sicknesses.some(s => s.type === 'sepsis');

    if (hasUntreatedBleeding && hasInfection && !hasSepsis && Math.random() < 0.05) { // 5%ã®ç¢ºç‡ã§ç™ºç—‡
        player.sicknesses.push({
            type: 'sepsis',
            duration: Math.floor(Math.random() * 3) + 3 // 3ã€œ5ã‚¿ãƒ¼ãƒ³ã®è‡´æ­»ã‚¿ã‚¤ãƒãƒ¼
        });
        log(getString("log_sepsis_start"), true);
    }
    // â˜…â˜…â˜…æ•—è¡€ç—‡ã®ç™ºç—‡åˆ¤å®šã“ã“ã¾ã§â˜…â˜…â˜…

    // ç—…æ°—ã®ç¶™ç¶šå‡¦ç†
    const newSicknesses = [];
    let sicknessesToAdd = [];
    player.sicknesses.forEach(sickness => {
        let stillSick = true;
        const sicknessName = getSicknessName(sickness.type);
        switch (sickness.type) {
            case 'itch': moraleLoss += 3; log(getString("log_itch_symptom"), false); break;
            case 'infection': moraleLoss += 2; player.bodyTemp += 0.2; log(getString("log_infection_drain"), false); break;
            case 'food_poisoning': moraleLoss += 3; log(getString("log_food_poisoning_drain"), false); break;
            case 'diarrhea':
                moraleLoss += 2;
                log(getString("log_diarrhea_drain"), false);
                if (Math.random() < 0.2 && !player.sicknesses.some(s => s.type === 'vomiting') && !sicknessesToAdd.some(s => s.type === 'vomiting')) {
                    sicknessesToAdd.push({ type: 'vomiting', duration: 6 });
                    log(getString("log_diarrhea_induces_vomiting"), true);
                }
                break;
            case 'fever': moraleLoss += 2; player.bodyTemp += 0.1; log(getString("log_fever_drain"), false); break;
            case 'vomiting':
                hungerLoss += 8;
                thirstLoss += 12;
                log(getString("log_vomiting_drain"), false);
                break;
            // â˜…â˜…â˜…ã“ã“ã‹ã‚‰ãŒæ•—è¡€ç—‡ã®åŠ¹æœå‡¦ç†ã§ã™â˜…â˜…â˜…
            case 'sepsis':
                const stillHasUntreatedBleeding = player.injuries.some(i => i.type === 'bleeding' && !i.treating_duration);
                const stillHasInfectionNow = player.sicknesses.some(s => s.type === 'infection');

                if (stillHasUntreatedBleeding && stillHasInfectionNow) {
                    // åŸå› ãŒæœªæ²»ç™‚ã®å ´åˆã€ç—‡çŠ¶ãŒæ‚ªåŒ–
                    totalTurnDamage += 5; // æ¯ã‚¿ãƒ¼ãƒ³5ã®ç›´æ¥ãƒ€ãƒ¡ãƒ¼ã‚¸
                    moraleLoss += 10;
                    player.bodyTemp += 0.5;
                    log(getString("log_sepsis_progress"), false);

                    // æ­»äº¡åˆ¤å®š (è‡ªç„¶å›å¾©å‡¦ç†ã®å‰ã«åˆ¤å®š)
                    if (sickness.duration <= 1) {
                        const causeMessage = getString("log_game_over_sepsis");
                        const gameOverMessage = getString("log_game_over_reason", { reason: causeMessage });
                        speak(gameOverMessage + " " + getString("log_game_over_title"));
                        handleGameOver(gameOverMessage);
                        return; // returnã§ä»¥é™ã®å‡¦ç†ã‚’ä¸­æ–­
                    }
                } else {
                    // åŸå› ãŒæ²»ç™‚ã•ã‚ŒãŸå ´åˆã€æ•—è¡€ç—‡ã®é€²è¡ŒãŒæ­¢ã¾ã‚‹
                    if (!sickness.medicated_duration) {
                        sickness.medicated_duration = 2; // 2ã‚¿ãƒ¼ãƒ³å¾Œã«å›å¾©
                        log(getString("log_sepsis_stopped"), true);
                    }
                }
                break;
            // â˜…â˜…â˜…æ•—è¡€ç—‡ã®åŠ¹æœå‡¦ç†ã“ã“ã¾ã§â˜…â˜…â˜…
        }
        if (sickness.medicated_duration) {
            sickness.medicated_duration--;
            if (sickness.medicated_duration <= 0) {
                log(getString("log_sickness_healed_meds", { sicknessName: sicknessName }), true);
                if (sickness.type === 'fever') {
                    player.feverImmunityTurns = 48;
                    log(getString("log_fever_immunity"));
                }
                stillSick = false;
            }
} else {
            // â˜…â˜…â˜…ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™â˜…â˜…â˜…
            // ãƒ“ã‚¿ãƒŸãƒ³ã¨å…ç–«åŠ›ã«åŸºã¥ã„ã¦å›å¾©ç¢ºç‡ã‚’è¨ˆç®—
            let recoveryChance = 0.2; // åŸºæœ¬å›å¾©ç¢ºç‡20%
            if (player.vitamins > 50) recoveryChance += 0.3; // ãƒ“ã‚¿ãƒŸãƒ³ãŒåŠåˆ†ä»¥ä¸Šã‚ã‚Œã°+30%
            recoveryChance += (player.immuneSystem / 100) * 0.5; // å…ç–«åŠ›ãŒ100ãªã‚‰+50%
            // â˜…â˜…â˜…ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™â˜…â˜…â˜…
            
            if (sickness.type === 'fever') {
                const initialFeverDuration = 48;
                const turnsPassed = initialFeverDuration - sickness.duration;
                if (turnsPassed >= 24 && player.vitamins <= 0) recoveryChance = 0.8;
            }
            if (Math.random() < recoveryChance) sickness.duration--;
            if (sickness.duration <= 0) {
                 log(getString("log_sickness_healed_natural", { sicknessName: sicknessName }), true);
                 if (sickness.type === 'fever') {
                    player.feverImmunityTurns = 48;
                    log(getString("log_fever_immunity"));
                 }
                 stillSick = false;
            }
        }
        if (stillSick) newSicknesses.push(sickness);
    });
    player.sicknesses = newSicknesses.concat(sicknessesToAdd);
    // ä½“æ¸©ã®è¨ˆç®—
    const campfireOnTile = placedObjects.find(c => c.type === 'campfire' && c.x === player.x && c.y === player.y);
    const insideBonus = (player.isInside || player.isInShelter) ? 5 : 0;
    let synergyBonus = 0;
    if ((player.isInside || player.isInShelter) && campfireOnTile) {
        synergyBonus = 10;
    }
    const campfireNearby = placedObjects.find(c => c.type === 'campfire' && Math.abs(c.x - player.x) <=1 && Math.abs(c.y - player.y) <= 1);
    const effectiveTemperature = currentTemperature + (campfireNearby ? 15 : 0) + insideBonus + synergyBonus;

    let fatInsulationPenalty = 0;
    if (player.fat < 25) { hungerLoss += 2; fatInsulationPenalty = 1.0; }
    if (player.fat <= 0) { hungerLoss += 3; fatInsulationPenalty = 2.5; log(getString("log_fat_depleted"), false); }
    const totalInsulation = player.insulation - fatInsulationPenalty;
    const insulationFactor = Math.max(0.1, 1 - (totalInsulation / 8));
    const tempDiff = effectiveTemperature - 25;

    player.bodyTemp += (tempDiff * 0.03) * insulationFactor;
    player.bodyTemp -= (player.bodyTemp - 36.5) * 0.08;

    // æ¿¡ã‚Œã«ã‚ˆã‚‹ä½“æ¸©ä½ä¸‹
    let wetItems = 0, soakingWetItems = 0;
    player.equipment.forEach(item => {
        if (item.type === 'clothing') {
            if (item.wetness === 'wet') wetItems++;
            else if (item.wetness === 'soaking_wet') soakingWetItems++;
        }
    });
    if (wetItems > 0 || soakingWetItems > 0) {
        const wetnessPenalty = (wetItems * 0.03) + (soakingWetItems * 0.10);
        player.bodyTemp -= wetnessPenalty;
        if (soakingWetItems > 0) log(getString("log_wetness_draining_major"), false);
        else if (wetItems > 0) log(getString("log_wetness_draining_minor"), false);
    }
    
    // ç•°å¸¸ä½“æ¸©ã«ã‚ˆã‚‹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ‚ªåŒ–
    if (player.bodyTemp > 37.5) { moraleLoss += 1; hungerLoss += 2; thirstLoss += 3; log(getString("log_hyperthermia_drain"), false); }
    else if (player.bodyTemp < 35.5) { moraleLoss += 1; hungerLoss += 3; thirstLoss += 2; log(getString("log_hypothermia_drain"), false); }
    player.hypothermiaTurns = (player.bodyTemp < 35.5) ? player.hypothermiaTurns + 1 : 0;
    
    // å¤©å€™ã«ã‚ˆã‚‹ç²¾ç¥æ‚ªåŒ–
    if (currentWeather.id === "stormy") moraleLoss += 3;
    else if (currentWeather.id === "rainy") moraleLoss += 1;
    else if (currentWeather.id === "sunny" && !isNight) player.morale += 0.5;
    
    // ç¶™ç¶šãƒ€ãƒ¡ãƒ¼ã‚¸ã®è¨ˆç®—
    if (player.morale <= 0) totalTurnDamage += 1;
    if (player.hunger <= 0) totalTurnDamage += 1.5;
    if (player.thirst <= 0) totalTurnDamage += 2;
    if (player.protein <= 0) totalTurnDamage += 0.5;

    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã¨æ „é¤Šç´ ã®æ¸›å°‘
    player.hunger -= hungerLoss;
    player.thirst -= thirstLoss;
    player.sleep -= sleepLoss;
    player.morale -= moraleLoss;
    player.carbs -= 2;
    player.protein -= 1;
    player.fat -= 1;
    player.vitamins -= 0.5;

    // æ „é¤Šä¸è¶³ã«ã‚ˆã‚‹ãƒšãƒŠãƒ«ãƒ†ã‚£
    if (player.carbs <= 0) {
        if (Math.random() < 0.2) {
            player.stunnedTurns = (player.stunnedTurns || 0) + 1;
            log(getString("log_carbs_depleted_stun"), true);
        }
    }
    if (player.protein < 25) {
        player.injuries.forEach(injury => { if (injury.duration > 0) injury.duration++; });
    }
    
    // ä½“åŠ›å›å¾©ãƒ»ãƒ€ãƒ¡ãƒ¼ã‚¸é©ç”¨
    if (player.hunger >= maxStats.hunger) { player.health += 0.5; player.morale += 1; }
    if (player.thirst >= maxStats.thirst) { player.health += 0.5; player.morale += 1; }
    if (totalTurnDamage > 0) player.health -= totalTurnDamage;

    // ä½“è‡­ã®å¢—åŠ 
    let bodyOdorIncrease = 1.5;
    if (player.bodyTemp > 37.5) bodyOdorIncrease += 0.5;
    if (player.equipment.some(e => e.type === 'clothing' && e.wetness === 'soaking_wet')) bodyOdorIncrease += 0.5;
    player.bodyOdor += bodyOdorIncrease;
    // â˜…â˜…â˜…ã“ã“ã‹ã‚‰ãŒé®ç—›å‰¤ã®åŠ¹æœã«é–¢ã™ã‚‹æ–°ã—ã„ãƒ­ã‚¸ãƒƒã‚¯ã§ã™â˜…â˜…â˜…
    if (player.painkillerEffectTurns > 0) {
        const painkillerRecovery = 15; // é®ç—›å‰¤ã«ã‚ˆã‚‹å›å¾©é‡
        player.painTolerance += painkillerRecovery;
        player.painkillerEffectTurns--;

        if (player.painkillerEffectTurns === 0) {
            log(getString("log_painkiller_wore_off"), false);
        }
    }
    // â˜…â˜…â˜…é®ç—›å‰¤ãƒ­ã‚¸ãƒƒã‚¯ã“ã“ã¾ã§â˜…â˜…â˜…
    // â˜…â˜…â˜…ã“ã“ã‹ã‚‰ãŒç—›ã¿è€æ€§ã«é–¢ã™ã‚‹æ–°ã—ã„ãƒ­ã‚¸ãƒƒã‚¯ã§ã™â˜…â˜…â˜…
    let painSourceCount = 0;
    // æ²»ç™‚ä¸­ã§ãªã„è² å‚·ã‚’æ•°ãˆã‚‹
    player.injuries.forEach(injury => {
        if (injury.type === 'bruise') painSourceCount++;
        if (injury.type === 'bleeding' && (!injury.treating_duration || injury.treating_duration <= 0)) painSourceCount++;
        if (injury.type === 'fracture' && !injury.splinted) painSourceCount++;
    });
    // æ²»ç™‚ä¸­ã§ãªã„ç—…æ°—ã‚’æ•°ãˆã‚‹
    player.sicknesses.forEach(sickness => {
        // â˜…â˜…â˜… ã“ã®ãƒªã‚¹ãƒˆã« 'food_poisoning' ã¨ 'itch' ã‚’è¿½åŠ  â˜…â˜…â˜…
        if (['infection', 'fever', 'diarrhea', 'food_poisoning', 'itch'].includes(sickness.type) && (!sickness.medicated_duration || sickness.medicated_duration <= 0)) {
            painSourceCount++;
        }
    });

    if (painSourceCount > 0) {
        // ç—›ã¿ã®åŸå› ãŒã‚ã‚‹å ´åˆã€è€æ€§ã‚’æ¸›å°‘ã•ã›ã‚‹
        const toleranceLoss = 1.0 * painSourceCount;
        player.painTolerance -= toleranceLoss;
    } else {
        // ç—›ã¿ã®åŸå› ãŒãªã„å ´åˆã€è‡ªç„¶å›å¾©ã•ã›ã‚‹
        if (player.painTolerance < maxStats.painTolerance) {
            const naturalRecoveryRate = 0.25;
            player.painTolerance += naturalRecoveryRate;
        }
    }
    // â˜…â˜…â˜…ã“ã“ã‹ã‚‰ãŒè¡€æ¶²é‡æ¸›å°‘æ€§ã‚·ãƒ§ãƒƒã‚¯ã®ãƒ­ã‚¸ãƒƒã‚¯ã§ã™â˜…â˜…â˜…
    if (player.bloodLevel <= 10) {
        if (player.hypovolemicShockTimer === undefined || player.hypovolemicShockTimer < 0) {
            // ã‚·ãƒ§ãƒƒã‚¯çŠ¶æ…‹ã®é–‹å§‹
            player.hypovolemicShockTimer = Math.floor(Math.random() * 2) + 2; // 2ã€œ3ã‚¿ãƒ¼ãƒ³ã®çŒ¶äºˆ
        } else {
            // ã‚·ãƒ§ãƒƒã‚¯çŠ¶æ…‹ã®ç¶™ç¶š
            player.hypovolemicShockTimer--;
        }

        if (player.hypovolemicShockTimer === 0) {
            const causeMessage = getString("log_game_over_hypovolemic_shock");
            const gameOverMessage = getString("log_game_over_reason", { reason: causeMessage });
            speak(gameOverMessage + " " + getString("log_game_over_title"));
            handleGameOver(gameOverMessage);
            return; // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ãªã®ã§ä»¥é™ã®å‡¦ç†ã¯ä¸è¦
        }
    } else {
        // è¡€æ¶²é‡ãŒ10ã‚’è¶…ãˆãŸã‚‰ã‚¿ã‚¤ãƒãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
        player.hypovolemicShockTimer = -1;
    }
    // â˜…â˜…â˜…ã“ã“ã‹ã‚‰ãŒæ–°ã—ã„å…ç–«ç³»ãƒ­ã‚¸ãƒƒã‚¯ã§ã™â˜…â˜…â˜…
    let immuneSystemStressors = 0;
    // æ²»ç™‚ã—ã¦ã„ãªã„è² å‚·ã‚’æ•°ãˆã‚‹
    player.injuries.forEach(injury => {
        if (injury.type === 'bleeding' && (!injury.treating_duration || injury.treating_duration <= 0)) immuneSystemStressors++;
        if (injury.type === 'fracture' && !injury.splinted) immuneSystemStressors++;
    });
    // æ²»ç™‚ã—ã¦ã„ãªã„ç—…æ°—ã‚’æ•°ãˆã‚‹
    player.sicknesses.forEach(sickness => {
        if (['food_poisoning', 'diarrhea', 'fever', 'infection'].includes(sickness.type) && (!sickness.medicated_duration || sickness.medicated_duration <= 0)) {
            immuneSystemStressors++;
        }
    });

if (immuneSystemStressors > 0) {
        // å…ç–«ç³»ã¸ã®è² è·ãŒã‚ã‚‹å ´åˆã€æ•°å€¤ã‚’æ¸›å°‘ã•ã›ã‚‹
        const immuneSystemLoss = 1.0 * immuneSystemStressors;
        player.immuneSystem -= immuneSystemLoss;
    } else {
        // è² è·ãŒãªã„å ´åˆã€è‡ªç„¶å›å¾©ã•ã›ã‚‹
        if (player.immuneSystem < maxStats.immuneSystem) {
            player.immuneSystem += 0.25; // åŸºæœ¬çš„ãªè‡ªç„¶å›å¾©
        }
    }
    // â˜…â˜…â˜…å…ç–«ç³»ãƒ­ã‚¸ãƒƒã‚¯ã“ã“ã¾ã§â˜…â˜…â˜…

    // å…¨ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ä¸Šé™/ä¸‹é™å†…ã«åã‚ã‚‹
    Object.keys(player).forEach(key => {
        if (['hunger', 'thirst', 'health', 'morale', 'sleep', 'bodyOdor', 'carbs', 'protein', 'fat', 'vitamins', 'bloodLevel'].includes(key)) {
            player[key] = Math.max(0, Math.min(maxStats[key] || 100, player[key]));
        }
    });
    
    // ã‚¢ã‚¤ãƒ†ãƒ ã®çŠ¶æ…‹æ›´æ–°ï¼ˆé®®åº¦ã€è€ä¹…åº¦ã€æ°´ã®å¤‰åŒ–ï¼‰
    [...player.inventory, ...player.equipment].forEach(item => {
        if (item.type === "consumable" && item.freshness !== undefined) item.freshness = Math.max(0, item.freshness - 2);
        if (item.type === 'container' && item.content) {
            if (item.content.name === 'ç¶ºéº—ãªãŠæ¹¯') {
                const cleanWaterTemplate = items.find(i => i.name === 'ãã‚Œã„ãªæ°´');
                if(cleanWaterTemplate) item.content = { ...cleanWaterTemplate };
                log(getString("log_hot_water_cooled", { containerName: getItemDisplayName(item) }));
            }
        }
    });

    if (!player.isInside && !player.isInShelter) {
        const equipmentToCheck = [...player.equipment];
        equipmentToCheck.forEach(item => {
            if (item.type === 'clothing') {
                if (currentWeather.id === 'stormy' || currentWeather.id === 'rainy') {
                    reduceItemDurability(item, 0.5);
                }
            }
        });
    }

    // UIæ›´æ–°
    updateEquippedStats();
    updateItemPanels();
    updateItemDetailPanel();
    generateWeatherAndTemperature();
}
// â–¼â–¼â–¼ ä»¥ä¸‹ã®æ–°ã—ã„é–¢æ•°ã‚’ <script> ã‚¿ã‚°å†…ã«ä¸¸ã”ã¨è¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
/**
 * åŸºæœ¬ç¢ºç‡ã¨ç¾åœ¨ã®å…ç–«åŠ›ã«åŸºã¥ã„ã¦ã€å®Ÿéš›ã®ç—…æ°—ç™ºç—‡ç¢ºç‡ã‚’è¨ˆç®—ã™ã‚‹
 * @param {number} baseChance - ç—…æ°—ã®åŸºæœ¬çš„ãªç™ºç—‡ç¢ºç‡ (0.0 ã‹ã‚‰ 1.0)
 * @returns {number} - å…ç–«åŠ›ã«ã‚ˆã£ã¦è£œæ­£ã•ã‚ŒãŸæœ€çµ‚çš„ãªç™ºç—‡ç¢ºç‡
 */
function calculateSicknessChance(baseChance) {
    // å…ç–«åŠ›ãŒ100ã®å ´åˆã€ç™ºç—‡ç‡ã¯åŠåˆ†ã«ã€‚å…ç–«åŠ›ãŒ0ã®å ´åˆã€ç™ºç—‡ç‡ã¯1.5å€ã«ãªã‚‹ã‚ˆã†ã«èª¿æ•´ã€‚
    const immuneSystemModifier = 1.5 - (player.immuneSystem / 100);
    return baseChance * immuneSystemModifier;
}

function updateItemDetailPanel() {
    if (currentItemDetail) {
        let updatedItem, itemIndex = currentItemDetail.index, itemSource = currentItemDetail.source;
        if (itemSource === 'inventory') updatedItem = player.inventory[itemIndex];
        else if (itemSource === 'equipment') updatedItem = player.equipment[itemIndex];
        else if (itemSource === 'dropped') updatedItem = (droppedItems[`${player.x},${player.y}`] || [])[itemIndex];
        else if (itemSource === 'placed') updatedItem = placedObjects.find(o => o.x === currentItemDetail.coords.x && o.y === currentItemDetail.coords.y);

        if (updatedItem) {
            if (itemSource === 'placed') showPlacedObjectDetail(updatedItem);
            else showItemDetail(updatedItem, itemIndex, itemSource);
        } else hideItemDetail();
    }
}
// â–¼â–¼â–¼ æ—¢å­˜ã®`generateNPC`é–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function generateNPC(typeFilter) {
    let templates = npcTemplates;
    if (typeof typeFilter === 'string') {
        templates = npcTemplates.filter(t => t.type === typeFilter);
    } else if (Array.isArray(typeFilter)) {
        templates = npcTemplates.filter(t => typeFilter.includes(t.type));
    }
    if (templates.length === 0) templates = npcTemplates;

    const template = JSON.parse(JSON.stringify(randChoice(templates)));
    const npc = { ...template, inventory: [], equipment: [], traits: [], stance: 'standing', isDodging: false, vulnerableTurns: 0, sprintCooldown: 0, stunnedTurns: 0, recoilTurns: 0, injuries: [], heavyAttackCooldown: 0 };
    npc.health = Math.floor(npc.health * (0.9 + Math.random() * 0.2));
    npc.maxHealth = npc.health;

    if (npc.type === 'Survivor' || npc.type === 'Trader') {
        npc.isCurious = Math.random() < 0.4;
        npc.isAggressive = Math.random() < 0.2;
    } else if (npc.type === 'Raider') {
        npc.isCurious = false;
        npc.isAggressive = Math.random() < 0.5;
    } else {
        npc.isCurious = false;
        npc.isAggressive = false;
    }
    npc.approachCooldown = 0;

    const equipItemCount = Math.floor(Math.random() * 3);
     for(let i=0; i<equipItemCount; i++) {
        const equipableItems = items.filter(item => (item.type === "equipment" || item.type === "clothing") && (!item.tags || !item.tags.includes(NO_LOOT_TAG)));
        if(equipableItems.length === 0) continue;
        const itemTemplate = randChoice(equipableItems);
        const newItem = createItemInstance(itemTemplate);
        newItem.durability = Math.max(20, Math.floor(Math.random() * 80) + 20);
        if (!npc.equipment.some(e => e.slot === newItem.slot)) npc.equipment.push(newItem);
    }

    const equippedGun = npc.equipment.find(e => e.ammoType);
    if (equippedGun && Math.random() < 0.75) {
        const ammoTemplate = items.find(i => i.type === 'ammo' && i.ammoType === equippedGun.ammoType);
        if (ammoTemplate) {
            const ammoCount = Math.floor(Math.random() * 3) + 1;
            for (let i = 0; i < ammoCount; i++) {
                npc.inventory.push({ ...ammoTemplate });
            }
        }
    }

    const invItemCount = Math.floor(Math.random() * 3) + 1;
    for(let i=0; i<invItemCount; i++) {
        const itemTemplate = randChoice(items.filter(item => (!item.tags || !item.tags.includes(NO_LOOT_TAG))));
        let newItem = createItemInstance(itemTemplate);
        if (newItem.type === "consumable") newItem.freshness = Math.max(20, Math.floor(Math.random() * 80) + 20);
        else if (newItem.type === "equipment" || newItem.type === "clothing") newItem.durability = Math.max(20, Math.floor(Math.random() * 80) + 20);
        else if (newItem.type === 'container') {
             const waterType = randChoice(['clean', 'dirty', null]);
             if (waterType === 'clean') newItem.content = { type: 'clean', freshness: Math.floor(Math.random() * 50) + 50 };
             else if (waterType === 'dirty') newItem.content = { type: 'dirty' };
        }
        npc.inventory.push(newItem);
    }
    
    if (Math.random() < 0.2) {
        if (Math.random() < 0.5) {
            npc.traits.push("ç›®ãŒã„ã„");
            npc.visionRange += 1;
        } else {
            npc.traits.push("ç›®ãŒæ‚ªã„");
            npc.visionRange -= 1;
        }
    }
    
    // â˜…â˜…â˜… ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â˜…â˜…â˜…
    // updateNpcStatsé–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã€NPCã®å…¨ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’åˆæœŸåŒ–ãƒ»è¨ˆç®—
    updateNpcStats(npc);
    // â˜…â˜…â˜… ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â˜…â˜…â˜…
    
    return npc;
}
// index.htmlå†…
function exploreTile() {
    if (isInteractionActive || player.health <= 0) {
        return;
    }

    const entityOnTile = entities.find(e => e.x === player.x && e.y === player.y);

    if (entityOnTile) {
        if (entityOnTile.isZombie || entityOnTile.type === 'Raider' || (entityOnTile.isAnimal && !entityOnTile.flees)) {
            log(getString("log_npc_encounter", { npcName: getString(`item_${entityOnTile.name}_name`) || entityOnTile.name }));
            startCombat(entityOnTile);
        }
        else if (entityOnTile.type === 'Survivor' || entityOnTile.type === 'Trader') {
            currentNPC = entityOnTile;
            startNPCEncounter();
        }
        else if (entityOnTile.isAnimal && entityOnTile.flees) {
            const fleeTile = findSafeFleeTileForEntity(entityOnTile);
            if (fleeTile) {
                entityOnTile.x = fleeTile.x;
                entityOnTile.y = fleeTile.y;
            }
            log(`${getString(`item_${entityOnTile.name}_name`)}ã¯é€ƒã’å‡ºã—ãŸï¼`);
            updateCurrentLocationPanel(false);
        }
        return;
    }

    const corpseOnTile = placedObjects.find(p => p.x === player.x && p.y === player.y && p.type === 'corpse');
    if (corpseOnTile) {
        if (corpseOnTile.isHumanCorpse && corpseOnTile.unsearched) {
            log(getString("log_human_corpse_found"), true);
        } else if (corpseOnTile.isAnimalCorpse && corpseOnTile.unbutchered) {
            log(getString("log_animal_carcass_found"), true);
        }
    }
    
    // è‡ªå‹•ã§æ¢ç´¢ã™ã‚‹ã®ã§ã¯ãªãã€ç¾åœ¨ä½ç½®ãƒ‘ãƒãƒ«ã‚’æ›´æ–°ã—ã¦ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å…¥åŠ›ã‚’å¾…ã¤
    updateCurrentLocationPanel(false);
}
// â–¼â–¼â–¼ æ—¢å­˜ã® `searchCurrentLocation` é–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function searchCurrentLocation() {
    if (isStunnedByPain()) { return; } // â˜…â˜…â˜… ã“ã®è¡Œã‚’è¿½åŠ  â˜…â˜…â˜…
    if (isInteractionActive || player.health <= 0) {
        return;
    }

    let tile = map[player.y][player.x];
    const translatedLocationName = getString(tile.loc.nameKey);
    const locationKey = `${player.x},${player.y}`;
    if (!droppedItems[locationKey]) droppedItems[locationKey] = [];

    // â–¼â–¼â–¼ ã€ä¿®æ­£ç‚¹1ã€‘æ¢ç´¢æ¸ˆã¿ã‚¿ã‚¤ãƒ«ã‚’å†åº¦æ¢ç´¢ã§ããªã„ã‚ˆã†ã«ã™ã‚‹ãƒã‚§ãƒƒã‚¯ã‚’å¾©æ´»ã•ã›ã¾ã—ãŸ â–¼â–¼â–¼
    if (tile.searched) {
        log(getString("log_location_here_searched", { locationName: translatedLocationName }));
        updateCurrentLocationPanel(false);
        return;
    }
    
    log(getString("log_location_here", { locationName: translatedLocationName }));
    updateCurrentLocationPanel(false);

    let itemsFound = [];
    const itemReference = {
        stone: items.find(i => i.name === 'çŸ³'), branch: items.find(i => i.name === 'æ'),
        leaf: items.find(i => i.name === 'å¤§ããªè‘‰'),
        mushroom: items.find(i => i.name === 'ã‚­ãƒã‚³'),
        corn: items.find(i => i.name === 'ãƒˆã‚¦ãƒ¢ãƒ­ã‚³ã‚·'),
        potato: items.find(i => i.name === 'ã‚¸ãƒ£ã‚¬ã‚¤ãƒ¢'),
        carrot: items.find(i => i.name === 'ãƒ‹ãƒ³ã‚¸ãƒ³'),
        carrotSeeds: items.find(i => i.name === 'ãƒ‹ãƒ³ã‚¸ãƒ³ã®ç¨®'),
        cabbageSeeds: items.find(i => i.name === 'ã‚­ãƒ£ãƒ™ãƒ„ã®ç¨®'),
        potatoSeeds: items.find(i => i.name === 'ã‚¸ãƒ£ã‚¬ã‚¤ãƒ¢ã®ç¨®'),
        clothScrap: items.find(i => i.name === 'å¸ƒåˆ‡ã‚Œ')
    };

    // --- è‡ªç„¶ç’°å¢ƒã§ã®ã‚¢ã‚¤ãƒ†ãƒ ç™ºè¦‹ãƒ­ã‚¸ãƒƒã‚¯ (æã€çŸ³ã€ã‚­ãƒã‚³ãªã©) ---
    if (tile.loc.nameKey === 'location_rock') {
        if (Math.random() < 0.8) itemsFound.push({ ...itemReference.stone });
    } else if (tile.loc.nameKey === 'location_untilled_field') {
        if (Math.random() < 0.3) itemsFound.push({ ...itemReference.corn });
        if (Math.random() < 0.3) itemsFound.push({ ...itemReference.potato });
        if (Math.random() < 0.3) itemsFound.push({ ...itemReference.carrot });
        if (Math.random() < 0.1) itemsFound.push({ ...itemReference.carrotSeeds });
        if (Math.random() < 0.1) itemsFound.push({ ...itemReference.cabbageSeeds });
        if (Math.random() < 0.1) itemsFound.push({ ...itemReference.potatoSeeds });
    } else if (tile.biome === 'Forest') {
        if (Math.random() < 0.7) itemsFound.push({ ...itemReference.leaf });
        if (Math.random() < 0.6) itemsFound.push({ ...itemReference.branch });
        if (Math.random() < 0.4) itemsFound.push({ ...itemReference.stone });
        if (Math.random() < 0.2) itemsFound.push({ ...itemReference.mushroom });
    } else if (tile.biome === 'Plains') {
        if (Math.random() < 0.4) itemsFound.push({ ...itemReference.leaf });
        if (Math.random() < 0.3) itemsFound.push({ ...itemReference.branch });
        if (Math.random() < 0.2) itemsFound.push({ ...itemReference.stone });
        const aloeTemplate = items.find(i => i.name === 'ã‚¢ãƒ­ã‚¨');
        if (aloeTemplate && Math.random() < 0.2) itemsFound.push({ ...aloeTemplate });
    }

    // â–¼â–¼â–¼ ã€ä¿®æ­£ç‚¹2ã€‘å±‹å¤–ã§ã‚‚ä¸€èˆ¬çš„ãªã‚¢ã‚¤ãƒ†ãƒ ãŒè¦‹ã¤ã‹ã‚‹ç¢ºç‡åˆ¤å®šã‚’ã“ã“ã«æ®‹ã—ã¾ã™ â–¼â–¼â–¼
    if (Math.random() * 100 < tile.loc.loot) {
        let lootableItems = items.filter(i => (!i.tags || !i.tags.includes(NO_LOOT_TAG)) && i.type !== 'ammo');
        if (lootableItems.length > 0) {
            let newItem = {...randChoice(lootableItems)};
            
            if (newItem.type === 'container') {
                newItem.content = null;
            } else if (newItem.type === "consumable" && newItem.freshness !== undefined) {
                newItem.freshness = Math.max(10, Math.floor(Math.random() * 90) + 10);
            } else if ((newItem.type === "equipment" || newItem.type === "clothing" || newItem.type === "tool") && newItem.durability !== undefined) {
                newItem.durability = Math.max(10, Math.floor(Math.random() * 90) + 10);
            }
            itemsFound.push(newItem);
        }
    }
    
    if (itemsFound.length > 0) {
        itemsFound.forEach(item => droppedItems[locationKey].push(item));
        updateCurrentLocationPanel(false);
    } else {
        log(getString("info_found_nothing"), false);
    }
    createSound(player.x, player.y, 3);
    
    // â–¼â–¼â–¼ ã€ä¿®æ­£ç‚¹3ã€‘ã‚¿ã‚¤ãƒ«ã‚’ã€Œæ¢ç´¢æ¸ˆã¿ã€ã«ã™ã‚‹å‡¦ç†ã‚’ç¢ºå®Ÿã«å®Ÿè¡Œã—ã¾ã™ â–¼â–¼â–¼
    tile.searched = true;

    snapshotStats();
    advanceTurn();
    updateTurnInfo();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    checkGameOver();
    processSpeechQueue();
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function showConditionTooltip(event, conditionType) {
    const preview = document.getElementById("statusPreview");
    
    // åŸºæœ¬æƒ…å ±ã‚’å–å¾—
    const title = getString(`condition_${conditionType}_title`);
    const description = getString(`condition_${conditionType}_desc`);
    
    // è©³ç´°ãªåŠ¹æœã¨å¯¾å‡¦æ³•ã‚’å–å¾—
    const effectText = getString(`injury_effect_${conditionType}`);
    const treatmentText = getString(`injury_treatment_${conditionType}`);

    // è¡¨ç¤ºç”¨ã®HTMLã‚’çµ„ã¿ç«‹ã¦ã‚‹
    let contentHtml = `<strong>${title}</strong>`;
    contentHtml += `<div style="margin-top: 5px; border-top: 1px solid #555; padding-top: 5px;">${description}</div>`;
    
    // åŠ¹æœãƒ†ã‚­ã‚¹ãƒˆãŒå­˜åœ¨ã™ã‚Œã°è¡¨ç¤ºï¼ˆç¿»è¨³ã‚­ãƒ¼ãŒãªã„å ´åˆã¯éè¡¨ç¤ºï¼‰
    if (effectText !== `injury_effect_${conditionType}`) {
        contentHtml += `<div style="margin-top: 8px;">`;
        contentHtml += `<strong>${getString("tooltip_label_effect")}:</strong> <span style="color: #e74c3c;">${effectText}</span>`;
        contentHtml += `</div>`;
    }

    // å¯¾å‡¦æ³•ãƒ†ã‚­ã‚¹ãƒˆãŒå­˜åœ¨ã™ã‚Œã°è¡¨ç¤º
    if (treatmentText !== `injury_treatment_${conditionType}`) {
        contentHtml += `<div style="margin-top: 5px;">`;
        contentHtml += `<strong>${getString("tooltip_label_treatment")}:</strong> <span style="color: #27ae60;">${treatmentText}</span>`;
        contentHtml += `</div>`;
    }

    preview.innerHTML = contentHtml;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã®ã™ãä¸‹ã«ã€æ–°ã—ã„é–¢æ•°ã‚’è¿½åŠ ã—ã¾ã™ â–¼â–¼â–¼
function showNormalConditionTooltip(event) {
    const preview = document.getElementById("statusPreview");
    const title = getString("condition_level_normal_title");
    const description = getString("condition_level_normal_desc");
    
    preview.innerHTML = `<strong>${title}</strong><div style="margin-top: 5px;">${description}</div>`;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}
// â–²â–²â–² ã“ã“ã¾ã§è¿½åŠ  â–²â–²â–²

/**
 * èº«ä½“ãƒ‘ãƒãƒ«ã®æ€ªæˆ‘ã‚¢ã‚¤ã‚³ãƒ³ã«ã‚«ãƒ¼ã‚½ãƒ«ã‚’åˆã‚ã›ãŸéš›ã«ã€ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã‚’è¡¨ç¤ºã™ã‚‹
 * @param {MouseEvent} event - ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
 * @param {object} injury - å¯¾è±¡ã®æ€ªæˆ‘ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
 */
function showInjuryTooltip(event, injury) {
    const preview = document.getElementById("statusPreview");
    
    // éª¨æŠ˜ã‹ã¤æ·»ãˆæœ¨ãŒã—ã¦ã‚ã‚‹å ´åˆã¯ã€'splinted_fracture' ã‚¿ã‚¤ãƒ—ã¨ã—ã¦æ‰±ã†
    const tooltipType = (injury.type === 'fracture' && injury.splinted) ? 'splinted_fracture' : injury.type;

    // JSONã‹ã‚‰å„ç¨®ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—
    const title = getString(`condition_${tooltipType}_title`);
    const description = getString(`condition_${tooltipType}_desc`);
    const effectText = getString(`injury_effect_${tooltipType}`);
    const treatmentText = getString(`injury_treatment_${tooltipType}`);

    // è¡¨ç¤ºç”¨ã®HTMLã‚’çµ„ã¿ç«‹ã¦ã‚‹
    let contentHtml = `<strong>${title}</strong>`;
    contentHtml += `<div style="margin-top: 5px; border-top: 1px solid #555; padding-top: 5px;">${description}</div>`;
    
    if (effectText !== `injury_effect_${tooltipType}`) {
        contentHtml += `<div style="margin-top: 8px;">`;
        contentHtml += `<strong>${getString("tooltip_label_effect")}:</strong> <span class="stat-negative">${effectText}</span>`;
        contentHtml += `</div>`;
    }

    if (treatmentText !== `injury_treatment_${tooltipType}`) {
        contentHtml += `<div style="margin-top: 5px;">`;
        contentHtml += `<strong>${getString("tooltip_label_treatment")}:</strong> <span class="stat-positive">${treatmentText}</span>`;
        contentHtml += `</div>`;
    }

    preview.innerHTML = contentHtml;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}
function updatePhysicalCondition() {
    const conditionDiv = document.getElementById("physicalCondition");
    const healthPercent = (player.health / maxStats.health) * 100;
    const hungerPercent = (player.hunger / maxStats.hunger) * 100;
    const thirstPercent = (player.thirst / maxStats.thirst) * 100;
    const sleepPercent = (player.sleep / maxStats.sleep) * 100;
    const moralePercent = (player.morale / maxStats.morale) * 100;
    const bodyTemp = player.bodyTemp;
    
    let messageElements = [], conditionLevel = "normal";

    // --- éŸ³å£°å†ç”Ÿãƒ­ã‚¸ãƒƒã‚¯ (å¤‰æ›´ãªã—) ---
    const isCurrentlySleepy = sleepPercent < 50;
    const isCurrentlyHypothermic = bodyTemp < 35.5;
    const isCurrentlyThirsty = thirstPercent < 50;
    const isCurrentlyHungry = hungerPercent < 50;
    const isCurrentlyFeverish = player.sicknesses.some(s => s.type === 'fever');
    const isCurrentlyBleeding = player.injuries.some(i => i.type === 'bleeding');
    const isCurrentlyBruised = player.injuries.some(i => i.type === 'bruise');
    const isCurrentlyFractured = player.injuries.some(i => i.type === 'fracture');

    if (isCurrentlySleepy && !wasPreviouslySleepy) { playPlayerVoice('sounds/yawn.wav', 0.7); }
    if (isCurrentlyHypothermic && !wasPreviouslyHypothermic) { playPlayerVoice('sounds/shiver.wav', 0.6); }
    if (isCurrentlyThirsty && !wasPreviouslyThirsty) { playPlayerVoice('sounds/swallow.wav', 0.8); }
    if (isCurrentlyHungry && !wasPreviouslyHungry) { playPlayerVoice('sounds/rumble.wav', 0.5); }
    if (isCurrentlyFeverish && !wasPreviouslyFeverish) { playPlayerVoice('sounds/cough.wav', 0.7); }
    if (isCurrentlyBleeding && !wasPreviouslyBleeding) { playPlayerVoice('sounds/heartbeat.wav', 0.9); }
    if (isCurrentlyBruised && !wasPreviouslyBruised) { playPlayerVoice('sounds/grunt.wav', 0.8); }
    if (isCurrentlyFractured && !wasPreviouslyFractured) { playPlayerVoice('sounds/pain.wav', 0.9); }

    wasPreviouslySleepy = isCurrentlySleepy;
    wasPreviouslyHypothermic = isCurrentlyHypothermic;
    wasPreviouslyThirsty = isCurrentlyThirsty;
    wasPreviouslyHungry = isCurrentlyHungry;
    wasPreviouslyFeverish = isCurrentlyFeverish;
    wasPreviouslyBleeding = isCurrentlyBleeding;
    wasPreviouslyBruised = isCurrentlyBruised;
    wasPreviouslyFractured = isCurrentlyFractured;
    
    const addCondition = (textKey, tooltipType, level) => {
        messageElements.push(`<span onmouseenter="showConditionTooltip(event, '${tooltipType}')" onmouseleave="hideStatusPreview()" onmousemove="updatePreviewPosition(event)">${getString(textKey)}</span>`);
        if (level === 'critical') {
            conditionLevel = 'critical';
        } else if (level === 'warning' && conditionLevel === 'normal') {
            conditionLevel = 'warning';
        }
    };
    // â–¼â–¼â–¼ ãƒ‡ãƒãƒƒã‚°ã‚³ãƒ¼ãƒ‰ã‚’è¿½åŠ  â–¼â–¼â–¼
    if (currentEnemy) { // æˆ¦é—˜ä¸­ã®ã¿ãƒ­ã‚°ã‚’å‡ºåŠ›
        console.log(`ãƒ‡ãƒãƒƒã‚° [UIæ›´æ–°]: player.stunnedTurns = ${player.stunnedTurns}`);
    }
    // â–²â–²â–² ãƒ‡ãƒãƒƒã‚°ã“ã“ã¾ã§ â–²â–²â–²
if (player.stunnedTurns > 0) {
        addCondition("condition_stunned_title", 'stunned', 'critical');
    }

    // â˜…â˜…â˜…ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’è¿½åŠ â˜…â˜…â˜…
    if (player.hypovolemicShockTimer > 0) {
        addCondition("condition_hypovolemic_shock_title", 'hypovolemic_shock', 'critical');
    }
    // â˜…â˜…â˜…è¿½åŠ ã“ã“ã¾ã§â˜…â˜…â˜…
    // â˜…â˜…â˜…ã“ã“ã‹ã‚‰ãŒç—›ã¿è€æ€§ä½ä¸‹ã«ã‚ˆã‚‹çŠ¶æ…‹è¡¨ç¤ºã®è¿½åŠ ç®‡æ‰€ã§ã™â˜…â˜…â˜…
    const painTolerancePercent = (player.painTolerance / maxStats.painTolerance) * 100;
    if (painTolerancePercent < 33.3) {
        addCondition("condition_severe_pain_title", 'severe_pain', 'critical');
    } else if (painTolerancePercent < 66.7) {
        addCondition("condition_mild_pain_title", 'mild_pain', 'warning');
    }
    // --- ã“ã“ã‹ã‚‰å…¨ã¦ã®ç—‡çŠ¶åˆ¤å®šã‚’ä¿®æ­£ ---
    if (healthPercent < 20) { addCondition("condition_critical_health_title", 'critical_health', 'critical'); }
    
    if (bodyTemp < 34.5) { addCondition("condition_severe_hypothermia_title", 'severe_hypothermia', 'critical'); } 
    else if (bodyTemp < 35.5) { addCondition("condition_hypothermia_title", 'hypothermia', 'warning'); }
    
    if (bodyTemp > 38.5) { addCondition("condition_high_fever_title", 'high_fever', 'critical'); } 
    else if (bodyTemp > 37.5) { addCondition("condition_mild_fever_title", 'mild_fever', 'warning'); }

    if (hungerPercent < 20) { addCondition("condition_starving_title", 'starving', 'critical'); } 
    else if (hungerPercent < 50) { addCondition("condition_hungry_title", 'hungry', 'warning'); }

    if (thirstPercent < 20) { addCondition("condition_dehydrated_title", 'dehydrated', 'critical'); } 
    else if (thirstPercent < 50) { addCondition("condition_thirsty_title", 'thirsty', 'warning'); }

    if (sleepPercent < 20) { addCondition("condition_extremely_sleepy_title", 'extremely_sleepy', 'critical'); } 
    else if (sleepPercent < 50) { addCondition("condition_sleepy_title", 'sleepy', 'warning'); }
    
    if (moralePercent < 20) { addCondition("condition_despair_title", 'despair', 'critical'); }
    
    player.injuries.forEach(injury => {
        if (injury.type === 'bleeding') {
            const textKey = injury.treating_duration > 0 ? "condition_bleeding_treating_title" : "condition_bleeding_title";
            addCondition(textKey, 'bleeding', 'critical');
        } else if (injury.type === 'bruise') {
            addCondition("condition_bruise_title", 'bruise', 'warning');
        } else if (injury.type === 'fracture') {
            const textKey = injury.splinted ? "condition_splinted_fracture_title" : "condition_fracture_title";
            const type = injury.splinted ? "splinted_fracture" : "fracture";
            addCondition(textKey, type, 'critical');
        }
    });
    // â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ–°ã—ãè¿½åŠ  â–¼â–¼â–¼
    player.injuries.forEach(injury => {
        if (injury.type === 'sore_feet') {
            addCondition("condition_sore_feet_title", 'sore_feet', 'warning');
        } else if (injury.type === 'injured_feet') {
            addCondition("condition_injured_feet_title", 'injured_feet', 'critical');
        }
    });
    // â–²â–²â–² è¿½åŠ ã¯ã“ã“ã¾ã§ â–²â–²â–²

player.sicknesses.forEach(sickness => {
        // â˜…â˜…â˜… ã“ã®è¡Œã‚’ä¿®æ­£ â˜…â˜…â˜…
        const level = (sickness.type === 'fever' || sickness.type === 'vomiting' || sickness.type === 'sepsis') ? 'critical' : 'warning';
        let textKey;
        if (sickness.medicated_duration > 0) {
            textKey = `condition_${sickness.type}_treating_title`;
        } else {
            textKey = `condition_${sickness.type}_title`;
        }
        addCondition(textKey, sickness.type, level);
    });

    if (messageElements.length === 0) {
        conditionDiv.innerHTML = `<strong>${getString("physical_condition_title")}:</strong><span class="condition-normal" onmouseenter="showNormalConditionTooltip(event)" onmouseleave="hideStatusPreview()" onmousemove="updatePreviewPosition(event)">${getString("condition_level_normal")}</span>`;
    } else {
        conditionDiv.innerHTML = `<strong>${getString("physical_condition_title")}:</strong><span class="condition-${conditionLevel}">${messageElements.join(", ")}</span>`;
    }
}

function logStatChanges(before, after) {
    // å†…éƒ¨çš„ãªã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åã¨ã€ç¿»è¨³ç”¨ã®ã‚­ãƒ¼ã‚’å¯¾å¿œä»˜ã‘ã‚‹
    const statsToCheck = {
        health: "status_health",
        hunger: "status_hunger",
        thirst: "status_thirst",
        morale: "status_morale",
        sleep: "status_sleep",
        bodyTemp: "status_body_temp"
    };

    for (const stat in statsToCheck) {
        const beforeVal = Math.round(before[stat]);
        const afterVal = Math.round(after[stat]);
        const delta = afterVal - beforeVal;

        if (delta !== 0) {
            // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åã‚’ç¾åœ¨ã®è¨€èªã«ç¿»è¨³
            const translatedStatName = getString(statsToCheck[stat]);
            
            // å¢—æ¸›ã«å¿œã˜ã¦ä½¿ç”¨ã™ã‚‹ç¿»è¨³ã‚­ãƒ¼ã‚’æ±ºå®š
            const logKey = delta > 0 ? "log_stat_increase" : "log_stat_decrease";
            
            // ç¿»è¨³ã‚­ãƒ¼ã¨å€¤ã‚’ä½¿ã£ã¦ã€å®Œå…¨ã«ç¿»è¨³ã•ã‚ŒãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç”Ÿæˆã—ã¦ãƒ­ã‚°ã«å‡ºåŠ›
            log(getString(logKey, { 
                statName: translatedStatName, 
                amount: Math.abs(delta) 
            }));
        }
    }
}
/**
 * ã‚²ãƒ¼ã‚¸ã®ç¾åœ¨å€¤ã¨æœ€å¤§å€¤ã«åŸºã¥ã„ã¦ã€é©ç”¨ã™ã‚‹CSSã‚¯ãƒ©ã‚¹åã‚’è¿”ã™
 * @param {number} currentValue - ç¾åœ¨ã®å€¤
 * @param {number} maxValue - æœ€å¤§å€¤
 * @param {boolean} [isReversed=false] - å€¤ãŒé«˜ã„ã»ã©æ‚ªã„ã‚²ãƒ¼ã‚¸ï¼ˆé‡é‡ãªã©ï¼‰ã‹ã©ã†ã‹
 * @returns {string} - 'status-high', 'status-mid', 'status-low' ã®ã„ãšã‚Œã‹
 */
function getBarColorClass(currentValue, maxValue, isReversed = false) {
    if (maxValue <= 0) return 'status-low';
    const percent = (currentValue / maxValue) * 100;

    let highThreshold = 70;
    let lowThreshold = 30;

    if (isReversed) {
        if (percent < lowThreshold) return 'status-high';
        if (percent < highThreshold) return 'status-mid';
        return 'status-low';
    } else {
        if (percent > highThreshold) return 'status-high';
        if (percent > lowThreshold) return 'status-mid';
        return 'status-low';
    }
}
function updateStatus() {
  function updateBar(idBar, idVal, val, maxVal, prevVal, statKey, isReversed = false) {
    const barElement = document.getElementById(idBar);
    const displayVal = Math.max(0, val || 0);
    const p = Math.min(1, displayVal / (maxVal || 1));
    barElement.style.width = (p * 100) + "%";

// --- Color and Blinking Logic ---
    const colorClass = getBarColorClass(displayVal, maxVal, isReversed);
    const barFrameElement = barElement.parentElement; // Get the .bar container

    barElement.className = 'fill'; // Reset fill classes
    barElement.classList.add(colorClass);

    barFrameElement.classList.remove('blinking'); // Always remove first
    if (colorClass === 'status-low') {
        barFrameElement.classList.add('blinking');
    }
    let deltaText = "";
    if (prevVal && prevVal[statKey] !== undefined) {
        const delta = Math.round(val - prevVal[statKey]);
        if (delta !== 0) deltaText = ` <span style="color:${delta > 0 ? 'limegreen' : 'indianred'}; font-weight:bold;">(${delta > 0 ? '+' : ''}${delta})</span>`;
    }
    document.getElementById(idVal).innerHTML = `${displayVal.toFixed(0)} / ${(maxVal || 0).toFixed(0)}${deltaText}`;
  }

  function updateValue(idVal, val, prevVal, suffix = '', precision = 0, statKey) {
    const valElem = document.getElementById(idVal);
    let deltaText = "";
    if (prevVal && prevVal[statKey] !== undefined) {
        const delta = parseFloat(val.toFixed(precision + 1)) - parseFloat(prevVal[statKey].toFixed(precision + 1));
        if (Math.abs(delta) > (precision === 0 ? 0.5 : 0)) deltaText = ` <span style="color:${delta > 0 ? 'limegreen' : 'indianred'}; font-weight:bold;">(${delta > 0 ? '+' : ''}${delta.toFixed(precision)})</span>`;
    }
    valElem.innerHTML = `${val.toFixed(precision)}${suffix}${deltaText}`;
  }

  updateBar("healthBar", "healthVal", player.health, maxStats.health, playerStatsBeforeAction, 'health');
  updateBar("hungerBar", "hungerVal", player.hunger, maxStats.hunger, playerStatsBeforeAction, 'hunger');
  updateBar("thirstBar", "thirstVal", player.thirst, maxStats.thirst, playerStatsBeforeAction, 'thirst');
  updateBar("moraleBar", "moraleVal", player.morale, maxStats.morale, playerStatsBeforeAction, 'morale');
  updateBar("sleepBar", "sleepVal", player.sleep, maxStats.sleep, playerStatsBeforeAction, 'sleep');
  
  const sleepBtn = document.getElementById("sleepNowBtn");

  // ãƒœã‚¿ãƒ³ãŒå¸¸ã«è¡¨ç¤ºã•ã‚Œã‚‹ã‚ˆã†ã«ã—ã€çŠ¶æ…‹ã«å¿œã˜ã¦ç„¡åŠ¹åŒ–/æœ‰åŠ¹åŒ–ã‚’åˆ‡ã‚Šæ›¿ãˆã¾ã™
  sleepBtn.style.display = 'block';
  sleepBtn.disabled = (player.sleep >= maxStats.sleep || isInteractionActive);
  
  const bodyTempBar = document.getElementById("bodyTempBar");
  const minTemp = 34.0, maxTemp = 41.0, normalRangeMin = 36.0, normalRangeMax = 37.5;
  const pTemp = (player.bodyTemp - minTemp) / (maxTemp - minTemp);
  bodyTempBar.style.width = (pTemp * 100) + "%";
  updateValue("bodyTempVal", player.bodyTemp, playerStatsBeforeAction, 'Â°C', 1, 'bodyTemp');
  
  // --- Special color logic for Body Temperature ---
  bodyTempBar.classList.remove('status-high', 'status-mid', 'status-low', 'blinking');
  if (player.bodyTemp < normalRangeMin || player.bodyTemp > normalRangeMax) {
      const isCritical = player.bodyTemp < 35.0 || player.bodyTemp > 38.5;
      bodyTempBar.classList.add(isCritical ? 'status-low' : 'status-mid');
      if (isCritical) {
          bodyTempBar.classList.add('blinking');
      }
  } else {
      bodyTempBar.classList.add('status-high');
  }
  
  updateBar("weightBar", "weightVal", player.weight, player.maxWeight, playerStatsBeforeAction, 'weight', true);
  updateBar("volumeBar", "volumeVal", player.volume, player.maxVolume, playerStatsBeforeAction, 'volume', true);
  
  // Attack and Defense don't need color changes based on value
  document.getElementById("attackBar").style.width = Math.min(1, player.attack / 50) * 100 + "%";
  document.getElementById("attackBar").style.backgroundColor = '#e67e22'; // Keep original color
  updateValue("attackVal", player.attack, playerStatsBeforeAction, '', 0, 'attack');
  document.getElementById("defenseBar").style.width = Math.min(1, player.defense / 50) * 100 + "%";
  document.getElementById("defenseBar").style.backgroundColor = '#2980b9'; // Keep original color
  updateValue("defenseVal", player.defense, playerStatsBeforeAction, '', 0, 'defense');
  
  updateBar("bodyOdorBar", "bodyOdorVal", player.bodyOdor, maxStats.bodyOdor, playerStatsBeforeAction, 'bodyOdor', true);
  // â–¼â–¼â–¼ ã“ã®3è¡Œã‚’è¿½åŠ  â–¼â–¼â–¼
  updateBar("bloodLevelBar", "bloodLevelVal", player.bloodLevel, maxStats.bloodLevel, playerStatsBeforeAction, 'bloodLevel');
  updateBar("immuneSystemBar", "immuneSystemVal", player.immuneSystem, maxStats.immuneSystem, playerStatsBeforeAction, 'immuneSystem');
  updateBar("painToleranceBar", "painToleranceVal", player.painTolerance, maxStats.painTolerance, playerStatsBeforeAction, 'painTolerance');
  // â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–² 
  updatePhysicalCondition();
  manageYawnEffect();
  manageShiverEffect();
  manageSwallowEffect();
  manageRumbleEffect();
  manageCoughEffect();
  manageHeartbeatEffect();
  manageGruntEffect();
  managePainEffect();
  manageFlySoundEffect();
  manageImpendingDoomVoice();
  manageInfectionEffect();
  manageItchEffect();
  
  updateBar("carbsBar", "carbsVal", player.carbs, maxStats.carbs, playerStatsBeforeAction, 'carbs');
  updateBar("proteinBar", "proteinVal", player.protein, maxStats.protein, playerStatsBeforeAction, 'protein');
  updateBar("fatBar", "fatVal", player.fat, maxStats.fat, playerStatsBeforeAction, 'fat');
  updateBar("vitaminsBar", "vitaminsVal", player.vitamins, maxStats.vitamins, playerStatsBeforeAction, 'vitamins');
  
  updateInjuryDisplay();
  
  manageLowHealthBGM();
  manageCriticalHealthHeartbeat();
}
// â–²â–²â–² `updateStatus` é–¢æ•°ã®ç½®ãæ›ãˆã“ã“ã¾ã§ â–²â–²â–²
/**
 * ã‹ã‚†ã¿åŠ¹æœéŸ³ã®é–‹å§‹ã¨åœæ­¢ã‚’ç®¡ç†ã™ã‚‹
 */
function manageItchEffect() {
    const hasItch = player.sicknesses.some(s => s.type === 'itch');

    if (hasItch && !itchTimer) {
        const initialDelay = (Math.random() * 10 + 5) * 1000; // 5ã€œ15ç§’å¾Œ
        itchTimer = setTimeout(playItchSoundAndScheduleNext, initialDelay);
    } else if (!hasItch && itchTimer) {
        clearTimeout(itchTimer);
        itchTimer = null;
    }
}

/**
 * ã‹ã‚†ã¿éŸ³ã‚’å†ç”Ÿã—ã€æ¬¡ã®å†ç”Ÿã‚’ä¸å®šæœŸã«ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã™ã‚‹
 */
function playItchSoundAndScheduleNext() {
    if (!player.sicknesses.some(s => s.type === 'itch')) {
        clearTimeout(itchTimer);
        itchTimer = null;
        return;
    }
    playSoundFile('sounds/itching.wav', 0.7);
    const nextDelay = (Math.random() * 30 + 20) * 1000; // 20ã€œ50ç§’å¾Œ
    itchTimer = setTimeout(playItchSoundAndScheduleNext, nextDelay);
}

function sleepForOneHour() {
    if (isStunnedByPain()) { return; } // â˜…â˜…â˜… ã“ã®è¡Œã‚’è¿½åŠ  â˜…â˜…â˜…
    interruptAndClearSpeech();
    if(isInteractionActive) return;
    const sleepingBag = placedObjects.find(o => o.type === 'sleeping_bag' && o.x === player.x && o.y === player.y);
    let sleepQuality = sleepingBag ? 2.0 : 0.5;
    // â–¼â–¼â–¼ ã“ã®è¡Œã®åŸºæœ¬å€¤ã‚’ 25 ã‹ã‚‰ 12 ã«å¤‰æ›´ â–¼â–¼â–¼
    let sleepAmount = 12 * sleepQuality;
    
    if (player.sleep >= maxStats.sleep) { 
        log(getString("log_no_need_to_sleep")); 
        processSpeechQueue();
        return; 
    }

    playSoundFile('sounds/sleep.wav');
    snapshotStats();
    // â˜…â˜…â˜…ã“ã®è¡Œã‚’è¿½åŠ â˜…â˜…â˜…
    // ç¡çœ ã«ã‚ˆã‚‹ç—›ã¿è€æ€§ã®å›å¾©ãƒœãƒ¼ãƒŠã‚¹ (ç¡çœ ã®è³ªã«å¿œã˜ã¦å¤‰å‹•)
    player.painTolerance += 2.0 * sleepQuality;
    player.immuneSystem += 1.0 * sleepQuality; // â˜…â˜…â˜… ã“ã®è¡Œã‚’è¿½åŠ  â˜…â˜…â˜…
    const campfireNearby = placedObjects.find(c => c.type === 'campfire' && Math.abs(c.x - player.x) <=1 && Math.abs(c.y - player.y) <= 1);
    const isProtected = sleepingBag || campfireNearby || player.isInside || player.isInShelter;
    const mosquitoChance = 0.6; 

    // â˜…â˜…â˜…ã“ã®è¡Œã‚’ä¿®æ­£â˜…â˜…â˜…
    if (!isProtected && Math.random() < calculateSicknessChance(mosquitoChance) && !player.sicknesses.some(s => s.type === 'itch')) {
        log(getString("log_mosquito_bite"), true);
        player.sicknesses.push({ type: 'itch', duration: 6 }); 
    } else {
        log(sleepingBag ? getString("log_sleep_in_bag") : getString("log_sleep_on_ground"));
    }

    // â–¼â–¼â–¼ æ–°ã—ã„ãƒ­ã‚¸ãƒƒã‚¯ â–¼â–¼â–¼
    if (player.injuries.some(i => i.type === 'fracture' && !i.splinted)) {
        sleepAmount *= 0.3; // éª¨æŠ˜ã®ç—›ã¿ã§ç¡çœ ã®å›å¾©é‡ãŒ70%æ¸›å°‘
        log(getString("log_sleep_fail_fracture"), false);
    }
    // â–²â–²â–² ã“ã“ã¾ã§ â–²â–²â–²

    player.sleep = Math.min(maxStats.sleep, player.sleep + sleepAmount);
    
    let healthRecovery = Math.round(2 * sleepQuality);
    if (player.protein < 25) {
        healthRecovery = 0;
        log(getString("log_protein_depleted_no_heal"), false);
    }

    if (player.sicknesses.some(s => s.type === 'itch')) {
        healthRecovery /= 2;
    }

    let moraleRecovery = Math.round(5 * sleepQuality);
    if (player.fat <= 0) {
        moraleRecovery /= 2;
        player.sleep /= 2;
    }

    player.health = Math.min(maxStats.health, player.health + healthRecovery);
    player.morale = Math.min(maxStats.morale, player.morale + moraleRecovery);

    player.hunger -= 1; player.thirst -= 1;
    logStatChanges(playerStatsBeforeAction, player);
    endPlayerTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    checkGameOver();
    updateTurnInfo();
    updateCurrentLocationPanel(false);
    processSpeechQueue();
}
// ã€1. ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã®è¿½åŠ ã€‘
// placedObjects ã®å®šç¾©ã®ä¸‹ã‚ãŸã‚Šã«ã€ä»¥ä¸‹ã®1è¡Œã‚’è¿½åŠ ã—ã¾ã™ã€‚
let previousVisionLevel = 0; // â˜…è¿½åŠ : å‰ã®ã‚¿ãƒ¼ãƒ³ã®è¦–ç•Œãƒ¬ãƒ™ãƒ«ã‚’è¨˜éŒ²
let isGameRunning = false; // ã‚²ãƒ¼ãƒ ãŒå®Ÿè¡Œä¸­ã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°
let speechQueue = []; // Holds messages waiting to be spoken.
let preCombatPanelStates = {}; // â˜…â˜…â˜… ã“ã®è¡Œã‚’è¿½åŠ  â˜…â˜…â˜…
let isNpcFootstepPlaying = false; // NPCã®è¶³éŸ³ãŒå†ç”Ÿä¸­ã‹ã‚’ç®¡ç†ã™ã‚‹ãƒ•ãƒ©ã‚°
let playerSeesEnemy = true;
let enemySeesPlayer = true;
let isSpeechQueueActive = false; // Prevents multiple speech processes from running at once.
// â–¼â–¼â–¼ ã“ã®ä¸‹ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ã€ä¸Šè¨˜ã®2è¡Œã®çœŸä¸‹ã«è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„ â–¼â–¼â–¼
/**
 * å³åº§ã«ç¾åœ¨ã®èª­ã¿ä¸Šã’ã‚’åœæ­¢ã—ã€å¾…æ©Ÿä¸­ã®ã‚­ãƒ¥ãƒ¼ã‚’ç©ºã«ã™ã‚‹é–¢æ•°
 */
function interruptAndClearSpeech() {
    speechSynthesis.cancel();
    speechQueue = [];
    isSpeechQueueActive = false;
}

/**
 * speechQueueï¼ˆèª­ã¿ä¸Šã’å¾…ã¡ãƒªã‚¹ãƒˆï¼‰ã‹ã‚‰ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é †ç•ªã«å‡¦ç†ã—ã¦èª­ã¿ä¸Šã’ã‚‹é–¢æ•°
 */
function processSpeechQueue() {
    // ã™ã§ã«èª­ã¿ä¸Šã’ä¸­ã‹ã€ã‚­ãƒ¥ãƒ¼ãŒç©ºã®å ´åˆã¯ä½•ã‚‚ã—ãªã„
    if (isSpeechQueueActive || speechQueue.length === 0) {
        return;
    }

    isSpeechQueueActive = true;
    const messageToSpeak = speechQueue.shift(); // ã‚­ãƒ¥ãƒ¼ã‹ã‚‰æ¬¡ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å–ã‚Šå‡ºã™

    // æ—¢å­˜ã®speaké–¢æ•°ã‚’ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ä»˜ãã§ä½¿ç”¨ã™ã‚‹
    // èª­ã¿ä¸Šã’ãŒçµ‚ã‚ã£ãŸã‚‰ã€æ¬¡ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å‡¦ç†ã‚’é–‹å§‹ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹
    const onSpeechEnd = () => {
        isSpeechQueueActive = false;
        processSpeechQueue(); // æ¬¡ã®ã‚¢ã‚¤ãƒ†ãƒ ã®å‡¦ç†ã‚’å‘¼ã³å‡ºã™
    };
    
    speak(messageToSpeak, onSpeechEnd);
}
// â–²â–²â–² ã“ã“ã¾ã§ã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„ â–²â–²â–²
let currentAmbientSound = null; // â˜…ç¾åœ¨å†ç”Ÿä¸­ã®ç’°å¢ƒéŸ³ã‚’è¨˜æ†¶ã™ã‚‹å¤‰æ•°ã‚’è¿½åŠ 
let yawnTimer = null; // ã‚ãã³éŸ³ã®ã‚¿ã‚¤ãƒãƒ¼ã‚’ç®¡ç†ã™ã‚‹å¤‰æ•°
let shiverTimer = null; // éœ‡ãˆéŸ³ã®ã‚¿ã‚¤ãƒãƒ¼ã‚’ç®¡ç†ã™ã‚‹å¤‰æ•°
let wasPreviouslySleepy = false;
let wasPreviouslyHypothermic = false;
let wasPreviouslyThirsty = false;
let wasPreviouslyHungry = false;
let wasPreviouslyFeverish = false;
let wasPreviouslyBleeding = false;
let wasPreviouslyBruised = false;
let wasPreviouslyFractured = false;
let swallowTimer = null;
let rumbleTimer = null;
let coughTimer = null;
let heartbeatTimer = null;
let gruntTimer = null;
let painTimer = null;
let flySoundNode = null; // ãƒã‚¨ã®åŠ¹æœéŸ³ã‚’ç®¡ç†ã™ã‚‹å¤‰æ•°
let infectionTimer = null; // æ„ŸæŸ“ç—‡ã®ã†ã‚ãå£°ã‚¿ã‚¤ãƒãƒ¼ã‚’ç®¡ç†ã™ã‚‹å¤‰æ•°
// MODIFIED FUNCTION
const HUMAN_CORPSE_IMG = 'images/human_corpse.png'; // äººã®æ­»ä½“ã®ç”»åƒãƒ‘ã‚¹
const ANIMAL_CARCASS_IMG = 'images/animal_carcass.png'; // å‹•ç‰©ã®æ­»éª¸ã®ç”»åƒãƒ‘ã‚¹
const BONES_IMG = 'images/corpse_bones.png'; // <<< ã“ã®è¡Œã‚’æ–°ã—ãè¿½åŠ ã—ã¦ãã ã•ã„
// ... æ—¢å­˜ã®å®šæ•°å®šç¾©ã®ä¸‹ã«è¿½åŠ  ...
const FRESH_ANIMAL_CARCASS_IMG = 'images/animal_carcass_fresh.png';
const FRESH_HUMAN_CORPSE_IMG = 'images/human_corpse_fresh.png';
const ZOMBIE_CORPSE_IMG = 'images/zombie_corpse.png';
let hasPlayedImpendingDoomVoice = false; // æœ€å¾Œã®å£°ã‚’å†ç”Ÿã—ãŸã‹ã‚’ç®¡ç†ã™ã‚‹ãƒ•ãƒ©ã‚°
let ambientGainNode = null; // ç’°å¢ƒéŸ³ã®éŸ³é‡ã‚’ç®¡ç†ã™ã‚‹ãƒãƒ¼ãƒ‰
let bgmSourceNode = null; // BGMã®å†ç”Ÿãƒãƒ¼ãƒ‰ã‚’ç®¡ç†ã™ã‚‹å¤‰æ•°
let lastPlayerVoiceTime = 0; // æœ€å¾Œã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å£°ãŒå†ç”Ÿã•ã‚ŒãŸæ™‚åˆ»ã‚’è¨˜éŒ²
const PLAYER_VOICE_COOLDOWN = 5000; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å£°ã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³æ™‚é–“ï¼ˆãƒŸãƒªç§’ï¼‰ã€‚ã“ã®å ´åˆ5ç§’ã€‚
// â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²
let lastSoundCalculation = { base: 0, shoes: {name: 'ç´ è¶³', modifier: 1.2}, weather: {name: 'å¿«æ™´', modifier: 1.0}, total: 0, source: 'ãªã—' };
// ã€2. æ–°ã—ã„é–¢æ•°ã®è¿½åŠ ã€‘
// updateTurnInfo é–¢æ•°ã®ã™ãä¸Šã«ã€ä»¥ä¸‹ã®ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—è¡¨ç¤ºç”¨é–¢æ•°ã‚’æ–°ãŸã«è¿½åŠ ã—ã¾ã™ã€‚

/**
 * è¦–ç•Œãƒ¬ãƒ™ãƒ«ã«ã‚«ãƒ¼ã‚½ãƒ«ã‚’åˆã‚ã›ãŸéš›ã«ã€ãã®å†…è¨³ã‚’ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã§è¡¨ç¤ºã™ã‚‹é–¢æ•°
 * @param {MouseEvent} event - ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
 */
function showVisionTooltip(event) {
    const preview = document.getElementById("statusPreview");
    let contentHtml = `<strong>${getString("tooltip_vision_title")}</strong><br/>`;
    let visionCalc = player.vision;
    let calculationStepsHtml = `<div>${getString("tooltip_vision_base")}: ${player.vision}</div>`;
    if (character.traits.includes("ç›®ãŒæ‚ªã„") && player.equipment.some(e => e.name === 'ãƒ¡ã‚¬ãƒ')) {
        calculationStepsHtml += `<div><span class="stat-positive">${getString("tooltip_vision_glasses")}</span>: +1</div>`;
        visionCalc++;
    }
    const hasTorch = player.equipment.some(e => e.isTorch);
    const hour = currentTime.getHours();
    const isEvening = hour >= 18 && hour < 21;
    const isDeepNight = hour >= 21 || hour < 6;

    if (isDeepNight) {
        let nightVision = 0;
        let nightReason = getString("tooltip_vision_night");
        if (hasTorch) {
            nightVision = 1;
            nightReason += `+<span class="stat-positive">${getString("tooltip_vision_torch")}</span>`;
        }
        if (character.traits.includes("ç›®ãŒã„ã„")) {
             if(nightVision < 1) nightReason += `+<span class="stat-positive">${getString("tooltip_vision_trait")}</span>`;
            nightVision = Math.max(nightVision, 1);
        }
        calculationStepsHtml += `<div>${nightReason}ã®ãŸã‚ <span class="stat-negative">${nightVision}</span> ã«è£œæ­£</div>`;
        visionCalc = nightVision;
    } else if (isEvening) {
        let originalVision = visionCalc;
        visionCalc = Math.max(hasTorch ? 1 : 0, visionCalc - 1);
        let duskReason = getString("tooltip_vision_dusk");
        if (hasTorch && originalVision - 1 < 1) duskReason += ` (<span class="stat-positive">${getString("tooltip_vision_dusk_torch")}</span>)`;
        calculationStepsHtml += `<div>${duskReason}ã«ã‚ˆã‚‹è£œæ­£: -1</div>`;
    }
    let weatherMultiplier = 1.0, weatherReason = "";
    if (currentWeather.name === 'é›¨') { weatherMultiplier = 0.75; weatherReason = getString("tooltip_vision_rain"); }
    if (currentWeather.name === 'åµ') { weatherMultiplier = 0.5; weatherReason = getString("tooltip_vision_storm"); }
    if (weatherMultiplier !== 1.0) {
        calculationStepsHtml += `<div>${weatherReason}${getString("tooltip_vision_penalty")}: Ã—${weatherMultiplier}</div>`;
        visionCalc *= weatherMultiplier;
    }
    const finalVision = Math.max(0, Math.round(visionCalc));
    contentHtml += calculationStepsHtml;
    contentHtml += `<div style="border-bottom: 1px solid #555; margin: 4px 0;"></div>`;
    if (Math.round(visionCalc) !== visionCalc) contentHtml += `<div>${getString("tooltip_vision_calc_result")}: ${visionCalc.toFixed(2)}</div>`;
    contentHtml += `<strong>${getString("tooltip_vision_final")}: ${finalVision}</strong>`;
    preview.innerHTML = contentHtml;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}
// â–¼â–¼â–¼ ã“ã®3ã¤ã®é–¢æ•°ã‚’æ–°ã—ãè¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼

/**
 * å­£ç¯€ã®ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã‚’è¡¨ç¤ºã™ã‚‹
 */
function showSeasonTooltip(event) {
    const preview = document.getElementById("statusPreview");
    const title = getString(`season_${currentSeason}`);
    const description = getString(`tooltip_season_${currentSeason}_desc`);
    preview.innerHTML = `<strong>${title}</strong><div style="margin-top: 5px;">${description}</div>`;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}

// â–¼â–¼â–¼ `showWeatherTooltip`é–¢æ•°ã‚’ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function showWeatherTooltip(event) {
    const preview = document.getElementById("statusPreview");
    
    // â˜…ä¿®æ­£ç‚¹ï¼šæ­£ã—ã„ã‚­ãƒ¼ã‚’ä½¿ã£ã¦ã‚¿ã‚¤ãƒˆãƒ«ã¨èª¬æ˜ã‚’å–å¾—
    const title = getString(currentWeather.nameKey);
    const description = getString(`tooltip_weather_${currentWeather.id}_desc`);
    const accuracyPenalty = getAccuracyModifier(); // ä¿®æ­£ã•ã‚ŒãŸé–¢æ•°ã‚’å‘¼ã³å‡ºã™

    let contentHtml = `<strong>${title}</strong><div style="margin-top: 5px;">${description}</div>`;
    
    if (accuracyPenalty > 0) {
        contentHtml += `<div style="margin-top: 8px; border-top: 1px solid #555; padding-top: 8px;">`;
        contentHtml += `<strong>${getString("tooltip_label_effect")}:</strong><br>`;
        contentHtml += `<span class="stat-negative">${getString("tooltip_weather_accuracy_penalty", { value: Math.round(accuracyPenalty * 100) })}</span>`;
        contentHtml += `</div>`;
    }

    preview.innerHTML = contentHtml;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}
// â–²â–²â–² ç½®ãæ›ãˆã“ã“ã¾ã§ â–²â–²â–²
function showDayStateTooltip(event) {
    const preview = document.getElementById("statusPreview");
    const hour = currentTime.getHours();
    let dayStateKey;
    if (hour >= 6 && hour < 12) { dayStateKey = "daystate_æœ"; } 
    else if (hour >= 12 && hour < 18) { dayStateKey = "daystate_æ˜¼"; } 
    else if (hour >= 18 && hour < 21) { dayStateKey = "daystate_å¤•æ–¹"; } 
    else { dayStateKey = "daystate_å¤œ"; }

    const title = getString(dayStateKey);
    const description = getString(`tooltip_${dayStateKey}_desc`);
    const accuracyPenalty = getAccuracyModifier();

    let contentHtml = `<strong>${title}</strong><div style="margin-top: 5px;">${description}</div>`;
    
    // å‘½ä¸­ç‡ã¸ã®å½±éŸ¿ã‚’è¡¨ç¤º (å¤œé–“ã¨å¤•æ–¹ã®ã¿)
    if (dayStateKey === "daystate_å¤œ" || dayStateKey === "daystate_å¤•æ–¹") {
        contentHtml += `<div style="margin-top: 8px; border-top: 1px solid #555; padding-top: 8px;">`;
        contentHtml += `<strong>${getString("tooltip_label_effect")}:</strong><br>`;
        contentHtml += `<span class="stat-negative">${getString("tooltip_weather_accuracy_penalty", { value: Math.round(accuracyPenalty * 100) })}</span>`;
        contentHtml += `</div>`;
    }
    
    preview.innerHTML = contentHtml;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}

function showSmellTooltip(event) {
    const preview = document.getElementById("statusPreview");
    let contentHtml = `<strong>${getString("tooltip_smell_title")}</strong><br/>`;
    let totalSmell = 0, hasSource = false;
    const smellyItems = [...player.inventory, ...player.equipment].filter(item => item.smell);
    if (smellyItems.length > 0) {
        smellyItems.forEach(item => {
            contentHtml += `<div>${getItemDisplayName(item)}: +${item.smell}</div>`;
            totalSmell += item.smell;
        });
        hasSource = true;
    }
    if (player.injuries.some(i => i.type === 'bleeding')) {
        contentHtml += `<div><span class="stat-negative">${getString("tooltip_smell_bleeding")}</span>: +15</div>`;
        totalSmell += 15;
        hasSource = true;
    }
    const bodyOdorSmell = Math.floor(player.bodyOdor / 5);
    if (bodyOdorSmell > 0) {
        contentHtml += `<div>${getString("tooltip_smell_body_odor")}: +${bodyOdorSmell}</div>`;
        totalSmell += bodyOdorSmell;
        hasSource = true;
    }
    if (!hasSource) {
        contentHtml += `<div>${getString("tooltip_smell_no_source")}</div>`;
    }
    contentHtml += `<div style="border-bottom: 1px solid #555; margin: 2px 0;"></div>`;
    contentHtml += `<strong>${getString("tooltip_smell_total")}: ${totalSmell}</strong>`;
    preview.innerHTML = contentHtml;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}

function showSoundTooltip(event) {
    const preview = document.getElementById("statusPreview");
    const calc = lastSoundCalculation;
    let contentHtml = `<strong>${getString("tooltip_sound_title")}</strong><br/>`;
    if (calc.total === 0) {
        contentHtml += `<div>${getString("tooltip_sound_no_source")}</div>`;
    } else {
        const shoeName = getString(`item_${calc.shoes.name}_name`) || calc.shoes.name;
        const weatherName = getString(`weather_${calc.weather.name}`) || calc.weather.name;
        contentHtml += `<div>${getString("tooltip_sound_action")} (${calc.source}): ${calc.base.toFixed(1)}</div>`;
        contentHtml += `<div>${getString("tooltip_sound_equipment")} (${shoeName}): Ã—${calc.shoes.modifier.toFixed(1)}</div>`;
        if (calc.weather.modifier !== 1.0) {
            contentHtml += `<div>${getString("tooltip_sound_weather")} (${weatherName}): Ã—${calc.weather.modifier.toFixed(1)}</div>`;
        }
        contentHtml += `<div style="border-bottom: 1px solid #555; margin: 2px 0;"></div>`;
        contentHtml += `<strong>${getString("tooltip_sound_total")}: ${calc.total.toFixed(1)}</strong>`;
    }
    preview.innerHTML = contentHtml;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}

// â–¼â–¼â–¼ `updateTurnInfo`é–¢æ•°ã‚’ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function updateTurnInfo() {
    const survivalDay = Math.floor(turn / 24) + 1;
    let turnInfoHtml = `${getString("time_turn")}: ${turn}<br>${getString("time_survival_day", { day: survivalDay })}`;

    const hasWatch = player.equipment.some(e => e.slot === 'wrist');
    if (hasWatch) {
        const currentHour = currentTime.getHours();
        const ampm = getString(currentHour >= 12 ? "time_pm" : "time_am");
        let hours = currentHour % 12;
        hours = hours ? hours : 12;
        const minutes = currentTime.getMinutes().toString().padStart(2, '0');
        
        let timeString = '';
        if (currentLanguage === 'ja') {
            timeString = `${ampm} ${hours}${getString("time_hour")}${minutes}${getString("time_minute")}`;
        } else {
            timeString = `${hours}:${minutes} ${ampm}`;
        }
        turnInfoHtml += `<br>${timeString}`;
    }
    
    const soundLevelHtml = `<span onmouseenter="showSoundTooltip(event)" onmouseleave="hideInfoTooltip()" onmousemove="updatePreviewPosition(event)">${currentSoundLevel}</span>`;
    const smellLevelHtml = `<span onmouseenter="showSmellTooltip(event)" onmouseleave="hideInfoTooltip()" onmousemove="updatePreviewPosition(event)">${currentPlayerSmell}</span>`;
    
    turnInfoHtml += `<br><span onmouseenter="showSoundTooltip(event)" onmouseleave="hideInfoTooltip()" onmousemove="updatePreviewPosition(event)">${getString("info_sound_level")}</span>: ${soundLevelHtml}`;
    turnInfoHtml += `<br><span onmouseenter="showSmellTooltip(event)" onmouseleave="hideInfoTooltip()" onmousemove="updatePreviewPosition(event)">${getString("info_smell_level")}</span>: ${smellLevelHtml}`;
    
    const currentVision = getVisionRange();
    const visionLevelHtml = `<span onmouseenter="showVisionTooltip(event)" onmouseleave="hideInfoTooltip()" onmousemove="updatePreviewPosition(event)">${currentVision}</span>`;
    turnInfoHtml += `<br><span onmouseenter="showVisionTooltip(event)" onmouseleave="hideInfoTooltip()" onmousemove="updatePreviewPosition(event)">${getString("info_vision_level")}</span>: ${visionLevelHtml}`;
    previousVisionLevel = currentVision;
    
    document.getElementById("turnInfoText").innerHTML = turnInfoHtml;
    updateMapHeaderInfo();
}
function showInfoTooltip(event, title, description) {
    const preview = document.getElementById("statusPreview");
    preview.innerHTML = `<strong>${title}</strong><div style="margin-top: 5px;">${description}</div>`;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}

function hideInfoTooltip() {
    hideStatusPreview();
}

// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function updateMapHeaderInfo() {
    let dayState, dayStateKey;
    const hour = currentTime.getHours();

    if (hour >= 6 && hour < 12) { dayState = 'æœ'; dayStateKey = "daystate_æœ"; } 
    else if (hour >= 12 && hour < 18) { dayState = 'æ˜¼'; dayStateKey = "daystate_æ˜¼"; } 
    else if (hour >= 18 && hour < 21) { dayState = 'å¤•æ–¹'; dayStateKey = "daystate_å¤•æ–¹"; } 
    else { dayState = 'å¤œ'; dayStateKey = "daystate_å¤œ"; }

    const seasonKey = `season_${currentSeason}`;
    // â˜…ä¿®æ­£ç‚¹ï¼šcurrentWeather.name ã§ã¯ãªã currentWeather.nameKey ã‚’ä½¿ç”¨
    const weatherKey = currentWeather.nameKey; 

    const seasonIconHtml = getIconHTML(seasonInfo[currentSeason].icon, 16);
    // â˜…ä¿®æ­£ç‚¹ï¼šå¤ã„weatherInfoã‚’ä½¿ã‚ãšã€currentWeatherã‹ã‚‰ç›´æ¥ã‚¢ã‚¤ã‚³ãƒ³ã‚’å–å¾—
    const weatherIconHtml = getIconHTML(currentWeather.icon, 16); 
    const dayStateIconHtml = getIconHTML(dayStateInfo[dayState].icon, 16);

    const seasonHtml = `<span onmouseenter="showSeasonTooltip(event)" onmouseleave="hideInfoTooltip()" onmousemove="updatePreviewPosition(event)">${seasonIconHtml} ${getString(seasonKey)}</span>`;
    const weatherHtml = `<span onmouseenter="showWeatherTooltip(event)" onmouseleave="hideInfoTooltip()" onmousemove="updatePreviewPosition(event)">${weatherIconHtml} ${getString(weatherKey)}</span>`;
    const dayStateHtml = `<span onmouseenter="showDayStateTooltip(event)" onmouseleave="hideInfoTooltip()" onmousemove="updatePreviewPosition(event)">${dayStateIconHtml} ${getString(dayStateKey)}</span>`;
    const tempHtml = `<span class="${currentTemperature > 28 ? 'temp-hot' : currentTemperature < 10 ? 'temp-cold' : 'temp-normal'}" onmouseenter="showBodyTempTooltip(event)" onmouseleave="hideStatusPreview()" onmousemove="updatePreviewPosition(event)">${currentTemperature.toFixed(1)}Â°C</span>`;

    document.getElementById("mapHeaderInfo").innerHTML = `${seasonHtml}|${weatherHtml}|${dayStateHtml}|${tempHtml}`;
}
// â–²â–²â–² ç½®ãæ›ãˆã“ã“ã¾ã§ â–²â–²â–²

function logClear() { document.getElementById("log").innerHTML = ""; }

// â–¼â–¼â–¼ `log` é–¢æ•°ã‚’ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function log(text, doSpeak = true) {
    const logDiv = document.getElementById("log");
    // Make previous log entries less prominent.
    Array.from(logDiv.children).forEach(div => {
        div.style.color = "#666";
        div.style.fontWeight = "normal";
    });
    
    // Create and append the new log entry to the UI.
    let div = document.createElement("div");
    div.innerHTML = text;
    div.classList.add("new");
    logDiv.appendChild(div);
    logDiv.scrollTop = logDiv.scrollHeight;

    // If the log entry should be spoken, add it to the queue.
    if (doSpeak) {
        // Create a temporary element to strip any HTML tags for clean speech.
        const tempDiv = document.createElement("div");
        tempDiv.innerHTML = text;
        const plainText = tempDiv.textContent || tempDiv.innerText || "";
        
        if(plainText) {
            speechQueue.push(plainText);
            // â˜…ä¿®æ­£ç‚¹ï¼šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã—ãŸå¾Œã€è‡ªå‹•çš„ã«èª­ã¿ä¸Šã’å‡¦ç†ã‚’é–‹å§‹ã™ã‚‹
            processSpeechQueue();
        }
    }
}
// â–²â–²â–² ç½®ãæ›ãˆã“ã“ã¾ã§ â–²â–²â–²
// index.htmlå†… (getItemDisplayName ã®å‰ã«è¿½åŠ )

/**
 * ã‚¢ã‚¤ãƒ†ãƒ ã®çŠ¶æ…‹ï¼ˆè€ä¹…åº¦ãªã©ï¼‰ã‚’å«ã¾ãªã„ã€åŸºæœ¬çš„ãªåå‰ã ã‘ã‚’ç¿»è¨³ã—ã¦è¿”ã™
 * @param {object} item - ã‚¢ã‚¤ãƒ†ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
 * @returns {string} - ç¿»è¨³ã•ã‚ŒãŸåŸºæœ¬çš„ãªã‚¢ã‚¤ãƒ†ãƒ å
 */
function getBaseItemName(item) {
    if (!item) return "";
    return getString(`item_${item.name}_name`) || item.name;
}
// ã€ã“ã®é–¢æ•°ã‚’ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ã€‘
function getPlacedObjectDisplayName(pObj) {
    if (pObj.type === 'tilled_field' && pObj.planted) {
        const plantName = getString(`item_${pObj.planted}_name`);
        const status = pObj.isHarvestable ? getString('status_harvestable') : getString('status_growing');
        return `${plantName} ${status}`;
    }

    if (pObj.isHumanCorpse) {
        return pObj.unsearched 
            ? getString('item_å¤ã„æ­»ä½“_name')
            : getString('item_æ¼ã‚‰ã‚ŒãŸæ­»ä½“_name');
    } else if (pObj.isAnimalCorpse) {
        const baseName = getString(`item_${pObj.name}_name`) || pObj.name;
        return pObj.unbutchered
            ? baseName
            : getString('item_è§£ä½“æ¸ˆã¿ã®æ­»éª¸_name');
    } 

    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â–¼â–¼â–¼
    else if (pObj.type === 'water_filter') {
        let status = '';
        if (pObj.waterType === 'dirty') status = ' (æ±šæ°´ä¸­)';
        else if (pObj.waterType === 'clean') status = ' (æµ„æ°´æ¸ˆ)';
        // "æ‰‹ä½œã‚Šæµ„æ°´å™¨ã‚­ãƒƒãƒˆ_name" ã§ã¯ãªã "æ‰‹ä½œã‚Šæµ„æ°´å™¨_name" ã‚’å‚ç…§ã™ã‚‹ã‚ˆã†ã«å¤‰æ›´
        return `${getString('item_æ‰‹ä½œã‚Šæµ„æ°´å™¨_name')}${status}`; 
    } 
    // â–²â–²â–² ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²

    else if (pObj.type === 'charcoal_pile') {
        return 'ç‚­ã®å±±';
    }

    const key = `item_${pObj.name}_name`;
    return getString(key) || pObj.name;
}
// â–²â–²â–² ç½®ãæ›ãˆã“ã“ã¾ã§ â–²â–²â–²
function getItemDisplayName(item) {
    if (!item) return "";
    
    // ä¿®æ­£ç‚¹ï¼šã‚¢ã‚¤ãƒ†ãƒ ã®'name'ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å…ƒã«ã€å¸¸ã«ç¿»è¨³ã‚­ãƒ¼ã‚’ç”Ÿæˆã—ã¦ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—
    let baseName = getString(`item_${item.name}_name`) || item.name;

    let prefix = '';
    let color = '#eee';

    if (item.durability !== undefined) {
        const durabilityPercent = item.durability;
        if (durabilityPercent === 100) { prefix = getString("durability_new"); color = '#2ecc71'; } 
        else if (durabilityPercent >= 70) { prefix = getString("durability_likenew"); color = '#eee'; } 
        else if (durabilityPercent >= 30) { prefix = getString("durability_used"); color = '#FFD700'; } 
        else if (durabilityPercent > 0) { prefix = getString("durability_worn"); color = '#FFA500'; } 
        else { prefix = getString("durability_broken"); color = '#FF4444'; }
    }
    
    let durabilityPrefix = prefix ? `<span style="color: ${color};">${prefix}</span> ` : '';
    let wetnessPrefix = '';
    if (item.wetness === 'wet') { wetnessPrefix = `<span style="color: lightblue;">(${getString("wetness_wet")}) </span>`; } 
    else if (item.wetness === 'soaking_wet') { wetnessPrefix = `<span style="color: blue;">(${getString("wetness_soaking_wet")}) </span>`; }

    let name = wetnessPrefix + durabilityPrefix + baseName;

    if (item.ammoType && item.ammoCapacity) {
        name += ` (${item.loadedAmmo}/${item.ammoCapacity})`;
        if (item.name === 'ãƒ©ã‚¤ãƒ•ãƒ«' && item.bayonetAttached) {
            name += ` ${getString("bayonet_attached")}`;
        }
    } else if (item.type === 'container') {
        if (!item.content) return `${name} (${getString("container_empty")})`;
        if (item.content.type === 'clean') return `${name} (${getString("container_clean_water")})`;
        return `${name} (${getString("container_dirty_water")})`;
    }
    
    // â–¼â–¼â–¼ è¿½åŠ  â–¼â–¼â–¼
    if (item.uses !== undefined) {
        name += ` ${getString("item_info_uses_remaining", { count: item.uses })}`;
    }
    // â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²

    return name;
}

// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function updateItemPanels() {
  const invDiv = document.getElementById("inventory"), equipDiv = document.getElementById("equipment");
  invDiv.innerHTML = ""; equipDiv.innerHTML = "";

  if (player.inventory.length === 0) {
      invDiv.textContent = getString("item_none");
  } else {
      player.inventory.forEach((item, idx) => {
        let div = document.createElement("div"); div.className = "item";
        let descText = "";
        if (item.type === "consumable" && item.freshness !== undefined) {
            descText = item.freshness > 0 ? `${getString("item_info_freshness")}: ${item.freshness.toFixed(0)}%` : getString("item_info_spoiled");
        } else if ((item.type === "equipment" || item.type === "clothing" || item.type === "tool") && item.durability !== undefined) {
            descText = `${getString("item_info_durability")}: ${item.durability.toFixed(0)}%`;
        } else if (item.type === "ammo") {
            descText = getString("item_info_ammo");
        }
        div.innerHTML = `${getIconHTML(getItemGraphic(item), 16)} ${getItemDisplayName(item)}${descText ? ` <span style="font-size: smaller; color: #888;">(${descText})</span>` : ''}`;
        div.onclick = () => showItemDetail(item, idx, 'inventory');
        invDiv.appendChild(div);
      });
  }
  
  if (player.equipment.length === 0) {
      equipDiv.textContent = getString("item_none");
  } else {
      player.equipment.forEach((item, idx) => {
        let div = document.createElement("div"); div.className = "item";
        let durabilityText = item.durability !== undefined ? item.durability.toFixed(0) : getString("item_info_not_applicable");
        let descText = `${getString("item_info_durability")}: ${durabilityText}%`;
        if (item.isTorch && item.duration) {
            descText += `, ${getString("item_info_remaining")}: ${item.duration}${getString("item_info_turns")}`;
        }
        let slotPrefix = item.slot ? `[${getSlotName(item.slot)}] ` : '';
        div.innerHTML = `${getIconHTML(getItemGraphic(item), 16)} ${slotPrefix}${getItemDisplayName(item)}<span style="font-size: smaller; color: #888;"> (${descText})</span>`;
        div.onclick = () => showItemDetail(item, idx, 'equipment');
        equipDiv.appendChild(div);
      });
  }

  updateCraftingPanel();
}

// â–¼â–¼â–¼ `updateCraftingPanel` ã‹ã‚‰ `canCraftItem` ã¾ã§ã®é–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function updateCraftingPanel() {
    const craftListDiv = document.getElementById("craftingList");
    craftListDiv.innerHTML = "";

    // â˜…ä¿®æ­£ç‚¹ï¼šç ”ç©¶ã§ã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã•ã‚ŒãŸãƒ¬ã‚·ãƒ”ã®ã¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
    const availableRecipes = recipes.filter(r => !r.requiredResearch || player.research.completed.includes(r.requiredResearch));

    const categories = {
        'available': { name: getString('craft_category_available'), recipes: [] },
        'weapon': { name: getString('craft_category_weapon'), recipes: [] },
        'armor_clothing': { name: getString('craft_category_armor_clothing'), recipes: [] },
        'tools': { name: getString('craft_category_tools'), recipes: [] },
        'other': { name: getString('craft_category_other'), recipes: [] }
    };

    // â˜…ä¿®æ­£ç‚¹ï¼šãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°å¾Œã® `availableRecipes` ã‚’ä½¿ç”¨
    availableRecipes.forEach(recipe => {
        const resultItem = items.find(i => i.name === recipe.result);
        if (!resultItem) return;
        const isCraftable = canCraftItem(recipe);
        const recipeData = { ...recipe, canCraft: isCraftable };

        if (isCraftable) {
            categories['available'].recipes.push(recipeData);
        }
        
        if (resultItem.type === 'equipment' && resultItem.slot === 'weapon') {
            categories['weapon'].recipes.push(recipeData);
        } else if (resultItem.type === 'equipment' || resultItem.type === 'clothing') {
            categories['armor_clothing'].recipes.push(recipeData);
        } else if (resultItem.type === 'tool' || resultItem.type === 'container') {
            categories['tools'].recipes.push(recipeData);
        } else {
            categories['other'].recipes.push(recipeData);
        }
    });

    for (const categoryKey in categories) {
        const category = categories[categoryKey];
        if (category.recipes.length === 0) continue;

        const header = document.createElement("div");
        header.className = "crafting-category-header";
        header.innerHTML = `<span>${category.name}</span><span class="toggle-arrow">â–¼</span>`;
        craftListDiv.appendChild(header);

        const recipeContainer = document.createElement("div");
        recipeContainer.className = "recipe-container";
        craftListDiv.appendChild(recipeContainer);

        header.addEventListener('click', () => {
            recipeContainer.classList.toggle('collapsed');
            const arrow = header.querySelector('.toggle-arrow');
            arrow.textContent = recipeContainer.classList.contains('collapsed') ? 'â–¶' : 'â–¼';
        });

        category.recipes.sort((a, b) => {
            const nameA = getString(`item_${a.result}_name`) || a.result;
            const nameB = getString(`item_${b.result}_name`) || b.result;
            if (categoryKey === 'available') {
                return nameA.localeCompare(nameB);
            }
            if (a.canCraft && !b.canCraft) return -1;
            if (!a.canCraft && b.canCraft) return 1;
            return nameA.localeCompare(nameB);
        });

        category.recipes.forEach(recipe => {
            const resultItem = items.find(i => i.name === recipe.result);
            const div = document.createElement("div");
            div.className = "item";
            div.addEventListener('mouseenter', (e) => showRecipeTooltip(resultItem, e));
            div.addEventListener('mouseleave', hideStatusPreview);
            div.addEventListener('mousemove', (e) => updatePreviewPosition(e));
            
            if (!recipe.canCraft) {
                div.classList.add("un-craftable");
            }
            
            let ingredientsHtml = recipe.ingredients.map(ing => {
                const translatedName = getString(`item_${ing.name}_name`) || ing.name;
                return `${translatedName} x${ing.count}`;
            }).join(', ');
            
            div.innerHTML = `<button>${getString("btn_craft")}</button>${getIconHTML(getItemGraphic(resultItem), 16)} ${getString(`item_${resultItem.name}_name`) || resultItem.name}<div class="recipe-ingredients">${ingredientsHtml}</div>`;
            
            if (recipe.canCraft) {
                div.querySelector("button").onclick = () => craftItem(recipe);
            }
            recipeContainer.appendChild(div);
        });
    }
}
function canCraftItem(recipe) {
    if (recipe.requiredResearch && !player.research.completed.includes(recipe.requiredResearch)) {
        return false;
    }

    // --- æ–°ã—ã„é“å…·ãƒã‚§ãƒƒã‚¯æ©Ÿèƒ½ ---
    if (recipe.requiredTool) {
        let hasTool = false;
        if (recipe.requiredTool === 'axe') {
            // è£…å‚™å“ã¨æ‰€æŒå“ã®ä¸¡æ–¹ã‹ã‚‰æ–§ã‚’æ¢ã™
            hasTool = [...player.inventory, ...player.equipment].some(item => item.isAxe);
        }
        if (!hasTool) {
            return false; // é“å…·ãŒãªã‘ã‚Œã°ã‚¯ãƒ©ãƒ•ãƒˆä¸å¯
        }
    }
    // --- ã“ã“ã¾ã§ ---

    const availableMaterials = {};
    player.inventory.forEach(item => { 
        availableMaterials[item.name] = (availableMaterials[item.name] || 0) + 1; 
    });
    const locationKey = `${player.x},${player.y}`;
    const itemsOnGround = droppedItems[locationKey] || [];
    itemsOnGround.forEach(item => {
        availableMaterials[item.name] = (availableMaterials[item.name] || 0) + 1;
    });

    return recipe.ingredients.every(ingredient => (availableMaterials[ingredient.name] || 0) >= ingredient.count);
}
// â–²â–²â–² ç½®ãæ›ãˆã“ã“ã¾ã§ â–²â–²â–²

function craftItem(recipe) {
    if (isStunnedByPain()) { return; } // â˜…â˜…â˜… ã“ã®è¡Œã‚’è¿½åŠ  â˜…â˜…â˜…
    interruptAndClearSpeech(); // <<< ã“ã®è¡Œã‚’è¿½åŠ 
    if (!canCraftItem(recipe)) { 
        log(getString("error_not_enough_materials")); 
        processSpeechQueue(); // <<< ã“ã®è¡Œã‚’è¿½åŠ 
        return; 
    }
    let failureChance = 0.10; 
    if (character.traits.includes("æ‰‹å…ˆãŒå™¨ç”¨")) failureChance = 0.05;
    else if (character.traits.includes("æ‰‹å…ˆãŒä¸å™¨ç”¨")) failureChance = 0.25;
    if (Math.random() < failureChance) {
        log(getString("craft_fail_lost_materials"), true);
        const materialsToLoseCount = Math.ceil(recipe.ingredients.length / 2);
        let ingredientPool = [];
        recipe.ingredients.forEach(ing => { for (let i = 0; i < ing.count; i++) ingredientPool.push(ing.name); });
        for (let i = 0; i < materialsToLoseCount; i++) {
            if (ingredientPool.length === 0) break;
            const lostIngredientName = randChoice(ingredientPool);
            ingredientPool.splice(ingredientPool.indexOf(lostIngredientName), 1);
            const invIndex = player.inventory.findIndex(invItem => invItem.name === lostIngredientName);
            if (invIndex > -1) {
                const removedItem = player.inventory.splice(invIndex, 1)[0];
                player.weight -= removedItem.weight || 0;
                player.volume -= removedItem.volume || 0;
                continue;
            }
            const locationKey = `${player.x},${player.y}`;
            const groundItems = droppedItems[locationKey] || [];
            const groundIndex = groundItems.findIndex(groundItem => groundItem.name === lostIngredientName);
            if (groundIndex > -1) groundItems.splice(groundIndex, 1);
        }
        updateItemPanels(); updateStatus(); updateCurrentLocationPanel(false);
        processSpeechQueue(); // <<< ã“ã®è¡Œã‚’è¿½åŠ 
        return;
    }
    snapshotStats();
    recipe.ingredients.forEach(ingredient => {
        for (let i = 0; i < ingredient.count; i++) {
            const invIndex = player.inventory.findIndex(invItem => invItem.name === ingredient.name);
            if (invIndex > -1) {
                const removedItem = player.inventory.splice(invIndex, 1)[0];
                player.weight -= removedItem.weight || 0;
                player.volume -= removedItem.volume || 0;
                continue;
            }
            const locationKey = `${player.x},${player.y}`;
            const groundItems = droppedItems[locationKey] || [];
            const groundIndex = groundItems.findIndex(groundItem => groundItem.name === ingredient.name);
            if (groundIndex > -1) groundItems.splice(groundIndex, 1);
        }
    });
    const resultItemTemplate = items.find(item => item.name === recipe.result);
    if (resultItemTemplate) {
        const newItem = { ...resultItemTemplate };
        if (newItem.durability !== undefined) {
            newItem.durability = Math.floor(Math.random() * 30) + 70;
        }
       if (newItem.name === 'campfire_kit') {
            newItem.uses = Math.floor(Math.random() * 3) + 3; 
        }
        if (player.weight + newItem.weight > player.maxWeight || player.volume + (newItem.volume || 0) > player.maxVolume) {
            log(getString("craft_success_grounded", { itemName: getItemDisplayName(newItem) }), true);
            const locationKey = `${player.x},${player.y}`;
            if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
            droppedItems[locationKey].push(newItem);
        } else {
            player.inventory.push(newItem);
            player.weight += newItem.weight || 0;
            player.volume += newItem.volume || 0;
        }
        log(getString("craft_success", { itemName: getItemDisplayName(newItem) }), true);
        createSound(player.x, player.y, 3);
    }
    endPlayerTurn(); drawMap(); updateStatus(); updateItemPanels(); updateCharacterBody(); updateCharacterInfo(); updateTurnInfo(); checkGameOver(); updateCurrentLocationPanel(false);
    processSpeechQueue(); // <<< ã“ã®è¡Œã‚’è¿½åŠ 
}
/**
 * Processes and speaks messages from the speechQueue sequentially.
 */
function processSpeechQueue() {
    // If the queue is already being processed or is empty, do nothing.
    if (isSpeechQueueActive || speechQueue.length === 0) {
        return;
    }

    isSpeechQueueActive = true;
    const messageToSpeak = speechQueue.shift(); // Get the next message from the queue.

    // Use the existing speak function with a callback.
    // When the speech ends, it will allow the next message to be processed.
    const onSpeechEnd = () => {
        isSpeechQueueActive = false;
        processSpeechQueue(); // Process the next item in the queue.
    };
    
    speak(messageToSpeak, onSpeechEnd);
}
// â–¼â–¼â–¼ æ—¢å­˜ã®dropItemé–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function dropItem(index) {
    interruptAndClearSpeech();
    snapshotStats();
    const droppedItem = player.inventory.splice(index, 1)[0];
    player.weight -= droppedItem.weight || 0;
    player.volume -= droppedItem.volume || 0;
    
    const logMessage = getString("log_drop_item", { itemName: getItemDisplayName(droppedItem) });
    
    const locationKey = `${player.x},${player.y}`;
    if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
    droppedItems[locationKey].push(droppedItem);

    // å…±é€šã®UIæ›´æ–°
    hideItemDetail();
    updateItemPanels(); 
    updateCurrentLocationPanel(false); 
    updateStatus(); 
    updateCharacterBody();

    // --- ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ ---
    if (currentEnemy) { // æˆ¦é—˜ä¸­ã®å ´åˆ
        combatLogMessage(logMessage, 'normal', () => {
            enemyCombatTurn();
        });
    } else { // æˆ¦é—˜ä¸­ã§ãªã„å ´åˆ
        log(logMessage);
        processSpeechQueue();
    }
}

function pickUpItemFromGround(index) {
    interruptAndClearSpeech(); // <<< ã“ã®è¡Œã‚’è¿½åŠ 
    const locationKey = `${player.x},${player.y}`;
    const itemToPickUp = droppedItems[locationKey][index];
    if (itemToPickUp.type === 'water_source') { 
        log(getString("log_cannot_pickup_water")); 
        hideItemDetail(); 
        processSpeechQueue(); // <<< ã“ã®è¡Œã‚’è¿½åŠ 
        return; 
    }
  
    if (player.weight + itemToPickUp.weight > player.maxWeight) { 
        speakAndAlert(getString("alert_pickup_fail_weight", { itemName: getItemDisplayName(itemToPickUp) })); 
        return; 
    }
    if (player.volume + (itemToPickUp.volume || 0) > player.maxVolume) { 
        speakAndAlert(getString("alert_pickup_fail_volume", { itemName: getItemDisplayName(itemToPickUp) })); 
        return; 
    }

    snapshotStats();
    const pickedUpItem = droppedItems[locationKey].splice(index, 1)[0];
    player.inventory.push(pickedUpItem); 
    player.weight += pickedUpItem.weight || 0;
    player.volume += pickedUpItem.volume || 0;
    log(getString("log_pickup_item", { itemName: getItemDisplayName(pickedUpItem) }));
    updateCurrentLocationPanel(false); updateItemPanels(); updateStatus(); updateCharacterBody(); hideItemDetail();
    processSpeechQueue(); // <<< ã“ã®è¡Œã‚’è¿½åŠ 
}
// â–¼â–¼â–¼ æ—¢å­˜ã®unequipItemé–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function unequipItem(index, showLog = true) {
    const itemToUnequip = player.equipment[index];
    if (!itemToUnequip) {
        console.error(`unequipItem called with invalid index: ${index}`);
        hideItemDetail();
        return;
    }

    let futureMaxWeight = maxStats.maxWeight;
    let futureMaxVolume = maxStats.maxVolume;
    player.equipment.forEach((item, i) => {
        if (i !== index) { 
            if (item.effects) {
                if (item.effects.maxWeight) futureMaxWeight += item.effects.maxWeight;
                if (item.effects.maxVolume) futureMaxVolume += item.effects.maxVolume;
            }
        }
    });

    if (player.weight > futureMaxWeight) {
        speakAndAlert(getString("alert_unequip_fail_weight"));
        hideItemDetail();
        return;
    }
    const futurePlayerVolume = player.volume + (itemToUnequip.volume || 0);
    if (futurePlayerVolume > futureMaxVolume) {
        speakAndAlert(getString("alert_unequip_fail_volume", {
            newVolume: futurePlayerVolume.toFixed(1),
            newMaxVolume: futureMaxVolume.toFixed(1)
        }));
        hideItemDetail();
        return;
    }

    snapshotStats();
    const unequippedItem = player.equipment.splice(index, 1)[0];
    
    // --- ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ ---
    if (unequippedItem.slot.startsWith('body_inner_')) {
        // ã‚¤ãƒ³ãƒŠãƒ¼ã®ã‚¹ãƒ­ãƒƒãƒˆã‚’æ±ç”¨çš„ãª 'body_inner' ã«æˆ»ã™
        unequippedItem.slot = 'body_inner';
    } else {
        unequippedItem.slot = (unequippedItem.handedness) ? 'weapon' : unequippedItem.slot;
    }
    // --- ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ ---

    player.inventory.push(unequippedItem);
    
    if (unequippedItem.isBlade) {
        playSoundFile('sounds/equip_blade.wav', 0.7);
    } else if (unequippedItem.type === 'clothing' || unequippedItem.type === 'equipment') {
        playSoundFile('sounds/equip_cloth.wav', 0.8);
    }

    updateEquippedStats(); 

    if (showLog && !currentEnemy) {
        log(getString("log_unequip_item", { itemName: getItemDisplayName(unequippedItem) }));
        updateItemPanels();
        updateStatus();
        updateCharacterBody();
        updateTurnInfo();
        processSpeechQueue();
    }

    if (currentEnemy) {
        const logMessage = getString("log_unequip_item", { itemName: getItemDisplayName(unequippedItem) });
        updateItemPanels(); 
        updateStatus(); 
        updateCharacterBody();
        combatLogMessage(logMessage, 'normal', () => {
            enemyCombatTurn();
        });
    }
}

function updateEquippedStats() {
    // 1. å…¨ã¦ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’åŸºæœ¬å€¤ã§åˆæœŸåŒ–
    player.attack = player.baseAttack;
    player.defense = player.baseDefense;
    player.reach = 1; // â˜…ãƒªãƒ¼ãƒã‚’åŸºæœ¬å€¤(1)ã§åˆæœŸåŒ–
    player.maxWeight = maxStats.maxWeight;
    player.maxVolume = maxStats.maxVolume;
    player.insulation = 0;

    // 2. æ­¦å™¨ã«ã‚ˆã‚‹æ”»æ’ƒåŠ›ã¨ãƒªãƒ¼ãƒã®è¨ˆç®—
    const weapons = player.equipment.filter(e => e.attack || e.fireDamage);
    if (weapons.length > 0) {
        let bestMeleeWeapon = { attack: 0, durability: 100, reach: 1 }; // ãƒªãƒ¼ãƒã®åˆæœŸå€¤ã‚‚è¨­å®š

        weapons.forEach(w => {
            let currentAttack = w.attack || 0;
            // éŠƒå‰£ä»˜ããƒ©ã‚¤ãƒ•ãƒ«ã®å¼¾åˆ‡ã‚Œæ™‚ã®ç‰¹æ®Šå‡¦ç†
            if (w.name === 'ãƒ©ã‚¤ãƒ•ãƒ«' && w.bayonetAttached && w.loadedAmmo === 0) {
                const knife = items.find(i => i.name === 'ãƒŠã‚¤ãƒ•');
                currentAttack = knife ? knife.attack : (w.attack || 0);
            }

            if (currentAttack > bestMeleeWeapon.attack) {
                bestMeleeWeapon = w;
            }
        });

        if (bestMeleeWeapon.attack > 0) {
            const durabilityFactor = (bestMeleeWeapon.durability === undefined ? 100 : bestMeleeWeapon.durability) / 100;
            
            let weaponAttackBonus = bestMeleeWeapon.attack || 0;
            if (bestMeleeWeapon.name === 'ãƒ©ã‚¤ãƒ•ãƒ«' && bestMeleeWeapon.bayonetAttached && bestMeleeWeapon.loadedAmmo === 0) {
                const knife = items.find(i => i.name === 'ãƒŠã‚¤ãƒ•');
                weaponAttackBonus = knife ? knife.attack : bestMeleeWeapon.attack;
            }
            
            player.attack += weaponAttackBonus * durabilityFactor;
            // â˜…æœ€ã‚‚å¼·ã„æ­¦å™¨ã®ãƒªãƒ¼ãƒã‚’ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒªãƒ¼ãƒã¨ã™ã‚‹
            player.reach = bestMeleeWeapon.reach || 1;
        }
    }
    
    // â˜…éŠƒå‰£ä»˜ããƒ©ã‚¤ãƒ•ãƒ«ã®ç‰¹åˆ¥ãƒªãƒ¼ãƒå‡¦ç†
    const rifle = player.equipment.find(e => e.name === 'ãƒ©ã‚¤ãƒ•ãƒ«' && e.bayonetAttached);
    if (rifle) {
        player.reach = Math.max(player.reach, 2);
    }

    // 3. å…¨ã¦ã®è£…å‚™å“ã‚’ãƒ«ãƒ¼ãƒ—ã—ã€æ”»æ’ƒåŠ›ä»¥å¤–ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’åˆç®—
    player.equipment.forEach(item => {
        const durabilityFactor = 0.3 + 0.7 * ((item.durability === undefined ? 100 : item.durability) / 100);
        player.defense += (item.defense || 0) * durabilityFactor;
        player.insulation += (item.insulation || 0) * durabilityFactor;
        
        if(item.effects) {
            const isBroken = item.durability !== undefined && item.durability <= 0;
            if (!isBroken) {
                if(item.effects.maxWeight) player.maxWeight += item.effects.maxWeight;
                if(item.effects.maxVolume) player.maxVolume += item.effects.maxVolume;
            }
        }
    });

    // 4. ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’æ•´æ•°ã«ä¸¸ã‚ã€æœ€çµ‚çš„ãªé‡é‡ã¨å®¹é‡ã‚’è¨ˆç®—
    player.attack = Math.floor(player.attack);
    player.defense = Math.floor(player.defense);
    
    // â–¼â–¼â–¼ ä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
    // é‡é‡(weight)ã¯æ‰€æŒå“ã¨è£…å‚™å“ã®ä¸¡æ–¹ã‚’åˆè¨ˆ
    player.weight = [...player.inventory, ...player.equipment].reduce((sum, item) => sum + (item.weight || 0), 0);
    // å®¹é‡(volume)ã¯æ‰€æŒå“(inventory)ã®ã¿ã‚’åˆè¨ˆ
    player.volume = player.inventory.reduce((sum, item) => sum + (item.volume || 0), 0);
    // â–²â–²â–² ä¿®æ­£ã“ã“ã¾ã§ â–²â–²â–²

    updateBodyPanel(); 
}
// â–¼â–¼â–¼ æ—¢å­˜ã®equipItemé–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function equipItem(idx, source = 'inventory') {
    const sourceArray = source === 'inventory' ? player.inventory : droppedItems[`${player.x},${player.y}`];
    let itemToEquip = sourceArray[idx];

    if (!itemToEquip) { console.error("ãƒ‡ãƒãƒƒã‚°: equipItem - å¯¾è±¡ã‚¢ã‚¤ãƒ†ãƒ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚", idx, source); return; }
    
    console.log("ãƒ‡ãƒãƒƒã‚°: equipItem - å‡¦ç†é–‹å§‹", { item: itemToEquip.name, source: source });

    if (itemToEquip.slot === 'body_inner') {
        console.log("ãƒ‡ãƒãƒƒã‚°: ã‚¤ãƒ³ãƒŠãƒ¼è£…å‚™ãƒ­ã‚¸ãƒƒã‚¯ã‚’é–‹å§‹ã—ã¾ã™ã€‚");
        const innerSlots = ['body_inner_1', 'body_inner_2', 'body_inner_3'];
        const occupiedInnerSlots = player.equipment.filter(e => innerSlots.includes(e.slot)).map(e => e.slot);
        const availableSlot = innerSlots.find(s => !occupiedInnerSlots.includes(s));

        if (!availableSlot) {
            console.error("ãƒ‡ãƒãƒƒã‚°: ç©ºãã‚¤ãƒ³ãƒŠãƒ¼ã‚¹ãƒ­ãƒƒãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚");
            speakAndAlert("ã‚¤ãƒ³ãƒŠãƒ¼ã¯ã“ã‚Œä»¥ä¸Šç€ã‚‰ã‚Œãªã„ã€‚");
            return;
        }
        
        console.log(`ãƒ‡ãƒãƒƒã‚°: ç©ºãã‚¹ãƒ­ãƒƒãƒˆ '${availableSlot}' ã‚’ç™ºè¦‹ã—ã¾ã—ãŸã€‚`);
        const newItem = { ...itemToEquip, slot: availableSlot };
        sourceArray[idx] = newItem;
        itemToEquip = newItem;
        console.log("ãƒ‡ãƒãƒƒã‚°: ã‚¢ã‚¤ãƒ†ãƒ ã®ã‚¹ãƒ­ãƒƒãƒˆã‚’ä¸€æ™‚çš„ã«å¤‰æ›´ã—ã¾ã—ãŸ:", itemToEquip);
    }
    
// â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã§ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
    if (source === 'dropped') {
        // äº¤æ›ã•ã‚Œã‚‹ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ¢ã™
        const replacedItem = player.equipment.find(e => e.slot === itemToEquip.slot);
        const replacedWeight = replacedItem ? replacedItem.weight : 0;
        
        // äº¤æ›å¾Œã®æœ€çµ‚çš„ãªé‡é‡ã‚’è¨ˆç®—
        const finalWeight = player.weight - replacedWeight + itemToEquip.weight;

        if (finalWeight > player.maxWeight) {
            speakAndAlert(getString("alert_pickup_fail_weight", { itemName: getItemDisplayName(itemToEquip) }));
            if (itemToEquip.slot.startsWith('body_inner_')) {
                 sourceArray[idx] = items.find(i => i.name === itemToEquip.name);
            }
            return;
        }
    }
    // â–²â–²â–² ç½®ãæ›ãˆã¯ã“ã“ã¾ã§ â–²â–²â–²
    
    const findMyIndex = (item) => sourceArray.findIndex(i => i === item);

    if (itemToEquip.slot !== 'weapon' || !itemToEquip.handedness) {
        let slot = itemToEquip.slot;
        if (!slot) { speakAndAlert(getString("alert_cannot_equip")); return; }
        
        const doEquip = () => {
            snapshotStats();
            let replacedItem = player.equipment.find(e => e.slot === slot);
            if(replacedItem) {
                const replacedItemIndex = player.equipment.findIndex(e => e.slot === slot);
                if (replacedItemIndex > -1) {
                    const itemToUnequip = player.equipment.splice(replacedItemIndex, 1)[0];
                    if (itemToUnequip.slot.startsWith('body_inner_')) {
                        itemToUnequip.slot = 'body_inner';
                    }
                    player.inventory.push(itemToUnequip);
                }
            }
            const newEquipIndex = findMyIndex(itemToEquip);
            if (newEquipIndex === -1) { hideItemDetail(); return; }
            let newEquip = sourceArray.splice(newEquipIndex, 1)[0];
            player.equipment.push(newEquip);
            
            console.log("ãƒ‡ãƒãƒƒã‚°: ã‚¢ã‚¤ãƒ†ãƒ ã‚’è£…å‚™é…åˆ—ã«ç§»å‹•ã—ã¾ã—ãŸã€‚ç¾åœ¨ã®è£…å‚™:", JSON.parse(JSON.stringify(player.equipment)));

            if (newEquip.isBlade) { playSoundFile('sounds/equip_blade.wav', 0.7); } 
            else if (newEquip.type === 'clothing' || newEquip.type === 'equipment') { playSoundFile('sounds/equip_cloth.wav', 0.8); }

            if (source === 'dropped') {
                player.weight += newEquip.weight || 0;
            } else {
                player.volume -= newEquip.volume || 0;
            }

            const logMessage = replacedItem ? getString("log_equip_swap", { oldItemName: getItemDisplayName(replacedItem), newItemName: getItemDisplayName(newEquip) }) : getString("log_equip_item", { itemName: getItemDisplayName(newEquip) });
            updateEquippedStats(); hideItemDetail();
            
            if (currentEnemy) {
                updateItemPanels(); updateStatus();
                combatLogMessage(logMessage, 'normal', () => { enemyCombatTurn(); });
            } else {
                log(logMessage); updateItemPanels(); updateStatus(); updateCharacterBody();
                updateTurnInfo();
                processSpeechQueue();
            }
        };

        let replacedItem = player.equipment.find(e => e.slot === slot);
        if (replacedItem) showItemComparisonModal(itemToEquip, replacedItem, doEquip, () => log(getString("log_equip_swap_canceled")));
        else doEquip();
        return;
    }
    
    
    // ...æ­¦å™¨è£…å‚™ã®ãƒ­ã‚¸ãƒƒã‚¯ã¯å¤‰æ›´ãªã—...
    const mainHandWeapon = player.equipment.find(e => e.slot === 'main_hand' || e.handedness === 'two');
    const offHandWeapon = player.equipment.find(e => e.slot === 'off_hand');

    if (itemToEquip.handedness === 'two') {
        const confirmMessage = getString("confirm_equip_two_handed", { itemName: getItemDisplayName(itemToEquip) });
        
        speakAndConfirm(confirmMessage, () => {
            snapshotStats();
            if (mainHandWeapon) {
                const mainHandIndex = player.equipment.findIndex(e => e === mainHandWeapon);
                if(mainHandIndex > -1) unequipItem(mainHandIndex, false);
            }
            if (offHandWeapon) {
                 const offHandIndex = player.equipment.findIndex(e => e === offHandWeapon);
                 if(offHandIndex > -1) unequipItem(offHandIndex, false);
            }

            const newWeaponIndex = findMyIndex(itemToEquip);
            if (newWeaponIndex === -1) { hideItemDetail(); return; }
            
            const newWeapon = sourceArray.splice(newWeaponIndex, 1)[0];
            newWeapon.slot = 'main_hand';
            player.equipment.push(newWeapon);

            if (newWeapon.isBlade) { playSoundFile('sounds/equip_blade.wav', 0.7); } 
            else if (newWeapon.type === 'equipment') { playSoundFile('sounds/equip_cloth.wav', 0.8); }

            if (source === 'dropped') {
                player.weight += newWeapon.weight || 0;
            } else {
                player.volume -= newWeapon.volume || 0;
            }
            
            const logMessage = getString("log_equip_two_handed", { itemName: getItemDisplayName(newWeapon) });
            updateEquippedStats(); hideItemDetail();

            if(currentEnemy){
                updateItemPanels(); updateStatus();
                combatLogMessage(logMessage, 'normal', () => { enemyCombatTurn(); });
            } else {
                log(logMessage); updateItemPanels(); updateStatus(); updateCharacterBody();
                updateTurnInfo();
                processSpeechQueue();
            }
        });
    } 
    else if (itemToEquip.handedness === 'one') {
        const equipToOneHand = (targetSlot) => {
            const currentWeaponInSlot = player.equipment.find(e => e.slot === targetSlot);
            
            const doEquipAction = () => {
                snapshotStats();
                const twoHandedWeapon = player.equipment.find(e => e.handedness === 'two');
                if (twoHandedWeapon) {
                     const twoHandedIndex = player.equipment.findIndex(e => e === twoHandedWeapon);
                     if(twoHandedIndex > -1) unequipItem(twoHandedIndex, false);
                }
                
                if (currentWeaponInSlot) {
                    const currentWeaponIndex = player.equipment.findIndex(e => e === currentWeaponInSlot);
                    if(currentWeaponIndex > -1) unequipItem(currentWeaponIndex, false);
                }

                const newWeaponIndex = findMyIndex(itemToEquip);
                if (newWeaponIndex === -1) { hideItemDetail(); return; }
                
                const newWeapon = sourceArray.splice(newWeaponIndex, 1)[0];
                newWeapon.slot = targetSlot;
                player.equipment.push(newWeapon);
                
                if (newWeapon.isBlade) { playSoundFile('sounds/equip_blade.wav', 0.7); } 
                else if (newWeapon.type === 'equipment') { playSoundFile('sounds/equip_cloth.wav', 0.8); }

                if (source === 'dropped') {
                    player.weight += newWeapon.weight || 0;
                } else {
                    player.volume -= newWeapon.volume || 0;
                }

                const logMessage = getString("log_equip_one_handed", { slotName: getSlotName(targetSlot), itemName: getItemDisplayName(newWeapon) });
                updateEquippedStats(); hideItemDetail();
                
                if(currentEnemy){
                    updateItemPanels(); updateStatus();
                    combatLogMessage(logMessage, 'normal', () => {
                        enemyCombatTurn();
                    });
                } else {
                    log(logMessage); updateItemPanels(); updateStatus(); updateCharacterBody();
                    updateTurnInfo();
                    processSpeechQueue();
                }
            };

            if (currentWeaponInSlot) {
                showItemComparisonModal(itemToEquip, currentWeaponInSlot, doEquipAction, () => log(getString("log_equip_swap_canceled")));
            } else {
                doEquipAction();
            }
        };
        
        if (!mainHandWeapon || mainHandWeapon.handedness === 'two') {
            equipToOneHand('main_hand');
        } else if (!offHandWeapon) {
            equipToOneHand('off_hand');
        } else {
             equipToOneHand('main_hand');
        }
    }
}
/**
 * æˆ¦é—˜ä¸­ã«ã‚¢ã‚¤ãƒ†ãƒ ã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚ã®å°‚ç”¨é–¢æ•°
 */
function handleCombatItemUse(item, itemIndex, source) {
    const sourceArray = source === 'inventory' ? player.inventory : droppedItems[`${player.x},${player.y}`];
    
    // åŒ…å¸¯ç³»ã®ã‚¢ã‚¤ãƒ†ãƒ ã®å‡¦ç†
    if (item.name.includes("åŒ…å¸¯")) {
        const bleedingInjury = player.injuries.find(i => i.type === 'bleeding' && !i.treating_duration);
        if (bleedingInjury) {
            snapshotStats();
            bleedingInjury.treating_duration = 3;
            bleedingInjury.infectionRisk = 0;
            
            // ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ¶ˆè²»
            const removedItem = sourceArray.splice(itemIndex, 1)[0];
            player.weight -= removedItem.weight || 0;
            if(source === 'inventory') player.volume -= removedItem.volume || 0;
            
            updateEquippedStats();
            updateItemPanels();
            updateStatus();
            updateCharacterBody();
            hideItemDetail();
            
            // æˆ¦é—˜ãƒ­ã‚°ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã—ã€æ•µã®ã‚¿ãƒ¼ãƒ³ã¸ç§»è¡Œ
            combatLogMessage(getString("log_bleeding_treating"), 'playerAttack', () => {
                enemyCombatTurn();
            });

        } else {
            // å‡ºè¡€ã—ã¦ã„ãªã„å ´åˆã¯ä½•ã‚‚ã—ãªã„
            hideItemDetail();
        }
        return;
    }
    
    // ã“ã“ã«ä»–ã®æˆ¦é—˜ã§ä½¿ç”¨å¯èƒ½ãªã‚¢ã‚¤ãƒ†ãƒ ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’è¿½åŠ å¯èƒ½
    // (ä¾‹ï¼šæˆ¦é—˜ä¸­ã«ä½¿ãˆã‚‹å›å¾©è–¬ãªã©)

    // ä¸Šè¨˜ä»¥å¤–ã®å ´åˆã¯ã€é€šå¸¸ã®useItemã‚’å‘¼ã³å‡ºã™ï¼ˆãŸã ã—æˆ¦é—˜ä¸­ã¯ã»ã¨ã‚“ã©ãŒå¯¾è±¡å¤–ï¼‰
    useItem(itemIndex, source);
}

function useItem(idx, source = 'inventory') {
    if (isStunnedByPain()) { return; } // â˜…â˜…â˜… ã“ã®è¡Œã‚’è¿½åŠ  â˜…â˜…â˜…
    interruptAndClearSpeech();
    const sourceArray = source === 'inventory' ? player.inventory : droppedItems[`${player.x},${player.y}`];
    let item = sourceArray[idx];
    
    if(item.useAction) {
        window[item.useAction](item, idx, source);
        return;
    }

    if (item.name.includes("åŒ…å¸¯") || item.name === 'simple_bandage') {
        const bleedingInjury = player.injuries.find(i => i.type === 'bleeding' && !i.treating_duration);
        if (bleedingInjury) {
            snapshotStats();
            bleedingInjury.treating_duration = 3;
            bleedingInjury.infectionRisk = 0;
            
            const removedItem = sourceArray.splice(idx, 1)[0];
            player.weight -= removedItem.weight || 0;
            if(source === 'inventory') player.volume -= removedItem.volume || 0;
            
            // æˆ¦é—˜ä¸­ã‹ã©ã†ã‹ã§å‡¦ç†ã‚’åˆ†å²
            if (currentEnemy) {
                // â˜…â˜…â˜…ã“ã“ãŒä¿®æ­£ç‚¹ã§ã™â˜…â˜…â˜…
                const logMessage = getString("log_bleeding_treating");
                combatLogMessage(logMessage, 'playerAttack', () => {
                    updateItemPanels(); 
                    updateStatus(); 
                    updateCharacterBody(); 
                    hideItemDetail();
                    enemyCombatTurn();
                });
            } else {
                // â˜…â˜…â˜…ã“ã“ãŒä¿®æ­£ç‚¹ã§ã™â˜…â˜…â˜…
                log(getString("log_bleeding_treating"));
                logStatChanges(playerStatsBeforeAction, player);
                updateItemPanels(); 
                updateStatus(); 
                updateCharacterBody(); 
                hideItemDetail();
                processSpeechQueue();
            }
        } else {
            log(getString("log_medicine_not_needed", { medicineName: getItemDisplayName(item) }));
            hideItemDetail();
        }
        return; 
    }

    if (item.type === "consumable") {
        snapshotStats();

        if (item.effects && item.effects.hunger > 0 && player.hunger >= maxStats.hunger) {
            log(getString("log_hunger_full"), true);
            hideItemDetail();
            processSpeechQueue();
            return;
        }

        if(item.isSealed) { 
            log(getString("log_item_is_sealed", { itemName: getItemDisplayName(item) })); 
            hideItemDetail(); 
            processSpeechQueue();
            return; 
        }
        
        let foodPoisoningChance = 0;
        if (item.freshness !== undefined) {
            if (item.freshness <= 0) foodPoisoningChance = 0.8; 
            else if (item.freshness < 40) foodPoisoningChance = 0.1;
        }
        if (item.foodPoisoningOnEat) {
            foodPoisoningChance = Math.max(foodPoisoningChance, item.foodPoisoningOnEat);
        }
        // â˜…â˜…â˜…ã“ã®è¡Œã‚’ä¿®æ­£â˜…â˜…â˜…
        if (foodPoisoningChance > 0 && Math.random() < calculateSicknessChance(foodPoisoningChance)) {
            if (!player.sicknesses.some(s => s.type === 'food_poisoning')) {
                log(getString("log_food_poisoning"), true);
                player.sicknesses.push({ type: 'food_poisoning', duration: 36 });
            }
        }

        if (item.effects && item.effects.hunger > 0) {
            playSoundFile('sounds/eat.wav', 0.8);
        }

        if (item.effects) {
            for (const stat in item.effects) {
                if (player[stat] !== undefined) {
                  let effect = item.effects[stat];
                  if (maxStats[stat]) player[stat] = Math.min(maxStats[stat], player[stat] + effect); else player[stat] += effect;
                }
            }
        }
        if (item.nutrients) {
            player.carbs = Math.min(maxStats.carbs, player.carbs + (item.nutrients.carbs || 0));
            player.protein = Math.min(maxStats.protein, player.protein + (item.nutrients.protein || 0));
            player.fat = Math.min(maxStats.fat, player.fat + (item.nutrients.fat || 0));
            player.vitamins = Math.min(maxStats.vitamins, player.vitamins + (item.nutrients.vitamins || 0));
            player.thirst = Math.min(maxStats.thirst, player.thirst + (item.nutrients.water || 0));
        }

        if (item.bodyTempBoost) {
            player.bodyTemp = Math.min(37.5, player.bodyTemp + item.bodyTempBoost);
            log(getString("log_body_temp_warmed_by_food"));
        }

        if (item.effects && item.effects.hunger > 0) {
            const healthToRestore = 5;
            player.health = Math.min(maxStats.health, player.health + healthToRestore);
        }
        
        const logMessage = (item.effects && item.effects.hunger > 0) 
            ? getString("log_eat_item", { itemName: getItemDisplayName(item) })
            : getString("log_use_item", { itemName: getItemDisplayName(item) });
        
        const wasCannedFood = item.name === 'opened_can_beans';

        const removedItem = sourceArray.splice(idx, 1)[0];
        player.weight -= removedItem.weight || 0;
        if(source === 'inventory') player.volume -= removedItem.volume || 0;
        
        if(wasCannedFood) {
            const emptyCanTemplate = items.find(i => i.name === 'ç©ºãç¼¶');
            if (emptyCanTemplate) {
                const newEmptyCan = { ...emptyCanTemplate };
                player.inventory.push(newEmptyCan);
                player.weight += newEmptyCan.weight || 0;
                player.volume += newEmptyCan.volume || 0;
            }
        }
        
        hideItemDetail();
        updateItemPanels(); 
        updateStatus(); 
        updateCharacterBody();
        
        if (currentEnemy) { // æˆ¦é—˜ä¸­ã®å ´åˆ
            combatLogMessage(logMessage, 'normal', () => {
                enemyCombatTurn();
            });
        } else { // æˆ¦é—˜ä¸­ã§ãªã„å ´åˆ
            log(logMessage);
            logStatChanges(playerStatsBeforeAction, player);
            processSpeechQueue();
        }
    }
}
// --- Sound Effects ---
function playSound(type) {
    try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        if(!ctx) return;
        const o = ctx.createOscillator(), g = ctx.createGain();
        o.connect(g); g.connect(ctx.destination);
        let duration = 0.2;
        switch(type) {
            case 'start': o.type = 'sine'; o.frequency.setValueAtTime(440, ctx.currentTime); g.gain.setValueAtTime(0.2, ctx.currentTime); o.frequency.exponentialRampToValueAtTime(880, ctx.currentTime + 0.2); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.2); duration = 0.2; break;
case 'attack': o.type = 'triangle'; g.gain.setValueAtTime(0.2, ctx.currentTime); o.frequency.setValueAtTime(880, ctx.currentTime); o.frequency.exponentialRampToValueAtTime(220, ctx.currentTime + 0.15); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.15); duration = 0.2; break;
            case 'gunshot': o.type = 'sawtooth'; o.frequency.setValueAtTime(2000, ctx.currentTime); o.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.1); g.gain.setValueAtTime(0.4, ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.2); duration = 0.3; break;
            case 'damage': o.type = 'square'; o.frequency.setValueAtTime(110, ctx.currentTime); g.gain.setValueAtTime(0.3, ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.2); duration = 0.25; break;
            case 'victory': o.type = 'sine'; g.gain.setValueAtTime(0.2, ctx.currentTime); o.frequency.setValueAtTime(523.25, ctx.currentTime); o.frequency.linearRampToValueAtTime(659.26, ctx.currentTime + 0.1); o.frequency.linearRampToValueAtTime(783.99, ctx.currentTime + 0.2); o.frequency.linearRampToValueAtTime(1046.50, ctx.currentTime + 0.4); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.5); duration = 0.6; break;
            case 'defeat': o.type = 'sawtooth'; g.gain.setValueAtTime(0.3, ctx.currentTime); o.frequency.setValueAtTime(220, ctx.currentTime); o.frequency.exponentialRampToValueAtTime(55, ctx.currentTime + 1.0); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 1.0); duration = 1.1; break;
            case 'zombie': o.frequency.value = 400; o.type = "square"; g.gain.setValueAtTime(0.1, ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.00001, ctx.currentTime + 0.4); duration = 0.5; break;
        }
        o.start(); o.stop(ctx.currentTime + duration);
    } catch (e) { console.error("Web Audio API not supported or failed.", e); }
}
// â–¼â–¼â–¼ ä»¥ä¸‹ã®2ã¤ã®é–¢æ•°ã‚’æ–°ã—ãè¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
/**
 * ä½ä½“åŠ›BGMã‚’åœæ­¢ã™ã‚‹
 */
function stopLowHealthBGM() {
    if (lowHealthBGMSourceNode) {
        try {
            lowHealthBGMSourceNode.stop();
        } catch (e) {
            // Do nothing
        }
    }
    clearTimeout(lowHealthBGMTimeout);
    lowHealthBGMSourceNode = null;
    isLowHealthBGMPlaying = false;
}
/**
 * ä½ä½“åŠ›æ™‚ã®å¿ƒéŸ³ã‚’åœæ­¢ã™ã‚‹
 */
function stopCriticalHeartbeat() {
    if (criticalHealthHeartbeatNode) {
        try {
            criticalHealthHeartbeatNode.stop();
        } catch (e) {
            // Do nothing
        }
        criticalHealthHeartbeatNode = null;
    }
}

/**
 * ä½ä½“åŠ›æ™‚ã®å¿ƒéŸ³ã‚’é–‹å§‹ã™ã‚‹
 */
async function startCriticalHeartbeat() {
    if (criticalHealthHeartbeatNode) return; // æ—¢ã«å†ç”Ÿä¸­ãªã‚‰ä½•ã‚‚ã—ãªã„

    try {
        const audioBuffer = await loadSound('sounds/heartbeat.wav');
        if (!audioBuffer) return;

        const source = audioCtx.createBufferSource();
        source.buffer = audioBuffer;
        source.loop = true; // ãƒ«ãƒ¼ãƒ—å†ç”Ÿã‚’æœ‰åŠ¹ã«ã™ã‚‹

        const gainNode = audioCtx.createGain();
        const volumeSlider = document.getElementById('volumeSlider');
        const volume = volumeSlider ? parseFloat(volumeSlider.value) * 0.8 : 0.3; // ç’°å¢ƒéŸ³ã‚ˆã‚Šå°‘ã—å¤§ãã‚ã«
        gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);

        source.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        source.start(0);

        criticalHealthHeartbeatNode = source;
    } catch (e) {
        console.error("å¿ƒéŸ³ã®å†ç”Ÿã«å¤±æ•—ã—ã¾ã—ãŸ:", e);
    }
}

// â–¼â–¼â–¼ æ—¢å­˜ã® `manageCriticalHealthHeartbeat` é–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function manageCriticalHealthHeartbeat() {
    const healthPercent = (player.health / maxStats.health) * 100;
    const bloodPercent = (player.bloodLevel / maxStats.bloodLevel) * 100;

    // â˜…ä½“åŠ›ã¾ãŸã¯è¡€æ¶²é‡ãŒ25%æœªæº€ã®å ´åˆã«å¿ƒéŸ³ã‚’å†ç”Ÿã™ã‚‹ã‚ˆã†æ¡ä»¶ã‚’å¤‰æ›´
    if ((healthPercent < 25 || bloodPercent < 25) && player.health > 0) {
        if (!criticalHealthHeartbeatNode) {
            startCriticalHeartbeat();
        }
        
        if (criticalHealthHeartbeatNode) {
            // ä½“åŠ›ã¨è¡€æ¶²é‡ã®ã†ã¡ã€ã‚ˆã‚Šä½ã„æ–¹ã®å€¤ã«åŸºã¥ã„ã¦å†ç”Ÿé€Ÿåº¦ã‚’æ±ºå®š
            const lowestPercent = Math.min(healthPercent, bloodPercent);
            const baseRate = 1.0;
            // 25%ã§1.0å€é€Ÿã€0%ã§2.5å€é€Ÿã«ãªã‚‹ã‚ˆã†ã«ç·šå½¢ã«å¤‰åŒ–
            const acceleration = (25 - lowestPercent) / 25 * 1.5;
            const newRate = baseRate + acceleration;
            criticalHealthHeartbeatNode.playbackRate.setValueAtTime(newRate, audioCtx.currentTime);
        }
    } else {
        if (criticalHealthHeartbeatNode) {
            stopCriticalHeartbeat();
        }
    }
}
/**
 * ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½“åŠ›ã«å¿œã˜ã¦ã€ä½ä½“åŠ›BGMã®å†ç”Ÿãƒ»åœæ­¢ã‚’ç®¡ç†ã™ã‚‹
 */
async function manageLowHealthBGM() {
    const healthPercent = (player.health / maxStats.health) * 100;

    if (healthPercent < 20 && !isLowHealthBGMPlaying) {
        // ä½“åŠ›ãŒ20%æœªæº€ã§ã€BGMãŒå†ç”Ÿã•ã‚Œã¦ã„ãªã„å ´åˆ
        isLowHealthBGMPlaying = true;

        const audioBuffer = await loadSound('sounds/low_health_bgm.mp3');
        if (!audioBuffer) {
            isLowHealthBGMPlaying = false; // ãƒ•ã‚¡ã‚¤ãƒ«ãŒãªã‘ã‚Œã°ãƒ•ãƒ©ã‚°ã‚’æˆ»ã™
            return;
        }

        const volumeSlider = document.getElementById('volumeSlider');
        const volume = volumeSlider ? parseFloat(volumeSlider.value) : 0.4;
        
        const gainNode = audioCtx.createGain();
        gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
        gainNode.connect(audioCtx.destination);

        const source = audioCtx.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(gainNode);
        source.start(0);
        lowHealthBGMSourceNode = source;

        // BGMãŒçµ‚äº†ã—ãŸå¾Œã€æ¬¡ã®å†ç”Ÿã¾ã§ã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã‚’è¨­å®š
        source.onended = () => {
            const nextPlayDelay = (Math.random() * 60 + 60) * 1000; // 60ã€œ120ç§’å¾Œã«å†å†ç”Ÿå¯èƒ½
            lowHealthBGMTimeout = setTimeout(() => {
                isLowHealthBGMPlaying = false;
            }, nextPlayDelay);
        };

    } else if (healthPercent >= 20 && isLowHealthBGMPlaying) {
        // ä½“åŠ›ãŒ20%ä»¥ä¸Šã§ã€BGMãŒå†ç”Ÿä¸­ã®å ´åˆã¯åœæ­¢ã™ã‚‹
        stopLowHealthBGM();
    }
}
// index.htmlå†…

async function playCombatBGM() {
    if (combatBgmSourceNode) return;

    try {
        const audioBuffer = await loadSound('sounds/combat_bgm.mp3');
        if (!audioBuffer) return;

        // â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯å…¨ä½“ã‚’ä¿®æ­£ â–¼â–¼â–¼
        const combatBgmSlider = document.getElementById('combatBgmVolumeSlider');
        const volume = combatBgmSlider ? parseFloat(combatBgmSlider.value) : 0.5;
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªgainNodeã®éŸ³é‡ã‚’è¨­å®š
        if (combatBgmGainNode) {
            combatBgmGainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
        }

        const source = audioCtx.createBufferSource();
        source.buffer = audioBuffer;
        source.loop = true;
        source.connect(combatBgmGainNode); // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªgainNodeã«æ¥ç¶š
        source.start(0);
        // â–²â–²â–² ä¿®æ­£ã¯ã“ã“ã¾ã§ â–²â–²â–²

        combatBgmSourceNode = source;
    } catch (e) {
        console.error("æˆ¦é—˜BGMã®å†ç”Ÿã«å¤±æ•—ã—ã¾ã—ãŸ:", e);
    }
}

/**
 * æˆ¦é—˜ç”¨BGMã‚’åœæ­¢ã™ã‚‹
 */
function stopCombatBGM() {
    if (combatBgmSourceNode) {
        try {
            combatBgmSourceNode.stop();
        } catch (e) {
            // æ—¢ã«åœæ­¢ã—ã¦ã„ã‚‹ãƒãƒ¼ãƒ‰ã‚’æ­¢ã‚ã‚ˆã†ã¨ã™ã‚‹ã¨ã‚¨ãƒ©ãƒ¼ãŒå‡ºã‚‹å ´åˆãŒã‚ã‚‹ãŸã‚ç„¡è¦–ã™ã‚‹
        }
        combatBgmSourceNode = null; // ç®¡ç†å¤‰æ•°ã‚’ãƒªã‚»ãƒƒãƒˆ
    }
}
/**
 * ã‚ãã³åŠ¹æœéŸ³ã®é–‹å§‹ã¨åœæ­¢ã‚’ç®¡ç†ã™ã‚‹é–¢æ•°
 */
function manageYawnEffect() {
    const sleepPercent = (player.sleep / maxStats.sleep) * 100;
    const isSleepy = sleepPercent < 50;

    if (isSleepy && !yawnTimer) {
        // çœ æ°—ãŒã‚ã‚Šã€ã‚¿ã‚¤ãƒãƒ¼ãŒå‹•ã„ã¦ã„ãªã„ãªã‚‰ã€æœ€åˆã®ã‚ãã³ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã™ã‚‹
        const initialDelay = (Math.random() * 20 + 10) * 1000; // 10ã€œ30ç§’å¾Œã«æœ€åˆã®ã‚ãã³
        yawnTimer = setTimeout(playYawnAndScheduleNext, initialDelay);
    } else if (!isSleepy && yawnTimer) {
        // çœ æ°—ãŒãªãã€ã‚¿ã‚¤ãƒãƒ¼ãŒå‹•ã„ã¦ã„ã‚‹ãªã‚‰åœæ­¢ã™ã‚‹
        clearTimeout(yawnTimer);
        yawnTimer = null;
    }
}

/**
 * ã‚ãã³ã‚’å†ç”Ÿã—ã€æ¬¡ã®ã‚ãã³ã‚’ä¸å®šæœŸã«ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã™ã‚‹é–¢æ•°
 */

/**
 * ä½ä½“æ¸©æ™‚ã®éœ‡ãˆåŠ¹æœéŸ³ã®é–‹å§‹ã¨åœæ­¢ã‚’ç®¡ç†ã™ã‚‹é–¢æ•° (ãƒ‡ãƒãƒƒã‚°ç‰ˆ)
 */
/**
 * ä½ä½“æ¸©æ™‚ã®éœ‡ãˆåŠ¹æœéŸ³ã®é–‹å§‹ã¨åœæ­¢ã‚’ç®¡ç†ã™ã‚‹é–¢æ•°
 */
function manageShiverEffect() {
    const isHypothermic = player.bodyTemp < 35.5;

    // ä½ä½“æ¸©çŠ¶æ…‹ã§ã€ã‹ã¤ã‚¿ã‚¤ãƒãƒ¼ãŒå‹•ã„ã¦ã„ãªã„å ´åˆã®ã¿ã€ãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹ã™ã‚‹
    if (isHypothermic && !shiverTimer) {
        // æœ€åˆã®åŠ¹æœéŸ³ã‚’å°‘ã—é…ã‚‰ã›ã¦é–‹å§‹
        const initialDelay = (Math.random() * 15 + 5) * 1000;
        shiverTimer = setTimeout(playShiverAndScheduleNext, initialDelay);
    }
}

/**
 * éœ‡ãˆéŸ³ã‚’å†ç”Ÿã—ã€æ¬¡ã®åŠ¹æœéŸ³ã‚’ä¸å®šæœŸã«ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã™ã‚‹é–¢æ•°
 * ã“ã®é–¢æ•°è‡ªèº«ãŒãƒ«ãƒ¼ãƒ—ã‚’ç¶™ç¶šã™ã‚‹ã‹ã©ã†ã‹ã‚’åˆ¤æ–­ã™ã‚‹
 */
function playShiverAndScheduleNext() {
    if (player.bodyTemp >= 35.5) {
        clearTimeout(shiverTimer);
        shiverTimer = null;
        return;
    }
    playPlayerVoice('sounds/shiver.wav', 0.6);
    const nextShiverDelay = (Math.random() * 40 + 20) * 1000;
    shiverTimer = setTimeout(playShiverAndScheduleNext, nextShiverDelay);
}
function playYawnAndScheduleNext() {
    playPlayerVoice('sounds/yawn.wav', 0.7);
    const nextYawnDelay = (Math.random() * 50 + 40) * 1000;
    yawnTimer = setTimeout(playYawnAndScheduleNext, nextYawnDelay);
}
// index.htmlã®<script>ã‚¿ã‚°å†…
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’æ–°ã—ãè¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
/**
 * æˆ¦é—˜é–‹å§‹æ™‚ã®è¦–èªç¢ºç‡ã‚’ã€çŠ¶æ³ã«å¿œã˜ã¦è¨ˆç®—ã™ã‚‹
 * @param {object} viewer - è¦–èªã™ã‚‹å´ï¼ˆplayer ã¾ãŸã¯ currentEnemyï¼‰
 * @param {number} preemptiveModifier - å…ˆåˆ¶æ”»æ’ƒã«ã‚ˆã‚‹è£œæ­£å€¤ (+50, -50, or 0)
 * @returns {number} - æœ€çµ‚çš„ãªè¦–èªç¢ºç‡ (0-100)
 */
function calculateVisibilityChance(viewer, preemptiveModifier = 0) {
    let baseChance = 80; // åŸºæœ¬ç¢ºç‡
    let modifiers = 0;

    // 1. æ™‚é–“å¸¯ã«ã‚ˆã‚‹è£œæ­£
    const hour = currentTime.getHours();
    if (hour >= 6 && hour < 8) { // æœ
        modifiers -= 10;
    } else if (hour >= 18 && hour < 21) { // å¤•æ–¹
        modifiers -= 30;
    } else if (hour >= 21 || hour < 6) { // å¤œ
        modifiers -= 60;
    }

    // 2. å¤©å€™ã«ã‚ˆã‚‹è£œæ­£
    switch (currentWeather.id) {
        case 'sunny': modifiers += 10; break;
        case 'rainy': modifiers -= 20; break;
        case 'stormy': modifiers -= 40; break;
    }

    // 3. åœ°å½¢ï¼ˆãƒã‚¤ã‚ªãƒ¼ãƒ ï¼‰ã«ã‚ˆã‚‹è£œæ­£
    const viewerTile = map[viewer.y][viewer.x];
    switch (viewerTile.biome) {
        case 'Plains': modifiers += 15; break;
        case 'Forest': modifiers -= 25; break;
        case 'Commercial':
        case 'Industrial':
        case 'Residential':
            modifiers -= 15;
            break;
    }

    // 4. å…ˆåˆ¶æ”»æ’ƒã«ã‚ˆã‚‹è£œæ­£ã‚’é©ç”¨
    modifiers += preemptiveModifier;

    const finalChance = baseChance + modifiers;
    return Math.max(0, Math.min(100, finalChance)); // æœ€çµ‚ç¢ºç‡ã‚’0%ï½100%ã®é–“ã«åã‚ã‚‹
}
// â–¼â–¼â–¼ æ—¢å­˜ã® startCombat é–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function startCombat(enemy, playerInitiates = true) {
    console.log(`DEBUG: startCombatãŒæ“ä½œã‚’ãƒ­ãƒƒã‚¯ã—ã‚ˆã†ã¨ã—ã¦ã„ã¾ã™ã€‚ æ™‚åˆ»: ${new Date().toLocaleTimeString()}`);
    player.isAiming = false;
    playCombatBGM();
    
    let playerPreemptiveMod = 0;
    let enemyPreemptiveMod = 0;
    if (playerInitiates) {
        playerPreemptiveMod = 50;
        enemyPreemptiveMod = -50;
    } else {
        playerPreemptiveMod = -50;
        enemyPreemptiveMod = 50;
    }

    const playerChance = calculateVisibilityChance(player, playerPreemptiveMod);
    const enemyChance = calculateVisibilityChance(enemy, enemyPreemptiveMod);

    playerSeesEnemy = Math.random() * 100 < playerChance;
    enemySeesPlayer = Math.random() * 100 < enemyChance;
    
    combatDistance = Math.floor(Math.random() * (10 - 4 + 1)) + 4;
    
    player.isDodging = false;
    player.isParrying = false;
    player.stance = 'standing';
    player.vulnerableTurns = 0;
    player.stunnedTurns = 0;
    player.heavyAttackCooldown = 0;

    // *** ã“ã“ãŒæ­£ã—ã„ä¿®æ­£ç®‡æ‰€ã§ã™ ***
    // preCombatPanelStatesãŒç©ºã®å ´åˆï¼ˆï¼ç›´æ¥æˆ¦é—˜ã«å…¥ã‚‹å ´åˆï¼‰ã®ã¿ã€ç¾åœ¨ã®ãƒ‘ãƒãƒ«çŠ¶æ…‹ã‚’ä¿å­˜ã—ã¾ã™ã€‚
    // å¯¾è©±ç”»é¢ã‹ã‚‰æ¥ãŸå ´åˆã¯ã€ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã¯å®Ÿè¡Œã•ã‚Œãšã€ä»¥å‰ä¿å­˜ã—ãŸçŠ¶æ…‹ãŒç¶­æŒã•ã‚Œã¾ã™ã€‚
    if (Object.keys(preCombatPanelStates).length === 0) {
        preCombatPanelStates = {};
        document.querySelectorAll('.panel').forEach(panel => {
            preCombatPanelStates[panel.id] = {
                display: window.getComputedStyle(panel).display,
                top: panel.style.top,
                left: panel.style.left,
                width: panel.style.width,
                height: panel.style.height,
                isMinimized: panel.classList.contains('minimized')
            };
        });
    }
    // *** ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ ***

    isInteractionActive = true;
    currentEnemy = enemy;
    currentEnemy.lastAction = null;
    currentNPC = null;

    const panelsToHide = document.querySelectorAll('.panel:not(#combatPanel):not(#statusPanel):not(#inventoryPanel):not(#itemDetailPanel):not(#bodyPanel)');
    panelsToHide.forEach(p => {
        if (!p.classList.contains('minimized')) {
            p.style.display = 'none';
        }
    });

    document.querySelector('#bodyPanel .panel-footer').style.display = 'none';
    document.getElementById('sleepNowBtn').style.display = 'none';
    const enemyName = getString(`item_${enemy.name}_name`) || enemy.name;
    const startMessageKey = (enemy.isZombie || enemy.isAnimal) ? "combat_start_hostile" : "combat_start_humanoid";
    const startMessage = getString(startMessageKey, { enemyName: enemyName });
    
    combatLogMessage(startMessage, 'normal');
    updateCombatUI();
    const combatPanel = document.getElementById('combatPanel');
    combatPanel.style.display = 'block';
    bringToFront(combatPanel);
    const statusPanel = document.getElementById('statusPanel');
    statusPanel.style.display = 'block';
    bringToFront(statusPanel);
    const inventoryPanel = document.getElementById('inventoryPanel');
    inventoryPanel.style.display = 'flex';
    bringToFront(inventoryPanel);
    const bodyPanel = document.getElementById('bodyPanel');
    bodyPanel.style.display = 'flex';
    bringToFront(bodyPanel);
    
    document.getElementById('combatLog').innerHTML = '';

    // ... (ã“ã‚Œä»¥é™ã®é–¢æ•°ã®å†…å®¹ã¯å¤‰æ›´ã‚ã‚Šã¾ã›ã‚“) ...

    document.getElementById('attackMainBtn').disabled = true;
    document.getElementById('attackOffBtn').disabled = true;
    document.getElementById('fireBtn').disabled = true;
    document.getElementById('runBtn').disabled = true;
    document.getElementById('advanceBtn').disabled = true;
    document.getElementById('retreatBtn').disabled = true;
    document.getElementById('dodgeBtn').disabled = true;
    document.getElementById('aimBtn').disabled = true;
    document.getElementById('proneBtn').disabled = true;
    document.getElementById('parryBtn').disabled = true;
    document.getElementById('legTripBtn').disabled = true;
    document.getElementById('standUpBtn').disabled = true;
    document.getElementById('sprintForwardBtn').disabled = true;
    document.getElementById('sprintBackwardBtn').disabled = true;
    document.getElementById('heavyMeleeBtn').disabled = true;
    document.getElementById('heavyRangedBtn').disabled = true;
    document.getElementById('throwWeaponBtn').disabled = true;
    document.getElementById('searchOpponentBtn').disabled = true;
    setTimeout(() => {
        if (!currentEnemy || player.health <= 0) return;

        if (playerInitiates) {
            log(getString("log_player_initiative"));
            document.querySelectorAll('#combatActions button').forEach(btn => btn.disabled = false);
            updateCombatUI();
        } else {
            const preemptiveStrikeMessage = getString("log_preemptive_strike", { enemyName: enemyName });
            
            const onSpeechEnd = () => {
                setTimeout(() => {
                    if (currentEnemy && player.health > 0) {
                        enemyCombatTurn();
                    }
                }, 400);
            };
            
            combatLogMessage(preemptiveStrikeMessage, 'enemyAttack', onSpeechEnd);
        }
    }, 1200);

    const setupTooltip = (btnId, actionKey) => {
        const btn = document.getElementById(btnId);
        btn.addEventListener('mouseenter', (e) => showCombatActionTooltip(e, actionKey));
        btn.addEventListener('mouseleave', hideCombatActionTooltip);
        btn.addEventListener('mousemove', (e) => updatePreviewPosition(e));
    };

    document.getElementById('attackMainBtn').onclick = () => handleAttack('main');
    setupTooltip('attackMainBtn', 'attack');
    document.getElementById('attackOffBtn').onclick = () => handleAttack('off');
    setupTooltip('attackOffBtn', 'attack');
    document.getElementById('fireBtn').onclick = handleFire;
    setupTooltip('fireBtn', 'fire');
    document.getElementById('runBtn').onclick = handleRun;
    setupTooltip('runBtn', 'run');
    document.getElementById('proneBtn').onclick = handleGoProne;
    setupTooltip('proneBtn', 'prone');
    document.getElementById('standUpBtn').onclick = handleStandUp;
    setupTooltip('standUpBtn', 'stand_up');
    document.getElementById('forwardRollBtn').onclick = handleForwardRoll;
    setupTooltip('forwardRollBtn', 'forward_roll');
    document.getElementById('backwardRollBtn').onclick = handleBackwardRoll;
    setupTooltip('backwardRollBtn', 'backward_roll');
    document.getElementById('sprintForwardBtn').onclick = handleSprintForward;
    setupTooltip('sprintForwardBtn', 'sprint_forward');
    document.getElementById('sprintBackwardBtn').onclick = handleSprintBackward;
    setupTooltip('sprintBackwardBtn', 'sprint_backward');
    document.getElementById('advanceBtn').onclick = handleAdvance;
    setupTooltip('advanceBtn', 'advance');
    document.getElementById('retreatBtn').onclick = handleRetreat;
    setupTooltip('retreatBtn', 'retreat');
    document.getElementById('dodgeBtn').onclick = handleDodge;
    setupTooltip('dodgeBtn', 'dodge');
    document.getElementById('aimBtn').onclick = handleAim;
    setupTooltip('aimBtn', 'aim');
    document.getElementById('heavyMeleeBtn').onclick = () => handleHeavyMeleeAttack('main'); 
    setupTooltip('heavyMeleeBtn', 'heavy_melee');
    document.getElementById('heavyMeleeOffBtn').onclick = () => handleHeavyMeleeAttack('off');
    setupTooltip('heavyMeleeOffBtn', 'heavy_melee');
    document.getElementById('heavyRangedBtn').onclick = handleHeavyRangedAttack;
    setupTooltip('heavyRangedBtn', 'heavy_ranged');
    document.getElementById('parryBtn').onclick = handleParry;
    setupTooltip('parryBtn', 'parry');
    document.getElementById('legTripBtn').onclick = handleLegTrip;
    setupTooltip('legTripBtn', 'leg_trip');
    document.getElementById('throwWeaponBtn').onclick = handleThrow;
    setupTooltip('throwWeaponBtn', 'throw');
    document.getElementById('searchOpponentBtn').onclick = handleSearchOpponent;
    setupTooltip('searchOpponentBtn', 'search_opponent');
}
/**
 * è¦–èªã§ãã¦ã„ãªã„ç›¸æ‰‹ã‚’æ¢ã™ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
 */
function handleSearchOpponent() {
    player.isAiming = false; // â˜…ã“ã®è¡Œã‚’è¿½åŠ 
    lockCombatInteractionPanels();
    document.querySelectorAll('#combatActions button').forEach(btn => btn.disabled = true);

    combatLogMessage(getString("log_player_searches"), 'normal', () => {
        if (Math.random() < 0.2) { // 20%ã®ç¢ºç‡ã§æˆåŠŸ
            playerSeesEnemy = true;
            combatLogMessage(getString("log_search_success"), 'victory', () => {
                enemyCombatTurn();
            });
        } else {
            combatLogMessage(getString("log_search_fail"), 'enemyAttack', () => {
                enemyCombatTurn();
            });
        }
    });
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’æ–°ã—ãè¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
/**
 * æ•µãŒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æ¢ã™ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
 */
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
/**
 * æ•µãŒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æ¢ã™ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
 */
function enemySearch() {
    const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;
    let logText;
    if (!playerSeesEnemy) {
        const logKeys = ["log_unseen_search_1", "log_unseen_search_2", "log_unseen_search_3"];
        logText = getString(randChoice(logKeys));
    } else {
        logText = getString("log_enemy_searches", { enemyName: enemyName });
    }

    combatLogMessage(logText, 'enemyAttack', () => {
        if (Math.random() < 0.2) { // 20%ã®ç¢ºç‡ã§æˆåŠŸ
            enemySeesPlayer = true;
            
            // â–¼â–¼â–¼ ä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
            // ãƒ­ã‚°ã‚­ãƒ¼ã‚’æ–°ã—ã„å°‚ç”¨ã®ã‚‚ã®ã«å¤‰æ›´
            combatLogMessage(getString("log_enemy_search_success"), 'enemyAttack', () => {
            // â–²â–²â–² ä¿®æ­£ã“ã“ã¾ã§ â–²â–²â–²
                startPlayerTurn();
            });
        } else {
            combatLogMessage(getString("log_search_fail"), 'playerAttack', () => {
                startPlayerTurn();
            });
        }
    });
}
// --- æ¸‡ã ---
function manageSwallowEffect() {
    const isThirsty = (player.thirst / maxStats.thirst) * 100 < 50;
    if (isThirsty && !swallowTimer) {
        const initialDelay = (Math.random() * 20 + 10) * 1000;
        swallowTimer = setTimeout(playSwallowAndScheduleNext, initialDelay);
    }
}
function playSwallowAndScheduleNext() {
    if ((player.thirst / maxStats.thirst) * 100 >= 50) {
        clearTimeout(swallowTimer);
        swallowTimer = null;
        return;
    }
    playPlayerVoice('sounds/swallow.wav', 0.8);
    const nextDelay = (Math.random() * 40 + 30) * 1000;
    swallowTimer = setTimeout(playSwallowAndScheduleNext, nextDelay);
}

// --- ç©ºè…¹ ---
function manageRumbleEffect() {
    const isHungry = (player.hunger / maxStats.hunger) * 100 < 50;
    if (isHungry && !rumbleTimer) {
        const initialDelay = (Math.random() * 25 + 15) * 1000;
        rumbleTimer = setTimeout(playRumbleAndScheduleNext, initialDelay);
    }
}
function playRumbleAndScheduleNext() {
    if ((player.hunger / maxStats.hunger) * 100 >= 50) {
        clearTimeout(rumbleTimer);
        rumbleTimer = null;
        return;
    }
    playPlayerVoice('sounds/rumble.wav', 0.5);
    const nextDelay = (Math.random() * 50 + 40) * 1000;
    rumbleTimer = setTimeout(playRumbleAndScheduleNext, nextDelay);
}

// --- ç™ºç†± ---
function manageCoughEffect() {
    const isFeverish = player.sicknesses.some(s => s.type === 'fever');
    if (isFeverish && !coughTimer) {
        const initialDelay = (Math.random() * 20 + 10) * 1000;
        coughTimer = setTimeout(playCoughAndScheduleNext, initialDelay);
    }
}
function playCoughAndScheduleNext() {
    if (!player.sicknesses.some(s => s.type === 'fever')) {
        clearTimeout(coughTimer);
        coughTimer = null;
        return;
    }
    playPlayerVoice('sounds/cough.wav', 0.7);
    const nextDelay = (Math.random() * 45 + 35) * 1000;
    coughTimer = setTimeout(playCoughAndScheduleNext, nextDelay);
}
// --- å‡ºè¡€ ---
function manageHeartbeatEffect() {
    const isBleeding = player.injuries.some(i => i.type === 'bleeding');
    if (isBleeding && !heartbeatTimer) {
        const initialDelay = (Math.random() * 8 + 4) * 1000;
        heartbeatTimer = setTimeout(playHeartbeatAndScheduleNext, initialDelay);
    }
}
function playHeartbeatAndScheduleNext() {
    if (!player.injuries.some(i => i.type === 'bleeding')) {
        clearTimeout(heartbeatTimer);
        heartbeatTimer = null;
        return;
    }
    playPlayerVoice('sounds/heartbeat.wav', 0.9);
    const nextDelay = (Math.random() * 10 + 10) * 1000;
    heartbeatTimer = setTimeout(playHeartbeatAndScheduleNext, nextDelay);
}

// --- æ‰“æ’² ---
function manageGruntEffect() {
    const isBruised = player.injuries.some(i => i.type === 'bruise');
    if (isBruised && !gruntTimer) {
        const initialDelay = (Math.random() * 30 + 15) * 1000;
        gruntTimer = setTimeout(playGruntAndScheduleNext, initialDelay);
    }
}
function playGruntAndScheduleNext() {
    if (!player.injuries.some(i => i.type === 'bruise')) {
        clearTimeout(gruntTimer);
        gruntTimer = null;
        return;
    }
    playPlayerVoice('sounds/grunt.wav', 0.8);
    const nextDelay = (Math.random() * 60 + 40) * 1000;
    gruntTimer = setTimeout(playGruntAndScheduleNext, nextDelay);
}


// --- éª¨æŠ˜ ---
function managePainEffect() {
    const isFractured = player.injuries.some(i => i.type === 'fracture');
    if (isFractured && !painTimer) {
        const initialDelay = (Math.random() * 25 + 10) * 1000;
        painTimer = setTimeout(playPainAndScheduleNext, initialDelay);
    }
}
/**
 * ä½“è‡­ã«å¿œã˜ã¦ãƒã‚¨ã®åŠ¹æœéŸ³ã®å†ç”Ÿ/åœæ­¢ã‚’ç®¡ç†ã™ã‚‹
 */
async function manageFlySoundEffect() {
    const bodyOdorThreshold = 70; // ãƒã‚¨ãŒãŸã‹ã‚Šå§‹ã‚ã‚‹ä½“è‡­ã®ã—ãã„å€¤

    if (player.bodyOdor > bodyOdorThreshold && !flySoundNode) {
        // ã—ãã„å€¤ã‚’è¶…ãˆã¦ã„ã¦ã€ã¾ã éŸ³ãŒå†ç”Ÿã•ã‚Œã¦ã„ãªã„å ´åˆ
        const volumeSlider = document.getElementById('volumeSlider');
        const volume = volumeSlider ? parseFloat(volumeSlider.value) * 0.5 : 0.2; // ç’°å¢ƒéŸ³ã®åŠåˆ†ã®éŸ³é‡ã«

        const audioBuffer = await loadSound('sounds/fly_buzz.wav');
        if (!audioBuffer) return;

        const gainNode = audioCtx.createGain();
        gainNode.gain.value = volume;
        gainNode.connect(audioCtx.destination);

        const sourceNode = audioCtx.createBufferSource();
        sourceNode.buffer = audioBuffer;
        sourceNode.loop = true; // éŸ³ã‚’ãƒ«ãƒ¼ãƒ—å†ç”Ÿã™ã‚‹
        sourceNode.connect(gainNode);
        sourceNode.start(0);

        flySoundNode = sourceNode; // å†ç”Ÿä¸­ã®ãƒãƒ¼ãƒ‰ã‚’ä¿å­˜
    } else if (player.bodyOdor <= bodyOdorThreshold && flySoundNode) {
        // ã—ãã„å€¤ã‚’ä¸‹å›ã£ã¦ã„ã¦ã€éŸ³ãŒå†ç”Ÿä¸­ã®å ´åˆ
        try {
            flySoundNode.stop(); // å†ç”Ÿã‚’åœæ­¢
        } catch (e) {
            // Do nothing
        }
        flySoundNode = null; // ç®¡ç†å¤‰æ•°ã‚’ãƒªã‚»ãƒƒãƒˆ
    }
}

/**
 * æ„ŸæŸ“ç—‡ã®ã†ã‚ãå£°åŠ¹æœéŸ³ã®é–‹å§‹ã¨åœæ­¢ã‚’ç®¡ç†ã™ã‚‹
 */
function manageInfectionEffect() {
    const isInfected = player.sicknesses.some(s => s.type === 'infection');

    if (isInfected && !infectionTimer) {
        // æ„ŸæŸ“ã—ã¦ã„ã¦ã€ã‚¿ã‚¤ãƒãƒ¼ãŒå‹•ã„ã¦ã„ãªã„ãªã‚‰ã€æœ€åˆã®éŸ³å£°ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
        const initialDelay = (Math.random() * 25 + 15) * 1000; // 15ã€œ40ç§’å¾Œ
        infectionTimer = setTimeout(playInfectionGroanAndScheduleNext, initialDelay);
    } else if (!isInfected && infectionTimer) {
        // æ„ŸæŸ“ã—ã¦ãŠã‚‰ãšã€ã‚¿ã‚¤ãƒãƒ¼ãŒå‹•ã„ã¦ã„ã‚‹ãªã‚‰åœæ­¢ã™ã‚‹
        clearTimeout(infectionTimer);
        infectionTimer = null;
    }
}

/**
 * æ„ŸæŸ“ç—‡ã®ã†ã‚ãå£°ã‚’å†ç”Ÿã—ã€æ¬¡ã®å†ç”Ÿã‚’ä¸å®šæœŸã«ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã™ã‚‹
 */
function playInfectionGroanAndScheduleNext() {
    if (!player.sicknesses.some(s => s.type === 'infection')) {
        clearTimeout(infectionTimer);
        infectionTimer = null;
        return; // æ„ŸæŸ“ç—‡ãŒæ²»ã£ã¦ã„ãŸã‚‰å‡¦ç†ã‚’çµ‚äº†
    }
    
    // æ„ŸæŸ“ç—‡ç”¨ã®ã†ã‚ãå£°ã‚’å†ç”Ÿ
    playSoundFile('sounds/infection_groan.wav', 0.8);

    // æ¬¡ã®å†ç”Ÿã‚’ãƒ©ãƒ³ãƒ€ãƒ ãªé–“éš”ã§è¨­å®š (40ã€œ80ç§’å¾Œ)
    const nextDelay = (Math.random() * 40 + 40) * 1000;
    infectionTimer = setTimeout(playInfectionGroanAndScheduleNext, nextDelay);
}
/**
 * æ¬¡ã®ã‚¿ãƒ¼ãƒ³ã«å—ã‘ã‚‹ã§ã‚ã‚ã†ç¶™ç¶šãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’äºˆæ¸¬ã—ã¦è¿”ã™
 * @returns {number} - äºˆæ¸¬ã•ã‚Œã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸é‡
 */
function predictNextTurnDamage() {
    let predictedDamage = 0;
    
    // ç—…æ°—ã‚„æ€ªæˆ‘ã«ã‚ˆã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’äºˆæ¸¬
    player.injuries.forEach(injury => {
        switch (injury.type) {
            case 'bleeding':
                if (!injury.treating_duration || injury.treating_duration <= 0) predictedDamage += 3;
                break;
            case 'bruise':
                predictedDamage += 1;
                break;
            case 'fracture':
                predictedDamage += injury.splinted ? 2 : 5;
                break;
        }
    });
    player.sicknesses.forEach(sickness => {
        if (!sickness.medicated_duration || sickness.medicated_duration <= 0) {
            if (sickness.type === 'fever') predictedDamage += 4;
            else predictedDamage += 2;
        }
    });

    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç•°å¸¸ã«ã‚ˆã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’äºˆæ¸¬
    if (player.bodyTemp < 35.5 || player.bodyTemp > 37.5) predictedDamage += 0.5;
    if (currentWeather.name === "åµ") predictedDamage += 1;
    if (player.morale <= 0) predictedDamage += 1;
    if (player.hunger <= 0) predictedDamage += 1.5;
    if (player.thirst <= 0) predictedDamage += 2;

    return predictedDamage;
}

/**
 * æ¬¡ã®ã‚¿ãƒ¼ãƒ³ã§æ­»äº¡ã™ã‚‹ã‹ã‚’åˆ¤å®šã—ã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æœ€å¾Œã®å£°ã‚’å†ç”Ÿã™ã‚‹
 */
function manageImpendingDoomVoice() {
    if (hasPlayedImpendingDoomVoice) return; // æ—¢ã«å†ç”Ÿæ¸ˆã¿ãªã‚‰ä½•ã‚‚ã—ãªã„

    const predictedDamage = predictNextTurnDamage();

    // ç¾åœ¨ã¯ç”Ÿå­˜ã—ã¦ã„ã‚‹ãŒã€æ¬¡ã®ã‚¿ãƒ¼ãƒ³ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã§æ­»äº¡ã™ã‚‹å ´åˆ
    if (player.health > 0 && (player.health - predictedDamage) <= 0) {
        // ä¾‹ã¨ã—ã¦'pain.wav'ã‚’å†ç”Ÿã—ã¾ã™ãŒã€å°‚ç”¨ã®éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Œã°ãã¡ã‚‰ã‚’æŒ‡å®šã—ã¦ãã ã•ã„
        playPlayerVoice('sounds/death_pain.wav', 1.0); 
        hasPlayedImpendingDoomVoice = true; // å†ç”Ÿãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
    }
}
/**
 * ãƒ¡ãƒ‹ãƒ¥ãƒ¼ç”»é¢ã®BGMã‚’å†ç”Ÿã™ã‚‹
 */
async function playMenuBGM() {
    if (bgmSourceNode) return; // æ—¢ã«å†ç”Ÿä¸­ãªã‚‰ä½•ã‚‚ã—ãªã„

    try {
        const audioBuffer = await loadSound('sounds/menu_bgm.mp3');
        if (!audioBuffer) return;

        // ç’°å¢ƒéŸ³ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‹ã‚‰éŸ³é‡ã‚’å–å¾—
        const volumeSlider = document.getElementById('volumeSlider');
        const volume = volumeSlider ? parseFloat(volumeSlider.value) : 0.4;
        if (ambientGainNode) {
            ambientGainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
        }

        const source = audioCtx.createBufferSource();
        source.buffer = audioBuffer;
        source.loop = true;
        source.connect(ambientGainNode);
        source.start(0);

        bgmSourceNode = source; // å†ç”Ÿä¸­ã®ãƒãƒ¼ãƒ‰ã‚’ä¿å­˜
    } catch (e) {
        console.error("BGMã®å†ç”Ÿã«å¤±æ•—ã—ã¾ã—ãŸ:", e);
    }
}

/**
 * ãƒ¡ãƒ‹ãƒ¥ãƒ¼ç”»é¢ã®BGMã‚’åœæ­¢ã™ã‚‹
 */
function stopMenuBGM() {
    if (bgmSourceNode) {
        try {
            bgmSourceNode.stop();
        } catch (e) {
            // Do nothing
        }
        bgmSourceNode = null;
    }
}

function playPainAndScheduleNext() {
    if (!player.injuries.some(i => i.type === 'fracture')) {
        clearTimeout(painTimer);
        painTimer = null;
        return;
    }
    playPlayerVoice('sounds/pain.wav', 0.9);
    const nextDelay = (Math.random() * 50 + 30) * 1000;
    painTimer = setTimeout(playPainAndScheduleNext, nextDelay);
}
// â–¼â–¼â–¼ æ—¢å­˜ã® updateCombatUI é–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ã€å…¨ä½“ã‚’ã€‘ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
// â–¼â–¼â–¼ æ—¢å­˜ã® updateCombatUI é–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ã€å…¨ä½“ã‚’ã€‘ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function updateCombatUI() {
    const playerCombatImageContainer = document.getElementById('combatPlayerAscii');
    const enemyCombatImageContainer = document.getElementById('combatEnemyAscii');
    const enemyNameH3 = document.getElementById('combatEnemyName');
    const enemyHealthDiv = document.getElementById('combatEnemyHealth').parentElement;

    const playerVisDiv = document.getElementById('playerVisibilityStatus');
    const enemyVisDiv = document.getElementById('enemyVisibilityStatus');
    playerVisDiv.innerHTML = `${getString("combat_visibility_status")}: ${getString(enemySeesPlayer ? "combat_vis_player_seen" : "combat_vis_player_not_seen")}`;
    enemyVisDiv.innerHTML = `${getString("combat_visibility_status")}: ${getString(playerSeesEnemy ? "combat_vis_enemy_seen" : "combat_vis_enemy_not_seen")}`;

    if (!playerSeesEnemy) {
        enemyCombatImageContainer.innerHTML = `<div class="combat-image-wrapper"><img src="images/unknown_enemy.png" alt="Unknown Enemy"></div>`;
        enemyNameH3.textContent = getString("unknown_enemy");
        enemyHealthDiv.style.display = 'none';
        document.getElementById('combatEnemyStanceContainer').style.display = 'none';
        document.getElementById('combatEnemyEquipment').style.display = 'none';
        document.getElementById('combatEnemyInjuries').style.display = 'none';
    } else {
        enemyHealthDiv.style.display = 'block';
        document.getElementById('combatEnemyStanceContainer').style.display = 'block';
        document.getElementById('combatEnemyInjuries').style.display = 'block';
        enemyNameH3.textContent = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;
        
        const enemyPortraitPath = currentEnemy.portraitIcon || currentEnemy.icon;
        enemyCombatImageContainer.innerHTML = `<div class="combat-image-wrapper"><img src="${enemyPortraitPath}" alt="Enemy Portrait"></div>`;
        const enemyImageWrapper = enemyCombatImageContainer.querySelector('.combat-image-wrapper');
        if (enemyImageWrapper) {
            const enemyBorderColor = getHealthColor(currentEnemy.health, currentEnemy.maxHealth);
            enemyImageWrapper.style.borderColor = enemyBorderColor;
        }
        document.getElementById('combatEnemyHealth').textContent = Math.max(0, currentEnemy.health).toFixed(0);
        const enemyEquipPanel = document.getElementById('combatEnemyEquipment');
        const enemyEquipListDiv = document.getElementById('combatEnemyEquipmentList');
         if (currentEnemy && (currentEnemy.isZombie || currentEnemy.isAnimal || !currentEnemy.equipment || currentEnemy.equipment.length === 0)) {
            enemyEquipPanel.style.display = 'none';
        } else if (currentEnemy) {
            enemyEquipPanel.style.display = 'block';
            enemyEquipListDiv.innerHTML = currentEnemy.equipment.map(item => `<div>${getIconHTML(getItemGraphic(item), 16)} ${getItemDisplayName(item)}</div>`).join('');
        }
    }

    const raceKey = character.race.replace('race_', '');
    const genderKey = character.gender.replace('gender_', '');
    const portraitIconPath = `images/portrait_${raceKey}_${genderKey}.png`;
    playerCombatImageContainer.innerHTML = `<div class="combat-image-wrapper"><img src="${portraitIconPath}" alt="Player Portrait"></div>`;
    const playerImageWrapper = playerCombatImageContainer.querySelector('.combat-image-wrapper');
    if (playerImageWrapper) {
        const playerBorderColor = getHealthColor(player.health, maxStats.health);
        playerImageWrapper.style.borderColor = playerBorderColor;
    }
    document.getElementById('combatPlayerHealth').textContent = `${Math.max(0, player.health).toFixed(0)} / ${maxStats.health}`;
    document.getElementById('combatPlayerAttack').textContent = player.attack;
    document.getElementById('combatPlayerDefense').textContent = player.defense;
    const playerEquipDiv = document.getElementById('combatEquipmentList');
    playerEquipDiv.innerHTML = player.equipment.length > 0 ? player.equipment.map(item => `<div>${getIconHTML(getItemGraphic(item), 16)} ${getSlotName(item.slot)}: ${getItemDisplayName(item)}</div>`).join('') : getString('item_none');
    
    const distanceDisplay = document.getElementById('combatDistanceDisplay');
    const weatherDisplay = document.getElementById('combatWeatherDisplay');
    const dayStateDisplay = document.getElementById('combatDayStateDisplay');

    if (distanceDisplay) {
        if (playerSeesEnemy) {
            distanceDisplay.innerHTML = `${getString("combat_distance")}: ${combatDistance}`;
        } else {
            distanceDisplay.innerHTML = `${getString("combat_distance")}: ?`;
        }
    }

    if (weatherDisplay && dayStateDisplay) {
        let dayState, dayStateKey;
        const hour = currentTime.getHours();
        if (hour >= 6 && hour < 12) { dayState = 'æœ'; dayStateKey = "daystate_æœ"; } 
        else if (hour >= 12 && hour < 18) { dayState = 'æ˜¼'; dayStateKey = "daystate_æ˜¼"; } 
        else if (hour >= 18 && hour < 21) { dayState = 'å¤•æ–¹'; dayStateKey = "daystate_å¤•æ–¹"; } 
        else { dayState = 'å¤œ'; dayStateKey = "daystate_å¤œ"; }
        
        dayStateDisplay.innerHTML = getIconHTML(dayStateInfo[dayState].icon, 24);
        weatherDisplay.innerHTML = getIconHTML(currentWeather.icon, 24);
    }
    weatherDisplay.onmouseenter = showWeatherTooltip;
    weatherDisplay.onmouseleave = hideInfoTooltip;
    weatherDisplay.onmousemove = updatePreviewPosition;
    dayStateDisplay.onmouseenter = showDayStateTooltip;
    dayStateDisplay.onmouseleave = hideInfoTooltip;
    dayStateDisplay.onmousemove = updatePreviewPosition;

    const attackMainBtn = document.getElementById('attackMainBtn');
    const attackOffBtn = document.getElementById('attackOffBtn');
    const heavyMeleeBtn = document.getElementById('heavyMeleeBtn');
    const heavyMeleeOffBtn = document.getElementById('heavyMeleeOffBtn');
    const heavyRangedBtn = document.getElementById('heavyRangedBtn');
    const fireBtn = document.getElementById('fireBtn');
    const advanceBtn = document.getElementById('advanceBtn');
    const retreatBtn = document.getElementById('retreatBtn');
    const dodgeBtn = document.getElementById('dodgeBtn');
    const aimBtn = document.getElementById('aimBtn');
    const parryBtn = document.getElementById('parryBtn');
    const legTripBtn = document.getElementById('legTripBtn');
    const proneBtn = document.getElementById('proneBtn');
    const standUpBtn = document.getElementById('standUpBtn');
    const forwardRollBtn = document.getElementById('forwardRollBtn');
    const backwardRollBtn = document.getElementById('backwardRollBtn');
    const sprintForwardBtn = document.getElementById('sprintForwardBtn');
    const sprintBackwardBtn = document.getElementById('sprintBackwardBtn');
    const runBtn = document.getElementById('runBtn');
    const throwWeaponBtn = document.getElementById('throwWeaponBtn');
    const searchOpponentBtn = document.getElementById('searchOpponentBtn');

    const hasFracture = player.injuries.some(i => i.type === 'fracture');

    [attackMainBtn, attackOffBtn, heavyMeleeBtn, heavyMeleeOffBtn, heavyRangedBtn, fireBtn, advanceBtn, retreatBtn, dodgeBtn, aimBtn, parryBtn, legTripBtn, proneBtn, standUpBtn, forwardRollBtn, backwardRollBtn, sprintForwardBtn, sprintBackwardBtn, runBtn, throwWeaponBtn, searchOpponentBtn].forEach(btn => {
        if(btn) btn.style.display = 'none';
    });
    
    if (!playerSeesEnemy) {
        searchOpponentBtn.style.display = 'block';
        if (player.stance === 'prone') {
            standUpBtn.style.display = 'block';
        } else {
            proneBtn.style.display = 'block';
        }
        runBtn.style.display = 'block';
    } else {
        const mainHandWeapon = player.equipment.find(e => e.slot === 'main_hand' || e.handedness === 'two');
        const offHandWeapon = player.equipment.find(e => e.slot === 'off_hand');
        const loadedGun = player.equipment.find(e => e.ammoType && e.loadedAmmo > 0);
        const throwableWeapon = player.equipment.find(e => e.isThrowable);
        const canMeleeAttack = combatDistance <= player.reach;
        const hasMeleeWeapon = mainHandWeapon || offHandWeapon;

        if (player.stance === 'standing') {
            if (throwableWeapon && combatDistance > 1) { throwWeaponBtn.style.display = 'block'; }
            if (canMeleeAttack) {
                const mainWeaponName = mainHandWeapon ? getBaseItemName(mainHandWeapon) : getString('combat_attack_bare_hand');
                attackMainBtn.textContent = `${getString('combat_attack')} (${mainWeaponName})`;
                attackMainBtn.style.display = 'block';
                if (offHandWeapon) {
                    attackOffBtn.textContent = `${getString('combat_attack')} (${getBaseItemName(offHandWeapon)})`;
                    attackOffBtn.style.display = 'block';
                }

                if (player.heavyAttackCooldown === 0) {
                    // â˜…â˜…â˜… ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â˜…â˜…â˜…
                    // ãƒ¡ã‚¤ãƒ³ãƒãƒ³ãƒ‰ã«éŠƒã‚’æŒã£ã¦ã„ãªã„ï¼ˆç´ æ‰‹ or è¿‘æ¥æ­¦å™¨ï¼‰å ´åˆã«ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
                    if (!mainHandWeapon || !mainHandWeapon.fireDamage) {
                        heavyMeleeBtn.textContent = `${getString('btn_heavy_attack_melee')} (${mainWeaponName})`;
                        heavyMeleeBtn.style.display = 'block';
                    }
                    // ã‚ªãƒ•ãƒãƒ³ãƒ‰ã«éŠƒã‚’æŒã£ã¦ã„ãªã„ï¼ˆç´ æ‰‹ or è¿‘æ¥æ­¦å™¨ï¼‰å ´åˆã«ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
                    if (offHandWeapon && !offHandWeapon.fireDamage) {
                        heavyMeleeOffBtn.textContent = `${getString('btn_heavy_attack_melee')} (${getBaseItemName(offHandWeapon)})`;
                        heavyMeleeOffBtn.style.display = 'block';
                    }
                    // â˜…â˜…â˜… ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â˜…â˜…â˜…
                }
                if (hasMeleeWeapon) {
                    parryBtn.style.display = 'block';
                    legTripBtn.style.display = 'block';
                }
            }
            if (loadedGun) {
                fireBtn.textContent = `${getString('combat_fire')} (${getBaseItemName(loadedGun)})`;
                fireBtn.style.display = 'block';
                if (player.heavyAttackCooldown === 0) {
                    heavyRangedBtn.textContent = `${getString('btn_heavy_attack_ranged')} (${getBaseItemName(loadedGun)})`;
                    heavyRangedBtn.style.display = 'block';
                }
            }
            if (combatDistance > 1) advanceBtn.style.display = 'block';
            if (combatDistance < MAX_COMBAT_DISTANCE) retreatBtn.style.display = 'block';
            dodgeBtn.style.display = 'block';
            aimBtn.style.display = 'block';
            runBtn.style.display = 'block';
            proneBtn.style.display = 'block';
            
            if (!hasFracture) {
                sprintForwardBtn.style.display = combatDistance > 2 ? 'block' : 'none';
                sprintBackwardBtn.style.display = combatDistance < MAX_COMBAT_DISTANCE ? 'block' : 'none';
            }

        } else { // Prone
            standUpBtn.style.display = 'block';
            if (!hasFracture) {
                forwardRollBtn.style.display = combatDistance > 1 ? 'block' : 'none';
                backwardRollBtn.style.display = combatDistance < MAX_COMBAT_DISTANCE ? 'block' : 'none';
            }
        }
    }
    
    let escapeChance = 0;
    if (!playerSeesEnemy && !enemySeesPlayer) { escapeChance = 0.50; }
    else if (!playerSeesEnemy && enemySeesPlayer) { escapeChance = 0.10; }
    else if (playerSeesEnemy && !enemySeesPlayer) { escapeChance = 0.80; }
    else {
        const baseEscapeChance = 0.10;
        const distanceBonus = (combatDistance - 1) * 0.04;
        escapeChance = Math.min(0.95, baseEscapeChance + distanceBonus);
    }
    const chancePercent = Math.round(escapeChance * 100);
    const runBtnTooltipDesc = getString("tooltip_action_run_dynamic", { chance: chancePercent });
    runBtn.onmouseenter = (e) => showInfoTooltip(e, getString('combat_run'), runBtnTooltipDesc);
    runBtn.onmouseleave = hideInfoTooltip;
    runBtn.onmousemove = (e) => updatePreviewPosition(e);
    
    document.querySelectorAll('#combatActions button').forEach(btn => btn.style.gridColumn = 'auto');
    const visibleButtons = Array.from(document.getElementById('combatActions').children)
                            .filter(btn => btn.id !== 'runBtn' && window.getComputedStyle(btn).display !== 'none');
    if (visibleButtons.length === 1) {
        visibleButtons[0].style.gridColumn = 'span 2';
    }
    
    let playerStanceKey = 'stance_standing';
    if (player.stance === 'prone' || player.stance === 'rolling') {
        playerStanceKey = 'stance_prone';
    }
    document.getElementById('combatPlayerStance').textContent = getString(playerStanceKey);

    const enemyStanceContainer = document.getElementById('combatEnemyStanceContainer');
    let enemyStanceKey = 'stance_standing';
    if (currentEnemy) {
        if (playerSeesEnemy) {
             enemyStanceContainer.style.display = 'block';
             if (currentEnemy.stance === 'prone' || currentEnemy.stance === 'rolling') {
                enemyStanceKey = 'stance_prone';
            }
        } else {
            enemyStanceContainer.style.display = 'none';
        }
    } else {
        enemyStanceContainer.style.display = 'none';
    }
    document.getElementById('combatEnemyStance').textContent = getString(enemyStanceKey);
}
// â–¼â–¼â–¼ æ—¢å­˜ã®showStatusPanelStatTooltipé–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
/**
 * ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ‘ãƒãƒ«ã®æ”»æ’ƒåŠ›ãƒ»é˜²å¾¡åŠ›ã«ã‚«ãƒ¼ã‚½ãƒ«ã‚’åˆã‚ã›ãŸéš›ã«ã€å†…è¨³ã‚’è¡¨ç¤ºã™ã‚‹
 * @param {string} stat - 'attack' ã¾ãŸã¯ 'defense'
 * @param {MouseEvent} event - ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
 */
function showStatusPanelStatTooltip(stat, event) {
    const preview = document.getElementById("statusPreview");
    const titleKey = stat === 'attack' ? "tooltip_combat_stat_attack" : "tooltip_combat_stat_defense";
    let contentHtml = `<strong>${getString(titleKey)}</strong><br/>`;

    let total, baseStat;
    if (stat === 'attack') {
        baseStat = player.baseAttack;
        total = player.attack;
    } else {
        baseStat = player.baseDefense;
        total = player.defense;
    }

    contentHtml += `<div>${getString("tooltip_combat_stat_base")}: ${baseStat}</div><div style="border-bottom: 1px solid #555; margin: 2px 0;"></div>`;

    if (stat === 'attack') {
        // --- ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ ---
        // æœ€ã‚‚å¼·ã„è¿‘æ¥æ­¦å™¨ã‚’1ã¤ã ã‘è¦‹ã¤ã‘ã‚‹ãƒ­ã‚¸ãƒƒã‚¯
        let bestMeleeWeapon = null;
        let maxEffectiveAttack = 0;

        player.equipment.forEach(item => {
            let currentAttack = item.attack || 0;
            if (item.name === 'ãƒ©ã‚¤ãƒ•ãƒ«' && item.bayonetAttached) {
                const knifeTemplate = items.find(i => i.name === item.attachedBayonetName);
                if (knifeTemplate) {
                    currentAttack = Math.max(currentAttack, knifeTemplate.attack);
                }
            }

            if (currentAttack > 0) {
                const durabilityFactor = (item.durability === undefined ? 100 : item.durability) / 100;
                const effectiveAttack = currentAttack * durabilityFactor;
                if (effectiveAttack > maxEffectiveAttack) {
                    maxEffectiveAttack = effectiveAttack;
                    bestMeleeWeapon = item;
                }
            }
        });

        // æœ€ã‚‚å¼·ã„æ­¦å™¨ã®ãƒœãƒ¼ãƒŠã‚¹ã®ã¿è¡¨ç¤ºã™ã‚‹
        if (bestMeleeWeapon) {
            contentHtml += `<div>${getBaseItemName(bestMeleeWeapon)}: +${Math.floor(maxEffectiveAttack)}</div>`;
        }
        // --- ä¿®æ­£ã¯ã“ã“ã¾ã§ ---
    } else { // é˜²å¾¡åŠ›ã®å ´åˆã¯å…¨ã¦ã®é˜²å…·ã‚’åˆç®—è¡¨ç¤º
        player.equipment.forEach(item => {
            const durabilityFactor = (item.durability === undefined ? 100 : item.durability) / 100;
            const bonus = (item.defense || 0) * durabilityFactor;
            if (bonus > 0) {
                contentHtml += `<div>${getBaseItemName(item)}: +${Math.floor(bonus)}</div>`;
            }
        });
    }
    
    contentHtml += `<div style="border-bottom: 1px solid #555; margin: 2px 0;"></div><div><strong>${getString("tooltip_combat_stat_total")}: ${total}</strong></div>`;
    
    preview.innerHTML = contentHtml;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}
// â–¼â–¼â–¼ æ—¢å­˜ã®showCombatStatTooltipé–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function showCombatStatTooltip(stat, event) {
    const preview = document.getElementById("statusPreview");
    let contentHtml = `<strong>${getString(stat === 'attack' ? "tooltip_combat_stat_attack" : "tooltip_combat_stat_defense")}</strong><br/>`;
    let total = 0, baseStat = 0;
    if (stat === 'attack') { baseStat = player.baseAttack; total = player.attack; } else { baseStat = player.baseDefense; total = player.defense; }
    
    contentHtml += `<div>${getString("tooltip_combat_stat_base")}: ${baseStat}</div><div style="border-bottom: 1px solid #555; margin: 2px 0;"></div>`;
    
    if (stat === 'attack') {
        // --- ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ ---
        // æœ€ã‚‚å¼·ã„è¿‘æ¥æ­¦å™¨ã‚’1ã¤ã ã‘è¦‹ã¤ã‘ã‚‹ãƒ­ã‚¸ãƒƒã‚¯
        let bestMeleeWeapon = null;
        let maxEffectiveAttack = 0;

        player.equipment.forEach(item => {
            let currentAttack = item.attack || 0;
            if (item.name === 'ãƒ©ã‚¤ãƒ•ãƒ«' && item.bayonetAttached) {
                const knifeTemplate = items.find(i => i.name === item.attachedBayonetName);
                if (knifeTemplate) {
                    currentAttack = Math.max(currentAttack, knifeTemplate.attack);
                }
            }

            if (currentAttack > 0) {
                const durabilityFactor = (item.durability === undefined ? 100 : item.durability) / 100;
                const effectiveAttack = currentAttack * durabilityFactor;
                if (effectiveAttack > maxEffectiveAttack) {
                    maxEffectiveAttack = effectiveAttack;
                    bestMeleeWeapon = item;
                }
            }
        });

        // æœ€ã‚‚å¼·ã„æ­¦å™¨ã®ãƒœãƒ¼ãƒŠã‚¹ã®ã¿è¡¨ç¤ºã™ã‚‹
        if (bestMeleeWeapon) {
            contentHtml += `<div>${getBaseItemName(bestMeleeWeapon)}: +${Math.floor(maxEffectiveAttack)}</div>`;
        }
        // --- ä¿®æ­£ã¯ã“ã“ã¾ã§ ---
    } else { // é˜²å¾¡åŠ›ã®å ´åˆã¯å…¨ã¦ã®é˜²å…·ã‚’åˆç®—è¡¨ç¤º
        player.equipment.forEach(item => {
            const durabilityFactor = (item.durability === undefined ? 100 : item.durability) / 100;
            const bonus = (item.defense || 0) * durabilityFactor;
            if (bonus > 0) {
                contentHtml += `<div>${getBaseItemName(item)}: +${Math.floor(bonus)}</div>`;
            }
        });
    }
    
    contentHtml += `<div style="border-bottom: 1px solid #555; margin: 2px 0;"></div><div><strong>${getString("tooltip_combat_stat_total")}: ${total}</strong></div>`;
    preview.innerHTML = contentHtml; 
    preview.style.display = 'block'; 
    updatePreviewPosition(event);
}


function hideCombatStatTooltip() { document.getElementById("statusPreview").style.display = "none"; }
function showCombatActionTooltip(event, actionKey) {
    const preview = document.getElementById("statusPreview");
    const button = event.target;
    const title = button.textContent.trim();
    const description = getString(`tooltip_action_${actionKey}`);
    
    preview.innerHTML = `<strong>${title}</strong><div style="margin-top: 5px;">${description}</div>`;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}

function hideCombatActionTooltip() {
    hideStatusPreview();
}

function combatLogMessage(msg, type = 'normal', onEndCallback) {
    const combatLog = document.getElementById('combatLog'), msgDiv = document.createElement('div');
    msgDiv.innerHTML = msg; // â† ã“ã“ã‚’ innerHTML ã«å¤‰æ›´
    if (type === 'playerAttack') msgDiv.style.color = 'lightblue'; else if (type === 'enemyAttack') msgDiv.style.color = 'indianred';
    else if (type === 'playerFire') msgDiv.style.color = '#e67e22';
    else if (type === 'victory') msgDiv.style.color = 'lightgreen'; else if (type === 'defeat') msgDiv.style.color = 'red';
    else if (type === 'run') msgDiv.style.color = 'yellow';
    combatLog.appendChild(msgDiv); combatLog.scrollTop = combatLog.scrollHeight;
    speak(msg, onEndCallback);
}

function showDealtDamage(dmg) {
    const damageText = document.createElement('div'); damageText.textContent = `-${dmg}`;
    damageText.style.cssText = "position: absolute; left: 50%; top: 40%; transform: translate(-50%, -50%) scale(1); font-size: 4em; font-weight: bold; color: #3498db; text-shadow: 0 0 8px #000; opacity: 0; pointer-events: none; transition: opacity 0.5s ease-out, transform 0.5s ease-out; z-index: 100;";
    const enemyPanel = document.getElementById('combatEnemy');
    enemyPanel.appendChild(damageText);
    setTimeout(() => { damageText.style.opacity = '1'; damageText.style.transform = 'translate(-50%, -50%) scale(1.5)'; }, 10);
    setTimeout(() => { damageText.style.opacity = '0'; damageText.style.transform = 'translate(-50%, -50%) scale(3)'; setTimeout(() => { if(damageText.parentNode) enemyPanel.removeChild(damageText); }, 500); }, 600);
}

function handleAttack(hand) {
    player.isAiming = false;
    lockCombatInteractionPanels(); // â–¼â–¼â–¼ ã“ã®è¡Œã‚’è¿½åŠ  â–¼â–¼â–¼
    snapshotStats();
    document.querySelectorAll('#combatActions button').forEach(btn => btn.disabled = true);
    const targetPart = randChoice(bodyParts);    
    const missPenalty = getAccuracyModifier();
    const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;
    let weapon, baseAccuracy = 70;
    const targetSlot = (hand === 'off') ? 'off_hand' : 'main_hand';
    weapon = player.equipment.find(e => e.slot === targetSlot) || (hand === 'main' ? player.equipment.find(e => e.handedness === 'two') : null);
    if (weapon) baseAccuracy = weapon.accuracy || 70;
    
    let finalMissChance = (1 - (baseAccuracy / 100)) + missPenalty;
    finalMissChance += getUnseenTargetModifier(false);
    // â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ–°ã—ãè¿½åŠ  â–¼â–¼â–¼
    if (player.isAiming) {
        finalMissChance -= 0.30; // å‘½ä¸­ç‡ã‚’30%å‘ä¸Šï¼ˆå¤±æ•—ç¢ºç‡ã‚’30%æ¸›å°‘ï¼‰
        player.isAiming = false; // ã€Œç‹™ã„ã€ã®åŠ¹æœã‚’æ¶ˆè²»ã™ã‚‹
    }
    finalMissChance = Math.max(0.05, finalMissChance); // æœ€ä½ã§ã‚‚5%ã¯å¤±æ•—ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹
    // â–²â–²â–² è¿½åŠ ã¯ã“ã“ã¾ã§ â–²â–²â–²
    if (Math.random() < finalMissChance) {
        playSoundFile('sounds/attack_miss.wav');
        
        // â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
        // 5%ã®ç¢ºç‡ã§æ­¦å™¨ã‚’è½ã¨ã™
        if (weapon && Math.random() < 0.05) {
            const weaponIndex = player.equipment.findIndex(e => e === weapon);
            if (weaponIndex > -1) {
                const droppedWeapon = player.equipment.splice(weaponIndex, 1)[0];
                const locationKey = `${player.x},${player.y}`;
                if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
                droppedItems[locationKey].push(droppedWeapon);
                
                combatLogMessage(`æ”»æ’ƒã‚’å¤–ã—ã€å‹•æºã—ã¦${getItemDisplayName(droppedWeapon)}ã‚’è½ã¨ã—ã¦ã—ã¾ã£ãŸï¼`, 'enemyAttack');
                updateBodyPanel(); // èº«ä½“ãƒ‘ãƒãƒ«ã‚’æ›´æ–°
                updateEquippedStats(); // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å†è¨ˆç®—
            }
        }
        // â–²â–²â–² è¿½åŠ ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²
    combatLogMessage(getString("log_player_attack_missed", { enemyName: enemyName }), 'enemyAttack', () => {
            enemyCombatTurn();
        });
        return;
    }

    if (currentEnemy.isDodging && Math.random() < 0.5) {
        combatLogMessage(getString("log_player_attack_dodged", { enemyName: enemyName }), 'enemyAttack', () => {
            enemyCombatTurn();
        });
        return;
    }

    if (weapon) {
        if (weapon.isBlade) {
            playSoundFile('sounds/blade_hit.wav');
        } else {
            playSoundFile('sounds/blunt_hit.wav');
        }
    } else {
        playSoundFile('sounds/punch.wav');
    }

    createSound(player.x, player.y, 4);
    
    let baseDamage = player.baseAttack;
    if (weapon) {
        const durabilityFactor = 0.3 + 0.7 * ((weapon.durability === undefined ? 100 : weapon.durability) / 100);
        let itemAttack = weapon.attack || 0;
        if (weapon.name === 'ãƒ©ã‚¤ãƒ•ãƒ«' && weapon.bayonetAttached && weapon.loadedAmmo === 0) {
            const knife = items.find(i => i.name === 'ãƒŠã‚¤ãƒ•');
            itemAttack = knife ? knife.attack : (weapon.attack || 0);
        }
        baseDamage = Math.floor(itemAttack * durabilityFactor);
    }
    
    let damageBonus = 0;
    if (currentEnemy.vulnerableTurns > 0) damageBonus += Math.floor(baseDamage * 0.5);
    if (currentEnemy.isProne) damageBonus += Math.floor(baseDamage * 0.5);

    const damageMultiplier = 100 / (100 + (currentEnemy.defense || 0));
    const randomVariance = baseDamage * (Math.random() * 0.2 - 0.1); // ãƒ€ãƒ¡ãƒ¼ã‚¸ã«Â±10%ã®æºã‚‰ãã‚’è¿½åŠ 
    let calculatedDamage = (baseDamage + randomVariance) * damageMultiplier;
    calculatedDamage += damageBonus; //  vulnerableçŠ¶æ…‹ãªã©ã®ãƒœãƒ¼ãƒŠã‚¹ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’åŠ ç®—
    const playerDamage = Math.max(1, Math.round(calculatedDamage));
    currentEnemy.health -= playerDamage;
    resolveKnockdown(currentEnemy, playerDamage);
    triggerShakeAnimation('combatEnemyAscii');
    showDealtDamage(playerDamage.toFixed(0));
    
    resolveCriticalHit(currentEnemy, targetPart);

   if (weapon) {
       reduceCombatItemDurability(weapon, 1);
    }
    
    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â–¼â–¼â–¼

    const translatedPartName = getString('part_' + targetPart);

    const logKey = weapon ? "combat_attack_player_part" : "combat_attack_player_barehand_part";
    const weaponNameForLog = weapon ? getBaseItemName(weapon) : getString("combat_attack_bare_hand");
    const logText = getString(logKey, { weaponName: weaponNameForLog, enemyName: enemyName, damage: playerDamage.toFixed(0), partName: translatedPartName });
    // â–²â–²â–² ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²

    combatLogMessage(logText, 'playerAttack', () => {
        updateEquippedStats(); 
        updateCombatUI();
        updateItemPanels();
        if (currentEnemy.health <= 0) {
            endCombat(true);
        } else if (currentEnemy.flees) {
            // --- ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ ---
            let escapeChance = 0;
            // NPCè¦–ç‚¹ã§ã®ç¢ºç‡è¨ˆç®—
            if (!playerSeesEnemy && !enemySeesPlayer) { // ãŠäº’ã„ã«è¦‹ãˆã¦ã„ãªã„
                escapeChance = 0.50; // 50%
            } else if (playerSeesEnemy && !enemySeesPlayer) { // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã ã‘ãŒè¦‹ãˆã¦ã„ã‚‹
                escapeChance = 0.10; // 10%
            } else if (!playerSeesEnemy && enemySeesPlayer) { // NPCã ã‘ãŒè¦‹ãˆã¦ã„ã‚‹
                escapeChance = 0.80; // 80%
            } else { // ãŠäº’ã„ã«è¦‹ãˆã¦ã„ã‚‹ï¼ˆå¾“æ¥ã®è·é›¢è¨ˆç®—ï¼‰
                const baseEscapeChance = 0.10;
                const distanceBonus = (combatDistance - 1) * 0.04;
                escapeChance = Math.min(0.95, baseEscapeChance + distanceBonus);
            }
            // --- ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ ---;

            if (Math.random() < escapeChance) {
                const fleeEnemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;
                const fleeTile = findSafeFleeTileForEntity(currentEnemy);
                if (fleeTile) {
                    const enemyInList = entities.find(e => e === currentEnemy);
                    if (enemyInList) {
                        enemyInList.x = fleeTile.x;
                        enemyInList.y = fleeTile.y;
                    }
                }
                combatLogMessage(getString("log_enemy_fled", { enemyName: fleeEnemyName }), 'run', () => endCombat('escaped'));
            } else {
                enemyCombatTurn();
            }
        }
        else {
            enemyCombatTurn();
        }
    });
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’æ–°ã—ãè¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
/**
 * è£…å‚™ã—ã¦ã„ã‚‹æŠ•æ“²æ­¦å™¨ã‚’æŠ•ã’ã‚‹å‡¦ç†
 */
function handleThrow() {
    player.isAiming = false;
    lockCombatInteractionPanels(); // â–¼â–¼â–¼ ã“ã®è¡Œã‚’è¿½åŠ  â–¼â–¼â–¼
    document.querySelectorAll('#combatActions button').forEach(btn => btn.disabled = true);
    
    // è£…å‚™ã—ã¦ã„ã‚‹æŠ•æ“²å¯èƒ½ãªæ­¦å™¨ï¼ˆçŸ³ï¼‰ã‚’æ¢ã™
    const weaponIndex = player.equipment.findIndex(e => e.isThrowable);
    if (weaponIndex === -1) {
        startPlayerTurn(); // æŠ•ã’ã‚‰ã‚Œã‚‹æ­¦å™¨ãŒãªã‘ã‚Œã°è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ã«æˆ»ã‚‹
        return;
    }
    const weapon = player.equipment[weaponIndex];
    const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;
    
    // å‘½ä¸­åˆ¤å®š
    const missPenalty = getAccuracyModifier();
    let finalMissChance = (1 - ((weapon.accuracy || 65) / 100)) + missPenalty;
    finalMissChance += getUnseenTargetModifier(false);
    // â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ–°ã—ãè¿½åŠ  â–¼â–¼â–¼
    if (player.isAiming) {
        finalMissChance -= 0.30; // å‘½ä¸­ç‡ã‚’30%å‘ä¸Šï¼ˆå¤±æ•—ç¢ºç‡ã‚’30%æ¸›å°‘ï¼‰
        player.isAiming = false; // ã€Œç‹™ã„ã€ã®åŠ¹æœã‚’æ¶ˆè²»ã™ã‚‹
    }
    finalMissChance = Math.max(0.05, finalMissChance); // æœ€ä½ã§ã‚‚5%ã¯å¤±æ•—ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹
    // â–²â–²â–² è¿½åŠ ã¯ã“ã“ã¾ã§ â–²â–²â–² 
   if (Math.random() < finalMissChance || (currentEnemy.isDodging && Math.random() < 0.5)) {
        // ãƒŸã‚¹ã—ãŸå ´åˆ
        playSoundFile('sounds/attack_miss.wav');
        combatLogMessage(getString("log_player_attack_missed", { enemyName: enemyName }), 'enemyAttack', () => {
            // çŸ³ã‚’æ¶ˆè²»
            player.equipment.splice(weaponIndex, 1);
            updateEquippedStats();
            enemyCombatTurn();
        });
        return;
    }

    // ãƒ’ãƒƒãƒˆã—ãŸå ´åˆ
    playSoundFile('sounds/throw_hit.wav'); // æ–°ã—ã„åŠ¹æœéŸ³ï¼ˆãªã‘ã‚Œã°'blunt_hit.wav'ãªã©ï¼‰
    createSound(player.x, player.y, 4);

    const playerDamage = Math.max(1, (weapon.throwDamage || 8) - (currentEnemy.defense || 0) + (Math.floor(Math.random() * 5) - 2));
    currentEnemy.health -= playerDamage;
    triggerShakeAnimation('combatEnemyAscii');
    showDealtDamage(playerDamage.toFixed(0));

    const logText = `${getItemDisplayName(weapon)}ã‚’æŠ•ã’ã¤ã‘ãŸï¼${enemyName}ã«${playerDamage.toFixed(0)}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆãŸã€‚`;

    combatLogMessage(logText, 'playerAttack', () => {
        // çŸ³ã‚’æ¶ˆè²»
        player.equipment.splice(weaponIndex, 1);
        updateEquippedStats();
        if (currentEnemy.health <= 0) {
            endCombat(true);
        } else {
            enemyCombatTurn();
        }
    });
}
// â–¼â–¼â–¼ æ—¢å­˜ã®handleFireé–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function handleFire() {
    if (isInteractionActive) return; // è¡Œå‹•ãƒ­ãƒƒã‚¯ãŒã‹ã‹ã£ã¦ã„ã‚Œã°ã€å³åº§ã«å‡¦ç†ã‚’ä¸­æ–­
    isInteractionActive = true;     // è¡Œå‹•ãƒ­ãƒƒã‚¯ã‚’ã‹ã‘ã‚‹
    player.isAiming = false; // â˜…æ”»æ’ƒä»¥å¤–ã®è¡Œå‹•ã§ç‹™ã„ã‚’è§£é™¤ã—å¿˜ã‚ŒãŸå ´åˆã®ä¿é™ºã¨ã—ã¦è¿½åŠ 
    lockCombatInteractionPanels(); // â–¼â–¼â–¼ ã“ã®è¡Œã‚’è¿½åŠ  â–¼â–¼â–¼
    snapshotStats();
    document.querySelectorAll('#combatActions button').forEach(btn => btn.disabled = true);
    const targetPart = randChoice(bodyParts);    
    const gun = player.equipment.find(e => e.ammoType && e.loadedAmmo > 0);
    if (!gun) {
        startPlayerTurn();
        return;
    }

    // --- ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ ---
    // ç™ºå°„éŸ³ã®å†ç”Ÿã¨å¼¾è–¬ã®æ¶ˆè²»ã‚’ã€å‘½ä¸­åˆ¤å®šã®å‰ã«è¡Œã†ã‚ˆã†ã«ç§»å‹•
    if (gun.ammoType === 'shotgun') {
        playSoundFile('sounds/shotgun.wav');
    } else if (gun.ammoType === 'rifle') {
        playSoundFile('sounds/rifle.wav');
    } else if (gun.ammoType === 'pistol') {
        playSoundFile('sounds/pistol.wav');
    } else {
        playSound('gunshot'); // ã‚¹ãƒªãƒ³ã‚°ãªã©ã‚‚ã“ã®éŸ³ã‚’å…±æœ‰
    }
    createSound(player.x, player.y, 25);
    gun.loadedAmmo--; // ç™ºå°„ã—ãŸæ™‚ç‚¹ã§å¼¾è–¬ã‚’æ¶ˆè²»
    // --- ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ ---

    let missChance = (1 - ((gun.accuracy || 85) / 100)) + getAccuracyModifier();
    missChance += getUnseenTargetModifier(false);
    if (currentEnemy.isProne) missChance += 0.75;
    if (currentEnemy.vulnerableTurns > 0) missChance = 0;
// â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒã€Œç‹™ã„ã‚’ã¤ã‘ã‚‹ã€åŠ¹æœã®é©ç”¨ç®‡æ‰€ã§ã™ â–¼â–¼â–¼
if (player.isAiming) {
    missChance -= 0.30; // å‘½ä¸­ç‡ã‚’30%å‘ä¸Šï¼ˆå¤±æ•—ç¢ºç‡ã‚’30%æ¸›å°‘ï¼‰
    player.isAiming = false; // ã€Œç‹™ã„ã€ã®åŠ¹æœã‚’æ¶ˆè²»ã™ã‚‹
}
missChance = Math.max(0.05, missChance); // æœ€ä½ã§ã‚‚5%ã¯å¤±æ•—ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹
// â–²â–²â–² è¿½åŠ ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²
    if (Math.random() < missChance) {
        playSoundFile('sounds/attack_miss.wav');
        const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;
        const missLogKey = currentEnemy.isProne ? "log_player_miss_prone" : "log_player_attack_missed";
        combatLogMessage(getString(missLogKey, { enemyName: enemyName }), 'enemyAttack', () => {
            enemyCombatTurn();
        });
        return;
    }
    
    const damageMultiplier = 100 / (100 + (currentEnemy.defense || 0));
    const randomVariance = gun.fireDamage * (Math.random() * 0.2 - 0.1);
    let calculatedDamage = (gun.fireDamage + randomVariance) * damageMultiplier;
    const playerDamage = Math.max(1, Math.round(calculatedDamage));
    currentEnemy.health -= playerDamage;
    resolveKnockdown(currentEnemy, playerDamage);
    triggerShakeAnimation('combatEnemyAscii');
    showDealtDamage(playerDamage.toFixed(0));

    resolveCriticalHit(currentEnemy, targetPart);

    const enemyName = getString(`item_${currentEnemy.name}_name`) || enemy.name;
    const weaponName = getBaseItemName(gun);
    
    const translatedPartName = getString('part_' + targetPart);
    const logText = getString("combat_fire_player_part", { weaponName: weaponName, enemyName: enemyName, damage: playerDamage.toFixed(0), partName: translatedPartName });

    combatLogMessage(logText, 'playerFire', () => {
        updateCombatUI();
        if (currentEnemy.health <= 0) endCombat(true);
        else enemyCombatTurn();
    });
}
/**
 * ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒç¢ºç‡ã§ä¼ã›çŠ¶æ…‹ã«ãªã‚‹ã‹åˆ¤å®šã™ã‚‹
 * @param {object} target - ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸå¯¾è±¡ (player ã¾ãŸã¯ currentEnemy)
 * @param {number} damageDealt - ä¸ãˆã‚‰ã‚ŒãŸãƒ€ãƒ¡ãƒ¼ã‚¸é‡
 */
function resolveKnockdown(target, damageDealt) {
    if (target.stance === 'prone' || !target.maxHealth) return; // æ—¢ã«ä¼ã›ã¦ã„ã‚‹å ´åˆã‚„æœ€å¤§ä½“åŠ›ãŒãªã„å ´åˆã¯ä½•ã‚‚ã—ãªã„

    // æœ€å¤§ä½“åŠ›ã«å¯¾ã™ã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸ã®å‰²åˆã§ãƒãƒƒã‚¯ãƒ€ã‚¦ãƒ³ç¢ºç‡ã‚’è¨ˆç®—
    const knockdownChance = damageDealt / target.maxHealth;

    if (Math.random() < knockdownChance) {
        target.stance = 'prone';
        const targetName = (target === player) ? getString("you") : (getString(`item_${target.name}_name`) || target.name);
        combatLogMessage(getString("log_knocked_down", { targetName: targetName }), 'enemyAttack');
    }
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’æ–°ã—ãè¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
/**
 * NPCãŒè£…å‚™ã—ã¦ã„ã‚‹æŠ•æ“²æ­¦å™¨ï¼ˆçŸ³ï¼‰ã‚’æŠ•ã’ã‚‹å‡¦ç†
 */
function enemyThrowWeapon() {
    const weaponIndex = currentEnemy.equipment.findIndex(e => e.isThrowable);
    if (weaponIndex === -1) { startPlayerTurn(); return; }
    const weapon = currentEnemy.equipment[weaponIndex];
    const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;
    const weaponName = getItemDisplayName(weapon);
    const missPenalty = getAccuracyModifier();
    let finalMissChance = (1 - ((weapon.accuracy || 65) / 100)) + missPenalty;
    finalMissChance += getUnseenTargetModifier(true);
    if (Math.random() < finalMissChance || (player.isDodging && Math.random() < 0.5)) {
        playSoundFile('sounds/attack_miss.wav');
        // â–¼â–¼â–¼ ä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
        let logText;
        if (!playerSeesEnemy) {
            const logKeys = ["log_unseen_throw_miss_1", "log_unseen_throw_miss_2"];
            logText = getString(randChoice(logKeys));
        } else {
            // â˜…ä¿®æ­£ç‚¹: ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸæ—¥æœ¬èªã‚’ç¿»è¨³ã‚­ãƒ¼ã«å¤‰æ›´
            logText = getString("log_enemy_throw_miss", { enemyName: enemyName, weaponName: weaponName });
        }
        // â–²â–²â–² ä¿®æ­£ã“ã“ã¾ã§ â–²â–²â–²
        combatLogMessage(logText, 'playerAttack', () => {
            currentEnemy.equipment.splice(weaponIndex, 1);
            updateCombatUI();
            startPlayerTurn();
        });
        return;
    }

    playSoundFile('sounds/throw_hit.wav'); 
    const enemyDamage = Math.max(1, (weapon.throwDamage || 8) - player.defense + (Math.floor(Math.random() * 5) - 2));
    player.health -= enemyDamage;
    player.painTolerance -= enemyDamage / 2; // â˜…â˜…â˜… ã“ã®è¡Œã‚’è¿½åŠ  â˜…â˜…â˜…
    triggerShakeAnimation('combatPlayerAscii');
    showDamage(enemyDamage.toFixed(0));

    let logText;
    if (!playerSeesEnemy) {
        logText = getString("log_unseen_hit_1");
    } else {
        // â˜…ä¿®æ­£ç‚¹: ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸæ—¥æœ¬èªã‚’ç¿»è¨³ã‚­ãƒ¼ã«å¤‰æ›´
        logText = getString("log_enemy_throw_hit", { 
            enemyName: enemyName, 
            weaponName: weaponName, 
            damage: enemyDamage.toFixed(0) 
        });
    }
    
    combatLogMessage(logText, 'enemyAttack', () => {
        currentEnemy.equipment.splice(weaponIndex, 1);
        updateCombatUI();
        if (player.health <= 0) { endCombat(false); } 
        else { startPlayerTurn(); }
    });
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function enemyMeleeAttack() {
    const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;
    const targetPart = randChoice(bodyParts);

    let finalMissChance;
    if (currentEnemy.isZombie) {
        finalMissChance = 0.10; 
    } else {
        const missPenalty = getAccuracyModifier();
        
        // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â–¼â–¼â–¼
        let weaponAccuracy = 70; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å‘½ä¸­ç‡ï¼ˆç´ æ‰‹ã‚„å‹•ç‰©ã®æ”»æ’ƒï¼‰
        // è£…å‚™(equipment)ãŒå­˜åœ¨ã—ã€ã‹ã¤é…åˆ—ã§ã‚ã‚‹å ´åˆã®ã¿æ­¦å™¨ã‚’æ¢ã™
        if (currentEnemy.equipment && Array.isArray(currentEnemy.equipment)) {
            const weapon = currentEnemy.equipment.find(e => e.attack);
            if (weapon) {
                weaponAccuracy = weapon.accuracy || 70;
            }
        }
        // â–²â–²â–² ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²

        finalMissChance = (1 - (weaponAccuracy / 100)) + missPenalty;
        finalMissChance += getUnseenTargetModifier(true);
    }

    if (Math.random() < finalMissChance) {
        playSoundFile('sounds/attack_miss.wav');
        const enemyWeapon = currentEnemy.equipment ? currentEnemy.equipment.find(e => e.attack) : null;
        if (enemyWeapon && Math.random() < 0.05) {
            const weaponIndex = currentEnemy.equipment.findIndex(e => e === enemyWeapon);
            if (weaponIndex > -1) {
                const droppedWeapon = currentEnemy.equipment.splice(weaponIndex, 1)[0];
                const locationKey = `${currentEnemy.x},${currentEnemy.y}`;
                if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
                droppedItems[locationKey].push(droppedWeapon);
                combatLogMessage(`${enemyName}ã¯æ”»æ’ƒã‚’å¤–ã—ã€ã¯ãšã¿ã§${getItemDisplayName(droppedWeapon)}ã‚’è½ã¨ã—ãŸï¼`, 'playerAttack');
            }
        }
        combatLogMessage(getString("log_enemy_attack_missed", { enemyName: enemyName }), 'playerAttack', () => {
            startPlayerTurn();
        });
        return;
    }

    if (player.isParrying) {
        const parryChance = 0.75;
        if (Math.random() < parryChance) {
            combatLogMessage(getString("log_player_parry_success"), 'playerAttack', () => {
                startPlayerTurn();
            });
            player.isParrying = false;
            return;
        } else {
            combatLogMessage(getString("log_player_parry_fail"), 'enemyAttack');
        }
    }

    if (player.isDodging) {
        const dodgeChance = 0.5;
        if (Math.random() < dodgeChance) {
            combatLogMessage(getString("log_player_attack_dodged", { enemyName: enemyName }), 'playerAttack', () => {
                startPlayerTurn();
            });
            player.isDodging = false;
            return;
        } else {
            combatLogMessage(getString("log_dodge_failed"), 'enemyAttack');
        }
    }

    const enemyWeapon = currentEnemy.equipment ? currentEnemy.equipment.find(e => e.attack) : null;

    if (currentEnemy.isZombie) { playSoundFile('sounds/zombie_attack.wav'); } 
    else if (currentEnemy.isAnimal) { playSoundFile('sounds/animal_attack.wav'); } 
    else if (enemyWeapon) {
        if (enemyWeapon.isBlade) { playSoundFile('sounds/blade_hit.wav'); } 
        else { playSoundFile('sounds/blunt_hit.wav'); }
    } else { playSoundFile('sounds/punch.wav'); }
      
    let damageBonus = 0;
    if (player.vulnerableTurns > 0) damageBonus = Math.floor((currentEnemy.attack || 5) * 0.5);
    if (player.isProne) damageBonus += Math.floor((currentEnemy.attack || 5) * 0.5);

    const damageMultiplier = 100 / (100 + player.defense);
    const randomVariance = (currentEnemy.attack || 5) * (Math.random() * 0.2 - 0.1);
    let calculatedDamage = ((currentEnemy.attack || 5) + randomVariance) * damageMultiplier;
    calculatedDamage += damageBonus;
    const enemyDamage = Math.max(1, Math.round(calculatedDamage));
    player.health -= enemyDamage;
    player.painTolerance -= enemyDamage / 2; // â˜…â˜…â˜… ã“ã®è¡Œã‚’è¿½åŠ  â˜…â˜…â˜…
    resolveKnockdown(player, enemyDamage);
    damagePlayerArmor(enemyDamage, targetPart);
    triggerShakeAnimation('combatPlayerAscii');
    showDamage(enemyDamage.toFixed(0));
    
    resolveCriticalHit(player, targetPart);
    
    let injuryMessage = null; 
    const injuryChance = enemyDamage / 25;
    if (Math.random() < injuryChance) {
        const isPartAlreadyInjured = player.injuries.some(injury => injury.part === targetPart);
        if (!isPartAlreadyInjured) {
            const hasBleeding = player.injuries.some(i => i.type === 'bleeding');
            const hasFracture = player.injuries.some(i => i.type === 'fracture');
            
            if (enemyDamage > 15 && Math.random() < 0.5 && !hasFracture) {
                player.injuries.push({ type: 'fracture', duration: 5, splinted: false, part: targetPart });
                injuryMessage = getString("log_got_fracture"); 
            } else if (enemyDamage > 8 && Math.random() < 0.7 && !hasBleeding) {
                player.injuries.push({ type: 'bleeding', part: targetPart });
                injuryMessage = getString("log_got_bleeding"); 
            } else if (!player.injuries.some(i => i.type === 'bruise')) {
                 player.injuries.push({ type: 'bruise', duration: 24, part: targetPart });
                 injuryMessage = getString("log_got_bruise"); 
            }
        }
    }

    const translatedPartName = getString('part_'
 + targetPart);
    const logText = getString("combat_attack_enemy_part", { enemyName: enemyName, damage: enemyDamage.toFixed(0), partName: translatedPartName });
    
    combatLogMessage(logText, 'enemyAttack', () => {
        const finalUpdate = () => {
            updateCombatUI(); 
            updateStatus(); 
            updateCharacterBody();
            if (player.health <= 0) {
                endCombat(false);
            } else {
                startPlayerTurn();
            }
        };

        if (injuryMessage) {
            combatLogMessage(injuryMessage, 'enemyAttack', finalUpdate);
        } else {
            finalUpdate();
        }
    });
    
    player.isParrying = false;
    player.isDodging = false;
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function enemyRangedAttack(gun) {
    let missChance = (1 - ((gun.accuracy || 85) / 100)) + getAccuracyModifier();
    missChance += getUnseenTargetModifier(true);
    if (player.isProne) missChance += 0.75;
    if (player.vulnerableTurns > 0) missChance = 0;
    
    // â–¼â–¼â–¼ ä¿®æ­£ç‚¹: å¼¾è–¬ã®æ¶ˆè²»ã‚’å‘½ä¸­åˆ¤å®šã®å‰ã«ç§»å‹• â–¼â–¼â–¼
    gun.loadedAmmo--;

    if (Math.random() < missChance) {
        playSoundFile('sounds/attack_miss.wav');
        const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;
        let logText;
        if (!playerSeesEnemy) {
            logText = getString("log_unseen_fire_miss_1");
        } else {
            const missLogKey = player.isProne ? "log_enemy_miss_prone" : "log_enemy_attack_missed";
            logText = getString(missLogKey, { enemyName: enemyName });
        }
        combatLogMessage(logText, 'playerAttack', () => {
            startPlayerTurn();
        });
        return;
    }

    if (gun.ammoType === 'shotgun') { playSoundFile('sounds/shotgun.wav'); } 
    else if (gun.ammoType === 'rifle') { playSoundFile('sounds/rifle.wav'); } 
    else if (gun.ammoType === 'pistol') { playSoundFile('sounds/pistol.wav'); } 
    else { playSound('gunshot'); }

    const enemyDamage = Math.max(1, (gun.fireDamage || 10) - player.defense + (Math.floor(Math.random() * 10) - 5));
    player.health -= enemyDamage;
    player.painTolerance -= enemyDamage / 2; // â˜…â˜…â˜… ã“ã®è¡Œã‚’è¿½åŠ  â˜…â˜…â˜…
    const targetPart = randChoice(bodyParts);
    resolveKnockdown(player, enemyDamage);
    damagePlayerArmor(enemyDamage, targetPart);
    triggerShakeAnimation('combatPlayerAscii');
    showDamage(enemyDamage.toFixed(0));
    resolveCriticalHit(player, targetPart);
    
    let injuryMessage = null;
    const injuryChance = enemyDamage / 25; 
    if (Math.random() < injuryChance) {
        const isPartAlreadyInjured = player.injuries.some(injury => injury.part === targetPart);
        if (!isPartAlreadyInjured) {
            const hasBleeding = player.injuries.some(i => i.type === 'bleeding');
            const hasFracture = player.injuries.some(i => i.type === 'fracture');
            
            if (enemyDamage > 15 && Math.random() < 0.5 && !hasFracture) {
                player.injuries.push({ type: 'fracture', duration: 5, splinted: false, part: targetPart });
                injuryMessage = getString("log_got_fracture");
            } else if (enemyDamage > 8 && Math.random() < 0.7 && !hasBleeding) {
                player.injuries.push({ type: 'bleeding', part: targetPart });
                injuryMessage = getString("log_got_bleeding");
            } else if (!player.injuries.some(i => i.type === 'bruise')) {
                 player.injuries.push({ type: 'bruise', duration: 24, part: targetPart });
                 injuryMessage = getString("log_got_bruise");
            }
        }
    }

    let logText;
    if (!playerSeesEnemy) {
        logText = getString("log_unseen_hit_1");
    } else {
        const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;
        const gunName = getBaseItemName(gun);
        const translatedPartName = getString('part_' + targetPart);
        logText = getString("combat_fire_enemy_part", { enemyName: enemyName, weaponName: gunName, damage: enemyDamage.toFixed(0), partName: translatedPartName });
    }
    
    combatLogMessage(logText, 'enemyAttack', () => {
        const finalUpdate = () => {
            updateCombatUI();
            updateStatus();
            updateCharacterBody();
            if (player.health <= 0) {
                endCombat(false);
            } else {
                startPlayerTurn();
            }
        };

        if (injuryMessage) {
            combatLogMessage(injuryMessage, 'enemyAttack', finalUpdate);
        } else {
            finalUpdate();
        }
    });
}
function handleAdvance() {
    player.isAiming = false; // â˜…ã“ã®è¡Œã‚’è¿½åŠ 
    lockCombatInteractionPanels(); // â–¼â–¼â–¼ ã“ã®è¡Œã‚’è¿½åŠ  â–¼â–¼â–¼
    if (resolveTripChance(player, 'walk')) { return; }
    if (combatDistance > 1) {
        // â–¼â–¼â–¼ ã“ã®è¡Œã‚’è¿½åŠ  â–¼â–¼â–¼
        playSoundFile('sounds/footstep.wav', 0.7);
        // â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²

        document.querySelectorAll('#combatActions button').forEach(btn => btn.disabled = true);
        
        combatDistance--;
        updateCombatUI();

        combatLogMessage(getString("log_player_advances"), 'normal', () => {
            if (combatDistance <= 1) {
                combatLogMessage(getString("log_melee_range_reached"), 'victory');
            }
            enemyCombatTurn();
        });
    }
}
/**
 * ã€Œå¾Œé€²ã™ã‚‹ã€ãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚ŒãŸã¨ãã®å‡¦ç†
 */
function handleRetreat() {
    player.isAiming = false; // â˜…ã“ã®è¡Œã‚’è¿½åŠ 
    lockCombatInteractionPanels();
    
    // --- ãƒ‡ãƒãƒƒã‚°ã“ã“ã‹ã‚‰ ---
    console.log("ãƒ‡ãƒãƒƒã‚°: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¾Œé€²å‡¦ç†(handleRetreat)ãŒå‘¼ã°ã‚Œã¾ã—ãŸã€‚");
    playSoundFile('sounds/footstep.wav', 0.7);
    console.log("ãƒ‡ãƒãƒƒã‚°: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¾Œé€²éŸ³ã®å†ç”Ÿã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆã—ã¾ã—ãŸã€‚");
    // --- ãƒ‡ãƒãƒƒã‚°ã“ã“ã¾ã§ ---

    document.querySelectorAll('#combatActions button').forEach(btn => btn.disabled = true);
    
    combatDistance++;
    updateCombatUI();

    combatLogMessage(getString("log_player_retreats"), 'normal', () => {
        enemyCombatTurn();
    });
}
/**
 * ã€Œå›é¿ã€ãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚ŒãŸã¨ãã®å‡¦ç†
 */
function handleDodge() {
    player.isAiming = false; // â˜…ã“ã®è¡Œã‚’è¿½åŠ 
    lockCombatInteractionPanels();
    document.querySelectorAll('#combatActions button').forEach(btn => btn.disabled = true);
    
    // å›é¿çŠ¶æ…‹ã‚’ã‚»ãƒƒãƒˆã—ã€ãƒ­ã‚°ã«è¡¨ç¤º
    player.isDodging = true;
    combatLogMessage(getString("log_player_dodges"), 'normal', () => {
        updateCombatUI();
        enemyCombatTurn(); // æ•µã®ã‚¿ãƒ¼ãƒ³ã¸
    });
}
function handleAim() {
    lockCombatInteractionPanels();
    document.querySelectorAll('#combatActions button').forEach(btn => btn.disabled = true);
    
    player.isAiming = true; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã€Œç‹™ã„ã€çŠ¶æ…‹ã«ã™ã‚‹
    
    combatLogMessage(getString("log_player_aims"), 'normal', () => {
        enemyCombatTurn(); // æ•µã®ã‚¿ãƒ¼ãƒ³ã¸
    });
}
function handleGoProne() {
    player.isAiming = false; // â˜…ã“ã®è¡Œã‚’è¿½åŠ 
    lockCombatInteractionPanels();
    document.querySelectorAll('#combatActions button').forEach(btn => btn.disabled = true);
    player.stance = 'prone';
    combatLogMessage(getString("log_player_goes_prone"), 'normal', () => {
        enemyCombatTurn();
    });
}

function handleStandUp() {
    player.isAiming = false; // â˜…ã“ã®è¡Œã‚’è¿½åŠ 
    lockCombatInteractionPanels();
    document.querySelectorAll('#combatActions button').forEach(btn => btn.disabled = true);
    player.stance = 'standing';
    player.vulnerableTurns = 2;

    // â–¼â–¼â–¼ ä¿®æ­£ç®‡æ‰€ï¼šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’1ã¤ã«ã¾ã¨ã‚ã€ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’å˜ç´”åŒ– â–¼â–¼â–¼
    const message = `${getString("log_player_stands_up")}<br>${getString("log_player_is_vulnerable")}`;
    combatLogMessage(message, 'normal', () => {
        enemyCombatTurn();
    });
}
// ãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¨­å®š
document.getElementById('advanceBtn').onclick = handleAdvance;
document.getElementById('retreatBtn').onclick = handleRetreat;
document.getElementById('dodgeBtn').onclick = handleDodge;
// ãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¨­å®š
document.getElementById('advanceBtn').onclick = handleAdvance;
document.getElementById('retreatBtn').onclick = handleRetreat;

function handleForwardRoll() {
    player.isAiming = false; // â˜…ã“ã®è¡Œã‚’è¿½åŠ 
    lockCombatInteractionPanels();
    if (player.injuries.some(i => i.type === 'fracture')) {
        log(getString("log_fracture_cant_move"), true);
        return;
    }
    if (combatDistance <= 1) return;

    playSoundFile('sounds/roll.wav');

    document.querySelectorAll('#combatActions button').forEach(btn => btn.disabled = true);
    combatDistance--;
    player.vulnerableTurns = 2;
    player.stance = 'rolling';

    updateCombatUI();

    // â–¼â–¼â–¼ ä¿®æ­£ç®‡æ‰€ï¼šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’1ã¤ã«ã¾ã¨ã‚ã€ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’å˜ç´”åŒ– â–¼â–¼â–¼
    const message = `${getString("log_player_rolls_forward")}<br>${getString("log_player_is_vulnerable")}`;
    combatLogMessage(message, 'normal', () => {
        enemyCombatTurn();
    });
}

function handleBackwardRoll() {
    player.isAiming = false; // â˜…ã“ã®è¡Œã‚’è¿½åŠ 
    lockCombatInteractionPanels();
    if (player.injuries.some(i => i.type === 'fracture')) {
        log(getString("log_fracture_cant_move"), true);
        return;
    }
    if (combatDistance >= MAX_COMBAT_DISTANCE) return;
    
    playSoundFile('sounds/roll.wav');

    document.querySelectorAll('#combatActions button').forEach(btn => btn.disabled = true);
    combatDistance++;
    player.vulnerableTurns = 2;
    player.stance = 'rolling';

    updateCombatUI();

    // â–¼â–¼â–¼ ä¿®æ­£ç®‡æ‰€ï¼šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’1ã¤ã«ã¾ã¨ã‚ã€ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’å˜ç´”åŒ– â–¼â–¼â–¼
    const message = `${getString("log_player_rolls_backward")}<br>${getString("log_player_is_vulnerable")}`;
    combatLogMessage(message, 'normal', () => {
        enemyCombatTurn();
    });
}
// â–¼â–¼â–¼ `handleSprintForward` ã‚’ã“ã®å†…å®¹ã§ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function handleSprintForward() {
    player.isAiming = false; // â˜…ã“ã®è¡Œã‚’è¿½åŠ 
    lockCombatInteractionPanels();
    if (resolveTripChance(player, 'sprint')) { return; }
    if (player.injuries.some(i => i.type === 'fracture')) {
        log(getString("log_fracture_cant_move"), true);
        return;
    }
    const distanceToMove = Math.floor(Math.random() * 2) + 2; 
    if (combatDistance <= distanceToMove) return; 
    playSoundFile('sounds/sprint.wav', 0.9);
    document.querySelectorAll('#combatActions button').forEach(btn => btn.disabled = true);
    combatDistance -= distanceToMove;
    player.vulnerableTurns = 2;
    player.stance = 'sprinting';
    updateCombatUI();
    const message = `${getString("log_player_sprints_forward")}<br>${getString("log_player_is_vulnerable")}`;
    combatLogMessage(message, 'normal', () => {
        // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â–¼â–¼â–¼
        if (!enemySeesPlayer) { // ã‚‚ã—æ•µãŒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¦‹ãˆã¦ã„ãªã‹ã£ãŸã‚‰
            if (Math.random() < 0.5) { // 50%ã®ç¢ºç‡ã§
                enemySeesPlayer = true; // æ•µãŒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¦–èªã§ãã‚‹ã‚ˆã†ã«ãªã‚‹
                combatLogMessage(getString("log_player_spotted_by_sprint"), 'enemyAttack');
            }
        }
        // â–²â–²â–² ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²
        enemyCombatTurn();
    });
}

// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã§ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function handleSprintBackward() {
    player.isAiming = false; // â˜…ã“ã®è¡Œã‚’è¿½åŠ 
    lockCombatInteractionPanels();
    if (resolveTripChance(player, 'sprint')) { return; }
    if (player.injuries.some(i => i.type === 'fracture')) {
        log(getString("log_fracture_cant_move"), true);
        return;
    }
    if (combatDistance >= MAX_COMBAT_DISTANCE) return;

    playSoundFile('sounds/sprint.wav', 0.9);

    document.querySelectorAll('#combatActions button').forEach(btn => btn.disabled = true);
    
    const distanceToMove = Math.floor(Math.random() * 2) + 2; 
    combatDistance = Math.min(MAX_COMBAT_DISTANCE, combatDistance + distanceToMove);

    player.vulnerableTurns = 2;
    player.stance = 'sprinting';

    updateCombatUI();

    const message = `${getString("log_player_sprints_backward")}<br>${getString("log_player_is_vulnerable")}`;
    
    combatLogMessage(message, 'normal', () => {
        // ã‚‚ã—æ•µãŒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¦‹ãˆã¦ã„ãªã‹ã£ãŸã‚‰ã€50%ã®ç¢ºç‡ã§æ°—ã¥ã‹ã‚Œã‚‹
        if (!enemySeesPlayer) {
            if (Math.random() < 0.5) {
                enemySeesPlayer = true;
                combatLogMessage(getString("log_player_spotted_by_sprint"), 'enemyAttack', () => {
                    // â†‘ã®ãƒ­ã‚°ãŒè¡¨ç¤ºã•ã‚ŒãŸå¾Œã«æ•µã®ã‚¿ãƒ¼ãƒ³ã‚’é–‹å§‹
                    enemyCombatTurn();
                });
                return; // ã“ã“ã§å‡¦ç†ã‚’çµ‚äº†ã—ãªã„ã¨ã€ä¸‹ã®enemyCombatTurnã‚‚å‘¼ã°ã‚Œã¦ã—ã¾ã†
            }
        }
        // é€šå¸¸é€šã‚Šæ•µã®ã‚¿ãƒ¼ãƒ³ã‚’é–‹å§‹
        enemyCombatTurn();
    });
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function enemyHeavyMeleeAttack() {
    const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;
    const targetPart = randChoice(bodyParts);
    
    let weapon = null;
    // â–¼â–¼â–¼ ä¿®æ­£ç‚¹: è£…å‚™(equipment)ãŒå­˜åœ¨ã™ã‚‹ã‹ã‚’å®‰å…¨ã«ãƒã‚§ãƒƒã‚¯ â–¼â–¼â–¼
    if (currentEnemy.equipment && Array.isArray(currentEnemy.equipment)) {
        weapon = currentEnemy.equipment.find(e => e.attack);
    }
    const weaponAccuracy = weapon ? (weapon.accuracy || 70) : 70;
    
    const missPenalty = getAccuracyModifier();
    let finalMissChance = (1 - (weaponAccuracy / 100)) + missPenalty + 0.20;
    finalMissChance += getUnseenTargetModifier(true);

    const finalUpdateSequence = () => {
        updateCombatUI();
        updateStatus();
        updateCharacterBody();
        if (player.health <= 0) {
            endCombat(false);
        } else {
            startPlayerTurn();
        }
    };

    const onAttackSequenceEnd = (injuryMsg) => {
        currentEnemy.vulnerableTurns = 2;
        currentEnemy.heavyAttackCooldown = 2;
        currentEnemy.recoilTurns = 1;
        combatLogMessage(getString("log_enemy_is_vulnerable", { enemyName: enemyName }), 'playerAttack', () => {
            if (injuryMsg) {
                combatLogMessage(injuryMsg, 'enemyAttack', finalUpdateSequence);
            } else {
                finalUpdateSequence();
            }
        });
    };

    if (Math.random() < finalMissChance) {
        playSoundFile('sounds/attack_miss.wav');
        combatLogMessage(getString("log_enemy_attack_missed", { enemyName: enemyName }), 'playerAttack', () => onAttackSequenceEnd(null));
    } else {
        playSoundFile('sounds/attack_heavy.wav');
        let damageBonus = 0;
        if (player.vulnerableTurns > 0) damageBonus = Math.floor((currentEnemy.attack || 5) * 0.5);
        if (player.isProne) damageBonus += Math.floor((currentEnemy.attack || 5) * 0.5);

        const enemyDamage = Math.max(1, Math.floor((currentEnemy.attack * 2.5) - player.defense + (Math.floor(Math.random() * 5) - 2) + damageBonus));
        player.health -= enemyDamage;
        player.painTolerance -= enemyDamage / 2; // â˜…â˜…â˜… ã“ã®è¡Œã‚’è¿½åŠ  â˜…â˜…â˜…
        resolveKnockdown(player, enemyDamage);
        damagePlayerArmor(enemyDamage, targetPart);
        showDamage(enemyDamage.toFixed(0));
        
        resolveCriticalHit(player, targetPart);
        
        let injuryMessage = null;
        const injuryChance = enemyDamage / 25;
        if (Math.random() < injuryChance) {
            const isPartAlreadyInjured = player.injuries.some(injury => injury.part === targetPart);
            if (!isPartAlreadyInjured) {
                const hasBleeding = player.injuries.some(i => i.type === 'bleeding');
                const hasFracture = player.injuries.some(i => i.type === 'fracture');
                
                if (enemyDamage > 15 && Math.random() < 0.5 && !hasFracture) {
                    player.injuries.push({ type: 'fracture', duration: 5, splinted: false, part: targetPart });
                    injuryMessage = getString("log_got_fracture");
                } else if (enemyDamage > 8 && Math.random() < 0.7 && !hasBleeding) {
                    player.injuries.push({ type: 'bleeding', part: targetPart });
                    injuryMessage = getString("log_got_bleeding");
                } else if (!player.injuries.some(i => i.type === 'bruise')) {
                     player.injuries.push({ type: 'bruise', duration: 24, part: targetPart });
                     injuryMessage = getString("log_got_bruise");
                }
            }
        }

        const translatedPartName = getString('part_' + targetPart);
        const logText = getString("log_enemy_heavy_attack_part", { enemyName: enemyName, damage: enemyDamage.toFixed(0), partName: translatedPartName });
        
        combatLogMessage(logText, 'enemyAttack', () => onAttackSequenceEnd(injuryMessage));
    }
}
function enemyHeavyRangedAttack(gun) {
    const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;
    const missPenalty = getAccuracyModifier();
    let missChance = (1 - ((gun.accuracy || 85) / 100)) + missPenalty + 0.20;
    missChance += getUnseenTargetModifier(true);
    if (player.isProne) missChance += 0.75;
    if (player.vulnerableTurns > 0) missChance = 0;
    
    gun.loadedAmmo--;

    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â–¼â–¼â–¼

    const finalUpdateSequence = () => {
        updateCombatUI();
        updateStatus();
        updateCharacterBody();
        if (player.health <= 0) {
            endCombat(false);
        } else {
            startPlayerTurn();
        }
    };
    
    const onAttackSequenceEnd = (injuryMsg) => {
        currentEnemy.vulnerableTurns = 2;
        currentEnemy.heavyAttackCooldown = 2;
        currentEnemy.recoilTurns = 1;
        combatLogMessage(getString("log_enemy_is_vulnerable", { enemyName: enemyName }), 'playerAttack', () => {
             if (injuryMsg) {
                combatLogMessage(injuryMsg, 'enemyAttack', finalUpdateSequence);
            } else {
                finalUpdateSequence();
            }
        });
    };

    if (Math.random() < missChance) {
        playSoundFile('sounds/attack_miss.wav');
        const missLogKey = player.isProne ? "log_enemy_miss_prone" : "log_enemy_attack_missed";
        combatLogMessage(getString(missLogKey, { enemyName: enemyName }), 'playerAttack', () => onAttackSequenceEnd(null));
    } else {
        playSoundFile('sounds/gunshot_heavy.wav', 0.9);
        const enemyDamage = Math.max(1, Math.floor((gun.fireDamage * 2.5) - player.defense + (Math.floor(Math.random() * 10) - 5)));
        player.health -= enemyDamage;
        player.painTolerance -= enemyDamage / 2; // â˜…â˜…â˜… ã“ã®è¡Œã‚’è¿½åŠ  â˜…â˜…â˜…
        resolveKnockdown(player, enemyDamage);
        damagePlayerArmor(enemyDamage, targetPart);
        showDamage(enemyDamage.toFixed(0));

        const targetPart = randChoice(bodyParts);
        resolveCriticalHit(player, targetPart);

        let injuryMessage = null;
        const injuryChance = enemyDamage / 25; 
        if (Math.random() < injuryChance) {
            const isPartAlreadyInjured = player.injuries.some(injury => injury.part === targetPart);
            if (!isPartAlreadyInjured) {
                const hasBleeding = player.injuries.some(i => i.type === 'bleeding');
                const hasFracture = player.injuries.some(i => i.type === 'fracture');
                
                if (enemyDamage > 15 && Math.random() < 0.5 && !hasFracture) {
                    player.injuries.push({ type: 'fracture', duration: 5, splinted: false, part: targetPart });
                    injuryMessage = getString("log_got_fracture");
                } else if (enemyDamage > 8 && Math.random() < 0.7 && !hasBleeding) {
                    player.injuries.push({ type: 'bleeding', part: targetPart });
                    injuryMessage = getString("log_got_bleeding");
                } else if (!player.injuries.some(i => i.type === 'bruise')) {
                     player.injuries.push({ type: 'bruise', duration: 24, part: targetPart });
                     injuryMessage = getString("log_got_bruise");
                }
            }
        }

        const translatedPartName = getString('part_' + targetPart);
        const logText = getString("log_enemy_heavy_attack_part", { weaponName: getBaseItemName(gun), enemyName: enemyName, damage: enemyDamage.toFixed(0), partName: translatedPartName });

        combatLogMessage(logText, 'enemyAttack', () => onAttackSequenceEnd(injuryMessage));
    }
    // â–²â–²â–² ä¿®æ­£ã“ã“ã¾ã§ â–²â–²â–²
}

function startPlayerTurn() {
    isInteractionActive = false; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¡Œå‹•ãƒ­ãƒƒã‚¯ã‚’è§£é™¤
    if (combatDistance <= 1) {
        playerSeesEnemy = true;
        enemySeesPlayer = true;
    }
        // â–¼â–¼â–¼ ãƒ‡ãƒãƒƒã‚°ã‚³ãƒ¼ãƒ‰ã‚’è¿½åŠ  â–¼â–¼â–¼
    if (currentEnemy) { // æˆ¦é—˜ä¸­ã®ã¿ãƒ­ã‚°ã‚’å‡ºåŠ›
        console.log(`ãƒ‡ãƒãƒƒã‚° [ã‚¿ãƒ¼ãƒ³é–‹å§‹æ™‚]: player.stunnedTurns = ${player.stunnedTurns}`);
    }
    // â–²â–²â–² ãƒ‡ãƒãƒƒã‚°ã“ã“ã¾ã§ â–²â–²â–²
    if (player.vulnerableTurns > 0) {
        player.vulnerableTurns--;
        if (player.vulnerableTurns === 0) {
            combatLogMessage(getString("log_vulnerability_wears_off"), 'playerAttack');
        }
    }
    if (player.heavyAttackCooldown > 0) {
        player.heavyAttackCooldown--;
    }
    
    // ä¸€æ™‚çš„ãªå§¿å‹¢ã‚’åŸºæœ¬å§¿å‹¢ã«æˆ»ã™
    if (player.stance === 'rolling') player.stance = 'prone';
    else if (player.stance === 'sprinting') player.stance = 'standing';

    if (player.stunnedTurns > 0) {
        player.stunnedTurns--;
        
        // â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ä¿®æ­£ â–¼â–¼â–¼
        // å¤§æ”»æ’ƒã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ãŒ1ã®å ´åˆã€ãã‚Œã¯å¤§æ”»æ’ƒã®åå‹•ã«ã‚ˆã‚‹è¡Œå‹•ä¸èƒ½ã¨åˆ¤æ–­
        const logKey = (player.heavyAttackCooldown === 1) 
            ? "log_turn_skipped_recoil" 
            : "log_is_stunned";
            
        // æ–°ã—ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ã¯ä¸»èªãŒå«ã¾ã‚Œã¦ã„ã‚‹ãŸã‚ã€å¼•æ•°ãŒä¸è¦ãªå ´åˆã«å¯¾å¿œ
        const message = (logKey === "log_turn_skipped_recoil")
            ? getString(logKey)
            : getString(logKey, { targetName: getString("you") });

        combatLogMessage(message, 'enemyAttack', () => {
            enemyCombatTurn();
        });
        // â–²â–²â–² ä¿®æ­£ã“ã“ã¾ã§ â–²â–²â–²
        return;
    }
    document.getElementById('inventoryPanel').classList.remove('interaction-locked');
    document.getElementById('itemDetailPanel').classList.remove('interaction-locked');
    document.querySelectorAll('#combatActions button').forEach(btn => btn.disabled = false);
    updateCombatUI();
}
function resolveCriticalHit(target, targetPart) {
    // é ­éƒ¨ã«å‘½ä¸­ã—ãŸå ´åˆã®ã¿ã€æ°—çµ¶åˆ¤å®šã‚’è¡Œã†
    if (targetPart === 'head') {
        const STUN_CHANCE_ON_HEADSHOT = 0.15; // é ­éƒ¨å‘½ä¸­æ™‚ã®æ°—çµ¶ç¢ºç‡ã‚’15%ã«è¨­å®š
        if (Math.random() < STUN_CHANCE_ON_HEADSHOT) {
            const stunDuration = Math.floor(Math.random() * 2) + 1; // 1ã€œ2ã‚¿ãƒ¼ãƒ³
            target.stunnedTurns = stunDuration;
            
            const targetName = (target === player) ? getString("you") : (getString(`item_${target.name}_name`) || target.name);
            combatLogMessage(getString("log_critical_hit", { targetName: targetName }), 'victory');
        }
    }
}
function enemyGoProne() {
    currentEnemy.stance = 'prone';
    const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;

    // â–¼â–¼â–¼ ä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
    let logText;
    if (!playerSeesEnemy) {
        const logKeys = ["log_unseen_stance_1", "log_unseen_stance_2"];
        logText = getString(randChoice(logKeys));
    } else {
        logText = getString("log_enemy_goes_prone", { enemyName: enemyName });
    }
    // â–²â–²â–² ä¿®æ­£ã“ã“ã¾ã§ â–²â–²â–²

    combatLogMessage(logText, 'enemyAttack', () => {
        startPlayerTurn();
    });
}

function enemyStandUp() {
    currentEnemy.lastAction = 'standUp'; // â˜…â˜…â˜… ã“ã®è¡Œã‚’è¿½åŠ  â˜…â˜…â˜…
    currentEnemy.stance = 'standing';
    currentEnemy.vulnerableTurns = 2;
    const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;

    // â–¼â–¼â–¼ ä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
    let logText, logText2;
    if (!playerSeesEnemy) {
        const logKeys = ["log_unseen_stance_1", "log_unseen_stance_2"];
        logText = getString(randChoice(logKeys));
        logText2 = null; // 2ã¤ç›®ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ä¸è¦
    } else {
        logText = getString("log_enemy_stands_up", { enemyName: enemyName });
        logText2 = getString("log_enemy_is_vulnerable", { enemyName: enemyName });
    }
    // â–²â–²â–² ä¿®æ­£ã“ã“ã¾ã§ â–²â–²â–²

    combatLogMessage(logText, 'enemyAttack', () => {
        if (logText2) {
            combatLogMessage(logText2, 'enemyAttack', () => {
                startPlayerTurn();
            });
        } else {
            startPlayerTurn();
        }
    });
}
function enemyDodge() {
    currentEnemy.isDodging = true;
    const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;
    combatLogMessage(getString("log_enemy_dodges", { enemyName: enemyName }), 'enemyAttack', () => {
        startPlayerTurn();
    });
}

function enemyRetreat() {
    if (combatDistance >= MAX_COMBAT_DISTANCE) { enemyAdvance(); return; } 
    playSoundFile('sounds/footstep.wav', 0.7);
    combatDistance++;
    const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;

    // â–¼â–¼â–¼ ä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
    let logText;
    if (!playerSeesEnemy) {
        const logKeys = ["log_unseen_move_1", "log_unseen_move_2", "log_unseen_move_3"];
        logText = getString(randChoice(logKeys));
    } else {
        logText = getString("log_enemy_retreats", { enemyName: enemyName });
    }
    // â–²â–²â–² ä¿®æ­£ã“ã“ã¾ã§ â–²â–²â–²
    
    combatLogMessage(logText, 'enemyAttack', () => {
        startPlayerTurn();
    });
}
function enemyDodge() {
    currentEnemy.isDodging = true;
    const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;
    combatLogMessage(getString("log_enemy_dodges", { enemyName: enemyName }), 'enemyAttack', () => {
        startPlayerTurn();
    });
}

function enemyRetreat() {
    if (resolveTripChance(currentEnemy, 'walk')) { return; }
    if (combatDistance >= MAX_COMBAT_DISTANCE) { enemyAdvance(); return; } // â† 8ã‚’å®šæ•°ã«å¤‰æ›´
    combatDistance++;
    const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;
    combatLogMessage(getString("log_enemy_retreats", { enemyName: enemyName }), 'enemyAttack', () => {
        startPlayerTurn();
    });
}

function enemyAdvance() {
    if (resolveTripChance(currentEnemy, 'walk')) { return; }
    if (combatDistance <= 1) { enemyMeleeAttack(); return; }
    if (currentEnemy.isZombie) { playSoundFile('sounds/zombie_shuffle.wav', 0.6); } 
    else { playSoundFile('sounds/footstep.wav', 0.7); }

    combatDistance--;
    const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;
    
    // â–¼â–¼â–¼ ä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
    let logText;
    if (!playerSeesEnemy) {
        const logKeys = ["log_unseen_move_1", "log_unseen_move_2", "log_unseen_move_3"];
        logText = getString(randChoice(logKeys));
    } else {
        logText = getString("log_enemy_advances", { enemyName: enemyName });
    }
    // â–²â–²â–² ä¿®æ­£ã“ã“ã¾ã§ â–²â–²â–²

    combatLogMessage(logText, 'enemyAttack', () => {
        if (playerSeesEnemy && combatDistance <= 1) combatLogMessage(getString("log_melee_range_reached"), 'victory');
        startPlayerTurn();
    });
}

function enemyForwardRoll() {
    if (combatDistance <= 1) { enemyStandUp(); return; }

    // â–¼â–¼â–¼ ã‚µã‚¦ãƒ³ãƒ‰å†ç”Ÿã‚’è¿½åŠ  â–¼â–¼â–¼
    playSoundFile('sounds/roll.wav');
    // â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²

    combatDistance--;
    currentEnemy.vulnerableTurns = 2;
    currentEnemy.stance = 'rolling';
    const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;
    
    combatLogMessage(getString("log_enemy_rolls_forward", { enemyName: enemyName }), 'enemyAttack', () => {
        combatLogMessage(getString("log_enemy_is_vulnerable", { enemyName: enemyName }), 'enemyAttack', () => {
            startPlayerTurn();
        });
    });
}

function enemyBackwardRoll() {
    currentEnemy.lastAction = 'backwardRoll'; // â˜…â˜…â˜… ã“ã®è¡Œã‚’è¿½åŠ  â˜…â˜…â˜…
    if (combatDistance >= MAX_COMBAT_DISTANCE) { enemyStandUp(); return; }

    // â–¼â–¼â–¼ ã‚µã‚¦ãƒ³ãƒ‰å†ç”Ÿã‚’è¿½åŠ  â–¼â–¼â–¼
    playSoundFile('sounds/roll.wav');
    // â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²

    combatDistance++;
    currentEnemy.vulnerableTurns = 2;
    currentEnemy.stance = 'rolling';
    const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;

    combatLogMessage(getString("log_enemy_rolls_backward", { enemyName: enemyName }), 'enemyAttack', () => {
        combatLogMessage(getString("log_enemy_is_vulnerable", { enemyName: enemyName }), 'enemyAttack', () => {
            startPlayerTurn();
        });
    });
}
// â–¼â–¼â–¼ `enemySprintForward` ã‚’ã“ã®å†…å®¹ã§ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function enemySprintForward() {
    if (resolveTripChance(currentEnemy, 'sprint')) { return; }
    const distanceToMove = Math.floor(Math.random() * 2) + 2; 
    if (combatDistance <= distanceToMove) { enemyAdvance(); return; } 
    if (currentEnemy.isZombie) { playSoundFile('sounds/zombie_move.wav'); } 
    else { playSoundFile('sounds/sprint.wav', 0.8); }
    combatDistance -= distanceToMove;
    currentEnemy.vulnerableTurns = 2;
    currentEnemy.stance = 'sprinting';
    const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;
    let logText;
    if (!playerSeesEnemy) {
        const logKeys = ["log_unseen_sprint_1", "log_unseen_sprint_2"];
        logText = getString(randChoice(logKeys));
    } else {
        logText = getString("log_enemy_sprints_forward", { enemyName: enemyName });
    }
    combatLogMessage(logText, 'enemyAttack', () => {
        // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â–¼â–¼â–¼
        if (!playerSeesEnemy) { // ã‚‚ã—ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæ•µã‚’è¦‹ãˆã¦ã„ãªã‹ã£ãŸã‚‰
            if (Math.random() < 0.5) { // 50%ã®ç¢ºç‡ã§
                playerSeesEnemy = true; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæ•µã‚’è¦–èªã§ãã‚‹ã‚ˆã†ã«ãªã‚‹
                combatLogMessage(getString("log_enemy_spotted_by_sprint"), 'victory');
            }
        }
        // â–²â–²â–² ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²
        combatLogMessage(getString("log_enemy_is_vulnerable", { enemyName: enemyName }), 'enemyAttack', () => {
            startPlayerTurn();
        });
    });
}

// â–¼â–¼â–¼ `enemySprintBackward` ã‚’ã“ã®å†…å®¹ã§ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
// index.htmlå†…
function enemySprintBackward() {
    if (resolveTripChance(currentEnemy, 'sprint')) { return; }
    if (combatDistance >= MAX_COMBAT_DISTANCE) { enemyRetreat(); return; }
    if (currentEnemy.isZombie) { playSoundFile('sounds/zombie_move.wav'); } 
    else { playSoundFile('sounds/sprint.wav', 0.8); }
    const distanceToMove = Math.floor(Math.random() * 2) + 2; 
    combatDistance = Math.min(MAX_COMBAT_DISTANCE, combatDistance + distanceToMove);
    currentEnemy.vulnerableTurns = 2;
    currentEnemy.stance = 'sprinting';
    const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;
    let logText;
    if (!playerSeesEnemy) {
        const logKeys = ["log_unseen_sprint_1", "log_unseen_sprint_2"];
        logText = getString(randChoice(logKeys));
    } else {
        logText = getString("log_enemy_sprints_backward", { enemyName: enemyName });
    }
    
    combatLogMessage(logText, 'enemyAttack', () => {
        // â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯å…¨ä½“ã‚’ä¿®æ­£ã—ã¾ã—ãŸ â–¼â–¼â–¼
        if (!playerSeesEnemy && Math.random() < 0.5) {
            playerSeesEnemy = true;
            // ã€Œæ•µã‚’ç™ºè¦‹ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å¾Œã«ã€ã€Œç„¡é˜²å‚™ã€â†’ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¿ãƒ¼ãƒ³ã¨ç¹‹ã’ã‚‹
            combatLogMessage(getString("log_enemy_spotted_by_sprint"), 'victory', () => {
                combatLogMessage(getString("log_enemy_is_vulnerable", { enemyName: enemyName }), 'enemyAttack', () => {
                    startPlayerTurn();
                });
            });
        } else {
            // æ•µã‚’ç™ºè¦‹ã—ãªã‹ã£ãŸå ´åˆã¯ã€ç›´æ¥ã€Œç„¡é˜²å‚™ã€â†’ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¿ãƒ¼ãƒ³ã¸
            combatLogMessage(getString("log_enemy_is_vulnerable", { enemyName: enemyName }), 'enemyAttack', () => {
                startPlayerTurn();
            });
        }
        // â–²â–²â–² ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²
    });
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’æ–°ã—ãè¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
/**
 * æˆ¦é—˜ä¸­ã®ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ãƒ‘ãƒãƒ«ï¼ˆæ‰€æŒå“ã€ã‚¢ã‚¤ãƒ†ãƒ è©³ç´°ï¼‰ã‚’ãƒ­ãƒƒã‚¯ã™ã‚‹
 */
function lockCombatInteractionPanels() {
    document.getElementById('inventoryPanel').classList.add('interaction-locked');
    document.getElementById('itemDetailPanel').classList.add('interaction-locked');
}
function enemyCombatTurn() {
// è¿‘æ¥è·é›¢(1)ãªã‚‰ã€ãŠäº’ã„ã‚’å¿…ãšè¦–èªã™ã‚‹
    if (combatDistance <= 1) {
        playerSeesEnemy = true;
        enemySeesPlayer = true;
    }
    lockCombatInteractionPanels();
    document.getElementById('inventoryPanel').classList.add('interaction-locked');
    document.getElementById('itemDetailPanel').classList.add('interaction-locked');
    if (currentEnemy.recoilTurns > 0) {
        currentEnemy.recoilTurns--;
        const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;
        combatLogMessage(getString("log_turn_skipped_recoil_enemy", { enemyName: enemyName }), 'playerAttack', () => {
            startPlayerTurn();
        });
        return;
    }
    if (currentEnemy && currentEnemy.injuries && currentEnemy.injuries.length > 0) {
        let turnDamage = 0;
        const newInjuries = [];
        currentEnemy.injuries.forEach(injury => {
            let stillInjured = true;
            switch (injury.type) {
                case 'bleeding': turnDamage += 3; break;
                case 'bruise':
                    turnDamage += 1;
                    injury.duration--;
                    if (injury.duration <= 0) stillInjured = false;
                    break;
                case 'fracture':
                    turnDamage += 5;
                    injury.duration--;
                    if (injury.duration <= 0) stillInjured = false;
                    break;
            }
            if (stillInjured) newInjuries.push(injury);
        });
        currentEnemy.injuries = newInjuries;
        if (turnDamage > 0) { currentEnemy.health -= turnDamage; }
        if (currentEnemy.health <= 0) { endCombat(true); return; }
    }
    currentEnemy.isDodging = false;
    if (currentEnemy.vulnerableTurns > 0) {
        currentEnemy.vulnerableTurns--;
        if (currentEnemy.vulnerableTurns === 0) {
            const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;
            combatLogMessage(getString("log_enemy_vulnerability_wears_off", { enemyName: enemyName }), 'enemyAttack');
        }
    }
    if (currentEnemy.heavyAttackCooldown > 0) { currentEnemy.heavyAttackCooldown--; }
    if (currentEnemy.stunnedTurns > 0) {
        currentEnemy.stunnedTurns--;
        const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;
        const logKey = (currentEnemy.heavyAttackCooldown === 1) ? "log_turn_skipped_recoil_enemy" : "log_is_stunned";
        combatLogMessage(getString(logKey, { targetName: enemyName, enemyName: enemyName }), 'playerAttack', () => {
            startPlayerTurn();
        });
        return;
    }
    if (currentEnemy.stance === 'rolling') currentEnemy.stance = 'prone';
    else if (currentEnemy.stance === 'sprinting') currentEnemy.stance = 'standing';

    const playerHasRangedWeapon = player.equipment.some(e => e.fireDamage > 0);
    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒAIãƒ­ã‚¸ãƒƒã‚¯ã®å…¨é¢çš„ã«ä¿®æ­£ç®‡æ‰€ã§ã™ â–¼â–¼â–¼

    // æ•µãŒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¦–èªã§ãã¦ã„ã‚‹ã‹ã©ã†ã‹ã§è¡Œå‹•ã‚’åˆ†å²
    if (!enemySeesPlayer) {
        // --- è¦–èªã§ãã¦ã„ãªã„å ´åˆã®AI ---
        const choices = [enemySearch];
        if (currentEnemy.stance === 'standing') {
            choices.push(enemyGoProne);
        }
        const action = randChoice(choices);
        if (action) action(); else startPlayerTurn();
        return;
    }

    // --- è¦–èªã§ãã¦ã„ã‚‹å ´åˆã®AIï¼ˆå¾“æ¥ã®AIãƒ­ã‚¸ãƒƒã‚¯ï¼‰ ---
    // --- AIã‚¿ã‚¤ãƒ—1: ã‚¾ãƒ³ãƒ“ã¨å‹•ç‰©ã®å˜ç´”AI ---
    if (currentEnemy.isZombie || currentEnemy.isAnimal) {
        let action = null;
        const hasFracture = currentEnemy.injuries && currentEnemy.injuries.some(i => i.type === 'fracture');
        if (currentEnemy.stance === 'prone') {
            action = (combatDistance <= 1 && Math.random() < 0.7) ? enemyBackwardRoll : enemyStandUp;
        } else if (hasFracture) {
            action = enemyMeleeAttack;
        } else {
            if (combatDistance > 1) {
                action = (combatDistance > 2 && Math.random() < 0.5) ? enemySprintForward : enemyAdvance;
            } else {
                const canHeavyAttack = currentEnemy.heavyAttackCooldown === 0;
                action = (canHeavyAttack && Math.random() < 0.3) ? enemyHeavyMeleeAttack : enemyMeleeAttack;
            }
        }
        if (action) action(); else startPlayerTurn();
        return;
    }

    // --- AIã‚¿ã‚¤ãƒ—2: ã‚¢ã‚°ãƒ¬ãƒƒã‚·ãƒ–ãªäººé–“NPCã®AI ---
    if (currentEnemy.isAggressive) {
        let action = null;
        const hasLoadedGun = currentEnemy.equipment && currentEnemy.equipment.find(e => e.ammoType && e.loadedAmmo > 0);
        const hasThrowable = currentEnemy.equipment && currentEnemy.equipment.find(e => e.isThrowable);
        const hasFracture = currentEnemy.injuries && currentEnemy.injuries.some(i => i.type === 'fracture');

        if (hasLoadedGun) {
            if (combatDistance > 1) {
                action = (currentEnemy.heavyAttackCooldown === 0 && Math.random() < 0.3) ? enemyHeavyRangedAttack : enemyRangedAttack;
            } else {
                action = hasFracture ? enemyMeleeAttack : enemyRetreat;
            }
        } else if (hasThrowable && combatDistance > 1) {
            action = enemyThrowWeapon;
        } else {
            if (combatDistance > 1) {
                action = hasFracture ? enemyAdvance : ((combatDistance > 2 && Math.random() < 0.6) ? enemySprintForward : enemyAdvance);
            } else {
                const canHeavyAttack = currentEnemy.heavyAttackCooldown === 0;
                action = (canHeavyAttack && Math.random() < 0.4) ? enemyHeavyMeleeAttack : enemyMeleeAttack;
            }
        }
        if (action) {
            if (action === enemyRangedAttack || action === enemyHeavyRangedAttack) action(hasLoadedGun);
            else action();
        } else {
            startPlayerTurn();
        }
        return;
    }
    
    // --- AIã‚¿ã‚¤ãƒ—3: é€šå¸¸ã®äººé–“NPCã®AI ---
    let hasGun = null;
    if (currentEnemy && currentEnemy.equipment) {
        hasGun = currentEnemy.equipment.find(e => e.ammoType && e.loadedAmmo > 0);
    }
    const hasThrowable = currentEnemy.equipment && currentEnemy.equipment.find(e => e.isThrowable);
    const healthPercent = (currentEnemy.health / currentEnemy.maxHealth) * 100;
    const hasFracture = currentEnemy.injuries && currentEnemy.injuries.some(i => i.type === 'fracture');
    let action;

    if (currentEnemy.stance === 'prone') {
        if (combatDistance <= 1) {
            // â˜…â˜…â˜…ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™â˜…â˜…â˜…
            // ç›´å‰ã®è¡Œå‹•ãŒå¾Œè»¢ã ã£ãŸå ´åˆã¯ã€å¼·åˆ¶çš„ã«ç«‹ã¡ä¸ŠãŒã‚‹ã‚ˆã†ã«ã™ã‚‹
            if (currentEnemy.lastAction === 'backwardRoll') {
                action = enemyStandUp;
            } else {
                const standUpChance = playerHasRangedWeapon ? 0.4 : 0.8;
                action = hasFracture ? enemyStandUp : (Math.random() < standUpChance) ? enemyStandUp : enemyBackwardRoll;
            }
            // â˜…â˜…â˜…ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™â˜…â˜…â˜…
        } else {
            if (hasGun && Math.random() < 0.7) action = enemyRangedAttack;
            else if (!hasFracture && Math.random() < 0.5) action = enemyForwardRoll;
            else action = enemyStandUp;
        }
    } else {
        const choices = [];
        if (currentEnemy.heavyAttackCooldown === 0) {
            const heavyAttackChance = player.vulnerableTurns > 0 ? 0.5 : 0.2;
            if (Math.random() < heavyAttackChance) {
                if (hasGun && combatDistance > 1) choices.push(enemyHeavyRangedAttack);
                if (combatDistance <= 1) choices.push(enemyHeavyMeleeAttack);
            }
        }

        if (healthPercent < 30) {
            if (!hasFracture) {
                choices.push(enemyRetreat, enemySprintBackward);
                if (playerHasRangedWeapon) choices.push(enemyGoProne);
            }
            choices.push(enemyDodge);
        } else {
            if (hasGun && combatDistance > 1) choices.push(enemyRangedAttack);
            if (hasThrowable && combatDistance > 1) choices.push(enemyThrowWeapon);
            if (combatDistance <= 1) choices.push(enemyMeleeAttack);
            if (!hasFracture) {
                if (combatDistance > 2) choices.push(enemySprintForward);
                if (combatDistance > 1) choices.push(enemyAdvance);
                choices.push(enemyRetreat);
                if (playerHasRangedWeapon) choices.push(enemyGoProne);
            }
            choices.push(enemyDodge);
        }
        action = randChoice(choices.filter(c => c));
    }
    
    if (!action) {
        if(combatDistance <= 1) action = enemyMeleeAttack;
        else if (!hasFracture) action = enemyAdvance;
        else action = enemyDodge;
    }

    if (action === enemyRangedAttack || action === enemyHeavyRangedAttack) {
        action(hasGun);
    } else {
        action();
    }
}
// ãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’æ–°ã—ãè¨­å®š
document.getElementById('advanceBtn').onclick = handleAdvance;
// index.htmlã®<script>ã‚¿ã‚°å†…ã«è¿½åŠ 

/**
 * ç§»å‹•æ™‚ã«ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãŒè»¢å€’ã™ã‚‹ã‹ã‚’åˆ¤å®šã—ã€å‡¦ç†ã™ã‚‹é–¢æ•°
 * @param {object} character - å¯¾è±¡ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ (player ã¾ãŸã¯ currentEnemy)
 * @param {string} moveType - ç§»å‹•ã®ç¨®é¡ ('walk' ã¾ãŸã¯ 'sprint')
 * @returns {boolean} - è»¢å€’ã—ãŸå ´åˆã¯ true, ã—ãªã‹ã£ãŸå ´åˆã¯ false
 */
function resolveTripChance(character, moveType) {
    // è»¢å€’ç¢ºç‡ã‚’è¨­å®š (é€šå¸¸ç§»å‹•: 2%, å…¨é€ŸåŠ›: 8%)
    const tripChance = moveType === 'sprint' ? 0.08 : 0.02;

    if (Math.random() < tripChance) {
        // è»¢å€’å‡¦ç†
        character.stance = 'prone'; // çŠ¶æ…‹ã‚’ã€Œä¼ã›ã€ã«å¤‰æ›´
        character.vulnerableTurns = 2; // è»¢å€’å¾Œã¯2ã‚¿ãƒ¼ãƒ³ç„¡é˜²å‚™ã«ãªã‚‹

        const targetName = (character === player) ? getString("you") : (getString(`item_${character.name}_name`) || character.name);
        const logMessage = getString("log_trip_fall", { targetName: targetName });

        // æˆ¦é—˜ãƒ­ã‚°ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã—ã€ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³ã«ç§»è¡Œã™ã‚‹
        combatLogMessage(logMessage, 'enemyAttack', () => {
            if (character === player) {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒè»¢å€’ã—ãŸå ´åˆã€æ•µã®ã‚¿ãƒ¼ãƒ³ã‚’é–‹å§‹
                enemyCombatTurn();
            } else {
                // æ•µãŒè»¢å€’ã—ãŸå ´åˆã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¿ãƒ¼ãƒ³ã‚’é–‹å§‹
                startPlayerTurn();
            }
        });

        return true; // è»¢å€’ã—ãŸã“ã¨ã‚’ç¤ºã™
    }

    return false; // è»¢å€’ã—ãªã‹ã£ãŸ
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function handleRun() {
    player.isAiming = false; // â˜…ã“ã®è¡Œã‚’è¿½åŠ 
    lockCombatInteractionPanels();
    if (player.injuries.some(i => i.type === 'fracture')) {
        log(getString("log_fracture_cant_move_run"), true);
        startPlayerTurn(); // éª¨æŠ˜ã§å‹•ã‘ãªã„å ´åˆã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¿ãƒ¼ãƒ³ã«æˆ»ã™
        return;
    }
    snapshotStats();
    document.querySelectorAll('#combatActions button').forEach(btn => btn.disabled = true);

    // --- ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ ---
    let escapeChance = 0;
    if (!playerSeesEnemy && !enemySeesPlayer) { // ãŠäº’ã„ã«è¦‹ãˆã¦ã„ãªã„
        escapeChance = 0.50; // 50%
    } else if (!playerSeesEnemy && enemySeesPlayer) { // ç›¸æ‰‹ã ã‘ãŒè¦‹ãˆã¦ã„ã‚‹
        escapeChance = 0.10; // 10%
    } else if (playerSeesEnemy && !enemySeesPlayer) { // è‡ªåˆ†ã ã‘ãŒè¦‹ãˆã¦ã„ã‚‹
        escapeChance = 0.80; // 80%
    } else { // ãŠäº’ã„ã«è¦‹ãˆã¦ã„ã‚‹ï¼ˆå¾“æ¥ã®è·é›¢è¨ˆç®—ï¼‰
        const baseEscapeChance = 0.10;
        const distanceBonus = (combatDistance - 1) * 0.04;
        escapeChance = Math.min(0.95, baseEscapeChance + distanceBonus);
    }
    // --- ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ ---

    if (Math.random() < escapeChance) {
        const enemyInList = entities.find(e => e.x === currentEnemy.x && e.y === currentEnemy.y);
        if (enemyInList) enemyInList.stunnedTurns = 1;
        const fleeTile = findSafeFleeTile();
        if (fleeTile) {
            player.x = fleeTile.x;
            player.y = fleeTile.y;
        }
        combatLogMessage(getString("combat_run_success"), "run", () => {
            updateStatus();
            endCombat('escaped');
        });
    } else {
        combatLogMessage(getString("combat_run_fail"), "run", () => {
            updateStatus();
            enemyCombatTurn();
        });
    }
}
// æ—¢å­˜ã® handleRun é–¢æ•°ã®ä¸‹ã‚ãŸã‚Šã«ã€ä»¥ä¸‹ã®é–¢æ•°ã‚’è¿½åŠ ã¾ãŸã¯ç½®ãæ›ãˆã¦ãã ã•ã„

function handleParry() {
    player.isAiming = false; // â˜…ã“ã®è¡Œã‚’è¿½åŠ 
    lockCombatInteractionPanels();
    document.querySelectorAll('#combatActions button').forEach(btn => btn.disabled = true);
    player.isParrying = true;
    combatLogMessage(getString("log_player_parries"), 'normal', () => {
        updateCombatUI();
        enemyCombatTurn();
    });
}

function handleLegTrip() {
    player.isAiming = false; // â˜…ã“ã®è¡Œã‚’è¿½åŠ 
    lockCombatInteractionPanels();
    document.querySelectorAll('#combatActions button').forEach(btn => btn.disabled = true);
    const successChance = 0.7; // è¶³æ‰•ã„ã®æˆåŠŸç‡: 70%
    const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;

    if (Math.random() < successChance) {
        currentEnemy.stance = 'prone';
        combatLogMessage(getString("log_player_leg_trip_success", { enemyName: enemyName }), 'playerAttack', () => {
            enemyCombatTurn();
        });
    } else {
        combatLogMessage(getString("log_player_leg_trip_fail"), 'enemyAttack', () => {
            enemyCombatTurn();
        });
    }
}


/**
 * å¤§ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸéš›ã®è² å‚·åˆ¤å®šã‚’è¡Œã†
 * @param {object} target - å¯¾è±¡ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¾ãŸã¯æ•µï¼‰
 * @param {number} damage - ä¸ãˆã‚‰ã‚ŒãŸãƒ€ãƒ¡ãƒ¼ã‚¸
 */
function resolvePlayerAttackInjuries(target, damage) {
    const injuryChance = damage / 100; // ãƒ€ãƒ¡ãƒ¼ã‚¸ãŒé«˜ã„ã»ã©è² å‚·ã—ã‚„ã™ã„
    if (Math.random() > injuryChance) return;

    const hasBleeding = target.injuries && target.injuries.some(i => i.type === 'bleeding');
    const hasFracture = target.injuries && target.injuries.some(i => i.type === 'fracture');
    const targetName = (target === player) ? getString("you") : (getString(`item_${target.name}_name`) || target.name);

if (damage > 25 && Math.random() < 0.25 && !hasFracture) {
        if (!target.injuries) target.injuries = [];
        const coords = randChoice(injuryCoordinates['fracture']);
        target.injuries.push({ type: 'fracture', duration: 48, splinted: false, x: coords.x, y: coords.y });
        combatLogMessage(getString("log_got_fracture_target", { targetName: targetName }), 'enemyAttack');
    } else if (damage > 15 && Math.random() < 0.4 && !hasBleeding) {
        if (!target.injuries) target.injuries = [];
        const coords = randChoice(injuryCoordinates['bleeding']);
        target.injuries.push({ type: 'bleeding', x: coords.x, y: coords.y });
        combatLogMessage(getString("log_got_bleeding_target", { targetName: targetName }), 'enemyAttack');
    }
}
function handleHeavyMeleeAttack(hand) {
    player.isAiming = false;
    lockCombatInteractionPanels(); // â–¼â–¼â–¼ ã“ã®è¡Œã‚’è¿½åŠ  â–¼â–¼
    if (player.heavyAttackCooldown > 0) {
        combatLogMessage(getString("log_cooldown_heavy_attack"));
        return;
    }
    document.querySelectorAll('#combatActions button').forEach(btn => btn.disabled = true);
    const targetPart = randChoice(bodyParts);
    const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;
    
    let weapon;
    const targetSlot = (hand === 'off') ? 'off_hand' : 'main_hand';
    weapon = player.equipment.find(e => e.slot === targetSlot) || (hand === 'main' ? player.equipment.find(e => e.handedness === 'two') : null);

    let baseDamage;
    let baseAccuracy;
    let weaponNameForLog;

    if (weapon) {
        const durabilityFactor = 0.3 + 0.7 * ((weapon.durability === undefined ? 100 : weapon.durability) / 100);
        let itemAttack = weapon.attack || 0;
        if (weapon.name === 'ãƒ©ã‚¤ãƒ•ãƒ«' && weapon.bayonetAttached && weapon.loadedAmmo === 0) {
            const knife = items.find(i => i.name === 'ãƒŠã‚¤ãƒ•');
            itemAttack = knife ? knife.attack : (weapon.attack || 0);
        }
        baseDamage = Math.floor(itemAttack * durabilityFactor);
        baseAccuracy = weapon.accuracy || 70;
        weaponNameForLog = getBaseItemName(weapon);
    } else {
        baseDamage = player.baseAttack;
        baseAccuracy = 60;
        weaponNameForLog = getString("combat_attack_bare_hand");
    }

    const missPenalty = getAccuracyModifier();
    let finalMissChance = (1 - (baseAccuracy / 100)) + missPenalty + 0.20;
    finalMissChance += getUnseenTargetModifier(false);
    // â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ–°ã—ãè¿½åŠ  â–¼â–¼â–¼
    if (player.isAiming) {
        finalMissChance -= 0.30; // å‘½ä¸­ç‡ã‚’30%å‘ä¸Šï¼ˆå¤±æ•—ç¢ºç‡ã‚’30%æ¸›å°‘ï¼‰
        player.isAiming = false; // ã€Œç‹™ã„ã€ã®åŠ¹æœã‚’æ¶ˆè²»ã™ã‚‹
    }
    finalMissChance = Math.max(0.05, finalMissChance); // æœ€ä½ã§ã‚‚5%ã¯å¤±æ•—ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹
    // â–²â–²â–² è¿½åŠ ã¯ã“ã“ã¾ã§ â–²â–²â–²
    const onAttackSequenceEnd = () => {
        player.vulnerableTurns = 2;
        player.heavyAttackCooldown = 2;
        player.stunnedTurns = 1;
        combatLogMessage(getString("log_player_is_vulnerable"), 'enemyAttack', () => {
            combatLogMessage(getString("log_heavy_attack_recoil"), 'enemyAttack', () => {
                 if (currentEnemy.health <= 0) endCombat(true); else enemyCombatTurn();
            });
        });
    };

    if (Math.random() < finalMissChance) {
        playSoundFile('sounds/attack_miss.wav');
                // â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
        // 5%ã®ç¢ºç‡ã§æ­¦å™¨ã‚’è½ã¨ã™
        if (weapon && Math.random() < 0.05) {
            const weaponIndex = player.equipment.findIndex(e => e === weapon);
            if (weaponIndex > -1) {
                const droppedWeapon = player.equipment.splice(weaponIndex, 1)[0];
                const locationKey = `${player.x},${player.y}`;
                if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
                droppedItems[locationKey].push(droppedWeapon);
                
                combatLogMessage(`æ”»æ’ƒã‚’å¤–ã—ã€å‹•æºã—ã¦${getItemDisplayName(droppedWeapon)}ã‚’è½ã¨ã—ã¦ã—ã¾ã£ãŸï¼`, 'enemyAttack');
                updateBodyPanel(); // èº«ä½“ãƒ‘ãƒãƒ«ã‚’æ›´æ–°
                updateEquippedStats(); // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å†è¨ˆç®—
            }
        }
        // â–²â–²â–² è¿½åŠ ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²
        combatLogMessage(getString("log_player_attack_missed", { enemyName: enemyName }), 'enemyAttack', onAttackSequenceEnd);
    } else {
        if (weapon) {
            playSoundFile('sounds/attack_heavy.wav');
        } else {
            playSoundFile('sounds/punch.wav');
        }
        let damageBonus = 0;
        if (currentEnemy.vulnerableTurns > 0) damageBonus += Math.floor(baseDamage * 0.5);
        if (currentEnemy.isProne) damageBonus += Math.floor(baseDamage * 0.5);

        const damageMultiplier = 100 / (100 + (currentEnemy.defense || 0));
        const randomVariance = baseDamage * 2.5 * (Math.random() * 0.2 - 0.1); // ãƒ€ãƒ¡ãƒ¼ã‚¸ã«Â±10%ã®æºã‚‰ãã‚’è¿½åŠ 
        let calculatedDamage = ((baseDamage * 2.5) + randomVariance) * damageMultiplier;
        calculatedDamage += damageBonus;
        const playerDamage = Math.max(1, Math.round(calculatedDamage));
        currentEnemy.health -= playerDamage;
        resolveKnockdown(currentEnemy, playerDamage);
        showDealtDamage(playerDamage.toFixed(0));
        
        resolveCriticalHit(currentEnemy, targetPart);
        resolvePlayerAttackInjuries(currentEnemy, playerDamage);
                // â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’è¿½åŠ  â–¼â–¼â–¼
        if (weapon) {
            reduceCombatItemDurability(weapon, 3); // å¤§æ”»æ’ƒã¯è€ä¹…å€¤ã‚’3æ¶ˆè²»
        }
        // â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²

        // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â–¼â–¼â–¼
        // const targetPart = randChoice(bodyParts); // ã“ã®è¡Œã‚’å‰Šé™¤ã—ã¾ã—ãŸ
        const translatedPartName = getString('part_' + targetPart);
        const logText = getString("log_player_heavy_attack_part", { weaponName: weaponNameForLog, enemyName: enemyName, damage: playerDamage.toFixed(0), partName: translatedPartName });
        // â–²â–²â–² ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²
        
        combatLogMessage(logText, 'playerAttack', onAttackSequenceEnd);
    }
}
function handleHeavyRangedAttack() {
    player.isAiming = false;
    lockCombatInteractionPanels();
    if (player.heavyAttackCooldown > 0) {
        combatLogMessage(getString("log_cooldown_heavy_attack"));
        // ã‚¿ãƒ¼ãƒ³ã‚’æ¶ˆè²»ã—ãªã„ã®ã§ã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¡Œå‹•é¸æŠã«æˆ»ã™
        startPlayerTurn();
        return;
    }
    document.querySelectorAll('#combatActions button').forEach(btn => btn.disabled = true);
    const targetPart = randChoice(bodyParts);
    const gun = player.equipment.find(e => e.ammoType && e.loadedAmmo > 0);
    if (!gun) { 
        startPlayerTurn(); 
        return; 
    }

    const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;
    const missPenalty = getAccuracyModifier();
    let missChance = (1 - ((gun.accuracy || 85) / 100)) + missPenalty + 0.20; // å¤§æ”»æ’ƒã®å‘½ä¸­ç‡ãƒšãƒŠãƒ«ãƒ†ã‚£
    missChance += getUnseenTargetModifier(false);
    if (currentEnemy.isProne) missChance += 0.75;
    if (currentEnemy.vulnerableTurns > 0) missChance = 0;

    if (player.isAiming) {
        missChance -= 0.30;
        player.isAiming = false;
    }
    missChance = Math.max(0.05, missChance);
    
    gun.loadedAmmo--;

    const onAttackSequenceEnd = () => {
        player.vulnerableTurns = 2;
        player.heavyAttackCooldown = 2;
        player.stunnedTurns = 1;
        combatLogMessage(getString("log_player_is_vulnerable"), 'enemyAttack', () => {
            combatLogMessage(getString("log_heavy_attack_recoil"), 'enemyAttack', () => {
                if (currentEnemy.health <= 0) endCombat(true); 
                else enemyCombatTurn();
            });
        });
    };

    if (Math.random() < missChance) {
        playSoundFile('sounds/attack_miss.wav');
        const missLogKey = currentEnemy.isProne ? "log_player_miss_prone" : "log_player_attack_missed";
        combatLogMessage(getString(missLogKey, { enemyName: enemyName }), 'enemyAttack', onAttackSequenceEnd);
    } else {
        playSoundFile('sounds/gunshot_heavy.wav', 0.9);
        
        // â˜…â˜…â˜… æ–°ã—ã„ãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—å¼ã‚’é©ç”¨ã—ãŸè¡Œ â˜…â˜…â˜…
        const playerDamage = Math.max(1, Math.floor(((gun.fireDamage * 2.5) * 0.2) + (gun.fireDamage * 2.5) - (currentEnemy.defense || 0) + (Math.floor(Math.random() * 10) - 5)));
        
        currentEnemy.health -= playerDamage;
        resolveKnockdown(currentEnemy, playerDamage);
        showDealtDamage(playerDamage.toFixed(0));
        resolveCriticalHit(currentEnemy, targetPart);
        resolvePlayerAttackInjuries(currentEnemy, playerDamage);
        
        if (gun) {
            reduceCombatItemDurability(gun, 3);
        }
        
        const translatedPartName = getString('part_' + targetPart);
        const logText = getString("log_player_heavy_attack_part", { weaponName: getBaseItemName(gun), enemyName: enemyName, damage: playerDamage.toFixed(0), partName: translatedPartName });

        combatLogMessage(logText, 'playerFire', onAttackSequenceEnd);
    }
}
function endCombat(result) {
    document.getElementById('inventoryPanel').classList.remove('interaction-locked');
    document.getElementById('itemDetailPanel').classList.remove('interaction-locked');
    stopCombatBGM();
    const wasVictory = result === true, wasEscaped = result === 'escaped';
    const originalEnemy = { ...currentEnemy };
    const enemyIndex = entities.findIndex(e => e && currentEnemy && e.x === currentEnemy.x && e.y === currentEnemy.y);

const cleanupAndExit = () => {
        // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒæ–°ã—ã„å¾©å…ƒãƒ­ã‚¸ãƒƒã‚¯ã§ã™ â–¼â–¼â–¼
        document.querySelectorAll('.panel').forEach(panel => {
            const savedState = preCombatPanelStates[panel.id];
            if (savedState) {
                // ä¿å­˜ã•ã‚ŒãŸçŠ¶æ…‹ã«æˆ»ã™
                panel.style.display = savedState.display;
                panel.style.top = savedState.top;
                panel.style.left = savedState.left;
                panel.style.width = savedState.width;
                panel.style.height = savedState.height;
                if (savedState.isMinimized) {
                    panel.classList.add('minimized');
                } else {
                    panel.classList.remove('minimized');
                }
            } else {
                // ä¿å­˜æƒ…å ±ãŒãªã„å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§éè¡¨ç¤ºï¼ˆå¿µã®ãŸã‚ï¼‰
                panel.style.display = 'none';
            }
        });

        // æˆ¦é—˜é–¢é€£ã®ãƒ‘ãƒãƒ«ã¯ç¢ºå®Ÿã«éè¡¨ç¤ºã«ã™ã‚‹
        const combatPanels = ['combatPanel', 'dialoguePanel', 'tradePanel'];
        combatPanels.forEach(id => {
            const panel = document.getElementById(id);
            if (panel) panel.style.display = 'none';
        });
        
        document.querySelector('#bodyPanel .panel-footer').style.display = 'block';
        isInteractionActive = false;
        console.log(`DEBUG: endCombatãŒæ“ä½œãƒ­ãƒƒã‚¯ã‚’è§£é™¤ã—ã¾ã—ãŸã€‚ æ™‚åˆ»: ${new Date().toLocaleTimeString()}`);

        if (wasVictory) {
            if (originalEnemy.isAnimal) {
                const decayTurns = Math.floor(Math.random() * 11) + 10;
                const corpse = { 
                    x: originalEnemy.x, y: originalEnemy.y, type: 'corpse', 
                    name: `${originalEnemy.name}ã®æ­»éª¸`, graphic: FRESH_ANIMAL_CARCASS_IMG, 
                    decayTimer: decayTurns, isAnimalCorpse: true, unbutchered: true, 
                    potentialLoot: originalEnemy.loot 
                };
                placedObjects.push(corpse);
                respawnEntity(originalEnemy.type);
            } else if (originalEnemy.isZombie) {
                const decayTurns = Math.floor(Math.random() * 6) + 5;
                const corpse = {
                    x: originalEnemy.x, y: originalEnemy.y, type: 'corpse',
                    name: 'ã‚¾ãƒ³ãƒ“ã®æ­»ä½“', graphic: ZOMBIE_CORPSE_IMG,
                    decayTimer: decayTurns
                };
                placedObjects.push(corpse);
            } else {
                const zombificationTurns = Math.floor(Math.random() * 3) + 3;
                const lootItems = [...(originalEnemy.inventory || []), ...(originalEnemy.equipment || [])];
                const corpse = { 
                    x: originalEnemy.x, y: originalEnemy.y, type: 'corpse', 
                    name: 'æ–°é®®ãªæ­»ä½“', graphic: FRESH_HUMAN_CORPSE_IMG, 
                    zombificationTimer: zombificationTurns, isHumanCorpse: true, unsearched: true, 
                    potentialLoot: lootItems
                };
                placedObjects.push(corpse);
                respawnEntity(originalEnemy.type);
            }
            if (enemyIndex > -1) entities.splice(enemyIndex, 1);
        }

        currentEnemy = null; currentNPC = null;
        player.painStunSchedule = []; // æˆ¦é—˜çµ‚äº†æ™‚ã«ç—›ã¿ã«ã‚ˆã‚‹è¡Œå‹•ä¸èƒ½çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
        updateExploration();
        drawMap(); 
        updateStatus(); 
        updateCharacterBody(); 
        updateCurrentLocationPanel(false);
    };
    const enemyName = getString(`item_${originalEnemy.name}_name`) || originalEnemy.name;
    
    if (wasEscaped) {
        cleanupAndExit();
    } else if (wasVictory) {
        if (originalEnemy.isZombie) playSoundFile('sounds/zombie_death.wav');
        combatLogMessage(getString("combat_end_victory", { enemyName: enemyName }), 'victory', () => setTimeout(cleanupAndExit, 1500));
    } else {
        combatLogMessage(getString("combat_end_defeat", { enemyName: enemyName }), 'defeat', () => {
            setTimeout(() => {
                const gameOverMessage = getString("log_game_over_combat");
                speak(gameOverMessage + " " + getString("log_game_over_title"));
                handleGameOver(gameOverMessage);
                document.getElementById('combatPanel').style.display = 'none';
                isInteractionActive = false; currentEnemy = null; currentNPC = null;
            }, 1500);
        });
    }
}
// ã€è¿½åŠ ã™ã‚‹æ–°ã—ã„é–¢æ•°ç¾¤ã€‘

function placeWaterFilter(item, itemIndex, source) {
    if (isStunnedByPain()) { return; }
    if (!player.isInside && !player.isInShelter) {
        log(getString("log_water_filter_not_indoors"));
        return;
    }
    if (placedObjects.some(o => o.x === player.x && o.y === player.y && o.type === 'water_filter')) {
        log(getString("log_water_filter_exists"));
        return;
    }

    snapshotStats();
    const sourceArray = source === 'inventory' ? player.inventory : droppedItems[`${player.x},${player.y}`];
    const removedItem = sourceArray.splice(itemIndex, 1)[0];
    if (source === 'inventory') {
        player.weight -= removedItem.weight;
        player.volume -= removedItem.volume;
    }

    log("æ‰‹ä½œã‚Šæµ„æ°´å™¨ã‚’è¨­ç½®ã—ãŸã€‚");
    placedObjects.push({ 
        x: player.x, 
        y: player.y, 
        type: 'water_filter', 
        name: 'æ‰‹ä½œã‚Šæµ„æ°´å™¨', // â˜…ã‚­ãƒƒãƒˆã®åå‰ã§ã¯ãªãã€è¨­ç½®ç‰©ã®åå‰ã«å¤‰æ›´
        graphic: 'images/water_filter_placed.png',
        waterType: 'none',
        purifyTimer: -1
    });

    hideItemDetail();
    endPlayerTurn();
    refreshGameState();
}
/**
 * æ±šã‚ŒãŸæ°´ã®å…¥ã£ãŸå®¹å™¨ã‹ã‚‰ã€æµ„æ°´å™¨ã«æ°´ã‚’æ³¨ã
 */
function pourDirtyWaterIntoFilter(container, containerIndex, source) {
    const filter = placedObjects.find(o => o.x === player.x && o.y === player.y && o.type === 'water_filter');
    if (!filter) return;

    snapshotStats();

    container.content = null;

    filter.waterType = 'dirty';
    filter.purifyTimer = 3;
    filter.graphic = 'images/water_filter_dirty.png';

    log("æµ„æ°´å™¨ã«æ±šã‚ŒãŸæ°´ã‚’æ³¨ã„ã ã€‚ã—ã°ã‚‰ãå¾…ã¦ã°é£²ã‚ã‚‹ã‚ˆã†ã«ãªã‚‹ã ã‚ã†ã€‚");

    hideItemDetail();
    // advanceTurn(); // â˜…ã“ã®è¡Œã‚’å‰Šé™¤ã—ã¾ã—ãŸ
    refreshGameState();
}

/**
 * æµ„æ°´å™¨ã‹ã‚‰ã€ç©ºã®å®¹å™¨ã«ãã‚Œã„ãªæ°´ã‚’æ±²ã‚€
 */
function fillContainerFromFilter(container, containerIndex, source) {
    if (isStunnedByPain()) { return; }
    const filter = placedObjects.find(o => o.x === player.x && o.y === player.y && o.type === 'water_filter');
    if (!filter) return;

    snapshotStats();

    container.content = { 
        type: 'clean', 
        name: 'ãã‚Œã„ãªæ°´', 
        freshness: 100 
    };

    filter.waterType = 'none';
    filter.graphic = 'images/water_filter_placed.png'; // â˜…ç”»åƒã‚’ã€Œç©ºã€ã«å¤‰æ›´

    log(`${getItemDisplayName(container)}ã«ç¶ºéº—ãªæ°´ã‚’æ±²ã‚“ã ã€‚`);

    hideItemDetail();
    endPlayerTurn();
    refreshGameState();
}
/**
 * æµ„æ°´å™¨ã«æ±šæ°´ã‚’æ³¨ã
 */
function addDirtyWaterToFilter(filterObject) {
    const dirtyWaterContainerIndex = player.inventory.findIndex(i => i.type === 'container' && i.content && i.content.type === 'dirty');
    if (dirtyWaterContainerIndex === -1) {
        log("æ±šã‚ŒãŸæ°´ã®å…¥ã£ãŸå®¹å™¨ã‚’æŒã£ã¦ã„ãªã„ã€‚");
        return;
    }
    
    snapshotStats();
    const container = player.inventory[dirtyWaterContainerIndex];
    container.content = null; // å®¹å™¨ã‚’ç©ºã«ã™ã‚‹
    
    filterObject.waterType = 'dirty';
    filterObject.purifyTimer = 1; // 1ã‚¿ãƒ¼ãƒ³å¾Œã«æµ„åŒ–
    
    log("æµ„æ°´å™¨ã«æ±šã‚ŒãŸæ°´ã‚’æ³¨ã„ã ã€‚ã—ã°ã‚‰ãå¾…ã¦ã°é£²ã‚ã‚‹ã‚ˆã†ã«ãªã‚‹ã ã‚ã†ã€‚");

    advanceTurn();
    refreshGameState();
}

/**
 * æµ„æ°´å™¨ã‹ã‚‰ç›´æ¥é£²ã‚€
 */
function drinkFromFilter(filterObject) {
    if (isStunnedByPain()) { return; }
    if (player.thirst >= maxStats.thirst) {
        log(getString("log_thirst_full"), true);
        return;
    }
    snapshotStats();
    player.thirst = Math.min(maxStats.thirst, player.thirst + 40);
    filterObject.waterType = 'none';
    filterObject.graphic = 'images/water_filter_placed.png'; // â˜…ç”»åƒã‚’ã€Œç©ºã€ã«å¤‰æ›´
    log("æµ„æ°´å™¨ã‹ã‚‰ç›´æ¥ãã‚Œã„ãªæ°´ã‚’é£²ã¿ã€å–‰ã®æ¸‡ãã‚’ç™’ã—ãŸã€‚");

    endPlayerTurn();
    refreshGameState();
}

/**
 * æµ„æ°´å™¨ã‹ã‚‰å®¹å™¨ã«æ°´ã‚’æ±²ã‚€
 */
function takeCleanWaterFromFilter(filterObject) {
    if (isStunnedByPain()) { return; }
    const emptyContainerIndex = player.inventory.findIndex(i => i.type === 'container' && !i.content);
    if (emptyContainerIndex === -1) {
        log("æ°´ã‚’æ±²ã‚€ãŸã‚ã®ç©ºã®å®¹å™¨ãŒãªã„ã€‚");
        return;
    }
    
    snapshotStats();
    const container = player.inventory[emptyContainerIndex];
    container.content = { type: 'clean', freshness: 100 };
    filterObject.waterType = 'none';
    
    log(`${getItemDisplayName(container)}ã«ç¶ºéº—ãªæ°´ã‚’æ±²ã‚“ã ã€‚`);
    
    endPlayerTurn();
    refreshGameState();
}
// ã€ã“ã“ã‹ã‚‰3ã¤ã®é–¢æ•°ã‚’è¿½åŠ ã€‘

/**
 * é–‹ç™ºè€…ãƒ‘ãƒãƒ«ã®è¡¨ç¤º/éè¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹
 */
function toggleDevPanel() {
    const panel = document.getElementById('devPanel');
    if (panel.style.display === 'none') {
        panel.style.display = 'flex';
        populateDevPanel();
        bringToFront(panel);
    } else {
        panel.style.display = 'none';
    }
}
/**
 * é–‹ç™ºè€…ãƒ‘ãƒãƒ«ã«å…¨ã‚¢ã‚¤ãƒ†ãƒ ã®ãƒªã‚¹ãƒˆã‚’ç”Ÿæˆã™ã‚‹ (æ¤œç´¢æ©Ÿèƒ½ä»˜ã)
 */
function populateDevPanel() {
    const listDiv = document.getElementById('devItemList');
    const searchTerm = document.getElementById('devItemSearch').value.toLowerCase(); // â˜…æ¤œç´¢èªã‚’å–å¾—
    listDiv.innerHTML = '';

    // devSelectedItemãŒãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã§æ¶ˆãˆãªã„ã‚ˆã†ã«ã€ä¸€åº¦ãƒªã‚»ãƒƒãƒˆã¯ã—ãªã„

    items.forEach(item => {
        const displayNameHTML = getItemDisplayName(item);

        // â˜…HTMLã‚¿ã‚°ã‚’é™¤å»ã—ã¦ã€ç´”ç²‹ãªãƒ†ã‚­ã‚¹ãƒˆåã‚’å–å¾—
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = displayNameHTML;
        const plainDisplayName = tempDiv.textContent || tempDiv.innerText || "";

        // â˜…æ¤œç´¢èªãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ (æ¤œç´¢èªãŒç©ºãªã‚‰å…¨è¡¨ç¤º)
        if (searchTerm === '' || plainDisplayName.toLowerCase().includes(searchTerm)) {
            let div = document.createElement("div");
            div.className = "item";
            div.innerHTML = `${getIconHTML(item.graphic, 16)} ${displayNameHTML}`;

            // ã‚‚ã—ã“ã®ã‚¢ã‚¤ãƒ†ãƒ ãŒç¾åœ¨é¸æŠã•ã‚Œã¦ã„ã‚‹ã‚¢ã‚¤ãƒ†ãƒ ãªã‚‰ã€selectedã‚¯ãƒ©ã‚¹ã‚’ä»˜ä¸
            if (devSelectedItem && devSelectedItem.name === item.name) {
                div.classList.add('selected');
            }

            div.onclick = () => {
                document.querySelectorAll('#devItemList .item.selected').forEach(el => el.classList.remove('selected'));
                div.classList.add('selected');
                devSelectedItem = item;
                document.getElementById('devSelectedItemName').textContent = plainDisplayName;
            };
            listDiv.appendChild(div);
        }
    });
}

// index.htmlã®<script>ã‚¿ã‚°å†…

// â–¼â–¼â–¼ æ—¢å­˜ã®`devSpawnItem`é–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
/**
 * é¸æŠã•ã‚ŒãŸã‚¢ã‚¤ãƒ†ãƒ ã‚’æŒ‡å®šã•ã‚ŒãŸæ•°ã ã‘ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¶³å…ƒã«ç”Ÿæˆã™ã‚‹
 */
function devSpawnItem() {
    if (!devSelectedItem) {
        log("é–‹ç™ºè€…: ç”Ÿæˆã™ã‚‹ã‚¢ã‚¤ãƒ†ãƒ ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚");
        return;
    }
    const quantity = parseInt(document.getElementById('devItemQuantity').value) || 1;
    const locationKey = `${player.x},${player.y}`;
    if (!droppedItems[locationKey]) {
        droppedItems[locationKey] = [];
    }

    log(`é–‹ç™ºè€…: ${getItemDisplayName(devSelectedItem)} ã‚’ ${quantity}å€‹ ç”Ÿæˆã—ã¾ã—ãŸã€‚`);

    for (let i = 0; i < quantity; i++) {
        // â˜…â˜…â˜… ã“ã“ãŒä¿®æ­£ç‚¹ã§ã™ â˜…â˜…â˜…
        // æœªå®šç¾©ã®ã€ŒitemTemplateã€ã§ã¯ãªãã€é¸æŠä¸­ã®ã€ŒdevSelectedItemã€ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
        // ã¾ãŸã€ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ­£ã—ãã‚³ãƒ”ãƒ¼ã™ã‚‹ãŸã‚ã« createItemInstance é–¢æ•°ã‚’ä½¿ã„ã¾ã™ã€‚
        const newItem = createItemInstance(devSelectedItem); 
        
        if (newItem) {
             droppedItems[locationKey].push(newItem);
        }
    }
    
    // UIã‚’æ›´æ–°ã—ã¦ã€åœ°é¢ã«ç½®ã‹ã‚ŒãŸã‚¢ã‚¤ãƒ†ãƒ ã‚’å³åº§ã«è¡¨ç¤ºã—ã¾ã™ã€‚
    updateCurrentLocationPanel(false);
}
// --- Game Over System ---
function initGame() {
    stopMenuBGM(); // â† ã“ã®è¡Œã‚’è¿½åŠ 
    stopWeatherEffect();
    stopClouds();
    document.getElementById('startScreen').style.display = 'none';
    document.getElementById('gameClearScreen').style.display = 'none';
    document.querySelectorAll('.panel').forEach(p => p.style.display = 'none');
    restartGame();
}

// â–¼â–¼â–¼ æ—¢å­˜ã® `restartGame` é–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function restartGame() {
      hasPlayedImpendingDoomVoice = false;
      currentAmbientSound = null;
      const panels = ["mapPanel", "statusPanel", "turnPanel", "logPanel", "inventoryPanel", "craftingPanel", "characterPanel", "currentLocationPanel", "minimapPanel", "bodyPanel"];
      panels.forEach(id => {
      const panel = document.getElementById(id);
      if (panel) {
          panel.style.display = 'block';
           if (['mapPanel', 'inventoryPanel', 'equipmentPanel', 'minimapPanel', 'craftingPanel', 'currentLocationPanel'].includes(id)) {
              panel.style.display = 'flex';
          }
      }
  });
    document.getElementById('itemDetailPanel').style.display = 'none';
    document.getElementById('gameClearScreen').style.display = 'none';
    genMap();

    // â–¼â–¼â–¼ ä¿®æ­£ç‚¹: ã‚¿ãƒ¼ãƒ³0ã§æ¢ç´¢ã™ã‚‹å‡¦ç†ã‚’å‰Šé™¤ã—ã¾ã—ãŸ â–¼â–¼â–¼
    // searchCurrentLocation(); // ã“ã®è¡Œã‚’å‰Šé™¤
    
    updatePlayerDirectionArrow();
    generateWeatherAndTemperature(); 
    snapshotStats();
    drawMap(); 
    updateStatus(); 
    updateItemPanels(); 
    logClear();
    updateCurrentLocationPanel(false); 
    updateCharacterBody(); 
    updateCharacterInfo(); 
    updateTurnInfo();
    log(generateBackstory());
    processSpeechQueue();
    updateBackgroundColor();
    isInteractionActive = false;
    drawMinimap();
    updateMovementButtons();
    isGameRunning = true;    
    updateBodyPanel();
}

// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function showRetryModal(message) {
    if (document.getElementById("retryModal")) return;
    const modalDiv = document.createElement("div"); 
    modalDiv.id = "retryModal";
    modalDiv.style.cssText = `position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #222; color: white; padding: 30px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.6); z-index: 9999; text-align: center; font-family: sans-serif;`;
    
    // ç”Ÿå­˜ã‚¿ãƒ¼ãƒ³æ•°ã‚’ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«è¿½åŠ 
    const survivalMessage = getString("log_turns_survived", { turn: turn });

    // ãƒœã‚¿ãƒ³ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ã€Œã¯ã„ã€ã¨ã€Œãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹ã€ã«å¤‰æ›´
    modalDiv.innerHTML = `<p style="font-size: 1.2em; margin-bottom: 10px;">${message}</p><p style="font-size: 1.1em; color: #f1c40f; margin-bottom: 20px;">${survivalMessage}</p><p style="font-size: 1.2em; margin-bottom: 20px;">${getString("confirm_retry_q")}</p><button id="retryYesBtn" style="background: #4CAF50; color: white; border: none; padding: 10px 20px; margin-right: 10px; border-radius: 5px; cursor: pointer;">${getString("btn_yes")}</button><button id="retryNoBtn" style="background: #4a4a52; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">${getString("btn_return_to_menu")}</button>`;
    
    document.body.appendChild(modalDiv);
    
    // ã€Œã¯ã„ã€ã‚’æŠ¼ã™ã¨ãƒªãƒˆãƒ©ã‚¤
    document.getElementById("retryYesBtn").onclick = () => { modalDiv.remove(); restartGame(); };
    // ã€Œãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹ã€ã‚’æŠ¼ã™ã¨æ–°ã—ã„é–¢æ•°ã‚’å‘¼ã³å‡ºã™
    document.getElementById("retryNoBtn").onclick = returnToMenu;
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’æ–°ã—ãè¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
function returnToMenu() {
    // â–¼â–¼â–¼ ã“ã®è¡Œã‚’è¿½åŠ  â–¼â–¼â–¼
    // é€²è¡Œä¸­ã®éŸ³å£°èª­ã¿ä¸Šã’ã‚’ã™ã¹ã¦åœæ­¢ã™ã‚‹
    speechSynthesis.cancel();
    // â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²

    // ã™ã¹ã¦ã®ã‚²ãƒ¼ãƒ ãƒ‘ãƒãƒ«ã‚’éè¡¨ç¤ºã«ã™ã‚‹
    document.querySelectorAll('.panel').forEach(p => p.style.display = 'none');
    
    // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã®ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’å‰Šé™¤
    const modal = document.getElementById("retryModal");
    if (modal) modal.remove();

    // ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ã‚’è¡¨ç¤ºã™ã‚‹
    document.getElementById('startScreen').style.display = 'flex';
    isGameRunning = false;

    // å¤©å€™ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚„BGMã‚’åœæ­¢
    stopWeatherEffect();
    stopClouds();
    stopLowHealthBGM(); // â–¼â–¼â–¼ ã“ã®è¡Œã‚’æ–°ã—ãè¿½åŠ  â–¼â–¼â–¼
    stopCriticalHeartbeat(); // â–¼â–¼â–¼ ã“ã®è¡Œã‚’æ–°ã—ãè¿½åŠ  â–¼â–¼â–¼
    stopCombatBGM(); // <<< ã“ã®è¡Œã‚’æ–°ã—ãè¿½åŠ 
    if (bgm) {
        bgm.pause();
        bgm.currentTime = 0; // æ›²ã‚’æœ€åˆã«æˆ»ã™
    }
    playMenuBGM(); // â† ã“ã®è¡Œã‚’è¿½åŠ 
}
/**
 * ã‚¢ã‚¤ãƒ†ãƒ ã®è€ä¹…å€¤ã‚’æ¸›ã‚‰ã—ã€å£Šã‚ŒãŸå ´åˆã«ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã‚„è£…å‚™ã‹ã‚‰å‰Šé™¤ã—ã¾ã™ã€‚
 * @param {object} item - å¯¾è±¡ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
 * @param {number} amount - æ¸›ã‚‰ã™è€ä¹…å€¤ã®é‡
 * @param {boolean} [silent=false] - trueã®å ´åˆã€ã‚¢ã‚¤ãƒ†ãƒ ç ´å£Šæ™‚ã®ãƒ­ã‚°ã‚’æŠ‘åˆ¶ã—ã¾ã™
 * @returns {boolean} - ã‚¢ã‚¤ãƒ†ãƒ ãŒç ´å£Šã•ã‚ŒãŸå ´åˆã¯trueã‚’è¿”ã—ã¾ã™
 */
function reduceItemDurability(item, amount, silent = false) {
    if (item.durability === undefined) return false;

    item.durability -= amount;

    if (item.durability <= 0) {
        item.durability = 0;
        const equipIndex = player.equipment.findIndex(e => e === item);
        const invIndex = player.inventory.findIndex(i => i === item);

        if (equipIndex > -1) {
            const removedItem = player.equipment.splice(equipIndex, 1)[0];
            if (!silent) log(getString("combat_weapon_break", { weaponName: getBaseItemName(removedItem) }), true);
            updateEquippedStats();
        } else if (invIndex > -1) {
            const removedItem = player.inventory.splice(invIndex, 1)[0];
            player.weight -= removedItem.weight || 0;
            player.volume -= removedItem.volume || 0;
            if (!silent) log(getString("combat_weapon_break", { weaponName: getBaseItemName(removedItem) }), true);
        }
        
        updateItemPanels();
        updateStatus();
        return true;
    }
    
    // å£Šã‚Œãªã‹ã£ãŸå ´åˆã§ã‚‚ã€UIä¸Šã®è€ä¹…å€¤è¡¨ç¤ºã‚’æ›´æ–°
    updateItemPanels(); 
    updateStatus();
    return false;
}

/**
 * æˆ¦é—˜ä¸­ã«ã‚¢ã‚¤ãƒ†ãƒ ã®è€ä¹…å€¤ã‚’æ¸›ã‚‰ã—ã€æˆ¦é—˜ãƒ­ã‚°ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‡ºåŠ›ã—ã¾ã™ã€‚
 * @param {object} item - å¯¾è±¡ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
 * @param {number} amount - æ¸›ã‚‰ã™è€ä¹…å€¤ã®é‡
 * @returns {boolean} - ã‚¢ã‚¤ãƒ†ãƒ ãŒç ´å£Šã•ã‚ŒãŸå ´åˆã¯trueã‚’è¿”ã—ã¾ã™
 */
function reduceCombatItemDurability(item, amount) {
    if (item.durability === undefined) return false;
    item.durability -= amount;
    if (item.durability <= 0) {
        item.durability = 0;
        const equipIndex = player.equipment.findIndex(e => e === item);
        if (equipIndex > -1) {
            const removedItem = player.equipment.splice(equipIndex, 1)[0];
            combatLogMessage(getString("combat_weapon_break", { weaponName: getBaseItemName(removedItem) }), 'enemyAttack');
            updateEquippedStats();
            updateCombatUI();
            updateItemPanels();
            updateStatus();
            return true;
        }
    }
    return false;
}

/**
 * ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸéš›ã«ã€é˜²å…·ã®è€ä¹…å€¤ã‚’æ¸›å°‘ã•ã›ã¾ã™ã€‚
 * @param {number} damageTaken - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå—ã‘ãŸãƒ€ãƒ¡ãƒ¼ã‚¸é‡
 * @param {string} hitPart - æ”»æ’ƒãŒå‘½ä¸­ã—ãŸéƒ¨ä½ ('head', 'torso'ãªã©)
 */
function damagePlayerArmor(damageTaken, hitPart) {
    if (damageTaken <= 0) return;

    let potentialSlots = [];
    switch (hitPart) {
        case 'head': potentialSlots = ['head', 'eyes']; break;
        case 'torso': potentialSlots = ['body_outer', 'body_inner', 'back']; break;
        case 'rightArm': case 'leftArm': potentialSlots = ['body_outer', 'hands']; break;
        case 'rightLeg': case 'leftLeg': potentialSlots = ['legs', 'feet']; break;
    }

    const equippedArmorInSlots = player.equipment.filter(e => potentialSlots.includes(e.slot));
    if (equippedArmorInSlots.length === 0) return;

    let armorToDamage = equippedArmorInSlots.find(e => e.slot === 'body_outer');
    if (!armorToDamage) {
        armorToDamage = randChoice(equippedArmorInSlots);
    }

    const durabilityDamage = Math.max(1, Math.ceil(damageTaken / 5));
    if (armorToDamage) {
        reduceCombatItemDurability(armorToDamage, durabilityDamage);
    }
}
// â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²
function handleGameOver(message) {
    isInteractionActive = true;
    stopWeatherEffect();
    stopClouds();
    stopLowHealthBGM(); // â–¼â–¼â–¼ ã“ã®è¡Œã‚’æ–°ã—ãè¿½åŠ  â–¼â–¼â–¼
    stopCriticalHeartbeat(); // â–¼â–¼â–¼ ã“ã®è¡Œã‚’æ–°ã—ãè¿½åŠ  â–¼â–¼â–¼
    document.querySelectorAll('.panel').forEach(p => p.style.display = 'none');
    showRetryModal(message);
}
// â–¼â–¼â–¼ æ—¢å­˜ã® `waitOneTurn` é–¢æ•°ã‚’ä¿®æ­£ â–¼â–¼â–¼
function waitOneTurn() {
    if (isStunnedByPain()) { return; } // â˜…â˜…â˜… ã“ã®è¡Œã‚’è¿½åŠ  â˜…â˜…â˜…
    interruptAndClearSpeech(); 
    if(isInteractionActive) return;
    snapshotStats();

    // â˜…â˜…â˜…ã“ã®è¡Œã‚’è¿½åŠ â˜…â˜…â˜…
    // ä¼‘æ¯ã«ã‚ˆã‚‹ç—›ã¿è€æ€§ã®å›å¾©ãƒœãƒ¼ãƒŠã‚¹
    player.painTolerance += 1.0;
    player.immuneSystem += 0.5; // â˜…â˜…â˜… ã“ã®è¡Œã‚’è¿½åŠ  â˜…â˜…â˜…
    log(getString("info_waited_one_turn"));
    endPlayerTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    checkGameOver();
    updateTurnInfo();
    updateCurrentLocationPanel(false);
    processSpeechQueue(); 
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’æ–°ã—ãè¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
function refreshGameState() {
    drawMap();
    updateEquippedStats();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    updateTurnInfo();
    updateCurrentLocationPanel(false);
    checkGameOver();
}
function triggerGameClear() {
    isInteractionActive = true; 
    log(getString("log_salvation_city_discovered")); 
    playSound('victory');
    document.querySelectorAll('.panel').forEach(p => p.style.display = 'none');
    const clearScreen = document.getElementById('gameClearScreen');
    const gateArt = document.getElementById('gateArt');
    const clearHeader = document.getElementById('clearHeader');
    const clearMessage = document.getElementById('clearMessage');
    const art1 = `
      ||||||||
    ||||||||||||
   | o ______ o |
   | o|      |o |
   | o|______|o |
    ||||||||||||
      ||||||||`;
    const msg1 = getString("game_clear_message_1");
    gateArt.textContent = art1; 
    clearMessage.textContent = msg1;
    clearScreen.style.display = 'flex'; 
    speak(getString("game_clear_header"));
    speak(msg1);
    setTimeout(() => {
        const art2 = `
      |||    |||
    |||||    |||||
   | o |    | o |
   | o |    | o |
   | o |____| o |
    |||||    |||||
      |||    |||`;
        const msg2 = getString("game_clear_message_2");
        gateArt.textContent = art2; 
        clearMessage.textContent = msg2; 
        speak(msg2);
    }, 3000);
}

function checkGameOver() {
    if (player.health <= 0 && !isInteractionActive) {
        let reasonKey = "";
        let replacements = {};
        if (player.bodyTemp >= 41) {
            reasonKey = "log_game_over_heatstroke";
            replacements = { temp: player.bodyTemp.toFixed(1) };
        } else if (player.bodyTemp <= 34) {
            reasonKey = "log_game_over_hypothermia";
            replacements = { temp: player.bodyTemp.toFixed(1) };
        } else if (player.thirst <= 0 && player.hunger <= 0) {
            reasonKey = "log_game_over_starvation_dehydration";
        } else if (player.thirst <= 0) {
            reasonKey = "log_game_over_dehydration";
        } else if (player.hunger <= 0) {
            reasonKey = "log_game_over_starvation";
        } else if (player.morale <= 0) {
            reasonKey = "log_game_over_despair";
        } else {
            reasonKey = "log_game_over_weakness";
        }
        const causeMessage = getString(reasonKey, replacements);
        const gameOverMessage = getString("log_game_over_reason", { reason: causeMessage });
        speak(gameOverMessage + " " + getString("log_game_over_title"));
        handleGameOver(gameOverMessage);
    }
}

function playZombieSound() { playSound('zombie'); }


function updateCurrentLocationPanel(isEncounter, entity = null) {
    const locationName = document.getElementById("locationName"),
        locationAscii = document.getElementById("locationAscii"),
        droppedItemsList = document.getElementById("droppedItemsList"),
        locationActions = document.getElementById("locationActions"),
        placedObjectsContainer = document.getElementById("locationPlacedObjects"),
        placedObjectsList = document.getElementById("placedObjectsList");

    locationActions.innerHTML = '';
    
    let tile = map[player.y][player.x];
    const facilityTypes = ['location_commercial', 'location_residential', 'location_industrial'];

    if (facilityTypes.includes(tile.loc.nameKey) && (!tile.explorableLocations || tile.explorableLocations.length > 0)) {
        const searchBuildingBtn = document.createElement('button');
        searchBuildingBtn.textContent = getString("btn_search_building");
        searchBuildingBtn.onclick = () => openExplorationPanel(tile);
        locationActions.appendChild(searchBuildingBtn);
    }
    
    const locationKey = `${player.x},${player.y}`;
    const waterReference = items.find(i => i.name === 'æ±šã‚ŒãŸæ°´');
    if (tile.loc.nameKey === 'location_pond' && waterReference && !(droppedItems[locationKey] || []).some(item => item.type === 'water_source')) {
        if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
        droppedItems[locationKey].push({ ...waterReference });
    }

    const harvestableCrop = placedObjects.find(p => p.x === player.x && p.y === player.y && p.isHarvestable);
    if (harvestableCrop) {
        const harvestBtn = document.createElement('button');
        harvestBtn.textContent = getString("btn_harvest_crop", { cropName: getString(`item_${harvestableCrop.planted}_name`) });
        harvestBtn.onclick = harvestCrop;
        locationActions.appendChild(harvestBtn);
    }
    const barricade = placedObjects.find(p => p.x === player.x && p.y === player.y && p.type === 'barricade');
    if (barricade && barricade.health < barricade.maxHealth) {
        const repairBtn = document.createElement('button');
        repairBtn.textContent = getString("btn_repair_barricade");
        repairBtn.onclick = repairBarricade;
        locationActions.appendChild(repairBtn);
    }
    
    const shelter = placedObjects.find(p => p.x === player.x && p.y === player.y && p.type === 'shelter');
    if (shelter) {
        const shelterBtn = document.createElement('button');
        if (player.isInShelter) {
            shelterBtn.textContent = getString("btn_exit_shelter");
            shelterBtn.onclick = exitShelter;
        } else {
            shelterBtn.textContent = getString("btn_enter_shelter");
            shelterBtn.onclick = enterShelter;
        }
        locationActions.appendChild(shelterBtn);
    }

    if (tile.loc.isShop) {
        const enterShopBtn = document.createElement('button');
        enterShopBtn.textContent = getString("btn_enter_shop");
        enterShopBtn.onclick = startTraderShopEncounter;
        locationActions.appendChild(enterShopBtn);
    }
    if (tile.loc.nameKey === 'location_cabin') {
        const cabinBtn = document.createElement('button');
        if (player.isInside) {
            cabinBtn.textContent = getString("btn_exit_cabin");
            cabinBtn.onclick = exitCabin;
        } else {
            cabinBtn.textContent = getString("btn_enter_cabin");
            cabinBtn.onclick = enterCabinWithEncounter;
        }
        locationActions.appendChild(cabinBtn);
    }
    if (tile.loc.nameKey === 'location_pond') {
        const washBtn = document.createElement('button');
        washBtn.textContent = getString("btn_wash_body");
        washBtn.onclick = washBody;
        
        washBtn.addEventListener('mouseenter', (e) => showInfoTooltip(e, getString('btn_wash_body'), getString('tooltip_btn_wash_body')));
        washBtn.addEventListener('mouseleave', hideInfoTooltip);
        washBtn.addEventListener('mousemove', (e) => updatePreviewPosition(e));
        
        locationActions.appendChild(washBtn);
    }
    if (tile.loc.nameKey === 'location_forest') {
        const gatherBtn = document.createElement('button');
        gatherBtn.id = 'gatherLogBtn';
        gatherBtn.textContent = getString("btn_gather_log", { count: tile.logSupply || 0 });
        const hasAxe = player.inventory.some(i => i.isAxe) || player.equipment.some(i => i.isAxe);
        if (!hasAxe || !tile.logSupply || tile.logSupply <= 0) {
            gatherBtn.disabled = true;
        }
        gatherBtn.onclick = gatherLog;
        locationActions.appendChild(gatherBtn);
    }

    if (isEncounter && entity) {
        locationName.textContent = getString(`item_${entity.name}_name`) || entity.name;
        locationAscii.innerHTML = getIconHTML(entity.icon, 128);
    } else {
        if (player.isInside) {
            locationName.textContent = getString("location_cabin_inside");
            locationAscii.innerHTML = getIconHTML('images/cabin_inside.png', 128);
        } else if (player.isInShelter) {
            locationName.textContent = getString("location_shelter_inside");
            locationAscii.innerHTML = getIconHTML('images/shelter_inside.png', 128);
        } else {
            locationName.textContent = getString(tile.loc.nameKey);
            
            // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â–¼â–¼â–¼
            let panelIcon = tile.loc.icon; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¢ã‚¤ã‚³ãƒ³ã‚’è¨­å®š
            
            // ã‚‚ã—ç¾åœ¨åœ°ãŒç‰¹å®šã®å ´æ‰€ãªã‚‰ã€ãƒ‘ãƒãƒ«å°‚ç”¨ã®ç”»åƒã«å·®ã—æ›¿ãˆã‚‹
            if (tile.loc.nameKey === 'location_plains') {
                panelIcon = 'images/plains_panel.png'; 
            } else if (tile.loc.nameKey === 'location_rock') {
                panelIcon = 'images/rock_panel.png';
            } else if (tile.loc.nameKey === 'location_forest') {
                panelIcon = 'images/forest_panel.png';
            } else if (tile.loc.nameKey === 'location_untilled_field') {
                panelIcon = 'images/field_panel.png';
            } else if (tile.loc.nameKey === 'location_pond') { // â† ä»¥ä¸‹ã‚’è¿½åŠ 
                panelIcon = 'images/pond_panel.png';
            } else if (tile.loc.nameKey === 'location_cabin') {
                panelIcon = 'images/cabin_panel.png';
            } else if (tile.loc.nameKey === 'location_commercial') {
                panelIcon = 'images/commercial_panel.png';
            } else if (tile.loc.nameKey === 'location_residential') {
                panelIcon = 'images/residential_panel.png';
            } else if (tile.loc.nameKey === 'location_industrial') {
                panelIcon = 'images/industrial_panel.png';
            } else if (tile.loc.nameKey === 'location_salvation_city') {
                panelIcon = 'images/salvation_city_panel.png'; // çµµæ–‡å­—ã‹ã‚‰ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã«å¤‰æ›´
            } else if (tile.loc.nameKey === 'location_trader_shop') {
                panelIcon = 'images/store_panel.png'; // ã“ã®è¡Œã‚’è¿½åŠ ã¾ãŸã¯å¤‰æ›´
            }
            locationAscii.innerHTML = getIconHTML(panelIcon, 1);
            updateLocationPanelImageSize(); 
            // â–²â–²â–² ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²
        }
    }
    if (player.isInside || player.isInShelter) {
        const facilitiesHeader = document.getElementById('facilitiesHeader');
        if (player.isInShelter) {
            facilitiesHeader.textContent = getString("location_info_facilities_shelter");
        } else {
            facilitiesHeader.textContent = getString("location_info_facilities");
        }
        
        const facilityTypes = ['workbench', 'junk_research_bench', 'campfire', 'unlit_campfire', 'sleeping_bag', 'wooden_box', 'water_filter'];
        const objectsInside = placedObjects.filter(p =>
            p.x === player.x &&
            p.y === player.y &&
            facilityTypes.includes(p.type)
        );

        if (objectsInside.length > 0) {
            placedObjectsList.innerHTML = '';
            placedObjectsList.className = ''; 

            objectsInside.forEach(obj => {
                const img = document.createElement('img');
                img.src = obj.graphic;
                img.className = 'facility-slot-icon';
                img.title = getPlacedObjectDisplayName(obj); 
                img.onclick = () => showPlacedObjectDetail(obj); 
                placedObjectsList.appendChild(img);
            });
            placedObjectsContainer.style.display = 'block';
        } else {
            placedObjectsContainer.style.display = 'none';
        }
    } else {
        placedObjectsContainer.style.display = 'none';
    }

    droppedItemsList.innerHTML = "";
    const itemsHere = droppedItems[`${player.x},${player.y}`] || [];
    if (itemsHere.length === 0) {
        droppedItemsList.textContent = getString("item_none");
        return;
    }
    itemsHere.forEach((item, idx) => {
        let div = document.createElement("div");
        div.className = "item";
        let descText = "";
        if (item.type === "consumable" && item.freshness !== undefined) descText = item.freshness > 0 ? `${getString("item_info_freshness")}: ${item.freshness.toFixed(0)}%` : getString("item_info_spoiled");
        else if ((item.type === "equipment" || item.type === "clothing" || item.type === "tool") && item.durability !== undefined) descText = `${getString("item_info_durability")}: ${item.durability.toFixed(0)}%`;
        div.innerHTML = `${getIconHTML(getItemGraphic(item), 16)} ${getItemDisplayName(item)}${descText ? ` <span style="font-size: smaller; color: #888;">(${descText})</span>` : ''}`;
        div.onclick = () => showItemDetail(item, idx, 'dropped');
        droppedItemsList.appendChild(div);
    });
} // â† â˜…â˜…â˜… ä¸è¶³ã—ã¦ã„ãŸé–‰ã˜æ‹¬å¼§ã¯ã“ã‚Œã§ã™ â˜…â˜…â˜…

/**
 * ç¾åœ¨ã®ä½ç½®ãƒ‘ãƒãƒ«ã®ã‚µã‚¤ã‚ºã«åˆã‚ã›ã¦ä¸­ã®ç”»åƒã®å¤§ãã•ã‚’èª¿æ•´ã™ã‚‹é–¢æ•°
 */
function updateLocationPanelImageSize() {
    const panel = document.getElementById('currentLocationPanel');
    const imageContainer = document.getElementById('locationAscii');
    if (!panel || !imageContainer) return;

    // ç”»åƒã‚³ãƒ³ãƒ†ãƒŠå†…ã®ç”»åƒè¦ç´ ã‚’å–å¾— (img ã¾ãŸã¯ span)
    const imageElement = imageContainer.querySelector('img') || imageContainer.querySelector('span');
    if (!imageElement) return;

    // ãƒ‘ãƒãƒ«ã®å†…éƒ¨ã‚µã‚¤ã‚ºï¼ˆãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’é™¤ãï¼‰ã‚’å–å¾—
    const panelWidth = panel.clientWidth;
    const panelHeight = imageContainer.offsetTop > 0 ? panel.clientHeight - imageContainer.offsetTop - 20 : panel.clientHeight - 60;

    // ãƒ‘ãƒãƒ«ã®å¹…ã¨é«˜ã•ã®ã†ã¡ã€å°ã•ã„æ–¹ã‚’åŸºæº–ã«ç”»åƒã‚µã‚¤ã‚ºã‚’æ±ºå®š (ä½™ç™½ã‚’è€ƒæ…®ã—ã¦80%ã«ã™ã‚‹)
    const newSize = Math.floor(Math.min(panelWidth, panelHeight) * 0.8);

    // ç”»åƒã‚µã‚¤ã‚ºãŒå°ã•ããªã‚Šã™ããªã„ã‚ˆã†ã«æœ€å°å€¤ã‚’è¨­å®š
    const finalSize = Math.max(32, newSize); 

    // è¨ˆç®—ã—ãŸã‚µã‚¤ã‚ºã‚’ç”»åƒè¦ç´ ã«é©ç”¨
    imageElement.style.width = `${finalSize}px`;
    imageElement.style.height = `${finalSize}px`;
    // ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚‚åŒæ§˜ã«è¨­å®šï¼ˆçµµæ–‡å­—ã®å ´åˆã«æœ‰åŠ¹ï¼‰
    imageElement.style.fontSize = `${finalSize}px`;
}
function enterCabinWithEncounter() {
    playSoundFile('sounds/door_open.wav');

    const tile = map[player.y][player.x]; 

    if (tile.cabinVisited) {
        player.isInside = true;
        updateCurrentLocationPanel(false);
        drawMap();
        log(getString("log_enter_cabin_safe")); 
        return; 
    }

    tile.cabinVisited = true; 

    player.isInside = true;
    updateCurrentLocationPanel(false);

    if (Math.random() < 0.05) {
        log("å°å±‹ã®ãƒ‰ã‚¢ã‚’ã‚†ã£ãã‚Šã¨é–‹ã‘ã‚‹ã¨...ä¸­ã«èª°ã‹ã„ã‚‹ï¼");
        
        const possibleEncounters = [
            { type: 'Zombie', chance: 35 }, { type: 'Bear', chance: 10 }, { type: 'Wolf', chance: 15 },
            { type: 'Survivor', chance: 20 }, { type: 'Trader', chance: 5 }, { type: 'Raider', chance: 15 }
        ];
        let totalChance = possibleEncounters.reduce((sum, e) => sum + e.chance, 0);
        let randomValue = Math.random() * totalChance;
        let selectedType;
        for (const encounter of possibleEncounters) {
            randomValue -= encounter.chance;
            if (randomValue <= 0) {
                selectedType = encounter.type;
                break;
            }
        }

        let newEntity;
        if (selectedType === 'Zombie') {
            const health = 60;
            newEntity = { type: 'Zombie', name: 'æ½œã‚“ã§ã„ãŸã‚¾ãƒ³ãƒ“', icon: 'images/zombie.png', portraitIcon: 'images/zombie_portrait.png', x: player.x, y: player.y, health: health, maxHealth: health, attack: 10, defense: 2, visionRange: 3, isZombie: true, stunnedTurns: 0, aiState: 'wandering', target: null, investigationTarget: null }; // â† portraitIcon ã‚’è¿½åŠ 
        } else if (selectedType === 'Bear' || selectedType === 'Wolf') {
            const template = wildlifeTemplates.find(t => t.type === selectedType);
            newEntity = { ...JSON.parse(JSON.stringify(template)), x: player.x, y: player.y, stunnedTurns: 0, aiState: 'attacking', target: player };
        } else {
            newEntity = generateNPC();
            newEntity.type = selectedType;
            const template = npcTemplates.find(t => t.type === selectedType);
            newEntity.name = template.name;
            newEntity.icon = template.icon;
            newEntity.x = player.x;
            newEntity.y = player.y;
        }
        
        entities.push(newEntity);
        drawMap();
        
        if (newEntity.isZombie || newEntity.type === 'Bear' || newEntity.type === 'Wolf' || newEntity.type === 'Raider') {
            setTimeout(() => startCombat(newEntity, false), 500);
        } else {
            currentNPC = newEntity;
            setTimeout(() => startNPCEncounter(), 500);
        }

    } else {
        drawMap();
        // â–¼â–¼â–¼ ã“ã®è¡Œã‚’ä¿®æ­£ â–¼â–¼â–¼
        log(getString("log_enter_cabin_no_encounter"));
    }
}
function exitCabin() {
    playSoundFile('sounds/door_close.wav');

    player.isInside = false;
    isInteractionActive = false; // â† ã“ã®è¡Œã‚’è¿½åŠ ã—ã¦ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ­ãƒƒã‚¯ã‚’è§£é™¤
    log(getString("log_exit_cabin"));
    refreshGameState(); 
}
/**
 * ã€Œè‡ªåˆ†ã®èº«ä½“ã€ãƒ‘ãƒãƒ«ã«æ€ªæˆ‘ã®ã‚¢ã‚¤ã‚³ãƒ³ã‚’è¡¨ç¤ºã™ã‚‹
 */
function updateInjuryDisplay() {
    const bodyPanel = document.getElementById('bodyPanel');
    const panelContent = bodyPanel.querySelector('.panel-content');
    if (!panelContent) return;

    const injuryCoordinates = {
        head: { x: 216, y: 59 },
        torso: { x: 163, y: 194 },
        rightArm: { x: 284, y: 231 },
        leftArm: { x: 127, y: 192 },
        rightLeg: { x: 244, y: 353 },
        leftLeg: { x: 166, y: 439 }
    };

    const existingInjuries = panelContent.querySelectorAll('.injury-icon');
    existingInjuries.forEach(icon => icon.remove());

    player.injuries.forEach(injury => {
        // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒå¤‰æ›´ç®‡æ‰€ã§ã™ â–¼â–¼â–¼
        let injuryType = injury.type; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æ€ªæˆ‘ã‚¿ã‚¤ãƒ—ã‚’è¨­å®š

        if (injury.type === 'fracture' && injury.splinted) {
            injuryType = 'splinted'; // éª¨æŠ˜ãŒå›ºå®šã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ 'splinted' ã‚’ä½¿ç”¨
        } else if (injury.type === 'bleeding' && injury.treating_duration > 0) {
            injuryType = 'bandaged'; // å‡ºè¡€ãŒæ²»ç™‚ä¸­ã®å ´åˆã¯ 'bandaged' ã‚’ä½¿ç”¨
        }
        // â–²â–²â–² å¤‰æ›´ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²

        const part = injury.part;
        
        if (!part || !injuryCoordinates[part]) return;
       
        const coords = injuryCoordinates[part];
        const imageUrl = `images/injury_${injuryType}.png`;

        const img = document.createElement('img');
        img.src = imageUrl;
        img.className = 'injury-icon';
        img.style.position = 'absolute';
        img.style.left = `${coords.x - 20}px`; 
        img.style.top = `${coords.y - 20}px`;
        img.style.width = '40px';
        img.style.height = '40px';
        img.style.zIndex = '1';
        
        img.style.cursor = 'help';
        
        img.addEventListener('mouseenter', (e) => showInjuryTooltip(e, injury));
        img.addEventListener('mouseleave', hideStatusPreview);
        img.addEventListener('mousemove', (e) => updatePreviewPosition(e));

        panelContent.appendChild(img);
    });
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function updateBodyPanel() {
    console.log("ãƒ‡ãƒãƒƒã‚°: updateBodyPanel() ãŒå‘¼ã°ã‚Œã¾ã—ãŸã€‚ç¾åœ¨ã®è£…å‚™:", JSON.parse(JSON.stringify(player.equipment)));
    
    // å†…éƒ¨ã®å¯¾å¿œè¡¨ã«æ–°ã—ã„ã‚¹ãƒ­ãƒƒãƒˆã‚’è¿½åŠ 
    const slotMapping = {
        'bodySlotHead': 'head', 
        'bodySlotEyes': 'eyes', 
        'bodySlotBodyOuter': 'body_outer',
        'bodySlotLegs': 'legs', 
        'bodySlotBack': 'back', 
        'bodySlotPochette': 'pochette', 
        'bodySlotWrist': 'wrist',
        'bodySlotMainHand': 'main_hand', 
        'bodySlotOffHand': 'off_hand',
        'bodySlotMouth': 'mouth', 
        'bodySlotNeck': 'neck', 
        'bodySlotBodyInner1': 'body_inner_1', 
        'bodySlotBodyInner2': 'body_inner_2', 
        'bodySlotBodyInner3': 'body_inner_3',
        'bodySlotLeftFoot': 'left_foot',
        'bodySlotRightFoot': 'right_foot',
        'bodySlotLeftPalm': 'left_palm',
        'bodySlotRightPalm': 'right_palm'
    };

    for (const elementId in slotMapping) {
        const slotElement = document.getElementById(elementId);
        if (slotElement) {
            slotElement.innerHTML = '';
            slotElement.onclick = null;
        }
    }

    player.equipment.forEach(item => {
        console.log(`ãƒ‡ãƒãƒƒã‚°: è£…å‚™å“ '${item.name}' (ã‚¹ãƒ­ãƒƒãƒˆ: ${item.slot}) ã‚’ãƒ‘ãƒãƒ«ã«åæ˜ ã—ã¾ã™ã€‚`);
        
        const iconHtml = getIconHTML(getItemGraphic(item), 32);
        const itemIndex = player.equipment.findIndex(e => e === item);
        const clickHandler = () => {
            if (itemIndex > -1) showItemDetail(item, itemIndex, 'equipment');
        };

        if (item.handedness === 'two') {
            const mainHandSlot = document.getElementById('bodySlotMainHand');
            const offHandSlot = document.getElementById('bodySlotOffHand');
            if (mainHandSlot) { mainHandSlot.innerHTML = iconHtml; mainHandSlot.onclick = clickHandler; }
            if (offHandSlot) { offHandSlot.innerHTML = iconHtml; offHandSlot.onclick = clickHandler; }
        } else {
            let targetElementId = null;
            for (const elementId in slotMapping) {
                if (slotMapping[elementId] === item.slot) {
                    targetElementId = elementId;
                    break;
                }
            }
            
            if(targetElementId){
                const slotElement = document.getElementById(targetElementId);
                if (slotElement) {
                    console.log(`ãƒ‡ãƒãƒƒã‚°: å¯¾å¿œã™ã‚‹HTMLè¦ç´  #${targetElementId} ã‚’ç™ºè¦‹ã—ã€æ›´æ–°ã—ã¾ã™ã€‚`);
                    slotElement.innerHTML = iconHtml;
                    slotElement.onclick = clickHandler;
                } else {
                    console.error(`ãƒ‡ãƒãƒƒã‚°: ã‚¨ãƒ©ãƒ¼ï¼HTMLè¦ç´  #${targetElementId} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚`);
                }
            } else {
                console.warn(`ãƒ‡ãƒãƒƒã‚°: è­¦å‘Šï¼ã‚¹ãƒ­ãƒƒãƒˆ '${item.slot}' ã«å¯¾å¿œã™ã‚‹HTMLè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚`);
            }
        }
    });
    console.log("ãƒ‡ãƒãƒƒã‚°: updateBodyPanel() ã®å‡¦ç†ãŒå®Œäº†ã—ã¾ã—ãŸã€‚");
}

function updateCharacterBody() {
  const pre = document.getElementById("charBody");
  if (!pre) return;

  if (player.health <= 0) {
      pre.innerHTML = getIconHTML(HUMAN_CORPSE_IMG, 96);
  } else {
      const raceKey = character.race.replace('race_', '');
      const genderKey = character.gender.replace('gender_', '');
      const portraitIconPath = `images/portrait_${raceKey}_${genderKey}.png`;

      // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä»Šå›ã®ä¿®æ­£ç®‡æ‰€ã§ã™ â–¼â–¼â–¼
      // getIconHTMLé–¢æ•°ã‚’ä½¿ã‚ãšã€ã‚µã‚¤ã‚ºæŒ‡å®šã®ãªã„imgã‚¿ã‚°ã‚’ç›´æ¥ç”Ÿæˆã—ã¾ã™
      pre.innerHTML = `<img src="${portraitIconPath}" alt="Character Portrait">`;
      // â–²â–²â–² ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²
  }

  const imgElement = pre.querySelector('img');
  if (!imgElement) return;

  if (player.health <= 0) {
      imgElement.style.borderColor = 'black';
      return;
  }
  
  const borderColor = getHealthColor(player.health, maxStats.health);
  imgElement.style.borderColor = borderColor;
}
// index.htmlå†…

function updateCharacterInfo() {
  document.getElementById("charName").textContent = getString(character.fullNameKey);
  document.getElementById("charAge").textContent = character.age;
  document.getElementById("charGender").textContent = getString(character.gender);
  document.getElementById("charJob").textContent = getString(character.job);
  document.getElementById("charRace").textContent = getString(character.race);
  
  const traitsContainer = document.getElementById("charTraits");
  traitsContainer.innerHTML = "";
  character.traits.forEach(traitId => {
      const trait = characterTraits.find(t => t.id === traitId);
      if (trait) {
          const pill = document.createElement("span");
          pill.className = "trait-pill";
          pill.textContent = getString(`trait_${trait.id}_name`) || trait.id;
          pill.addEventListener("mouseenter", (e) => showTraitDetail(e, trait));
          pill.addEventListener("mouseleave", hideTraitDetail);
          traitsContainer.appendChild(pill);
      }
  });

  const memoryContainer = document.getElementById("memoryContainer");
  memoryContainer.innerHTML = "";
  if (character.salvationCityHint) {
      const memoryDiv = document.createElement("div");
      memoryDiv.style.cssText = "color: #f1c40f; font-size: 12px;";
      memoryDiv.innerHTML = `<strong data-translate-key="char_info_memory">è¨˜æ†¶</strong>:<br>${character.salvationCityHint}`;
      memoryContainer.appendChild(memoryDiv);
  }
}
// index.htmlå†…
// index.htmlå†…

function showTraitDetail(event, trait) {
  const preview = document.getElementById("statusPreview");
  preview.style.display = "block";
  preview.style.pointerEvents = "none";
  
  const traitName = getString(`trait_${trait.id}_name`) || trait.id;
  const traitDesc = getString(`trait_${trait.id}_desc`) || "No description available.";
  
  let contentHtml = `<strong>${traitName}</strong><br><div style="margin-top: 5px; margin-bottom: 5px;">${traitDesc}</div>`;
  
  if (trait.effects && Object.keys(trait.effects).length > 0) {
      contentHtml += `<div style="margin-top: 5px;"><strong>${getString("tooltip_label_effect")}:</strong></div>`;
      contentHtml += Object.keys(trait.effects).map(stat => {
        const change = trait.effects[stat];
        const sign = change > 0 ? "+" : "";
        const className = change > 0 ? "positive" : "negative";
        return `<div class="preview-stat"><span class="preview-stat-name">${getStatName(stat)}:</span><span class="preview-change ${className}">${sign}${change}</span></div>`;
    }).join('');
  }
  preview.innerHTML = contentHtml;
  updatePreviewPosition(event);
}

function hideTraitDetail() {
  document.getElementById("statusPreview").style.display = "none";
}

function drawMinimap() {
  const canvas = document.getElementById('minimapCanvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  
  canvas.width = canvas.offsetWidth;
  canvas.height = canvas.offsetHeight;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  const tileSize = minimapZoomLevel;

  const halfTilesX = canvas.width / (2 * tileSize);
  const halfTilesY = canvas.height / (2 * tileSize);
  
  const startMapX = Math.floor(player.x - halfTilesX);
  const endMapX = Math.ceil(player.x + halfTilesX);
  const startMapY = Math.floor(player.y - halfTilesY);
  const endMapY = Math.ceil(player.y + halfTilesY);

  for (let mapY = startMapY; mapY < endMapY; mapY++) {
    for (let mapX = startMapX; mapX < endMapX; mapX++) {
      if (mapX < 0 || mapY < 0 || mapX >= mapSize || mapY >= mapSize) {
        continue;
      }
      
      const tile = map[mapY][mapX];
      if (!tile.explored) {
        continue; 
      }
      
      let color = '#333'; 
      switch (tile.biome) {
        case 'Plains': color = '#5a6349'; break;
        case 'Forest': color = '#2d572c'; break;
        case 'Town':   color = '#666666'; break;
        case 'Road':   color = '#444444'; break;
      }
      
      // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â–¼â–¼â–¼
      // è¨˜æ†¶ã¨ã—ã¦è¡¨ç¤ºã™ã¹ãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¿ã‚¤ãƒ—ãƒªã‚¹ãƒˆ
      const memorableObjectTypes = ['shelter', 'sleeping_bag', 'campfire', 'unlit_campfire', 'wooden_box', 'barricade', 'workbench'];
      // ã“ã®å ´æ‰€ã«è¨˜æ†¶ã™ã¹ãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚ã‚‹ã‹æ¤œç´¢
      const memorableObject = placedObjects.find(obj => obj.x === mapX && obj.y === mapY && memorableObjectTypes.includes(obj.type));

      if (memorableObject) {
          // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚ã‚Œã°ã€ç‰¹åˆ¥ãªè‰²ï¼ˆç´«ï¼‰ã§ä¸Šæ›¸ã
          color = '#9b59b6';
      }
      // â–²â–²â–² ä¿®æ­£ã“ã“ã¾ã§ â–²â–²â–²

      const drawX = (canvas.width / 2) + (mapX - player.x - 0.5) * tileSize;
      const drawY = (canvas.height / 2) + (mapY - player.y - 0.5) * tileSize;

      ctx.fillStyle = color;
      ctx.fillRect(drawX, drawY, tileSize, tileSize);
    }
  }

  if (salvationCityDiscovered) {
      const cityDrawX = (canvas.width / 2) + (salvationCityCoords.x - player.x - 0.5) * tileSize;
      const cityDrawY = (canvas.height / 2) + (salvationCityCoords.y - player.y - 0.5) * tileSize;
      ctx.fillStyle = '#ffd700'; 
      ctx.fillRect(cityDrawX, cityDrawY, tileSize, tileSize);
  }

  ctx.fillStyle = '#ff0000'; 
  ctx.fillRect((canvas.width / 2) - (tileSize / 2), (canvas.height / 2) - (tileSize / 2), tileSize, tileSize);
}

function showDamage(dmg) {
  const dp = document.getElementById("damagePop");
  const popContainer = currentEnemy ? document.getElementById('combatPlayer') : document.body;
  if (currentEnemy) popContainer.style.position = 'relative';
  popContainer.appendChild(dp);
  dp.textContent = `-${dmg}`;
  dp.style.opacity = "1";
  dp.style.transform = "translate(-50%, -50%) scale(1.5)";
  setTimeout(() => {
      dp.style.opacity = "0";
      dp.style.transform = "translate(-50%, -50%) scale(3)";
  }, 100);
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’æ–°ã—ãè¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
/**
 * æŒ‡å®šã•ã‚ŒãŸIDã®è¦ç´ ã«ã€éœ‡ãˆã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é©ç”¨ã™ã‚‹
 * @param {string} elementId - ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é©ç”¨ã™ã‚‹è¦ç´ ã®ID
 */
function triggerShakeAnimation(elementId) {
    const element = document.getElementById(elementId);
    if (!element) return;

    // æ—¢ã«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ã§ã‚ã‚Œã°ä¸€åº¦ã‚¯ãƒ©ã‚¹ã‚’å‰Šé™¤ã—ã¦ãƒªã‚»ãƒƒãƒˆ
    element.classList.remove('shake-animation');
    
    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¯ãƒ©ã‚¹ã‚’å†åº¦è¿½åŠ ã™ã‚‹ãŸã‚ã«å°‘ã—å¾…ã¤
    void element.offsetWidth; // å¼·åˆ¶çš„ãªãƒªãƒ•ãƒ­ãƒ¼ã‚’ãƒˆãƒªã‚¬ãƒ¼

    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ 
    element.classList.add('shake-animation');

    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒçµ‚ã‚ã£ãŸã‚‰ã‚¯ãƒ©ã‚¹ã‚’å‰Šé™¤ï¼ˆå†åº¦é©ç”¨ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ï¼‰
    setTimeout(() => {
        element.classList.remove('shake-animation');
    }, 400); // CSSã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚é–“ã¨åˆã‚ã›ã‚‹ (0.4s = 400ms)
}
// â–¼â–¼â–¼ æ—¢å­˜ã®`showItemDetail`é–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function showItemDetail(item, index, source) {
    const panel = document.getElementById("itemDetailPanel"),
        header = document.getElementById("itemDetailHeader"),
        graphic = document.getElementById("itemDetailGraphic"),
        content = document.getElementById("itemDetailContent"),
        actions = document.getElementById("itemDetailActions");
    currentItemDetail = { item, index, source };
    header.innerHTML = `${getItemDisplayName(item)}`;
    graphic.innerHTML = getIconHTML(getItemGraphic(item), 96);

    // --- ã‚¢ã‚¤ãƒ†ãƒ è©³ç´°æƒ…å ±ã®ç”Ÿæˆ ---
    let description = getString(item.desc);
    if (description === item.desc && item.desc.startsWith('item_') && item.desc.endsWith('_desc')) {
        description = getString("item_no_description");
    }
    let details = `<div class="item-description">${description}</div>`;
    const itemTypeMap = { "consumable": "item_type_consumable", "container": "item_type_container", "equipment": "item_type_equipment", "clothing": "item_type_clothing", "tool": "item_type_tool", "material": "item_type_material", "water_source": "item_type_water_source", "ammo": "item_type_ammo", "placed_object": "item_type_placed_object" };
    const typeKey = itemTypeMap[item.type] || item.type;
    details += `<strong>${getString("detail_label_type")}</strong> ${getString(typeKey)}<br>`;
    if (item.type === "consumable" && item.nutrients) {
        let nutrientHtml = '';
        const nutrientMap = { hunger: 'status_hunger', carbs: 'status_carbs', protein: 'status_protein', fat: 'status_fat', vitamins: 'status_vitamins', water: 'status_thirst' };
        const displayNutrients = { ...item.nutrients, ...(item.effects && { hunger: item.effects.hunger }) };
        for (const nutrient in nutrientMap) {
            if (displayNutrients[nutrient] > 0) nutrientHtml += `<strong>${getString(nutrientMap[nutrient])}</strong> <span class="item-effect-positive">+${displayNutrients[nutrient]}</span><br>`;
        }
        if (nutrientHtml) details += `<div style="margin-top: 5px; border-top: 1px solid #555; padding-top: 5px;">${nutrientHtml}</div>`;
    } else if (["equipment", "clothing", "tool"].includes(item.type)) {
        if(item.handedness) details += `<strong>${getString("detail_label_handedness")}</strong> ${getString(item.handedness === 'one' ? 'handedness_one' : 'handedness_two')}<br>`;
        if (item.slot) details += `<strong>${getString("detail_label_slot")}</strong> ${getSlotName(item.slot)}<br>`;
        if (item.durability !== undefined) details += `<strong>${getString("detail_label_durability")}</strong> ${item.durability.toFixed(0)}%<br>`;
        if (item.uses !== undefined) details += `<strong>${getString("detail_label_uses")}</strong> ${item.uses}<br>`;
        const durabilityFactor = (item.durability === undefined ? 100 : item.durability) / 100;
        if (item.attack) details += `<strong>${getString("detail_label_attack_melee")}</strong> <span class="item-effect-positive">+${Math.floor(item.attack * durabilityFactor)}</span> (${getString("detail_label_base")}: ${item.attack})<br>`;
        if (item.reach) details += `<strong>${getString("detail_label_reach")}</strong> ${item.reach}<br>`;
        if (item.fireDamage) details += `<strong>${getString("detail_label_attack_ranged")}</strong> <span class="item-effect-positive">${item.fireDamage}</span><br>`;
        if (item.accuracy !== undefined) details += `<strong>${getString("detail_label_accuracy")}</strong> ${item.accuracy}%<br>`;
        if (item.defense) details += `<strong>${getString("detail_label_defense")}</strong> <span class="item-effect-positive">+${Math.floor(item.defense * durabilityFactor)}</span> (${getString("detail_label_base")}: ${item.defense})<br>`;
        if (item.insulation) details += `<strong>${getString("detail_label_insulation")}</strong> <span class="item-effect-positive">+${(item.insulation * durabilityFactor).toFixed(1)}</span> (${getString("detail_label_base")}: ${item.insulation.toFixed(1)})<br>`;
        if (item.effects && item.effects.maxWeight) details += `<strong>${getString("detail_label_max_weight")}</strong> <span class="item-effect-positive">+${item.effects.maxWeight}</span><br>`;
        if (item.effects && item.effects.maxVolume) details += `<strong>${getString("detail_label_max_volume")}</strong> <span class="item-effect-positive">+${item.effects.maxVolume}</span><br>`;
        if (item.isTorch) details += `<strong>${getString("detail_label_duration")}</strong> ${item.duration} Turns<br>`;
    }
    details += `<strong>${getString("detail_label_weight")}</strong> ${item.weight || 0}<br><strong>${getString("detail_label_volume")}</strong> ${item.volume || 0}<br><strong>${getString("detail_label_value")}</strong> ${item.value || 0}<br>`;
    content.innerHTML = details;

    actions.querySelectorAll('button').forEach(btn => btn.style.display = 'none');
    document.getElementById("closeItemDetailBtn").style.display = 'inline-block';
    // â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ä¸¸ã”ã¨è¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
    const isTradeScreen = ['playerInv', 'playerEquip', 'npcInv', 'npcEquip', 'playerOffer', 'npcOffer'].includes(source);

    if (isTradeScreen) {
        // ã‚«ãƒ¼ãƒˆã«å…¥ã‚Œã‚‹å‰ã®ã‚¢ã‚¤ãƒ†ãƒ ã®å ´åˆ
        if (['playerInv', 'playerEquip', 'npcInv', 'npcEquip'].includes(source)) {
            const addToCartBtn = document.getElementById('addToCartBtn');
            addToCartBtn.style.display = 'inline-block';
            addToCartBtn.onclick = () => {
                moveTradeItem(source, index); // æ—¢å­˜ã®ç§»å‹•é–¢æ•°ã‚’å‘¼ã³å‡ºã™
                hideItemDetail();             // ãƒ‘ãƒãƒ«ã‚’é–‰ã˜ã‚‹
            };
        } 
        // æ—¢ã«ã‚«ãƒ¼ãƒˆã«å…¥ã£ã¦ã„ã‚‹ã‚¢ã‚¤ãƒ†ãƒ ã®å ´åˆ
        else if (['playerOffer', 'npcOffer'].includes(source)) {
            const removeFromCartBtn = document.getElementById('removeFromCartBtn');
            removeFromCartBtn.style.display = 'inline-block';
            removeFromCartBtn.onclick = () => {
                moveTradeItem(source, index); // æ—¢å­˜ã®ç§»å‹•é–¢æ•°ã‚’å‘¼ã³å‡ºã™
                hideItemDetail();             // ãƒ‘ãƒãƒ«ã‚’é–‰ã˜ã‚‹
            };
        }
    } 
    // â–²â–²â–² è¿½åŠ ã¯ã“ã“ã¾ã§ â–²â–²â–²
    // â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ–°ã—ãè¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
    const isBleeding = player.injuries.some(i => i.type === 'bleeding' && !i.treating_duration);
    const isBandage = (item.name === 'åŒ…å¸¯' || item.name === 'simple_bandage');

    if (isBandage && isBleeding) {
        const treatBtn = document.getElementById("treatBleedingBtn");
        treatBtn.style.display = 'inline-block';
        // æˆ¦é—˜ä¸­ã‹ã©ã†ã‹ã«å¿œã˜ã¦ã€æ­£ã—ã„ã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«è¨­å®š
        treatBtn.onclick = currentEnemy 
            ? () => handleCombatItemUse(item, index, source) 
            : () => useItem(index, source);
    }
    // â–²â–²â–² è¿½åŠ ã¯ã“ã“ã¾ã§ â–²â–²â–²

    const isOnCampfire = placedObjects.some(c => c.type === 'campfire' && c.x === player.x && c.y === player.y);
    const unlitCampfireNearby = placedObjects.some(c => c.type === 'unlit_campfire' && c.x === player.x && c.y === player.y);
    const waterFilter = placedObjects.find(o => o.x === player.x && o.y === player.y && o.type === 'water_filter');
    const waterSourceOnGround = (droppedItems[`${player.x},${player.y}`] || []).find(i => i.type === 'water_source');
    const hasLighter = player.inventory.some(i => i.name === 'ãƒ©ã‚¤ã‚¿ãƒ¼');
    const rackOnTile = placedObjects.find(o => o.x === player.x && o.y === player.y && o.type === 'drying_rack');

    if (item.name === 'ç”Ÿè‚‰' && rackOnTile && rackOnTile.content.length < 5) {
        document.getElementById("dryMeatBtn").style.display = 'inline-block';
        document.getElementById("dryMeatBtn").onclick = () => addSingleMeatToRack(item, index, source);
    }
    
    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â–¼â–¼â–¼
    if (source === 'inventory' || source === 'dropped') {
        if (source === 'inventory') {
            document.getElementById("dropItemBtn").style.display = 'inline-block';
            document.getElementById("dropItemBtn").onclick = () => { dropItem(index); hideItemDetail(); };
        } else { 
            document.getElementById("pickupItemBtn").style.display = 'inline-block';
            document.getElementById("pickupItemBtn").onclick = () => pickUpItemFromGround(index);
        }

        if (dismantleRecipes[item.name]) {
            document.getElementById("dismantleBtn").style.display = 'inline-block';
            document.getElementById("dismantleBtn").onclick = () => dismantleItem(index, source);
        }
        
        const isAttachableKnife = ['ãƒŠã‚¤ãƒ•', 'ã‚³ãƒ³ãƒãƒƒãƒˆãƒŠã‚¤ãƒ•', 'æ‰‹ä½œã‚ŠçŸ³ãƒŠã‚¤ãƒ•'].includes(item.name);
        if (isAttachableKnife) {
            let rifleToAttach = player.equipment.find(e => e.name === 'ãƒ©ã‚¤ãƒ•ãƒ«' && !e.bayonetAttached);
            if (!rifleToAttach) rifleToAttach = player.inventory.find(i => i.name === 'ãƒ©ã‚¤ãƒ•ãƒ«' && !i.bayonetAttached);
            if (!rifleToAttach) {
                const groundItems = droppedItems[`${player.x},${player.y}`] || [];
                rifleToAttach = groundItems.find(i => i.name === 'ãƒ©ã‚¤ãƒ•ãƒ«' && !i.bayonetAttached);
            }
            if (rifleToAttach) {
                document.getElementById("attachBayonetBtn").style.display = 'inline-block';
                document.getElementById("attachBayonetBtn").onclick = () => attachKnifeToRifle(index, source, rifleToAttach);
            }
        }
        
        if (item.name === 'ãƒ©ã‚¤ãƒ•ãƒ«' && item.bayonetAttached) {
            document.getElementById("detachBayonetBtn").style.display = 'inline-block';
            document.getElementById("detachBayonetBtn").onclick = () => detachBayonet(index, source);
        }

        if (item.ammoType) {
            const compatibleWeapon = player.equipment.find(weapon => weapon.ammoType === item.ammoType && weapon.loadedAmmo < weapon.ammoCapacity);
            if (compatibleWeapon) {
                document.getElementById("reloadGunBtn").style.display = 'inline-block';
                document.getElementById("reloadGunBtn").onclick = () => reloadWeaponFromAmmo(index, source);
            }
        }

        if (item.type === 'tool') {
            if (item.useAction && item.useAction.startsWith('place')) {
                document.getElementById("placeObjectBtn").style.display = 'inline-block';
                document.getElementById("placeObjectBtn").onclick = () => window[item.useAction](item, index, source);
            }
            if (item.useAction === 'startFire' && unlitCampfireNearby) {
                document.getElementById("startFireBtn").style.display = 'inline-block';
                document.getElementById("startFireBtn").onclick = () => startFire(item, index, source);
            }
        }

        if (item.type === 'container') {
            if (item.content) { 
                document.getElementById("drinkItemBtn").style.display = 'inline-block';
                document.getElementById("drinkItemBtn").onclick = () => drinkFromContainer(index, source);
                document.getElementById("emptyItemBtn").style.display = 'inline-block';
                document.getElementById("emptyItemBtn").onclick = () => emptyContainer(index, source);
                if (item.canBoil && item.content.type === 'dirty' && isOnCampfire) {
                    document.getElementById("boilItemBtn").style.display = 'inline-block';
                    document.getElementById("boilItemBtn").onclick = () => boilWater(index, source);
                }
                if (item.content.type === 'dirty' && waterFilter && waterFilter.waterType === 'none') {
                    document.getElementById("pourToFilterBtn").style.display = 'inline-block';
                    document.getElementById("pourToFilterBtn").onclick = () => pourDirtyWaterIntoFilter(item, index, source);
                }
            } else { 
                if (waterSourceOnGround) {
                    const fillBtn = document.getElementById("fillItemBtn");
                    fillBtn.style.display = 'inline-block';
                    fillBtn.textContent = getString("btn_fill");
                    fillBtn.onclick = () => fillContainerFromSource(index, source);
                }
                if (waterFilter && waterFilter.waterType === 'clean') {
                    const fillBtn = document.getElementById("fillItemBtn");
                    fillBtn.style.display = 'inline-block';
                    fillBtn.textContent = getString("btn_fill_from_filter");
                    fillBtn.onclick = () => fillContainerFromFilter(item, index, source);
                }
            }
        }

        if (item.type === 'water_source') {
            document.getElementById("drinkItemBtn").style.display = 'inline-block';
            document.getElementById("drinkItemBtn").onclick = drinkFromSource;
        }

        if (item.type === "consumable") {
            const itemUseClickHandler = currentEnemy ? () => handleCombatItemUse(item, index, source) : () => useItem(index, source);
            if (item.effects && item.effects.hunger > 0) {
                document.getElementById("eatItemBtn").style.display = 'inline-block';
                document.getElementById("eatItemBtn").onclick = itemUseClickHandler;
            } else if (item.useAction) {
                document.getElementById("useItemBtn").style.display = 'inline-block';
                document.getElementById("useItemBtn").onclick = itemUseClickHandler;
            }
        }

        if (cookingMap[item.name] && isOnCampfire) {
            document.getElementById("cookItemBtn").style.display = 'inline-block';
            document.getElementById("cookItemBtn").onclick = () => cookFood(index, source);
        }

        if (item.type === "equipment" || item.type === "clothing") {
            document.getElementById("equipItemBtn").style.display = 'inline-block';
            document.getElementById("equipItemBtn").onclick = () => equipItem(index, source);
        }

        if (item.name === 'æ' || item.name === 'å¤§ããªè‘‰') {
            if (isOnCampfire) {
                document.getElementById("addFuelBtn").style.display = 'inline-block';
                document.getElementById("addFuelBtn").onclick = () => addFuelToCampfire(index, source);
            }
            if (item.name === 'æ' && hasLighter) {
                document.getElementById("craftTorchBtn").style.display = 'inline-block';
                document.getElementById("craftTorchBtn").onclick = () => craftTorchWithLighter(index, source);
            }
        }
    } else if (source === 'equipment') {
        document.getElementById("unequipItemBtn").style.display = 'inline-block';
        document.getElementById("unequipItemBtn").onclick = () => { unequipItem(index); hideItemDetail(); };
        if (item.useAction === 'startFire' && unlitCampfireNearby) {
            document.getElementById("startFireBtn").style.display = 'inline-block';
            document.getElementById("startFireBtn").onclick = () => startFire(item, index, 'equipment');
        }
        if (item.ammoType && item.loadedAmmo > 0) {
            document.getElementById("unloadGunBtn").style.display = 'inline-block';
            document.getElementById("unloadGunBtn").onclick = () => unloadWeapon(index);
        }
        if (item.name === 'ãƒ©ã‚¤ãƒ•ãƒ«' && item.bayonetAttached) {
            document.getElementById("detachBayonetBtn").style.display = 'inline-block';
            document.getElementById("detachBayonetBtn").onclick = () => detachBayonet(index, source);
        }
    }
    // â–²â–²â–² ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²

    panel.style.display = 'block';
    bringToFront(panel);
}
// â–¼â–¼â–¼ æ—¢å­˜ã®`attachKnifeToRifle`é–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function attachKnifeToRifle(knifeIndex, knifeSource, rifle) {
    snapshotStats();
    
    const sourceArray = knifeSource === 'inventory' ? player.inventory : droppedItems[`${player.x},${player.y}`];
    const knife = sourceArray.splice(knifeIndex, 1)[0];

    if (!knife) return;

    if (knifeSource === 'inventory') {
        player.weight -= knife.weight || 0;
        player.volume -= knife.volume || 0;
    }

    // â˜…â˜…â˜… ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â˜…â˜…â˜…
    rifle.bayonetAttached = true; // ã“ã®è¡Œã¯å¤‰æ›´ãªã—
    rifle.attachedBayonetName = knife.name; // â˜…è£…ç€ã—ãŸãƒŠã‚¤ãƒ•ã®åå‰ã‚’ä¿å­˜
    // â˜…â˜…â˜… ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â˜…â˜…â˜…
    
    log(getString("log_attach_bayonet_success", { 
        rifleName: getItemDisplayName(rifle), 
        knifeName: getItemDisplayName(knife) 
    }));
    
    hideItemDetail();
    updateItemPanels();
    updateEquippedStats();
    updateStatus();
    updateCurrentLocationPanel(false);
    processSpeechQueue();
}
// â–¼â–¼â–¼ æ—¢å­˜ã®`detachBayonet`é–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function detachBayonet(rifleIndex, source) {
    let rifle;
    if (source === 'equipment') {
        rifle = player.equipment[rifleIndex];
    } else if (source === 'inventory') {
        rifle = player.inventory[rifleIndex];
    } else if (source === 'dropped') {
        const locationKey = `${player.x},${player.y}`;
        rifle = (droppedItems[locationKey] || [])[rifleIndex];
    }

    if (!rifle || !rifle.bayonetAttached) return;

    snapshotStats();

    // â˜…â˜…â˜… ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â˜…â˜…â˜…
    const detachedKnifeName = rifle.attachedBayonetName; // â˜…ä¿å­˜ã•ã‚ŒãŸãƒŠã‚¤ãƒ•ã®åå‰ã‚’å–å¾—
    
    rifle.bayonetAttached = null; // â˜…çŠ¶æ…‹ã‚’nullã«æˆ»ã™
    rifle.attachedBayonetName = null; // â˜…ä¿å­˜ã—ãŸåå‰ã‚’ã‚¯ãƒªã‚¢

    const knifeTemplate = items.find(i => i.name === detachedKnifeName); // â˜…å–å¾—ã—ãŸåå‰ã§ãƒŠã‚¤ãƒ•ã‚’æ¢ã™
    // â˜…â˜…â˜… ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â˜…â˜…â˜…

    if (knifeTemplate) {
        const returnedKnife = createItemInstance(knifeTemplate);
        
        if (player.weight + returnedKnife.weight > player.maxWeight || player.volume + (returnedKnife.volume || 0) > player.maxVolume) {
            log(getString("craft_success_grounded", { itemName: getItemDisplayName(returnedKnife) }));
            const locationKey = `${player.x},${player.y}`;
            if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
            droppedItems[locationKey].push(returnedKnife);
        } else {
            player.inventory.push(returnedKnife);
            player.weight += returnedKnife.weight || 0;
            player.volume += returnedKnife.volume || 0;
        }

        log(getString("log_detach_bayonet_success", { 
            rifleName: getItemDisplayName(rifle), 
            knifeName: getItemDisplayName(returnedKnife) 
        }));
    }

    hideItemDetail();
    updateItemPanels();
    updateEquippedStats();
    updateStatus();
    updateCurrentLocationPanel(false);
    processSpeechQueue();
}

function getStatName(stat) {
    switch (stat) {
        case 'health': return getString('status_health');
        case 'hunger': return getString('status_hunger');
        case 'thirst': return getString('status_thirst');
        case 'morale': return getString('status_morale');
        case 'sleep': return getString('status_sleep');
        case 'bodyTemp': return getString('status_body_temp');
        case 'attack': return getString('status_attack');
        case 'defense': return getString('status_defense');
        case 'insulation': return getString('status_insulation');
        case 'weight': return getString('status_weight');
        case 'volume': return getString('status_volume');
        case 'maxWeight': return getString('status_max_weight');
        // ä¿®æ­£ç‚¹ï¼š'maxVolume': ã®å¾Œã«ã‚³ãƒ­ãƒ³':'ã‚’è¿½åŠ 
        case 'maxVolume': return getString('status_max_volume');
        case 'vision': return getString('status_vision');
        default: return stat;
    }
}
function getSicknessName(type) {
    // ä¿®æ­£ç‚¹ï¼šãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸæ—¥æœ¬èªã‚’ã€ç¿»è¨³ã‚­ãƒ¼ã‚’å‘¼ã³å‡ºã™å½¢ã«ä¿®æ­£
    return getString(`sickness_${type}`);
}
// â–¼â–¼â–¼ æ—¢å­˜ã®getSlotNameé–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function getSlotName(slot) {
    switch (slot) {
        case 'main_hand': return getString('slot_main_hand');
        case 'off_hand': return getString('slot_off_hand');
        case 'weapon': return getString('slot_weapon');
        case 'head': return getString('slot_head');
        case 'body_inner_1': return getString('slot_body_inner_1');
        case 'body_inner_2': return getString('slot_body_inner_2');
        case 'body_inner_3': return getString('slot_body_inner_3');
        case 'body_outer': return getString('slot_body_outer');
        case 'legs': return getString('slot_legs');
        case 'hands': return getString('slot_hands');
        case 'feet': return getString('slot_left_foot'); // å¤ã„feetã‚’left_footã«ãƒãƒƒãƒ”ãƒ³ã‚°
        case 'left_foot': return getString('slot_left_foot');
        case 'right_foot': return getString('slot_right_foot');
        case 'left_palm': return getString('slot_left_palm');
        case 'right_palm': return getString('slot_right_palm');
        case 'back': return getString('slot_back');
        case 'pochette': return getString('slot_pochette');
        case 'eyes': return getString('slot_eyes');
        case 'wrist': return getString('slot_wrist');
        case 'mouth': return getString('slot_mouth');
        case 'neck': return getString('slot_neck');
        default: return getString('slot_other');
    }
}
function hideItemDetail() { 
    document.getElementById("itemDetailPanel").style.display = 'none';
    currentItemDetail = null; 
    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰è¿½åŠ  â–¼â–¼â–¼
    // ãƒ‘ãƒãƒ«ãŒé–‰ã˜ã‚‹éš›ã«ã€é–¢é€£ã™ã‚‹UIã‚’ã™ã¹ã¦æ›´æ–°ã—ã¦ãƒ‡ãƒ¼ã‚¿ã®æ•´åˆæ€§ã‚’ä¿ã¤
    updateItemPanels();
    updateCurrentLocationPanel(false);
    updateStatus();
    // â–²â–²â–² ã“ã“ã¾ã§è¿½åŠ  â–²â–²â–²
}

document.getElementById("closeItemDetailBtn").onclick = hideItemDetail;

function updatePreviewPosition(event) {
  const preview = document.getElementById("statusPreview");
  const rect = preview.getBoundingClientRect();
  let left = event.clientX + 10,
      top = event.clientY - 10;
  if (left + rect.width > window.innerWidth) left = event.clientX - rect.width - 10;
  if (top + rect.height > window.innerHeight) top = event.clientY - rect.height - 10;
  if (top < 0) top = 10;
  if (left < 0) left = 10;
  preview.style.left = left + "px";
  preview.style.top = top + "px";
}

function hideStatusPreview() { document.getElementById("statusPreview").style.display = "none"; }

// index.html å†…

function showBodyTempTooltip(event) {
    const preview = document.getElementById("statusPreview");
    const campfireNearby = placedObjects.find(c => c.type === 'campfire' && Math.abs(c.x - player.x) <= 1 && Math.abs(c.y - player.y) <= 1);
    const insideBonus = player.isInside ? 5 : 0;
    const effectiveTemperature = currentTemperature + (campfireNearby ? 15 : 0) + insideBonus;
    
    let contentHtml = `<strong>${getString("tooltip_body_temp_title")}</strong><div>${getString("tooltip_body_temp_outside")}: ${currentTemperature.toFixed(1)}Â°C</div>`;
    if (player.isInside) contentHtml += `<div>${getString("tooltip_body_temp_cabin")}: <span class="stat-positive">+${insideBonus}Â°C</span></div>`;
    if (campfireNearby) contentHtml += `<div>${getString("tooltip_body_temp_campfire")}: <span class="stat-positive">+15Â°C</span></div>`;
    contentHtml += `<div>${getString("tooltip_body_temp_insulation")}: <span class="stat-positive">${player.insulation.toFixed(1)}</span></div><div style="border-bottom: 1px solid #555; margin: 2px 0;"></div><strong>${getString("tooltip_body_temp_effective")}: ${effectiveTemperature.toFixed(1)}Â°C</strong>`;
    
    preview.innerHTML = contentHtml;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}

function showMovementTooltip(event, mode) {
    const preview = document.getElementById("statusPreview");
    let title = '';
    let description = '';

    if (mode === 'walk') {
        title = 'æ­©è¡Œ';
        description = 'æ¨™æº–çš„ãªç§»å‹•æ–¹æ³•ã€‚1ã‚¿ãƒ¼ãƒ³ã«1ãƒã‚¹ç§»å‹•ã—ã¾ã™ã€‚ç«‹ã¦ã‚‹éŸ³ã¯æ¯”è¼ƒçš„å°ã•ã„ã§ã™ã€‚';
    } else if (mode === 'run') {
        title = 'èµ°è¡Œ';
        description = 'é«˜é€Ÿç§»å‹•ã€‚1ã‚¿ãƒ¼ãƒ³ã«å¿…ãš2ãƒã‚¹ç§»å‹•ã—ã¾ã™ã€‚å¤§ããªéŸ³ã‚’ç«‹ã¦ã€è¿½åŠ ã§ç©ºè…¹ã¨æ¸‡ãã‚’æ¶ˆè²»ã—ã¾ã™ã€‚';
    } else {
        return;
    }

    preview.innerHTML = `<strong>${title}</strong><div style="margin-top: 5px;">${description}</div>`;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}
function getDirectionHint(fromX, fromY, toX, toY) {
    const deltaX = toX - fromX,
        deltaY = toY - fromY;
    let vertical = "",
        horizontal = "";
    if (Math.abs(deltaY) > 2) vertical = (deltaY < 0) ? "åŒ—" : "å—";
    if (Math.abs(deltaX) > 2) horizontal = (deltaX > 0) ? "æ±" : "è¥¿";
    if (vertical && horizontal) return `ã“ã“ã‹ã‚‰${vertical}${horizontal}ã®æ–¹è§’ã«ã€ç”Ÿå­˜è€…ã®æœ€å¾Œã®æ¥½åœ’ãŒã‚ã‚‹ã¨ã„ã†å™‚ã ã€‚`;
    if (vertical) return `ã“ã“ã‹ã‚‰${vertical}ã®æ–¹è§’ã«ã€ç”Ÿå­˜è€…ã®æœ€å¾Œã®æ¥½åœ’ãŒã‚ã‚‹ã¨ã„ã†å™‚ã ã€‚`;
    if (horizontal) return `ã“ã“ã‹ã‚‰${horizontal}ã®æ–¹è§’ã«ã€ç”Ÿå­˜è€…ã®æœ€å¾Œã®æ¥½åœ’ãŒã‚ã‚‹ã¨ã„ã†å™‚ã ã€‚`;
    return "ã“ã®è¾ºã‚Šã«ã‚ã‚‹ã¨èããŒ...è©³ã—ã„å ´æ‰€ã¾ã§ã¯ã‚ã‹ã‚‰ãªã„ãªã€‚";
}


function startTraderShopEncounter() {
    isInteractionActive = true;
    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â–¼â–¼â–¼
    const shopKeeper = generateNPC('Trader'); // â† 'Trader'ã‚’æ˜ç¢ºã«æŒ‡å®šã—ã¦ç”Ÿæˆ
    shopKeeper.name = 'ShopTrader';
    shopKeeper.isAggressive = false;
    // â–²â–²â–² ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²
    currentNPC = shopKeeper;
    startNPCEncounter();
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function startNPCEncounter() {
    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â–¼â–¼â–¼
    // ãƒ‘ãƒãƒ«ã‚’éè¡¨ç¤ºã«ã™ã‚‹å‰ã«ã€ç¾åœ¨ã®çŠ¶æ…‹ã‚’è¨˜æ†¶ã™ã‚‹
    preCombatPanelStates = {};
    document.querySelectorAll('.panel').forEach(panel => {
        preCombatPanelStates[panel.id] = {
            display: window.getComputedStyle(panel).display,
            top: panel.style.top,
            left: panel.style.left,
            width: panel.style.width,
            height: panel.style.height,
            isMinimized: panel.classList.contains('minimized')
        };
    });
    // â–²â–²â–² ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²
    // â–¼â–¼â–¼ ãƒ‡ãƒãƒƒã‚°ã‚³ãƒ¼ãƒ‰ â–¼â–¼â–¼
    console.log("ã€é­é‡é–‹å§‹æ™‚ã€‘ãƒ‘ãƒãƒ«ã®çŠ¶æ…‹ã‚’è¨˜æ†¶ã—ã¾ã—ãŸ:", JSON.parse(JSON.stringify(preCombatPanelStates)));
    // â–²â–²â–² ãƒ‡ãƒãƒƒã‚°ã“ã“ã¾ã§ â–²â–²â–²
    isInteractionActive = true;
    const npcName = getString(`item_${currentNPC.name}_name`) || currentNPC.name;

    if (currentNPC.type === 'Raider') {
        log(getString("log_npc_encounter", { npcName: npcName }), false);
        startCombat(currentNPC);
        return;
    }

    const dialoguePanel = document.getElementById('dialoguePanel');
    document.querySelectorAll('.panel:not(#dialoguePanel)').forEach(p => p.style.display = 'none');
    document.getElementById('dialogueNpcName').textContent = npcName;
    
    // â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã§ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
    const npcPortraitPath = currentNPC.portraitIcon || currentNPC.icon;
    document.getElementById('dialogueNpcAscii').innerHTML = `<img src="${npcPortraitPath}" alt="NPC Portrait">`;
    // â–²â–²â–² ç½®ãæ›ãˆã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²

    const dialogueImg = document.getElementById('dialogueNpcAscii').querySelector('img');
    if (dialogueImg) {
        const template = npcTemplates.find(t => t.type === currentNPC.type);
        if (template) {
            const maxHealth = template.health;
            const borderColor = getHealthColor(currentNPC.health, maxHealth);
            dialogueImg.style.borderColor = borderColor;
        }
    }

    document.getElementById('dialogueText').innerHTML = `<p><i>ã€Œ${getString(currentNPC.dialogue.greeting)}ã€</i></p>`;
    const infoBtn = document.getElementById('dialogueInfoBtn');
    if (currentNPC.knowsSalvationCity) {
        infoBtn.style.display = 'block';
        infoBtn.disabled = false;
        infoBtn.onclick = () => {
            const hint = getDirectionHint(player.x, player.y, salvationCityCoords.x, salvationCityCoords.y);
            document.getElementById('dialogueText').innerHTML += `<p style="color: yellow;"><i>ã€Œ${hint}ã€</i></p>`;
            document.getElementById('dialogueText').scrollTop = document.getElementById('dialogueText').scrollHeight;
            character.salvationCityHint = hint;
            updateCharacterInfo();
            infoBtn.disabled = true;
        };
    } else { infoBtn.style.display = 'none'; }
    document.getElementById('dialogueTradeBtn').onclick = openTradeWindow;
    document.getElementById('dialogueFightBtn').onclick = () => {
        dialoguePanel.style.display = 'none';
        log(getString("log_npc_attack", { npcName: npcName }), false);
        startCombat(currentNPC);
    };
    document.getElementById('dialogueLeaveBtn').onclick = () => {
        log(getString("log_npc_farewell", { npcName: npcName }));
        endNPCEncounter();
    };
    dialoguePanel.style.display = 'block';
    bringToFront(dialoguePanel);
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function endNPCEncounter() {
    isInteractionActive = false;
    currentNPC = null;
    currentEnemy = null;

    // NPCé–¢é€£ã¨é–‹ç™ºè€…ãƒ‘ãƒãƒ«ã‚’ç¢ºå®Ÿã«éè¡¨ç¤ºã«ã™ã‚‹
    document.getElementById('dialoguePanel').style.display = 'none';
    document.getElementById('tradePanel').style.display = 'none';
    document.getElementById('devPanel').style.display = 'none';

    // æ¢ç´¢ãƒ‘ãƒãƒ«ã‚’é–‰ã˜ã‚‹
    closeExplorationPanel();
    // â–¼â–¼â–¼ ãƒ‡ãƒãƒƒã‚°ã‚³ãƒ¼ãƒ‰ â–¼â–¼â–¼
    console.log("ã€é­é‡çµ‚äº†æ™‚ã€‘ã“ã®æƒ…å ±ã‚’ä½¿ã£ã¦ãƒ‘ãƒãƒ«ã‚’å¾©å…ƒã—ã¾ã™:", JSON.parse(JSON.stringify(preCombatPanelStates)));
    // â–²â–²â–² ãƒ‡ãƒãƒƒã‚°ã“ã“ã¾ã§ â–²â–²â–²
    // ä¿å­˜ã•ã‚ŒãŸçŠ¶æ…‹ã‹ã‚‰å…¨ã¦ã®ãƒ‘ãƒãƒ«ã®è¡¨ç¤ºã‚’å¾©å…ƒã™ã‚‹
    for (const panelId in preCombatPanelStates) {
        const panel = document.getElementById(panelId);
        const savedState = preCombatPanelStates[panelId];
        if (panel && savedState) {
            panel.style.display = savedState.display;
            panel.style.top = savedState.top;
            panel.style.left = savedState.left;
            panel.style.width = savedState.width;
            panel.style.height = savedState.height;
            if (savedState.isMinimized) {
                panel.classList.add('minimized');
            } else {
                panel.classList.remove('minimized');
            }
        }
    }
    
    // ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹ã‚’æœ€æ–°ã«æ›´æ–°ã™ã‚‹
    refreshGameState();
}
let playerOffer = [],
    npcOffer = [],
    tradePlayerInv = [],
    tradePlayerEquip = [],
    tradeNpcInv = [],
    tradeNpcEquip = [];

function openTradeWindow() {
    tradePlayerInv = JSON.parse(JSON.stringify(player.inventory));
    tradePlayerEquip = JSON.parse(JSON.stringify(player.equipment));
    tradeNpcInv = JSON.parse(JSON.stringify(currentNPC.inventory));
    tradeNpcEquip = JSON.parse(JSON.stringify(currentNPC.equipment));
    playerOffer = [];
    npcOffer = [];
    document.getElementById('dialoguePanel').style.display = 'none';
    const tradePanel = document.getElementById('tradePanel');
    tradePanel.style.display = 'flex';
    bringToFront(tradePanel);
    renderTradeUI();
    document.getElementById('executeTradeBtn').onclick = executeTrade;
    document.getElementById('cancelTradeBtn').onclick = () => {
        tradePanel.style.display = 'none';
        document.getElementById('dialoguePanel').style.display = 'block';
    };
}

// index.htmlå†…

function renderTradeUI() {
    const playerInvDiv = document.getElementById('playerTradeInventory'),
        playerEquipDiv = document.getElementById('playerTradeEquipment'),
        npcInvDiv = document.getElementById('npcTradeInventory'),
        npcEquipDiv = document.getElementById('npcTradeEquipment'),
        playerOfferDiv = document.getElementById('playerOfferArea'),
        npcOfferDiv = document.getElementById('npcOfferArea');
    playerInvDiv.innerHTML = '';
    playerEquipDiv.innerHTML = '';
    npcInvDiv.innerHTML = '';
    npcEquipDiv.innerHTML = '';
    playerOfferDiv.innerHTML = '';
    npcOfferDiv.innerHTML = '';
    const createItemDiv = (item, source, index) => {
        const div = document.createElement('div');
        div.className = 'item';
        div.innerHTML = `${getIconHTML(getItemGraphic(item), 16)} ${getItemDisplayName(item)} (${getString("trade_item_value")}: ${item.value || 0})`;
        
        // â˜…ä¿®æ­£ç‚¹: ã‚¯ãƒªãƒƒã‚¯ã§ã‚¢ã‚¤ãƒ†ãƒ è©³ç´°ãƒ‘ãƒãƒ«ã‚’é–‹ãã‚ˆã†ã«å¤‰æ›´
        div.onclick = () => showItemDetail(item, index, source);
        
        return div;
    };
    tradePlayerInv.forEach((item, i) => playerInvDiv.appendChild(createItemDiv(item, 'playerInv', i)));
    tradePlayerEquip.forEach((item, i) => playerEquipDiv.appendChild(createItemDiv(item, 'playerEquip', i)));
    tradeNpcInv.forEach((item, i) => npcInvDiv.appendChild(createItemDiv(item, 'npcInv', i)));
    tradeNpcEquip.forEach((item, i) => npcEquipDiv.appendChild(createItemDiv(item, 'npcEquip', i)));
    playerOffer.forEach((item, i) => playerOfferDiv.appendChild(createItemDiv(item, 'playerOffer', i)));
    npcOffer.forEach((item, i) => npcOfferDiv.appendChild(createItemDiv(item, 'npcOffer', i)));
    updateTradeValues();
}

function moveTradeItem(source, index) {
    const move = (from, to, idx) => { to.push(from.splice(idx, 1)[0]); };
    if (source === 'playerInv') move(tradePlayerInv, playerOffer, index);
    else if (source === 'playerEquip') move(tradePlayerEquip, playerOffer, index);
    else if (source === 'npcInv') move(tradeNpcInv, npcOffer, index);
    else if (source === 'npcEquip') move(tradeNpcEquip, npcOffer, index);
    else if (source === 'playerOffer') {
        const itemToMove = playerOffer.splice(index, 1)[0];
        const wasEquipped = player.equipment.some(e => e.name === itemToMove.name && e.graphic === itemToMove.graphic);
        if (wasEquipped && !tradePlayerEquip.some(e => e.slot === itemToMove.slot)) tradePlayerEquip.push(itemToMove);
        else tradePlayerInv.push(itemToMove);
    } else if (source === 'npcOffer') {
        const itemToMove = npcOffer.splice(index, 1)[0];
        const wasEquipped = currentNPC.equipment.some(e => e.name === itemToMove.name && e.graphic === itemToMove.graphic);
        if (wasEquipped && !tradeNpcEquip.some(e => e.slot === itemToMove.slot)) tradeNpcEquip.push(itemToMove);
        else tradeNpcInv.push(itemToMove);
    }
    renderTradeUI();
}

function updateTradeValues() {
    const playerValue = playerOffer.reduce((sum, item) => sum + (item.value || 0), 0);
    const npcValue = npcOffer.reduce((sum, item) => sum + (item.value || 0), 0);
    document.getElementById('playerTradeValue').textContent = playerValue;
    document.getElementById('npcTradeValue').textContent = npcValue;
    const tradeBtn = document.getElementById('executeTradeBtn');
    if (playerValue >= npcValue * 0.9 && (playerValue > 0 || npcValue > 0)) {
        tradeBtn.disabled = false;
        tradeBtn.style.background = '#4CAF50';
    } else {
        tradeBtn.disabled = true;
        tradeBtn.style.background = '#333';
    }
}

function executeTrade() {
    snapshotStats();
    const finalInventory = [...tradePlayerInv, ...npcOffer];
    const finalEquipment = [...tradePlayerEquip];
    const finalItems = [...finalInventory, ...finalEquipment];
    let newWeight = finalItems.reduce((sum, item) => sum + (item.weight || 0), 0);
    let newVolume = finalInventory.reduce((sum, item) => sum + (item.volume || 0), 0);
    let newMaxWeight = maxStats.maxWeight;
    let newMaxVolume = maxStats.maxVolume;
    finalEquipment.forEach(item => {
        if(item.effects) {
            if(item.effects.maxWeight) newMaxWeight += item.effects.maxWeight;
            if(item.effects.maxVolume) newMaxVolume += item.effects.maxVolume;
        }
    });
    if (newWeight > newMaxWeight) {
        speakAndAlert(getString("alert_trade_fail_weight")); return;
    }
    if (newVolume > newMaxVolume) {
        speakAndAlert(getString("alert_trade_fail_volume")); return;
    }
    log(getString("trade_success"));
    player.inventory = finalInventory;
    player.equipment = finalEquipment;
    currentNPC.inventory = [...tradeNpcInv, ...playerOffer];
    currentNPC.equipment = [...tradeNpcEquip];
    updateEquippedStats();
    document.getElementById('tradePanel').style.display = 'none';
    document.getElementById('dialoguePanel').style.display = 'block';
    const dialogueText = document.getElementById('dialogueText');
    dialogueText.innerHTML += `<p style="color: lightgreen;"><i>${getString("trade_success")}</i></p>`;
    dialogueText.scrollTop = dialogueText.scrollHeight;
    updateItemPanels();
    updateStatus();
}

// --- Rain Animation Functions ---
function triggerLightning() {
    const flash = document.getElementById('lightning-flash');
    if (flash && currentWeather.name === 'åµ') {
        flash.classList.add('active');
        setTimeout(() => {
            flash.classList.remove('active');
        }, 300);

        if (lightningTimeout) clearTimeout(lightningTimeout);
        lightningTimeout = setTimeout(triggerLightning, Math.random() * 8000 + 4000);
    }
}

// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function startWeatherEffect(weatherId) {
    const weatherContainer = document.getElementById('weather-container');
    if (!weatherContainer) return;

    weatherContainer.innerHTML = '';
    weatherContainer.style.display = 'block';
    weatherContainer.className = '';

    let dropCount = 100;
    // â˜…ä¿®æ­£ç‚¹ï¼šå¤©å€™ID 'stormy' ã§åˆ¤å®šã™ã‚‹ã‚ˆã†ã«å¤‰æ›´
    if (weatherId === 'stormy') {
        dropCount = 150;
        weatherContainer.classList.add('storm');
        if (lightningTimeout) clearTimeout(lightningTimeout);
        lightningTimeout = setTimeout(triggerLightning, Math.random() * 5000 + 2000);
    }

    for (let i = 0; i < dropCount; i++) {
        const drop = document.createElement('div');
        drop.className = 'drop';
        drop.style.left = Math.random() * 120 - 10 + 'vw';

        let duration = (Math.random() * 0.5 + 0.5);
        // â˜…ä¿®æ­£ç‚¹ï¼šå¤©å€™ID 'stormy' ã§åˆ¤å®šã™ã‚‹ã‚ˆã†ã«å¤‰æ›´
        if (weatherId === 'stormy') {
            duration = (Math.random() * 0.3 + 0.3);
        }

        drop.style.animationDuration = duration + 's';
        drop.style.animationDelay = Math.random() * 5 + 's';
        weatherContainer.appendChild(drop);
    }
}

function stopWeatherAudio() {
    [...rainSourceNodes, ...stormSourceNodes, ...birdsSourceNodes, ...windSourceNodes].forEach(node => {
        try {
            node.stop();
        } catch (e) {
            // Do nothing
        }
    });
    rainSourceNodes = [];
    stormSourceNodes = [];
    birdsSourceNodes = [];
    windSourceNodes = [];
    currentAmbientSound = null; // â˜…è¨˜æ†¶ã—ã¦ã„ã‚‹éŸ³ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹å‡¦ç†ã‚’è¿½åŠ 
}
function stopWeatherEffect() {
    stopWeatherAudio(); // éŸ³å£°ã®åœæ­¢ã‚’å°‚é–€ã®é–¢æ•°ã«ä»»ã›ã‚‹

    // ã“ã“ã‹ã‚‰ä¸‹ã¯ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãªã©ã€è¦‹ãŸç›®ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ã¿ã‚’åœæ­¢ã™ã‚‹
    const weatherContainer = document.getElementById('weather-container');
    if (weatherContainer) {
        weatherContainer.style.display = 'none';
        weatherContainer.innerHTML = '';
    }
    if (lightningTimeout) {
        clearTimeout(lightningTimeout);
        lightningTimeout = null;
    }
    const flash = document.getElementById('lightning-flash');
    if (flash) flash.classList.remove('active');
}



function startClouds() {
    const cloudContainer = document.getElementById('cloud-container');
    if (!cloudContainer || cloudContainer.style.display === 'block') return;

    cloudContainer.innerHTML = '';
    cloudContainer.style.display = 'block';

    const cloudCount = 5;
    for (let i = 0; i < cloudCount; i++) {
        const cloud = document.createElement('div');
        cloud.className = 'cloud';

        const size = Math.random() * 0.5 + 0.75;
        cloud.style.transform = `scale(${size})`;
        cloud.style.top = `${Math.random() * 80}%`;

        const duration = Math.random() * 30 + 40;
        cloud.style.animationDuration = `${duration}s`;
        cloud.style.animationDelay = `-${Math.random() * duration}s`;

        cloudContainer.appendChild(cloud);
    }
}

function stopClouds() {
    const cloudContainer = document.getElementById('cloud-container');
    if (cloudContainer) {
        cloudContainer.style.display = 'none';
        cloudContainer.innerHTML = '';
    }
}
function placeUnlitCampfire(item, itemIndex, source) {
    let isBlocked = false;
    const outdoorBlockers = ['workbench', 'junk_research_bench', 'barricade', 'shelter', 'wooden_box', 'sleeping_bag'];

    if (player.isInside || player.isInShelter) {
        isBlocked = placedObjects.some(o => o.x === player.x && o.y === player.y && (o.type === 'unlit_campfire' || o.type === 'campfire'));
    } else {
        isBlocked = placedObjects.some(o => o.x === player.x && o.y === player.y && outdoorBlockers.includes(o.type));
    }
    
    if (isBlocked) { 
        log(getString("log_campfire_exists"));
        return; 
    }
    snapshotStats();

    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â–¼â–¼â–¼
    item.uses--;

    if (item.uses <= 0) {
        log(getString("log_unlit_campfire_placed_and_used_up"));
        
        // ã‚¢ã‚¤ãƒ†ãƒ ãŒã©ã“ã«ã‚ã‚‹ã‹ã«å¿œã˜ã¦ã€æ­£ã—ã„å ´æ‰€ã‹ã‚‰å‰Šé™¤ã™ã‚‹
        const sourceArray = source === 'inventory' ? player.inventory : droppedItems[`${player.x},${player.y}`];
        const removedItem = sourceArray.splice(itemIndex, 1)[0];

        // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã‹ã‚‰æ¶ˆè²»ã—ãŸå ´åˆã®ã¿ã€é‡é‡ã¨å®¹é‡ã‚’æ¸›ã‚‰ã™
        if (source === 'inventory') {
            player.weight -= removedItem.weight;
            player.volume -= removedItem.volume;
        }
    } else {
        log(getString("log_unlit_campfire_placed"));
    }
    // â–²â–²â–² ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²

    placedObjects.push({ x: player.x, y: player.y, type: 'unlit_campfire', name: 'ã¾ã ç«ã®ã¤ã„ã¦ã„ãªã„ãŸãç«', graphic: 'images/campfire_kit.png' });
    drawMap();
    updateItemPanels();
    updateStatus();
    hideItemDetail();
}
function startFire(fireStarter, itemIndex, source) {
    const unlitCampfire = placedObjects.find(c => c.type === 'unlit_campfire' && c.x === player.x && c.y === player.y);
    if (!unlitCampfire) { log(getString("log_fire_no_target")); hideItemDetail(); return; }
    snapshotStats();

    // ä½¿ç”¨ã—ãŸé“å…·ã«ã‚ˆã£ã¦å†ç”Ÿã™ã‚‹éŸ³ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹
    if (fireStarter.name === 'ãƒ©ã‚¤ã‚¿ãƒ¼') {
        playSoundFile('sounds/lighter.wav', 0.9);
    } else if (fireStarter.name === 'ç«æ‰“çŸ³' || fireStarter.name === 'ç«èµ·ã“ã—å™¨') {
        // ç«èµ·ã“ã—å™¨ã‚‚ç«æ‰“çŸ³ã¨åŒã˜ç³»çµ±ã®éŸ³ã‚’å†ç”Ÿ
        playSoundFile('sounds/flint.wav', 0.9);
    }

    log(getString("log_fire_started", { fireStarterName: getItemDisplayName(fireStarter) }));
    unlitCampfire.type = 'campfire';
    unlitCampfire.name = 'ãŸãç«';
    // â–¼â–¼â–¼ ã“ã®è¡Œã‚’æ–°ã—ãè¿½åŠ ã—ã¾ã—ãŸ â–¼â–¼â–¼
    unlitCampfire.graphic = 'images/campfire_lit.png'; // ç«ãŒã¤ã„ãŸæ™‚ã®ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«åã‚’æŒ‡å®š
    // â–²â–²â–² è¿½åŠ ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²
    unlitCampfire.duration = 2;
    const itemContainer = (source === 'inventory') ? player.inventory : player.equipment;
    if (fireStarter.isTorch) {
        fireStarter.duration -= 1;
        if (fireStarter.duration <= 0) {
            log(getString("combat_weapon_break", { weaponName: getItemDisplayName(fireStarter) }));
            const removedItem = itemContainer.splice(itemIndex, 1)[0];
            player.weight -= removedItem.weight || 0;
            player.volume -= removedItem.volume || 0;
        }
     } else if (fireStarter.durability) {
         reduceItemDurability(fireStarter, 20, itemIndex, source);
     }
    
    if (player.isInShelter) {
        updateCurrentLocationPanel(false);
    }
    
    drawMap(); updateItemPanels(); updateStatus(); hideItemDetail();
}
function addFuelToCampfire(itemIndex, source) {
    const campfire = placedObjects.find(c => c.type === 'campfire' && c.x === player.x && c.y === player.y);
    if (!campfire) return;

    const sourceArray = source === 'inventory' ? player.inventory : droppedItems[`${player.x},${player.y}`];
    const fuelItem = sourceArray[itemIndex];
    if (!fuelItem) return;

    // â˜…ã‚¢ã‚¤ãƒ†ãƒ ã«ã‚ˆã£ã¦ç‡ƒæ–™ã®ä¾¡å€¤ã‚’æ±ºå®š
    let fuelValue = 0;
    if (fuelItem.name === 'æ') {
        fuelValue = 2; // æã¯2ã‚¿ãƒ¼ãƒ³
    } else if (fuelItem.name === 'å¤§ããªè‘‰') {
        fuelValue = 1; // å¤§ããªè‘‰ã¯1ã‚¿ãƒ¼ãƒ³
    }

    if (fuelValue > 0) {
        snapshotStats();
        const removedItem = sourceArray.splice(itemIndex, 1)[0];
        if (source === 'inventory') {
            player.weight -= removedItem.weight || 0;
            player.volume -= removedItem.volume || 0;
        }

        campfire.duration += fuelValue;
        log(getString("log_add_fuel_success", { duration: campfire.duration }));

        updateItemPanels();
        updateStatus();
        hideItemDetail();
        drawMap();
    }
}

function craftTorchWithLighter(branchIndex) {
    snapshotStats();
    const lighterIndex = player.inventory.findIndex(i => i.name === 'ãƒ©ã‚¤ã‚¿ãƒ¼');
    if (lighterIndex === -1) return;
    const lighter = player.inventory[lighterIndex];
    lighter.durability -= 10;
    const removedBranch = player.inventory.splice(branchIndex, 1)[0];
    player.weight -= removedBranch.weight;
    player.volume -= removedBranch.volume;
    const torchTemplate = items.find(i => i.name === 'æ¾æ˜');
    const newTorch = { ...torchTemplate, duration: torchTemplate.duration, durability: Math.floor(Math.random() * 30) + 70 };
    player.inventory.push(newTorch);
    player.weight += newTorch.weight;
    player.volume += newTorch.volume;
    log(getString("log_torch_crafted"));
    if (lighter.durability <= 0) {
        log(getString("log_lighter_empty"));
        const removedLighter = player.inventory.splice(lighterIndex, 1)[0];
        player.weight -= removedLighter.weight;
        player.volume -= removedLighter.volume;
    }
    updateItemPanels(); updateStatus(); hideItemDetail();
}

// â–¼â–¼â–¼ æ—¢å­˜ã® placeSleepingBag é–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
// â–¼â–¼â–¼ æ—¢å­˜ã® placeSleepingBag é–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function placeSleepingBag(item, itemIndex, source) {
    if (isStunnedByPain()) { return; }
    const corpseOnTile = placedObjects.find(o => o.x === player.x && o.y === player.y && o.type === 'corpse');
    if (corpseOnTile) {
        // â˜…â˜…â˜… ã“ã“ã‚’ä¿®æ­£ã—ã¾ã—ãŸ â˜…â˜…â˜…
        log(getString("log_sleeping_bag_blocked_corpse"));
        hideItemDetail();
        return;
    }

    let isBlocked = false;
    const outdoorBlockers = ['workbench', 'junk_research_bench', 'barricade', 'shelter', 'wooden_box', 'sleeping_bag'];

    if (player.isInside || player.isInShelter) {
        isBlocked = placedObjects.some(o => o.x === player.x && o.y === player.y && o.type === 'sleeping_bag');
    } else {
        isBlocked = placedObjects.some(o => o.x === player.x && o.y === player.y && outdoorBlockers.includes(o.type));
    }

    if (isBlocked) {
        log(getString("log_sleeping_bag_blocked"));
        return;
    }

    snapshotStats();
    
    const sourceArray = source === 'inventory' ? player.inventory : droppedItems[`${player.x},${player.y}`];
    const removedItem = sourceArray.splice(itemIndex, 1)[0];

    if (source === 'inventory') {
        player.weight -= removedItem.weight;
        player.volume -= removedItem.volume;
    }

    let logKey = "log_sleeping_bag_placed";
    if (player.isInShelter) {
        logKey = "log_sleeping_bag_placed_in_shelter";
    } else if (player.isInside) {
        logKey = "log_sleeping_bag_placed_inside";
    }
    log(getString(logKey));

    placedObjects.push({ x: player.x, y: player.y, type: 'sleeping_bag', name: 'sleeping_bag', graphic: 'images/sleeping_bag.png' });
    
    drawMap();
    updateItemPanels();
    updateStatus();
    hideItemDetail();
    processSpeechQueue();
}
function placeShelter(item, itemIndex, source) {
    const currentTile = map[player.y][player.x];
    const forbiddenAreas = ['location_cabin', 'location_pond'];
    const forbiddenBiomes = ['Town'];

    if (placedObjects.find(o => o.x === player.x && o.y === player.y) || forbiddenAreas.includes(currentTile.loc.nameKey) || forbiddenBiomes.includes(currentTile.biome)) {
        log(getString("log_shelter_blocked"));
        return;
    }

    snapshotStats();
    playSoundFile('sounds/shelter_build.wav', 0.8);
    // â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã§ã‚¢ã‚¤ãƒ†ãƒ ã®æ¶ˆè²»å…ƒã‚’æ­£ã—ãåˆ¤å®šã—ã¾ã™ â–¼â–¼â–¼
    const sourceArray = source === 'inventory' ? player.inventory : droppedItems[`${player.x},${player.y}`];
    const removedItem = sourceArray.splice(itemIndex, 1)[0];

    if (source === 'inventory') {
        player.weight -= removedItem.weight;
        player.volume -= removedItem.volume;
    }
    // â–²â–²â–² ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²

    log(getString("log_shelter_placed"));
    placedObjects.push({ x: player.x, y: player.y, type: 'shelter', name: 'shelter', graphic: 'images/shelter.png' });
    
    drawMap();
    updateItemPanels();
    updateStatus();
    hideItemDetail();
}

function enterShelter() {
    // â–¼â–¼â–¼ ã‚µã‚¦ãƒ³ãƒ‰å†ç”Ÿã‚’è¿½åŠ  â–¼â–¼â–¼
    playSoundFile('sounds/shelter_enter.wav');
    // â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²

    player.isInShelter = true;
    updateCurrentLocationPanel(false);
    drawMap();
    log(getString("log_shelter_enter_safe"));
}

function exitShelter() {
    // â–¼â–¼â–¼ ã‚µã‚¦ãƒ³ãƒ‰å†ç”Ÿã‚’è¿½åŠ  â–¼â–¼â–¼
    playSoundFile('sounds/shelter_exit.wav');
    // â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²

    player.isInShelter = false;
    log(getString("log_exit_shelter"));
    refreshGameState(); 
}
function placeWoodenBox(item, itemIndex, source) {
    if (placedObjects.find(o => o.x === player.x && o.y === player.y)) { log(getString("log_wooden_box_blocked")); return; }
    snapshotStats();

    const sourceArray = source === 'inventory' ? player.inventory : droppedItems[`${player.x},${player.y}`];
    const removedItem = sourceArray.splice(itemIndex, 1)[0];

    if (source === 'inventory') {
        player.weight -= removedItem.weight;
        player.volume -= removedItem.volume;
    }
    
    log(getString("log_wooden_box_placed"));
    placedObjects.push({ x: player.x, y: player.y, type: 'wooden_box', name: 'wooden_box', graphic: 'images/wooden_box.png', content: [], capacity: 10 });
    drawMap(); updateItemPanels(); updateStatus(); hideItemDetail();
}

// index.htmlå†…

// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function cookFood(itemIndex, source = 'inventory') {
    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â–¼â–¼â–¼
    const branch = player.inventory.find(i => i.name === 'æ');
    if (!branch) {
        log(getString("log_cook_fail_no_branch"), true);
        hideItemDetail(); // ã‚¢ã‚¤ãƒ†ãƒ è©³ç´°ã‚’é–‰ã˜ã‚‹
        return;
    }
    // â–²â–²â–² ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²

    const sourceArray = source === 'inventory' ? player.inventory : droppedItems[`${player.x},${player.y}`];
    const rawItem = sourceArray[itemIndex];
    const cookedItemName = cookingMap[rawItem.name];
    if (!cookedItemName) return;

    snapshotStats();
    
    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â–¼â–¼â–¼
    // æã®è€ä¹…å€¤ã‚’20æ¸›ã‚‰ã™ã€‚ã‚‚ã—å£Šã‚ŒãŸã‚‰reduceItemDurabilityãŒè‡ªå‹•ã§å‡¦ç†ã™ã‚‹
    reduceItemDurability(branch, 20);
    // â–²â–²â–² ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²

    const removedItem = sourceArray.splice(itemIndex, 1)[0];
    player.weight -= removedItem.weight;
    if (source === 'inventory') player.volume -= removedItem.volume;
    
    const cookedItemTemplate = items.find(i => i.name === cookedItemName);
    const newItem = { ...cookedItemTemplate, name: cookedItemName };
    
    player.inventory.push(newItem);
    player.weight += newItem.weight;
    player.volume += newItem.volume;
    log(getString("log_cooked_item", { rawItemName: getItemDisplayName(rawItem), cookedItemName: getItemDisplayName(newItem) }));
    updateItemPanels();
    updateStatus();
    hideItemDetail();
}
function boilWater(itemIndex, source = 'inventory') {
    snapshotStats();
    const sourceArray = source === 'inventory' ? player.inventory : droppedItems[`${player.x},${player.y}`];
    const container = sourceArray[itemIndex];
    
    // ã€Œç¶ºéº—ãªãŠæ¹¯ã€ã®ã‚¢ã‚¤ãƒ†ãƒ æƒ…å ±ã‚’å–å¾—
    const hotWaterTemplate = items.find(i => i.name === 'ç¶ºéº—ãªãŠæ¹¯');
    if (hotWaterTemplate) {
        // å®¹å™¨ã®ä¸­èº«ã‚’ã€Œç¶ºéº—ãªãŠæ¹¯ã€ã«ç½®ãæ›ãˆã‚‹
        container.content = { ...hotWaterTemplate };
        log(getString("log_water_boiled_hot", { containerName: getItemDisplayName(container) }));
    }

    updateItemPanels(); 
    updateStatus(); 
    hideItemDetail();
}

function drinkFromContainer(itemIndex, source = 'inventory') {
    if (player.thirst >= maxStats.thirst) {
        log(getString("log_thirst_full"), true);
        hideItemDetail();
        return;
    }

    snapshotStats();
    const sourceArray = source === 'inventory' ? player.inventory : droppedItems[`${player.x},${player.y}`];
    const container = sourceArray[itemIndex];
    const content = container.content;

    if (content.name === 'ç¶ºéº—ãªãŠæ¹¯') {
        // â–¼â–¼â–¼ è¿½åŠ  â–¼â–¼â–¼
        playSoundFile('sounds/drink_hot.wav', 0.8);
        player.thirst = Math.min(maxStats.thirst, player.thirst + content.effects.thirst);
        if (content.bodyTempBoost) {
            player.bodyTemp = Math.min(37.5, player.bodyTemp + content.bodyTempBoost);
        }
        log(getString("log_drink_hot_water"));
    } else if (content.name === 'ãã‚Œã„ãªæ°´' || content.type === 'clean') {
        // â–¼â–¼â–¼ è¿½åŠ  â–¼â–¼â–¼
        playSoundFile('sounds/drink_clean.wav', 0.8);
        const thirstEffect = content.effects ? content.effects.thirst : 40;
        player.thirst = Math.min(maxStats.thirst, player.thirst + thirstEffect);
        log(getString("log_drink_clean"));
    } else {
        // â–¼â–¼â–¼ è¿½åŠ  â–¼â–¼â–¼
        playSoundFile('sounds/drink_dirty.wav', 0.9);
        player.thirst = Math.min(maxStats.thirst, player.thirst + 20);
        // â˜…â˜…â˜…ã“ã®è¡Œã‚’ä¿®æ­£â˜…â˜…â˜…
        if (Math.random() < calculateSicknessChance(0.8) && !player.sicknesses.some(s => s.type === 'diarrhea')) {
            log(getString("log_drink_dirty_sick"), true);
            player.sicknesses.push({ type: 'diarrhea', duration: 36 });
        } else {
            log(getString("log_drink_dirty_ok"));
        }
    }

    container.content = null;
    logStatChanges(playerStatsBeforeAction, player);
    updateItemPanels(); 
    updateStatus(); 
    hideItemDetail();
}

function drinkFromSource() {
    if (player.thirst >= maxStats.thirst) {
        log(getString("log_thirst_full"), true);
        hideItemDetail();
        return;
    }

    snapshotStats();
    // â–¼â–¼â–¼ è¿½åŠ  â–¼â–¼â–¼
    playSoundFile('sounds/drink_dirty.wav', 0.9);
    
    player.thirst = Math.min(maxStats.thirst, player.thirst + 20);
    // â˜…â˜…â˜…ã“ã®è¡Œã‚’ä¿®æ­£â˜…â˜…â˜…
    if (Math.random() < calculateSicknessChance(0.9) && !player.sicknesses.some(s => s.type === 'diarrhea')) {
        log("åœ°é¢ã®æ°´ã‚’ç›´æ¥é£²ã‚“ã ...ã™ãã«å¾Œæ‚”ã™ã‚‹ã“ã¨ã«ãªã£ãŸï¼", true);
        player.sicknesses.push({ type: 'diarrhea', duration: 36 });
    } else {
        log("åœ°é¢ã®æ°´ã‚’ç›´æ¥é£²ã‚“ã ã€‚å–‰ã¯æ½¤ã£ãŸãŒã€è…¹ã®èª¿å­ãŒæ‚ªã„...");
    }
    logStatChanges(playerStatsBeforeAction, player);
    updateStatus();
    hideItemDetail();
}

function fillContainerFromSource(itemIndex, source = 'inventory') {
    const sourceArray = source === 'inventory' ? player.inventory : droppedItems[`${player.x},${player.y}`];
    const emptyContainer = sourceArray[itemIndex];

    if (emptyContainer && emptyContainer.type === 'container' && !emptyContainer.content) {
        snapshotStats();
        emptyContainer.content = { type: 'dirty' };
        log(getString("log_fill_container_success", { containerName: getItemDisplayName(emptyContainer) }));
        updateItemPanels();
        updateStatus();
        hideItemDetail();
    } else {
        const trueEmptyContainerIndex = player.inventory.findIndex(i => i.type === 'container' && !i.content);
        if (trueEmptyContainerIndex === -1) { log("æ°´ã‚’æ±²ã‚€ãŸã‚ã®ç©ºã®å®¹å™¨ãŒãªã„ã€‚"); hideItemDetail(); return; }
        snapshotStats();
        player.inventory[trueEmptyContainerIndex].content = { type: 'dirty' };
        log(getString("log_fill_container_success", { containerName: getItemDisplayName(player.inventory[trueEmptyContainerIndex]) }));
        updateItemPanels();
        updateStatus();
        hideItemDetail();
    }
}
function emptyContainer(itemIndex, source) { // â˜…å¼•æ•°ã« source ã‚’è¿½åŠ 
    snapshotStats();

    // â˜…ã‚¢ã‚¤ãƒ†ãƒ ãŒã©ã“ã«ã‚ã‚‹ã‹ã«å¿œã˜ã¦æ­£ã—ãå–å¾—ã™ã‚‹
    const sourceArray = source === 'inventory' ? player.inventory : droppedItems[`${player.x},${player.y}`];
    const container = sourceArray[itemIndex];

    // â˜…ã‚³ãƒ³ãƒ†ãƒŠãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’è¿½åŠ 
    if (!container) {
        console.error("emptyContainer: å¯¾è±¡ã®ã‚³ãƒ³ãƒ†ãƒŠãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚");
        hideItemDetail();
        return;
    }

    log(getString("log_empty_container", { containerName: getItemDisplayName(container) }));

    // â˜…ä¸­èº«ã«å¿œã˜ãŸã‚¢ã‚¤ãƒ†ãƒ ã‚’åœ°é¢ã«ç”Ÿæˆï¼ˆæ°´ä»¥å¤–ã‚‚è€ƒæ…®ï¼‰
    if (container.content) {
        const contentName = container.content.name;
        const contentTemplate = items.find(i => i.name === contentName);
        if (contentTemplate) {
             const droppedContent = { ...contentTemplate };
             const locationKey = `${player.x},${player.y}`;
             if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
             droppedItems[locationKey].push(droppedContent);
        }
    }

    container.content = null;
    updateItemPanels();
    updateCurrentLocationPanel(false);
    updateStatus();
    hideItemDetail();
}

function openCan(itemIndex, source = 'inventory') {
    snapshotStats();
    const sourceArray = source === 'inventory' ? player.inventory : droppedItems[`${player.x},${player.y}`];
    const can = sourceArray[itemIndex];
    can.isSealed = false;
    can.name = 'opened_can_beans';
    can.effects = can.sealedEffects;
    can.smell = 3;
    log(getString("log_open_can_success", { canName: getString(`item_${can.name}_name`) || can.name }));
    updateItemPanels();
    updateStatus();
    hideItemDetail();
}

function forceOpenCan(itemIndex, source = 'inventory') {
    snapshotStats();
    const sourceArray = source === 'inventory' ? player.inventory : droppedItems[`${player.x},${player.y}`];
    const can = sourceArray[itemIndex];
    const emptyCanTemplate = items.find(i => i.name === 'ç©ºãç¼¶');
    if (Math.random() < 0.6) {
        log(getString("log_force_open_fail", { canName: getString(`item_${can.name}_name`) || can.name }));
        const removedCan = sourceArray.splice(itemIndex, 1)[0];
        player.inventory.push({ ...emptyCanTemplate });
        player.weight -= (removedCan.weight - emptyCanTemplate.weight);
        if (source === 'inventory') player.volume -= (removedCan.volume - emptyCanTemplate.volume);

    } else {
        can.isSealed = false;
        can.name = 'opened_can_beans';
        can.effects = can.sealedEffects;
        can.smell = 3;
        log(getString("log_force_open_success", { canName: getString(`item_${can.name}_name`) || can.name }));
    }
    updateItemPanels();
    updateStatus();
    hideItemDetail();
}
/**
 * æ•°é‡ã‚’å…¥åŠ›ã™ã‚‹ãŸã‚ã®ã‚«ã‚¹ã‚¿ãƒ ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•°
 * @param {string} message - ãƒ¢ãƒ¼ãƒ€ãƒ«ã«è¡¨ç¤ºã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
 * @param {string} defaultValue - å…¥åŠ›æ¬„ã®åˆæœŸå€¤
 * @param {number} max - å…¥åŠ›ã§ãã‚‹æœ€å¤§å€¤
 * @param {function(number)} onConfirm - OKãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚ŒãŸã¨ãã«ã€å…¥åŠ›ã•ã‚ŒãŸå€¤ã‚’å¼•æ•°ã¨ã—ã¦å®Ÿè¡Œã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯
 * @param {function} [onCancel] - ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚ŒãŸã¨ãã«å®Ÿè¡Œã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯
 */
function showInputModal(message, defaultValue, max, onConfirm, onCancel) {
    isInteractionActive = true;
    const existingModal = document.getElementById("inputModal");
    if (existingModal) existingModal.remove();

    const modalDiv = document.createElement("div");
    modalDiv.id = "inputModal";
    modalDiv.style.cssText = `position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #333; color: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.6); z-index: 2001; font-family: sans-serif; width: 350px; text-align: center;`;

    const inputHTML = `<p style="margin-top: 0; margin-bottom: 15px;">${message}</p>
                       <input type="number" id="modalInput" min="1" max="${max}" value="${defaultValue}" style="width: 80%; padding: 8px; font-size: 1.2em; text-align: center; background: #222; color: #eee; border: 1px solid #555; border-radius: 4px;">`;
    
    const buttonsHTML = `<div style="margin-top: 20px;">
                           <button id="modalConfirmBtn" style="background: #4CAF50; color: white; border: none; padding: 10px 20px; margin-right: 10px; border-radius: 5px; cursor: pointer;">${getString("btn_ok")}</button>
                           <button id="modalCancelBtn" style="background: #4a4a52; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">${getString("btn_cancel")}</button>
                         </div>`;

    modalDiv.innerHTML = inputHTML + buttonsHTML;
    document.body.appendChild(modalDiv);
    
    const inputElement = document.getElementById('modalInput');
    inputElement.focus();
    inputElement.select();

    const closeModal = () => {
        modalDiv.remove();
        isInteractionActive = false;
    };

    document.getElementById("modalConfirmBtn").onclick = () => {
        const value = parseInt(inputElement.value);
        if (!isNaN(value) && value > 0 && value <= max) {
            if (onConfirm) onConfirm(value);
            closeModal();
        } else {
            // ç„¡åŠ¹ãªå…¥åŠ›ã«å¯¾ã™ã‚‹è¦–è¦šçš„ãªãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
            inputElement.style.outline = "2px solid red";
            setTimeout(() => { inputElement.style.outline = "none"; }, 1000);
        }
    };

    document.getElementById("modalCancelBtn").onclick = () => {
        if (onCancel) onCancel();
        closeModal();
    };

    // Enterã‚­ãƒ¼ã¨Escapeã‚­ãƒ¼ã®ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
    inputElement.onkeydown = (event) => {
        if (event.key === 'Enter') {
            document.getElementById("modalConfirmBtn").click();
        } else if (event.key === 'Escape') {
            document.getElementById("modalCancelBtn").click();
        }
    };
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function showPlacedObjectDetail(object) {
    const panel = document.getElementById("itemDetailPanel"),
        header = document.getElementById("itemDetailHeader"),
        graphic = document.getElementById("itemDetailGraphic"),
        content = document.getElementById("itemDetailContent");

    currentItemDetail = { item: object, source: 'placed', coords: { x: object.x, y: object.y } };
    header.textContent = getPlacedObjectDisplayName(object);
    graphic.innerHTML = getIconHTML(object.graphic, 96);

    let description = getString("tooltip_placed_object_no_desc");
    let weight = 0, volume = 0;

    const itemTemplate = items.find(i => object.type === i.useAction?.replace('place', '')) || items.find(i => object.name === i.name);
    if (itemTemplate) {
        description = getString(itemTemplate.desc);
        weight = itemTemplate.weight || 0;
        volume = itemTemplate.volume || 0;
    }

    let detailsHtml = `<div class="item-description">${description}</div><strong>${getString("detail_label_type")}</strong> ${getString("item_type_placed_object")}<br>`;

    if (object.type === 'barricade') {
        detailsHtml += `<strong>${getString("combat_health")}</strong> ${object.health.toFixed(0)} / ${object.maxHealth.toFixed(0)}`;
    } else if (object.type === 'campfire') {
        detailsHtml += `${getString("info_remaining_turns_compact", { duration: object.duration })}`;
    } else if (object.type === 'drying_rack') {
        const dryingCount = object.content.filter(m => m.turnsLeft > 0).length;
        const driedCount = object.content.filter(m => m.turnsLeft <= 0).length;
        detailsHtml += `<div style="margin-top:5px; border-top: 1px solid #555; padding-top: 5px;"><strong>${getString("info_drying_status")}:</strong><br><span>${getString("info_drying_meat", { count: dryingCount })}</span><br><span>${getString("info_dried_meat", { count: driedCount })}</span></div>`;
    } else {
        detailsHtml += `<strong>${getString("detail_label_weight")}</strong> ${weight}<br><strong>${getString("detail_label_volume")}</strong> ${volume}`;
    }
    content.innerHTML = detailsHtml;

    document.getElementById("itemDetailActions").querySelectorAll('button').forEach(btn => btn.style.display = 'none');
    document.getElementById("closeItemDetailBtn").style.display = 'inline-block';

    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â–¼â–¼â–¼
    if (object.type === 'drying_rack') {
        const driedCount = object.content.filter(m => m.turnsLeft <= 0).length;
        const spaceLeft = 5 - object.content.length;
        const hasRawMeat = player.inventory.some(i => i.name === 'ç”Ÿè‚‰') || (droppedItems[`${player.x},${player.y}`] || []).some(i => i.name === 'ç”Ÿè‚‰');

        if (spaceLeft > 0 && hasRawMeat) {
            document.getElementById("addMeatBtn").style.display = 'inline-block';
            document.getElementById("addMeatBtn").onclick = () => showAddMeatToRackUI(object);
        }
        if (driedCount > 0) {
            document.getElementById("takeDriedMeatBtn").style.display = 'inline-block';
            document.getElementById("takeDriedMeatBtn").onclick = () => takeDriedMeatFromRack(object);
        }
    }
    // â–²â–²â–² ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²

    if (object.type === 'bear_trap_sprung') {
        document.getElementById("resetTrapBtn").style.display = 'inline-block';
        document.getElementById("resetTrapBtn").onclick = resetBearTrap;
    }
    if (object.type === 'bear_trap_armed' || object.type === 'bear_trap_sprung') {
        document.getElementById("removeTrapBtn").style.display = 'inline-block';
        document.getElementById("removeTrapBtn").onclick = removeBearTrap;
    }

    if (object.type === 'workbench' || object.type === 'junk_research_bench') {
        const useBtn = document.getElementById(object.type === 'workbench' ? "useWorkbenchBtn" : "conductResearchBtn");
        useBtn.style.display = 'inline-block';
        useBtn.onclick = () => {
            if (object.type === 'workbench') openWorkbenchPanel();
            else openResearchPanel(true);
        };
    }

    if (object.type === 'barricade' && (player.inventory.some(i => i.isAxe) || player.equipment.some(i => i.isAxe))) {
        document.getElementById("dismantleBtn").style.display = 'inline-block';
        document.getElementById("dismantleBtn").onclick = dismantleBarricade;
    } else if (object.isAnimalCorpse && object.unbutchered) {
        if (player.inventory.some(i => i.isBlade) || player.equipment.some(i => i.isBlade)) {
            document.getElementById("butcherItemBtn").style.display = 'inline-block';
            document.getElementById("butcherItemBtn").onclick = butcherAnimalCorpse;
        }
    } else if (object.isHumanCorpse && object.unsearched) {
        document.getElementById("searchCorpseBtn").style.display = 'inline-block';
        document.getElementById("searchCorpseBtn").onclick = searchHumanCorpse;
    } else if (object.type === 'sleeping_bag' || (object.type === 'wooden_box' && (!object.content || object.content.length === 0))) {
        const pickupBtn = document.getElementById("pickupItemBtn");
        pickupBtn.style.display = 'inline-block';
        pickupBtn.onclick = () => pickupPlacedObject(object);
    }

    panel.style.display = 'block';
    bringToFront(panel);
}
// â–¼â–¼â–¼ æ—¢å­˜ã® `pickupPlacedObject` é–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function pickupPlacedObject(object) {
    let itemTemplate;
    
    // â˜…â˜…â˜… ä¿®æ­£ç‚¹ï¼šæ¢ã™ã‚¢ã‚¤ãƒ†ãƒ ã®åå‰ã‚’ã€æ—¥æœ¬èªåã‹ã‚‰IDã«å¤‰æ›´ â˜…â˜…â˜…
    if (object.type === 'sleeping_bag') {
        itemTemplate = items.find(i => i.name === 'sleeping_bag');
    } else if (object.type === 'wooden_box') {
        itemTemplate = items.find(i => i.name === 'wooden_box');
    } 
    // â˜…â˜…â˜… ä¿®æ­£ã“ã“ã¾ã§ â˜…â˜…â˜…
    
    else if (object.type === 'shelter') {
        log(getString("log_pickup_shelter_fail"));
        hideItemDetail();
        return;
    } else {
        log(getString("log_pickup_fail_generic"));
        return;
    }

    if (!itemTemplate) return;
    const itemName = getItemDisplayName(itemTemplate);

    if (player.weight + itemTemplate.weight > player.maxWeight) {
        log(getString("log_pickup_fail_weight", { itemName: itemName }));
        return;
    }
    if (player.volume + (itemTemplate.volume || 0) > player.maxVolume) {
        log(getString("log_pickup_fail_volume", { itemName: itemName }));
        return;
    }

    const objectIndex = placedObjects.findIndex(o => o === object);
    
    if (objectIndex > -1) {
        placedObjects.splice(objectIndex, 1);
        const newItem = { ...itemTemplate };
        player.inventory.push(newItem);
        player.weight += newItem.weight;
        player.volume += newItem.volume;
        log(getString("log_pickup_placed_object_success", { itemName: itemName }));
        hideItemDetail();
        drawMap();
        updateItemPanels();
        updateStatus();
    }
}

function showRecipeTooltip(item, event) {
    const preview = document.getElementById("statusPreview");
    
    const itemName = getString(`item_${item.name}_name`) || item.name;
    const itemDesc = getString(`item_${item.name}_desc`) || item.desc;

    let details = `<strong>${itemName}</strong><br><div class="item-description" style="margin-top:5px; border-bottom: 1px solid #555; padding-bottom: 5px;">${itemDesc}</div>`;

    // --- ã“ã“ã‹ã‚‰è©³ç´°ãªã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º ---
    if (item.effects) {
        if(item.effects.health) details += `<strong>${getString('status_health')}</strong> <span class="item-effect-positive">+${item.effects.health}</span><br>`;
        if(item.effects.hunger) details += `<strong>${getString('status_hunger')}</strong> <span class="item-effect-positive">+${item.effects.hunger}</span><br>`;
        if(item.effects.thirst) details += `<strong>${getString('status_thirst')}</strong> <span class="item-effect-positive">+${item.effects.thirst}</span><br>`;
        if(item.effects.morale) details += `<strong>${getString('status_morale')}</strong> <span class="item-effect-positive">+${item.effects.morale}</span><br>`;
        if(item.effects.sleep) details += `<strong>${getString('status_sleep')}</strong> <span class="item-effect-positive">+${item.effects.sleep}</span><br>`;
    }
    if (item.attack) details += `<strong>${getString('detail_label_attack_melee')}</strong> <span class="item-effect-positive">+${item.attack}</span><br>`;
    if (item.fireDamage) details += `<strong>${getString('detail_label_attack_ranged')}</strong> <span class="item-effect-positive">+${item.fireDamage}</span><br>`;
    if (item.defense) details += `<strong>${getString('detail_label_defense')}</strong> <span class="item-effect-positive">+${item.defense}</span><br>`;
    if (item.insulation) details += `<strong>${getString('detail_label_insulation')}</strong> <span class="item-effect-positive">+${item.insulation.toFixed(1)}</span><br>`;
    
    if (item.effects) {
        if (item.effects.maxWeight) details += `<strong>${getString('detail_label_max_weight')}</strong> <span class="item-effect-positive">+${item.effects.maxWeight}</span><br>`;
        if (item.effects.maxVolume) details += `<strong>${getString('detail_label_max_volume')}</strong> <span class="item-effect-positive">+${item.effects.maxVolume}</span><br>`;
    }
    
    details += `<div style="margin-top:5px; border-top: 1px solid #555; padding-top: 5px;">`;
    details += `<strong>${getString('detail_label_weight')}</strong> ${item.weight || 0}<br><strong>${getString('detail_label_volume')}</strong> ${item.volume || 0}<br>`;
    details += `</div>`;

    preview.innerHTML = details;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}

let currentStorageBox = null;
function openStoragePanel(boxObject) {
    isInteractionActive = true; currentStorageBox = boxObject;
    const storagePanel = document.getElementById('storagePanel');
    document.getElementById('storagePanelHeader').textContent = `${boxObject.name}ã®ä¸­èº«`;
    renderStorageUI();
    storagePanel.style.display = 'flex'; bringToFront(storagePanel);
}

function renderStorageUI() {
    if(!currentStorageBox) return;
    const boxArea = document.getElementById('storageBoxArea'), playerArea = document.getElementById('storagePlayerInventory');
    boxArea.innerHTML = ''; playerArea.innerHTML = '';
    document.getElementById('storageBoxTitle').textContent = `æœ¨ç®±ã®ä¸­èº« (${currentStorageBox.content.length}/${currentStorageBox.capacity})`;
    const createItemDiv = (item, source, index) => {
        const div = document.createElement('div'); div.className = 'item';
        // â–¼â–¼â–¼ ã“ã®è¡Œã‚’ä¿®æ­£ã—ã¾ã—ãŸ â–¼â–¼â–¼
        div.innerHTML = `${getIconHTML(item.graphic, 16)} ${getItemDisplayName(item)}`;
        // â–²â–²â–² ä¿®æ­£ã“ã“ã¾ã§ â–²â–²â–²
        div.onclick = () => moveStorageItem(source, index); return div;
    };
    currentStorageBox.content.forEach((item, i) => boxArea.appendChild(createItemDiv(item, 'box', i)));
    player.inventory.forEach((item, i) => playerArea.appendChild(createItemDiv(item, 'player', i)));
    const pickupBtn = document.getElementById('pickupStorageBtn');
    pickupBtn.disabled = currentStorageBox.content.length > 0;
}

function moveStorageItem(source, index) {
    if(source === 'player') {
        if(currentStorageBox.content.length < currentStorageBox.capacity) {
            const itemToStore = player.inventory.splice(index, 1)[0];
            currentStorageBox.content.push(itemToStore);
        } else { log("æœ¨ç®±ã¯ã‚‚ã†æº€æ¯ã ã€‚"); }
    } else {
        const itemToTake = currentStorageBox.content[index];
        if(player.weight + itemToTake.weight > player.maxWeight) { log("ã“ã‚Œä»¥ä¸ŠæŒã¦ãªã„ã€‚"); } 
        else if(player.volume + (itemToTake.volume || 0) > player.maxVolume) { log("å®¹é‡ãŒè¶³ã‚Šãªã„ã€‚"); } 
        else { 
            player.inventory.push(currentStorageBox.content.splice(index, 1)[0]); 
        }
    }
    updateEquippedStats(); updateStatus(); renderStorageUI();
}

function pickupStorageBox() {
    if (currentStorageBox && currentStorageBox.content.length === 0) {
        const boxItem = items.find(i => i.name === 'æœ¨ç®±');
        if (player.weight + boxItem.weight > player.maxWeight) {
            log("é‡ã™ãã¦æœ¨ç®±ã‚’æ‹¾ãˆãªã„ã€‚"); return;
        }
        if (player.volume + (boxItem.volume || 0) > player.maxVolume) {
            log("å®¹é‡ãŒè¶³ã‚Šãªãã¦æœ¨ç®±ã‚’æ‹¾ãˆãªã„ã€‚"); return;
        }
        const boxIndex = placedObjects.findIndex(o => o.x === currentStorageBox.x && o.y === currentStorageBox.y);
        if (boxIndex > -1) {
            placedObjects.splice(boxIndex, 1);
            player.inventory.push({...boxItem});
            log("ç©ºã®æœ¨ç®±ã‚’æ‹¾ã„ä¸Šã’ãŸã€‚");
            closeStoragePanel();
            drawMap(); 
            updateEquippedStats(); 
            updateStatus();
            updateItemPanels();
        }
    }
}

function closeStoragePanel() {
    document.getElementById('storagePanel').style.display = 'none';
    currentStorageBox = null; isInteractionActive = false;
    updateItemPanels();
}

// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’æ–°ã—ãè¿½åŠ  â–¼â–¼â–¼
function unloadWeapon(gunIndexInEquipment) {
    const gun = player.equipment[gunIndexInEquipment];
    if (!gun || gun.loadedAmmo <= 0) return;

    const ammoToUnloadCount = gun.loadedAmmo;
    let ammoTemplate;

    // éŠƒã®å¼¾è–¬ã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦ã€ç”Ÿæˆã™ã‚‹å¼¾è–¬ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ±ºå®š
    if (gun.ammoType === 'stone') {
        ammoTemplate = items.find(i => i.name === 'çŸ³');
    } else {
        ammoTemplate = items.find(i => i.type === 'ammo' && i.ammoType === gun.ammoType);
    }

    if (!ammoTemplate) {
        console.error(`Unload failed: Could not find ammo template for type "${gun.ammoType}"`);
        return;
    }

    const totalWeight = (ammoTemplate.weight || 0) * ammoToUnloadCount;
    const totalVolume = (ammoTemplate.volume || 0) * ammoToUnloadCount;

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå–ã‚Šå‡ºã—ãŸå¼¾è–¬ã‚’æŒã¦ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    if (player.weight + totalWeight > player.maxWeight) {
        speakAndAlert(getString("alert_unload_fail_weight"));
        return;
    }
    if (player.volume + totalVolume > player.maxVolume) {
        speakAndAlert(getString("alert_unload_fail_volume"));
        return;
    }
    
    snapshotStats();

    // å¼¾è–¬ã‚’ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã«æˆ»ã™
    for (let i = 0; i < ammoToUnloadCount; i++) {
        player.inventory.push({ ...ammoTemplate });
    }
    player.weight += totalWeight;
    player.volume += totalVolume;

    // éŠƒã®è£…å¡«æ•°ã‚’0ã«ã™ã‚‹
    gun.loadedAmmo = 0;

    log(getString("log_unload_success", { gunName: getItemDisplayName(gun), count: ammoToUnloadCount }));
    
    // UIã‚’æ›´æ–°
    updateItemPanels();
    updateEquippedStats();
    updateStatus();
    hideItemDetail();
    processSpeechQueue();
}
// â–¼â–¼â–¼ æ—¢å­˜ã®reloadWeaponFromAmmoé–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function reloadWeaponFromAmmo(ammoIndex, source) {
    const sourceArray = source === 'inventory' ? player.inventory : droppedItems[`${player.x},${player.y}`];
    const ammo = sourceArray[ammoIndex];
    if (!ammo || !ammo.ammoType) return;

    const gunToReload = player.equipment.find(gun => 
        gun.ammoType === ammo.ammoType && 
        gun.loadedAmmo < gun.ammoCapacity
    );

    if (!gunToReload) {
        return;
    }

    snapshotStats();
    let reloadedCount = 0;
    
    while (gunToReload.loadedAmmo < gunToReload.ammoCapacity) {
        const currentAmmoIndex = sourceArray.findIndex(i => i.ammoType === ammo.ammoType);
        
        if (currentAmmoIndex > -1) {
            const consumedAmmo = sourceArray.splice(currentAmmoIndex, 1)[0];
            if (source === 'inventory') {
                player.weight -= consumedAmmo.weight || 0;
                player.volume -= consumedAmmo.volume || 0;
            }
            gunToReload.loadedAmmo++;
            reloadedCount++;
        } else {
            break;
        }
    }

    // å…±é€šã®UIæ›´æ–°
    hideItemDetail();
    updateItemPanels();
    updateEquippedStats();
    updateStatus();

    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â–¼â–¼â–¼
    // æˆ¦é—˜ä¸­ã‹ã©ã†ã‹ã§å‡¦ç†ã‚’åˆ†å²
    if (currentEnemy) {
        // æˆ¦é—˜ä¸­ã®å ´åˆï¼š1ã‚¿ãƒ¼ãƒ³ã‚’æ¶ˆè²»ã—ã€æ•µã®ã‚¿ãƒ¼ãƒ³ã«ç§»è¡Œã™ã‚‹
        if (reloadedCount > 0) {
            const logText = getString("log_reload_success", { gunName: getItemDisplayName(gunToReload), count: reloadedCount });
            
            combatLogMessage(logText, 'normal', () => {
                updateCombatUI(); // ãƒœã‚¿ãƒ³ã®è¡¨ç¤ºã‚’æ›´æ–°
                enemyCombatTurn();
            });
        } else {
            // è£…å¡«ã™ã‚‹å¼¾ãŒãªã‹ã£ãŸå ´åˆã§ã‚‚ã€UIã¯æ›´æ–°ã—ã¦æ•µã®ã‚¿ãƒ¼ãƒ³ã«ã¯ã›ãšã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¡Œå‹•é¸æŠã«æˆ»ã™
            updateCombatUI();
            startPlayerTurn();
        }
    } else {
        // æˆ¦é—˜ä¸­ã§ãªã„å ´åˆï¼šé€šå¸¸ã®ãƒ­ã‚°è¡¨ç¤ºã¨éŸ³å£°ã‚­ãƒ¥ãƒ¼å‡¦ç†
        if (reloadedCount > 0) {
            log(getString("log_reload_success", { gunName: getItemDisplayName(gunToReload), count: reloadedCount }));
        }
        processSpeechQueue();
    }
    // â–²â–²â–² ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²
}
function attachBayonet(rifleIndexInEquipment) {
    const rifle = player.equipment[rifleIndexInEquipment];
    const knifeIndex = player.inventory.findIndex(i => i.name === 'ãƒŠã‚¤ãƒ•');

    if (rifle && rifle.name === 'ãƒ©ã‚¤ãƒ•ãƒ«' && knifeIndex > -1) {
        const knife = player.inventory.splice(knifeIndex, 1)[0];
        player.weight -= knife.weight;
        player.volume -= knife.volume;
        rifle.bayonetAttached = true;
        log(`${rifle.name}ã«${knife.name}ã‚’è£…ç€ã—ãŸã€‚è¿‘æ¥æ”»æ’ƒãŒå¼·åŒ–ã•ã‚Œã‚‹ã€‚`);
        updateEquippedStats();
        updateItemPanels();
        updateStatus();
        hideItemDetail();
    }
}

function ensureKnowledgeableTrader() {
    const knowledgeableTraderExists = entities.some(e => e.type === 'Trader' && e.knowsSalvationCity);
    if (!knowledgeableTraderExists) {
        const anyTrader = entities.find(e => e.type === 'Trader');
        if (anyTrader) {
            anyTrader.knowsSalvationCity = true;
        } else {
            let x, y;
            do {
                x = Math.floor(Math.random() * mapSize);
                y = Math.floor(Math.random() * mapSize);
            } while (entities.some(e => e.x === x && e.y === y) || (player.x === x && player.y === y));
            
            const newTrader = generateNPC();
            newTrader.type = 'Trader';
            newTrader.x = x;
            newTrader.y = y;
            newTrader.stunnedTurns = 0;
            newTrader.knowsSalvationCity = true;
            entities.push(newTrader);
        }
    }
}

// index.html ã® <script> ã‚¿ã‚°å†…

// â–¼â–¼â–¼ æ—¢å­˜ã®updateBackgroundColoré–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function updateBackgroundColor() {
    const hour = currentTime.getHours();
    
    // 1. ç¾åœ¨ã®æ™‚é–“ã‹ã‚‰ã€é©ç”¨ã™ã¹ãæ–°ã—ã„ã‚¯ãƒ©ã‚¹åã‚’æ±ºå®š
    let newClass = '';
    if (hour >= 5 && hour <= 8) {
        newClass = 'bg-morning';
    } else if (hour >= 9 && hour <= 16) {
        newClass = 'bg-day';
    } else if (hour >= 17 && hour <= 19) {
        newClass = 'bg-evening';
    } else {
        newClass = 'bg-night';
    }

    // 2. ã‚‚ã—ã‚¯ãƒ©ã‚¹åãŒå¤‰ã‚ã£ã¦ã„ãªã‘ã‚Œã°ã€ä½•ã‚‚ã—ãªã„
    if (newClass === currentTimeOfDayClass) {
        return;
    }

    // 3. ç¾åœ¨è¡¨ç¤ºã•ã‚Œã¦ã„ãªã„æ–¹ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å–å¾—
    const inactiveLayerIndex = activeBgLayer === 1 ? 2 : 1;
    const activeLayer = document.getElementById(`background-layer-${activeBgLayer}`);
    const inactiveLayer = document.getElementById(`background-layer-${inactiveLayerIndex}`);

    // 4. è¡¨ç¤ºã•ã‚Œã¦ã„ãªã„ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ã€æ–°ã—ã„èƒŒæ™¯ç”»åƒã‚¯ãƒ©ã‚¹ã‚’è¨­å®š
    inactiveLayer.className = `background-layer ${newClass}`;
    
    // 5. æ–°ã—ã„ç”»åƒã‚’è¡¨ç¤ºã•ã›ã€å¤ã„ç”»åƒã‚’ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã•ã›ã‚‹
    inactiveLayer.style.opacity = 1;
    activeLayer.style.opacity = 0;

    // 6. çŠ¶æ…‹ã‚’æ›´æ–°
    activeBgLayer = inactiveLayerIndex; // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’åˆ‡ã‚Šæ›¿ãˆ
    currentTimeOfDayClass = newClass;   // ç¾åœ¨ã®ã‚¯ãƒ©ã‚¹åã‚’æ›´æ–°
}
// â–²â–²â–² ç½®ãæ›ãˆã¯ã“ã“ã¾ã§ â–²â–²â–²

// MODIFIED FUNCTION
function butcherAnimalCorpse() {
    if (isStunnedByPain()) { return; }
    const corpse = currentItemDetail.item;
    if (!corpse || !corpse.unbutchered) return;

    const blade = player.inventory.find(i => i.isBlade) || player.equipment.find(i => i.isBlade);
    if (!blade) {
        log(getString("log_butcher_need_blade"), true);
        return;
    }
    
    snapshotStats();
    
    const bladeName = getItemDisplayName(blade);
    const corpseName = getString(`item_${corpse.name}_name`) || corpse.name;
    log(getString("log_butcher_start", { bladeName: bladeName, corpseName: corpseName }), true);
    
    let itemsFound = [];
    const meatTemplate = items.find(i => i.name === 'ç”Ÿè‚‰');
    const furTemplate = items.find(i => i.name === 'æ¯›çš®');
    
    if (meatTemplate && corpse.potentialLoot.meat > 0) {
        for (let i = 0; i < corpse.potentialLoot.meat; i++) { itemsFound.push({...meatTemplate}); }
        log(getString("log_butcher_meat", { count: corpse.potentialLoot.meat }), true);
    }
    if (furTemplate && corpse.potentialLoot.fur > 0) {
        for (let i = 0; i < corpse.potentialLoot.fur; i++) { itemsFound.push({...furTemplate}); }
        log(getString("log_butcher_fur", { count: corpse.potentialLoot.fur }), true);
    }

    const locationKey = `${player.x},${player.y}`;
    if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
    itemsFound.forEach(item => droppedItems[locationKey].push(item));
    
    const corpseIndex = placedObjects.findIndex(p => p === corpse);
    if (corpseIndex > -1) {
        const newCorpseObject = { 
            ...corpse, 
            unbutchered: false, 
            graphic: BONES_IMG // <<< éª¨ã®ç”»åƒã«å¤‰æ›´
        };
        placedObjects.splice(corpseIndex, 1, newCorpseObject);
    }

    hideItemDetail();
    endPlayerTurn();
    updateCurrentLocationPanel(false);
    updateStatus();
    updateCharacterBody();
    updateTurnInfo();
    processSpeechQueue(); // speech queue
}

// MODIFIED FUNCTION
function searchHumanCorpse() {
    if (isStunnedByPain()) { return; }
    const corpse = currentItemDetail.item;
    if (!corpse || !corpse.unsearched) return;
    snapshotStats();
    
    const corpseName = getString(`item_${corpse.name}_name`) || corpse.name;
    log(getString("log_search_corpse", { corpseName: corpseName }), true);

    const locationKey = `${player.x},${player.y}`;
    if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
    
    if (corpse.potentialLoot && corpse.potentialLoot.length > 0) {
        corpse.potentialLoot.forEach(item => { droppedItems[locationKey].push(item); });
        log(getString("log_corpse_found_items"), true);
    } else {
        log(getString("log_corpse_found_nothing"), true);
    }

    const corpseIndex = placedObjects.findIndex(p => p === corpse);
    if (corpseIndex > -1) {
        const newCorpseObject = { 
            ...corpse, 
            unsearched: false, 
            graphic: BONES_IMG // <<< éª¨ã®ç”»åƒã«å¤‰æ›´
        };
        placedObjects.splice(corpseIndex, 1, newCorpseObject);
    }

    hideItemDetail();
    endPlayerTurn();
    updateCurrentLocationPanel(false);
    updateStatus();
    updateCharacterBody();
    updateTurnInfo();
    processSpeechQueue(); // speech queue
}

// â–¼â–¼â–¼ searchHumanCorpseé–¢æ•°ã‚’ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function searchHumanCorpse() {
    if (isStunnedByPain()) { return; }
    const corpse = currentItemDetail.item;
    if (!corpse || !corpse.unsearched) return;
    snapshotStats();
    
    const corpseName = getString(`item_${corpse.name}_name`) || corpse.name;
    log(getString("log_search_corpse", { corpseName: corpseName }), true);

    const locationKey = `${player.x},${player.y}`;
    if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
    
    if (corpse.potentialLoot && corpse.potentialLoot.length > 0) {
        corpse.potentialLoot.forEach(item => { droppedItems[locationKey].push(item); });
        log(getString("log_corpse_found_items"), true);
    } else {
        log(getString("log_corpse_found_nothing"), true);
    }

    const corpseIndex = placedObjects.findIndex(p => p === corpse);
    if (corpseIndex > -1) {
        const newCorpseObject = { 
            ...corpse, 
            unsearched: false, 
            graphic: HUMAN_CORPSE_IMG // â–¼â–¼â–¼ ä¿®æ­£ â–¼â–¼â–¼
        };
        placedObjects.splice(corpseIndex, 1, newCorpseObject);
    }

    hideItemDetail();
    advanceTurn();
    updateCurrentLocationPanel(false);
    updateStatus();
    updateCharacterBody();
    updateTurnInfo();
}

// â–¼â–¼â–¼ ã“ã®é–¢æ•°å…¨ä½“ã‚’ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function applySplint(item, itemIndex, source) {
    const fracture = player.injuries.find(i => i.type === 'fracture' && !i.splinted);
    if (fracture) {
        fracture.splinted = true;
        log(getString("log_splint_applied"), true); // â˜…ä¿®æ­£ç‚¹: ç¿»è¨³ã‚­ãƒ¼ã‚’ä½¿ç”¨

        // â˜…ä¿®æ­£ç‚¹: ã‚¢ã‚¤ãƒ†ãƒ ã®å ´æ‰€(source)ã«å¿œã˜ã¦æ­£ã—ã„é…åˆ—ã‹ã‚‰ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ¶ˆè²»ã™ã‚‹
        const sourceArray = source === 'inventory' ? player.inventory : droppedItems[`${player.x},${player.y}`];
        const removedItem = sourceArray.splice(itemIndex, 1)[0];

        // â˜…ä¿®æ­£ç‚¹: æ‰€æŒå“ã‹ã‚‰æ¶ˆè²»ã—ãŸå ´åˆã®ã¿ã€é‡é‡ã¨å®¹é‡ã‚’æ›´æ–°ã™ã‚‹
        if (source === 'inventory' && removedItem) {
            player.weight -= removedItem.weight || 0;
            player.volume -= removedItem.volume || 0;
        }

        updateItemPanels();
        updateStatus();
        hideItemDetail();
        processSpeechQueue(); // â˜…ä¿®æ­£ç‚¹: æ­£ã—ã„é–¢æ•°åã«å¤‰æ›´
    } else {
        log(getString("log_splint_not_needed")); // â˜…ä¿®æ­£ç‚¹: ç¿»è¨³ã‚­ãƒ¼ã‚’ä½¿ç”¨
        processSpeechQueue(); // â˜…ä¿®æ­£ç‚¹: æ­£ã—ã„é–¢æ•°åã«å¤‰æ›´
    }
}

function cureSickness(sicknessType, medicineName, itemIndex, source) {
    const sickness = player.sicknesses.find(s => s.type === sicknessType);
    if (sickness) {
        log(`${medicineName}ã‚’æœç”¨ã—ãŸã€‚å°‘ã—æ¥½ã«ãªã£ãŸã‚ˆã†ã ã€‚`, true);
        sickness.medicated_duration = 6; 
        
        // â˜…â˜…â˜…ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™â˜…â˜…â˜…
        // ã‚¢ã‚¤ãƒ†ãƒ ã®å ´æ‰€(source)ã«å¿œã˜ã¦ã€æ­£ã—ã„é…åˆ—ã‹ã‚‰ã‚¢ã‚¤ãƒ†ãƒ ã‚’å‰Šé™¤ã™ã‚‹
        const sourceArray = source === 'inventory' ? player.inventory : droppedItems[`${player.x},${player.y}`];
        const removedItem = sourceArray.splice(itemIndex, 1)[0];

        // ã‚¢ã‚¤ãƒ†ãƒ ãŒæ‰€æŒå“(inventory)ã‹ã‚‰æ¶ˆè²»ã•ã‚ŒãŸå ´åˆã®ã¿ã€é‡é‡ã¨å®¹é‡ã‚’æ›´æ–°ã™ã‚‹
        if (removedItem && source === 'inventory') {
            player.weight -= removedItem.weight;
            player.volume -= removedItem.volume;
        }
        // â˜…â˜…â˜…ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™â˜…â˜…â˜…

        updateItemPanels();
        updateStatus();
        hideItemDetail();
        speakQueuedLogs();
    } else {
        log(`${medicineName}ã‚’é£²ã‚€å¿…è¦ã¯ãªã„ã‚ˆã†ã ã€‚`);
        speakQueuedLogs();
    }
}
// index.html å†…

function repairItemWithTape(tapeIndex) {
    const repairableItems = [...player.equipment, ...player.inventory].filter(i =>
        (i.type === 'equipment' || i.type === 'clothing' || i.type === 'tool') &&
        i.durability !== undefined && i.durability < 100
    );

    if (repairableItems.length === 0) {
        log(getString("log_repair_no_items"));
        return;
    }

    hideItemDetail();

    const modalDiv = document.createElement("div");
    modalDiv.id = "repairModal";
    modalDiv.style.cssText = `position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #222; color: white; padding: 20px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.6); z-index: 1001; max-height: 80vh; display: flex; flex-direction: column;`;
    
    modalDiv.innerHTML = `<h3 style="margin-top:0; padding-bottom:10px; border-bottom:1px solid #555;">${getString("repair_select_title")}</h3>`;

    const itemListDiv = document.createElement("div");
    itemListDiv.className = "item-list";
    itemListDiv.style.maxHeight = "60vh";

    repairableItems.forEach(itemToRepair => {
        const itemDiv = document.createElement("div");
        itemDiv.className = "item";
        itemDiv.innerHTML = `${getIconHTML(itemToRepair.graphic, 16)} ${getItemDisplayName(itemToRepair)} (${getString("item_info_durability")}: ${itemToRepair.durability.toFixed(0)}%)`;
        itemDiv.onclick = () => {
            executeRepair(itemToRepair, tapeIndex);
            document.body.removeChild(modalDiv);
        };
        itemListDiv.appendChild(itemDiv);
    });
    
    modalDiv.appendChild(itemListDiv);

    const cancelBtn = document.createElement("button");
    cancelBtn.textContent = getString("trade_cancel");
    cancelBtn.style.cssText = `margin-top: 15px; padding: 8px 15px; background: #444; color: #eee; border: none; border-radius: 5px; cursor: pointer;`;
    cancelBtn.onclick = () => document.body.removeChild(modalDiv);
    
    modalDiv.appendChild(cancelBtn);
    document.body.appendChild(modalDiv);
}

function executeRepair(itemToRepair, tapeIndex) {
    const repairAmount = 50;
    const originalDurability = itemToRepair.durability;
    itemToRepair.durability = Math.min(100, itemToRepair.durability + repairAmount);

    log(`ãƒ€ã‚¯ãƒˆãƒ†ãƒ¼ãƒ—ã‚’ä½¿ã£ã¦${getItemDisplayName(itemToRepair)}ã‚’ä¿®ç†ã—ãŸã€‚(è€ä¹…åº¦: ${originalDurability.toFixed(0)}% -> ${itemToRepair.durability.toFixed(0)}%)`);

    // ãƒ€ã‚¯ãƒˆãƒ†ãƒ¼ãƒ—ã‚’æ¶ˆè²»
    const removedTape = player.inventory.splice(tapeIndex, 1)[0];
    player.weight -= removedTape.weight;
    player.volume -= removedTape.volume;

    updateItemPanels();
    updateStatus();
    speakQueuedLogs(); // ã€è¿½åŠ ã€‘
}


function cureFoodPoisoning(item, itemIndex, source) {
    cureSickness('food_poisoning', 'èƒƒè…¸è–¬', itemIndex, source);
}

function cureDiarrhea(item, itemIndex, source) {
    cureSickness('diarrhea', 'ä¸‹ç—¢æ­¢ã‚', itemIndex, source);
}

function cureFever(item, itemIndex, source) {
    cureSickness('fever', 'è§£ç†±å‰¤', itemIndex, source);
}

function cureInfection(item, itemIndex, source) {
    const infection = player.sicknesses.find(s => s.type === 'infection');
    if (infection) {
        log(getString("log_cure_infection_success", { itemName: getItemDisplayName(item) }), true);
        
        player.sicknesses = player.sicknesses.filter(s => s.type !== 'infection');
        
        // â˜…â˜…â˜…ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™â˜…â˜…â˜…
        const sourceArray = source === 'inventory' ? player.inventory : droppedItems[`${player.x},${player.y}`];
        const removedItem = sourceArray.splice(itemIndex, 1)[0];

        if (removedItem && source === 'inventory') {
            player.weight -= removedItem.weight;
            player.volume -= removedItem.volume;
        }
        // â˜…â˜…â˜…ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™â˜…â˜…â˜…
        
        updateItemPanels();
        updateStatus();
        hideItemDetail();
    } else {
        log(getString("log_cure_infection_fail"), true);
    }
}
function cureItch(item, itemIndex, source) {
    const itch = player.sicknesses.find(s => s.type === 'itch');
    if (itch) {
        log(getString("log_cure_itch_success", { itemName: getItemDisplayName(item) }), true);
        
        player.sicknesses = player.sicknesses.filter(s => s.type !== 'itch');
        
        // â˜…â˜…â˜…ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™â˜…â˜…â˜…
        const sourceArray = source === 'inventory' ? player.inventory : droppedItems[`${player.x},${player.y}`];
        const removedItem = sourceArray.splice(itemIndex, 1)[0];

        if (removedItem && source === 'inventory') {
            player.weight -= removedItem.weight;
            player.volume -= removedItem.volume;
        }
        // â˜…â˜…â˜…ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™â˜…â˜…â˜…
        
        updateItemPanels();
        updateStatus();
        hideItemDetail();
    } else {
        log(getString("log_cure_itch_fail"), true);
    }
}

function gatherLog() {
    if (isStunnedByPain()) { return; }
    snapshotStats();
    let tile = map[player.y][player.x];
    if (Math.random() < 0.5) {
        log(getString("log_gather_log_fail"));
    } else {
        const logItemTemplate = items.find(i => i.name === 'ä¸¸å¤ª');
        const newItem = { ...logItemTemplate };
        if (player.weight + newItem.weight > player.maxWeight || player.volume + newItem.volume > player.maxVolume) {
            log(getString("log_gather_log_grounded"));
            const locationKey = `${player.x},${player.y}`;
            if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
            droppedItems[locationKey].push(newItem);
        } else {
            log(getString("log_gather_log_success"));
            player.inventory.push(newItem);
            player.weight += newItem.weight;
            player.volume += newItem.volume;
        }
        tile.logSupply--;
    }
    endPlayerTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    updateTurnInfo();
    checkGameOver();
    updateCurrentLocationPanel(false);
}

function placeBarricade(recipe) {
    if (placedObjects.some(o => o.x === player.x && o.y === player.y)) {
        log("ã“ã“ã«ã¯æ—¢ã«ä½•ã‹è¨­ç½®ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€ãƒãƒªã‚±ãƒ¼ãƒ‰ã‚’è¨­ç½®ã§ããªã„ã€‚");
        return;
    }
    snapshotStats();
    log("ä¸¸å¤ªã‚’æ¶ˆè²»ã—ã¦ãƒãƒªã‚±ãƒ¼ãƒ‰ã‚’è¨­ç½®ã—ãŸã€‚");
    createSound(player.x, player.y, 6);
    
    for (let i = 0; i < recipe.ingredients[0].count; i++) {
        const logIndex = player.inventory.findIndex(item => item.name === 'ä¸¸å¤ª');
        if (logIndex > -1) {
            const removedLog = player.inventory.splice(logIndex, 1)[0];
            player.weight -= removedLog.weight;
            player.volume -= removedLog.volume;
        }
    }

    placedObjects.push({ 
        x: player.x, 
        y: player.y, 
        type: 'barricade', 
        name: 'ãƒãƒªã‚±ãƒ¼ãƒ‰', 
        graphic: 'ğŸš§', 
        health: 100,
        maxHealth: 100 
    });

    advanceTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    updateTurnInfo();
    checkGameOver();
    updateCurrentLocationPanel(false);
}

// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function placeBarricadeItem(item, itemIndex, source) {
    if (isStunnedByPain()) { return; }
    if (placedObjects.find(o => o.x === player.x && o.y === player.y)) { 
        log(`ã“ã“ã«ã¯æ—¢ã«ä½•ã‹ãŒè¨­ç½®ã•ã‚Œã¦ã„ã‚‹ã€‚`); 
        return; 
    }
    
    snapshotStats();
    
    const removedItem = player.inventory.splice(itemIndex, 1)[0];
    player.weight -= removedItem.weight;
    player.volume -= removedItem.volume;
    
    log("ãƒãƒªã‚±ãƒ¼ãƒ‰ã‚’è¨­ç½®ã—ãŸã€‚");
    createSound(player.x, player.y, 6);
    
    // â–¼â–¼â–¼ ã“ã®è¡Œã‚’ä¿®æ­£ã—ã¾ã—ãŸ â–¼â–¼â–¼
    placedObjects.push({ 
        x: player.x, 
        y: player.y, 
        type: 'barricade', 
        name: 'ãƒãƒªã‚±ãƒ¼ãƒ‰', 
        graphic: 'images/barricade.png', 
        health: 100,
        maxHealth: 100 
    });
    // â–²â–²â–² ä¿®æ­£ã“ã“ã¾ã§ â–²â–²â–²
    
    drawMap();
    updateItemPanels();
    updateStatus();
    hideItemDetail();
}
// â–¼â–¼â–¼ ã“ã“ã‹ã‚‰4ã¤ã®é–¢æ•°ã‚’ã¾ã¨ã‚ã¦è¿½åŠ  â–¼â–¼â–¼
/**
 * ä¹¾ç‡¥ãƒ©ãƒƒã‚¯ã‚’åœ°é¢ã«è¨­ç½®ã™ã‚‹
 */
function placeDryingRack(item, itemIndex, source) {
    if (isStunnedByPain()) { return; }
    const currentTile = map[player.y][player.y];
    const forbiddenBiomes = ['Town', 'Commercial', 'Industrial', 'Residential', 'Road'];

    if (placedObjects.find(o => o.x === player.x && o.y === player.y) || forbiddenBiomes.includes(currentTile.biome)) {
        log(getString("log_cannot_place_here")); // æ±ç”¨çš„ãªè¨­ç½®ä¸å¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
        return;
    }

    snapshotStats();
    
    const sourceArray = source === 'inventory' ? player.inventory : droppedItems[`${player.x},${player.y}`];
    const removedItem = sourceArray.splice(itemIndex, 1)[0];

    if (source === 'inventory') {
        player.weight -= removedItem.weight;
        player.volume -= removedItem.volume;
    }

    log(getString("log_place_drying_rack"));
    placedObjects.push({ 
        x: player.x, 
        y: player.y, 
        type: 'drying_rack', 
        name: 'drying_rack', // â–¼â–¼â–¼ ã“ã“ã‚’å¤‰æ›´ â–¼â–¼â–¼
        graphic: 'images/drying_rack.png', 
        content: [] // ä¹¾ç‡¥ä¸­ã®è‚‰ã‚’ä¿å­˜ã™ã‚‹é…åˆ—
    });
    
    hideItemDetail();
    endPlayerTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCurrentLocationPanel(false);
}

/**
 * ä¹¾ç‡¥ãƒ©ãƒƒã‚¯ã«ç”Ÿè‚‰ã‚’è¿½åŠ ã™ã‚‹UIã‚’è¡¨ç¤ºã™ã‚‹
 */
function showAddMeatToRackUI(rack) {
    const locationKey = `${player.x},${player.y}`;
    const availableRawMeat = [
        ...player.inventory.filter(i => i.name === 'ç”Ÿè‚‰'),
        ...(droppedItems[locationKey] || []).filter(i => i.name === 'ç”Ÿè‚‰')
    ];
    
    const spaceLeft = 5 - rack.content.length;

    if (availableRawMeat.length === 0) {
        log(getString("log_no_raw_meat_to_dry"));
        return;
    }
    if (spaceLeft === 0) {
        log(getString("log_drying_rack_full"));
        return;
    }

    const maxAdd = Math.min(availableRawMeat.length, spaceLeft);
    
    // prompt()ã®ä»£ã‚ã‚Šã«æ–°ã—ã„ãƒ¢ãƒ¼ãƒ€ãƒ«é–¢æ•°ã‚’å‘¼ã³å‡ºã™
    showInputModal(
        getString("prompt_how_many_meat_to_add", { count: maxAdd }), // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
        "1", // åˆæœŸå€¤
        maxAdd, // æœ€å¤§å€¤
        (meatToAdd) => { // OKãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚ŒãŸå¾Œã®å‡¦ç†
            addMeatToRack(rack, meatToAdd);
        }
    );
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
/**
 * ç”Ÿè‚‰ã®è©³ç´°ãƒ‘ãƒãƒ«ã‹ã‚‰ã€1ã¤ã®ç”Ÿè‚‰ã‚’ä¹¾ç‡¥ãƒ©ãƒƒã‚¯ã«è¿½åŠ ã™ã‚‹
 */
function addSingleMeatToRack(item, itemIndex, source) {
    const rack = placedObjects.find(o => o.x === player.x && o.y === player.y && o.type === 'drying_rack');
    if (!rack) return;

    if (rack.content.length >= 5) {
        log(getString("log_drying_rack_full"));
        return;
    }
    
    snapshotStats();
    
    // ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ¶ˆè²»
    const sourceArray = source === 'inventory' ? player.inventory : droppedItems[`${player.x},${player.y}`];
    const removedMeat = sourceArray.splice(itemIndex, 1)[0];
    if (source === 'inventory') {
        player.weight -= removedMeat.weight;
        player.volume -= removedMeat.volume;
    }

    // ãƒ©ãƒƒã‚¯ã«è¿½åŠ 
    rack.content.push({ name: 'ç”Ÿè‚‰', turnsLeft: 5 }); // 5ã‚¿ãƒ¼ãƒ³å¾Œã«å®Œæˆ
    log(getString("log_added_meat_to_rack", { count: 1 }));
    
    hideItemDetail();

    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â–¼â–¼â–¼
    // advanceTurn() ã‚’å‰Šé™¤ã—ã€ã‚¿ãƒ¼ãƒ³ã‚’æ¶ˆè²»ã—ãªã„UIæ›´æ–°é–¢æ•°ã‚’å‘¼ã³å‡ºã™
    refreshGameState();
    // â–²â–²â–² ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²
}
/**
 * å®Ÿéš›ã«ä¹¾ç‡¥ãƒ©ãƒƒã‚¯ã«ç”Ÿè‚‰ã‚’è¿½åŠ ã™ã‚‹å‡¦ç†
 */
function addMeatToRack(rack, count) {
    if (isStunnedByPain()) { return; }
    snapshotStats();
    let addedCount = 0;
    for (let i = 0; i < count; i++) {
        // ã¾ãšã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã‹ã‚‰æ¢ã™
        const invIndex = player.inventory.findIndex(item => item.name === 'ç”Ÿè‚‰');
        if (invIndex > -1) {
            const removedMeat = player.inventory.splice(invIndex, 1)[0];
            player.weight -= removedMeat.weight;
            player.volume -= removedMeat.volume;
        } else {
            // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã«ãªã‘ã‚Œã°åœ°é¢ã‹ã‚‰æ¢ã™
            const locationKey = `${player.x},${player.y}`;
            const groundIndex = (droppedItems[locationKey] || []).findIndex(item => item.name === 'ç”Ÿè‚‰');
            if (groundIndex > -1) {
                droppedItems[locationKey].splice(groundIndex, 1);
            }
        }
        rack.content.push({ name: 'ç”Ÿè‚‰', turnsLeft: 5 });
        addedCount++;
    }

    log(getString("log_added_meat_to_rack", { count: addedCount }));
    
    hideItemDetail();
    endPlayerTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCurrentLocationPanel(false);
}

/**
 * ä¹¾ç‡¥ãƒ©ãƒƒã‚¯ã‹ã‚‰å®Œæˆã—ãŸå¹²ã—è‚‰ã‚’å›åã™ã‚‹
 */
function takeDriedMeatFromRack(rack) {
    snapshotStats();
    const driedMeatTemplate = items.find(i => i.name === 'dried_meat');
    if (!driedMeatTemplate) return;

    let collectedCount = 0;
    const remainingContent = [];

    rack.content.forEach(item => {
        if (item.turnsLeft <= 0) {
            const newItem = { ...driedMeatTemplate };
            if (player.weight + newItem.weight > player.maxWeight || player.volume + (newItem.volume || 0) > player.maxVolume) {
                const locationKey = `${player.x},${player.y}`;
                if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
                droppedItems[locationKey].push(newItem);
            } else {
                player.inventory.push(newItem);
                player.weight += newItem.weight;
                player.volume += newItem.volume;
            }
            collectedCount++;
        } else {
            remainingContent.push(item);
        }
    });

    rack.content = remainingContent;
    
    log(getString("log_collected_dried_meat", { count: collectedCount }));

    hideItemDetail();
    updateItemPanels();
    updateStatus();
    updateCurrentLocationPanel(false);
}
// â–²â–²â–² 4ã¤ã®é–¢æ•°è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²
function dismantleBarricade() {
    if (isStunnedByPain()) { return; }
    const barricadeObject = currentItemDetail.item;
    if (!barricadeObject || barricadeObject.type !== 'barricade') return;
    
    log("æ–§ã‚’ä½¿ã„ã€ãƒãƒªã‚±ãƒ¼ãƒ‰ã‚’è§£ä½“ã—ã¦ã‚¢ã‚¤ãƒ†ãƒ ã«æˆ»ã—ãŸã€‚");

    const barricadeItem = items.find(i => i.name === 'ãƒãƒªã‚±ãƒ¼ãƒ‰');
    if (barricadeItem) {
        const newItem = { ...barricadeItem };

        if (player.weight + newItem.weight > player.maxWeight || player.volume + newItem.volume > player.maxVolume) {
            log("é‡ã•ã‹å®¹é‡ãŒè¶³ã‚Šãªãã¦æŒã¦ãªã„ãŸã‚ã€åœ°é¢ã«ç½®ã„ãŸã€‚");
            const locationKey = `${barricadeObject.x},${barricadeObject.y}`;
            if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
            droppedItems[locationKey].push(newItem);
        } else {
            log("ãƒãƒªã‚±ãƒ¼ãƒ‰ã‚’æ‰€æŒå“ã«åŠ ãˆãŸã€‚");
            player.inventory.push(newItem);
            player.weight += newItem.weight;
            player.volume += newItem.volume;
        }
    }

    const objectIndex = placedObjects.findIndex(o => o === barricadeObject);
    if (objectIndex > -1) {
        placedObjects.splice(objectIndex, 1);
    }
    
    hideItemDetail();
    advanceTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCurrentLocationPanel(false);
}

function dismantleItem(itemIndex, source) {
    const sourceArray = source === 'inventory' ? player.inventory : droppedItems[`${player.x},${player.y}`];
    const itemToDismantle = sourceArray[itemIndex];
    if (!itemToDismantle) return;
    const recipe = dismantleRecipes[itemToDismantle.name];
    if (!recipe) {
        log(getString("log_dismantle_cannot"));
        return;
    }
    log(getString("log_dismantle_success", { itemName: getItemDisplayName(itemToDismantle) }));
    const removedItem = sourceArray.splice(itemIndex, 1)[0];
    player.weight -= removedItem.weight || 0;
    if (source === 'inventory') player.volume -= removedItem.volume || 0;
    
    recipe.forEach(result => {
        const materialTemplate = items.find(i => i.name === result.name);
        if (materialTemplate) {
            for (let i = 0; i < result.count; i++) {
                const newItem = { ...materialTemplate };
                if (player.weight + newItem.weight <= player.maxWeight && player.volume + newItem.volume <= player.maxVolume) {
                    player.inventory.push(newItem);
                    player.weight += newItem.weight || 0;
                    player.volume += newItem.volume || 0;
                    log(getString("log_dismantle_result", { itemName: getItemDisplayName(newItem) }));
                } else {
                    const locationKey = `${player.x},${player.y}`;
                    if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
                    droppedItems[locationKey].push(newItem);
                    log(getString("log_dismantle_grounded", { itemName: getItemDisplayName(newItem) }));
                }
            }
        }
    });
    hideItemDetail(); updateEquippedStats(); updateItemPanels(); updateStatus(); updateCurrentLocationPanel(false);
}

function wipeClothes(item, itemIndex, source) {
    const soakingWetClothes = player.equipment.filter(e => e.type === 'clothing' && e.wetness === 'soaking_wet');
    if (soakingWetClothes.length === 0) {
        log(getString("log_wipe_clothes_not_needed"));
        hideItemDetail();
        return;
    }

    log(getString("log_wipe_clothes_success", { itemName: getItemDisplayName(item) }));
    soakingWetClothes.forEach(cloth => {
        cloth.wetness = 'wet';
    });

    updateItemPanels();
    updateStatus();
    hideItemDetail();
}
function wringCloth(item, itemIndex, source) {
    if (isStunnedByPain()) { return; }
    if (item.wetness !== 'soaking_wet') {
        log(getString("log_wring_not_needed"));
        hideItemDetail();
        return;
    }
    snapshotStats();
    log(getString("log_wring_clothes", { itemName: getItemDisplayName(item) }));
    item.wetness = 'wet';
    hideItemDetail();
    endPlayerTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    updateTurnInfo();
    checkGameOver();
    updateCurrentLocationPanel(false);
}

// --- NEW Vision and Sound Functions ---
function getDistance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’æ–°ã—ãè¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
/**
 * ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘¨å›²ã«ã‚ã‚‹ã€æ•µãŒãŠã‚‰ãšç§»å‹•å¯èƒ½ãªå®‰å…¨ãªã‚¿ã‚¤ãƒ«ã‚’æ¢ã™
 * @returns {object|null} - å®‰å…¨ãªã‚¿ã‚¤ãƒ«ã®åº§æ¨™ {x, y} ã¾ãŸã¯ null
 */
function findSafeFleeTile() {
    const fleeRadius = 2; // é€ƒèµ°ã™ã‚‹ç¯„å›²ï¼ˆå‘¨å›²2ãƒã‚¹ï¼‰
    let safeTiles = [];

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘¨å›²ã®ãƒã‚¹ã‚’ãƒã‚§ãƒƒã‚¯
    for (let y = player.y - fleeRadius; y <= player.y + fleeRadius; y++) {
        for (let x = player.x - fleeRadius; x <= player.x + fleeRadius; x++) {
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç¾åœ¨åœ°ã¨ã€ãƒãƒƒãƒ—ç¯„å›²å¤–ã¯é™¤å¤–
            if ((x === player.x && y === player.y) || x < 0 || y < 0 || x >= mapSize || y >= mapSize) {
                continue;
            }

            // ãã®ãƒã‚¹ã«ä»–ã®ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãŒã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯
            const isOccupied = entities.some(e => e.x === x && e.y === y);
            // ãã®ãƒã‚¹ãŒé€šè¡Œå¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆå£ãªã©ã‚’é¿ã‘ã‚‹ï¼‰
            const isPassable = !map[y][x].loc.blocksVision;

            if (!isOccupied && isPassable) {
                safeTiles.push({ x: x, y: y });
            }
        }
    }

    if (safeTiles.length > 0) {
        return randChoice(safeTiles); // å®‰å…¨ãªãƒã‚¹ã®ä¸­ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«1ã¤é¸ã‚“ã§è¿”ã™
    } else {
        return null; // å®‰å…¨ãªãƒã‚¹ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆ
    }
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’æ–°ã—ãè¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
/**
 * æŒ‡å®šã•ã‚ŒãŸã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®å‘¨å›²ã«ã‚ã‚‹ã€ç§»å‹•å¯èƒ½ãªå®‰å…¨ãªã‚¿ã‚¤ãƒ«ã‚’æ¢ã™
 * @param {object} entity - å¯¾è±¡ã®ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£
 * @returns {object|null} - å®‰å…¨ãªã‚¿ã‚¤ãƒ«ã®åº§æ¨™ {x, y} ã¾ãŸã¯ null
 */
function findSafeFleeTileForEntity(entity) {
    const fleeRadius = 1; // éš£æ¥ã™ã‚‹ãƒã‚¹ã®ã¿ã‚’å¯¾è±¡
    let safeTiles = [];

    for (let y = entity.y - fleeRadius; y <= entity.y + fleeRadius; y++) {
        for (let x = entity.x - fleeRadius; x <= entity.x + fleeRadius; x++) {
            if ((x === entity.x && y === entity.y) || x < 0 || y < 0 || x >= mapSize || y >= mapSize) {
                continue;
            }

            const isOccupiedByOther = entities.some(e => e !== entity && e.x === x && e.y === y);
            const isPlayerOccupied = (player.x === x && player.y === y);
            const isPassable = !map[y][x].loc.blocksVision;

            if (!isOccupiedByOther && !isPlayerOccupied && isPassable) {
                safeTiles.push({ x: x, y: y });
            }
        }
    }

    if (safeTiles.length > 0) {
        return randChoice(safeTiles);
    } else {
        return null; // å®‰å…¨ãªãƒã‚¹ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆ
    }
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function hasLineOfSight(x1, y1, x2, y2) {
    let dx = Math.abs(x2 - x1);
    let dy = -Math.abs(y2 - y1);
    let sx = x1 < x2 ? 1 : -1;
    let sy = y1 < y2 ? 1 : -1;
    let err = dx + dy;

    let currentX = x1;
    let currentY = y1;

    while (true) {
        // ç›®çš„åœ°ã‚¿ã‚¤ãƒ«è‡ªä½“ã¯è¦–ç•Œã‚’é®ã‚‹éšœå®³ç‰©ã¨ã¯è¦‹ãªã•ãªã„ãŸã‚ã€ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹
        if (currentX === x2 && currentY === y2) {
            break;
        }

        // é–‹å§‹ç‚¹ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ï¼‰ä»¥å¤–ã®ä¸­é–“ã‚¿ã‚¤ãƒ«ãŒè¦–ç•Œã‚’é®ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        const isStartPoint = (currentX === x1 && currentY === y1);
        if (!isStartPoint && map[currentY][currentX].loc.blocksVision) {
            return false;
        }
        
        let e2 = 2 * err;
        if (e2 >= dy) {
            err += dy;
            currentX += sx;
        }
        if (e2 <= dx) {
            err += dx;
            currentY += sy;
        }
    }
    return true;
}
/**
 * ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®5ãƒã‚¹å‘¨è¾ºã«ã‚ã‚‹æ­»ä½“ã‚’æ¤œçŸ¥ã—ã€ã‚«ãƒ©ã‚¹ã®é³´ãå£°åŠ¹æœéŸ³ã‚’ä¸€åº¦ã ã‘å†ç”Ÿã™ã‚‹ã€‚
 * ä¸€åº¦ç¯„å›²å¤–ã«å‡ºã‚‹ã¨ã€å†åº¦å†ç”Ÿã§ãã‚‹ã‚ˆã†ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹ã€‚
 */
function checkNearbyCorpsesForSound() {
    const checkRadius = 5; // æ¤œçŸ¥ç¯„å›²ï¼ˆ5ãƒã‚¹ï¼‰

    // placedObjectså†…ã®å…¨ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒã‚§ãƒƒã‚¯
    placedObjects.forEach(obj => {
        // ã‚¿ã‚¤ãƒ—ãŒ 'corpse' ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆã‚ã‚‰ã‚†ã‚‹æ­»ä½“ãƒ»æ­»éª¸ï¼‰ã®ã¿ã‚’å¯¾è±¡ã¨ã™ã‚‹
        if (obj.type === 'corpse') {
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è·é›¢ã‚’è¨ˆç®—ï¼ˆãƒã‚§ãƒ“ã‚·ã‚§ãƒ•è·é›¢: ç¸¦æ¨ªæ–œã‚ã®æœ€å¤§ç§»å‹•ãƒã‚¹æ•°ï¼‰
            const distance = Math.max(Math.abs(player.x - obj.x), Math.abs(player.y - obj.y));

            if (distance <= checkRadius) {
                // ç¯„å›²å†…ã§ã€ã¾ã ã‚µã‚¦ãƒ³ãƒ‰ãŒå†ç”Ÿã•ã‚Œã¦ã„ãªã„å ´åˆ
                if (!obj.soundPlayed) {
                    playSoundFile('sounds/crow_caw.wav', 0.6); // ã‚«ãƒ©ã‚¹ã®éŸ³ã‚’å†ç”Ÿï¼ˆéŸ³é‡ã¯0.6ã«è¨­å®šï¼‰
                    obj.soundPlayed = true; // å†ç”Ÿæ¸ˆã¿ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
                }
            } else {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒç¯„å›²å¤–ã«å‡ºãŸã‚‰ã€ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦å†åº¦å†ç”Ÿã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹
                obj.soundPlayed = false;
            }
        }
    });
}
function createSound(x, y, radius, sourceAction = 'ä¸æ„ã®ç‰©éŸ³') {
    const shoes = player.equipment.find(e => e.slot === 'feet');
    const soundModifier = shoes ? (shoes.soundModifier || 1.0) : 1.2; 
    let weatherModifier = 1.0;
    if (currentWeather.name === 'é›¨') weatherModifier = 0.7;
    if (currentWeather.name === 'åµ') weatherModifier = 0.4;

    let soundRadius = radius * soundModifier * weatherModifier;

    currentSoundLevel = parseFloat(soundRadius.toFixed(1));

    lastSoundCalculation = {
        base: radius,
        shoes: shoes ? { name: shoes.name, modifier: soundModifier } : { name: 'ç´ è¶³', modifier: soundModifier },
        weather: { name: currentWeather.id, modifier: weatherModifier },
        total: currentSoundLevel,
        source: sourceAction
    };

    entities.forEach(entity => {
        if (getDistance(x, y, entity.x, entity.y) <= soundRadius) {
            if (entity.isZombie || (entity.isAnimal && !entity.flees)) {
                entity.investigationTarget = { x, y };
                entity.aiState = 'investigating';
            } else if (radius > 5 && (entity.flees || entity.type === 'Survivor' || entity.type === 'Trader')) {
                entity.target = {x, y}; 
                entity.aiState = 'fleeing';
            }
        }
    });
}

function moveEntityTowards(entity, targetX, targetY) {
    let dx = targetX - entity.x;
    let dy = targetY - entity.y;
    let newX = entity.x;
    let newY = entity.y;

    // â–¼â–¼â–¼ ä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
    // æ¨ªæ–¹å‘ã«è·é›¢ãŒã‚ã‚Œã°ã€æ¨ªã«1ãƒã‚¹å‹•ã
    if (dx !== 0) {
        newX += Math.sign(dx);
    }
    // ç¸¦æ–¹å‘ã«è·é›¢ãŒã‚ã‚Œã°ã€ç¸¦ã«1ãƒã‚¹å‹•ã
    if (dy !== 0) {
        newY += Math.sign(dy);
    }
    // â–²â–²â–² ä¿®æ­£ã“ã“ã¾ã§ â–²â–²â–²

    moveEntityTo(entity, newX, newY);
}
/**
 * ãƒ™ã‚¢ãƒˆãƒ©ãƒƒãƒ—ã‚’åœ°é¢ã«è¨­ç½®ã™ã‚‹
 */
function placeBearTrap(item, itemIndex, source) {
    if (placedObjects.find(o => o.x === player.x && o.y === player.y)) {
        log(getString("log_shelter_blocked"));
        return;
    }
    snapshotStats();

    // â˜…â˜…â˜… ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â˜…â˜…â˜…
    // ã‚¢ã‚¤ãƒ†ãƒ ãŒã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã«ã‚ã‚‹ã‹ã€åœ°é¢ã«ã‚ã‚‹ã‹ã‚’æ­£ã—ãåˆ¤æ–­ã—ã¾ã™
    const sourceArray = source === 'inventory' ? player.inventory : droppedItems[`${player.x},${player.y}`];
    const removedItem = sourceArray.splice(itemIndex, 1)[0];

    // removedItemãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ã€ã‚¨ãƒ©ãƒ¼ã‚’é˜²ããŸã‚ã«å‡¦ç†ã‚’ä¸­æ–­ã—ã¾ã™
    if (!removedItem) {
        console.error("placeBearTrap: å¯¾è±¡ã®ã‚¢ã‚¤ãƒ†ãƒ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚");
        hideItemDetail();
        return;
    }

    // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã‹ã‚‰æ¶ˆè²»ã—ãŸå ´åˆã®ã¿ã€é‡é‡ã¨å®¹é‡ã‚’æ¸›ã‚‰ã—ã¾ã™
    if (source === 'inventory') {
        player.weight -= removedItem.weight || 0;
        player.volume -= removedItem.volume || 0;
    }
    // â˜…â˜…â˜… ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â˜…â˜…â˜…

    log(getString("log_place_beartrap"));
    placedObjects.push({ 
        x: player.x, 
        y: player.y, 
        type: 'bear_trap_armed', 
        name: 'ä»•æ›ã‘ã‚‰ã‚ŒãŸãƒ™ã‚¢ãƒˆãƒ©ãƒƒãƒ—', 
        graphic: 'images/beartrap_armed.png' 
    });

    drawMap();
    updateItemPanels();
    updateStatus();
    hideItemDetail();
}
/**
 * è¨­ç½®ã•ã‚ŒãŸãƒ™ã‚¢ãƒˆãƒ©ãƒƒãƒ—ã‚’å›åã—ã€ã‚¢ã‚¤ãƒ†ãƒ ã«æˆ»ã™
 */
function removeBearTrap() {
    if (isStunnedByPain()) { return; }
    const trapObject = currentItemDetail.item;
    if (!trapObject || (trapObject.type !== 'bear_trap_armed' && trapObject.type !== 'bear_trap_sprung')) return;

    const trapKitTemplate = items.find(i => i.name === 'ãƒ™ã‚¢ãƒˆãƒ©ãƒƒãƒ—ã‚­ãƒƒãƒˆ');
    if (!trapKitTemplate) return;

    snapshotStats();

    const trapIndex = placedObjects.findIndex(p => p === trapObject);
    if (trapIndex > -1) {
        placedObjects.splice(trapIndex, 1);
    }

    const newItem = { ...trapKitTemplate };
    if (player.weight + newItem.weight > player.maxWeight || player.volume + (newItem.volume || 0) > player.maxVolume) {
        log("ç½ ã‚’å›åã—ãŸãŒã€æŒã¡ãã‚Œãªã„ãŸã‚åœ°é¢ã«ç½®ã„ãŸã€‚");
        const locationKey = `${player.x},${player.y}`;
        if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
        droppedItems[locationKey].push(newItem);
    } else {
        log("ãƒ™ã‚¢ãƒˆãƒ©ãƒƒãƒ—ã‚’å›åã—ãŸã€‚");
        player.inventory.push(newItem);
        player.weight += newItem.weight || 0;
        player.volume += newItem.volume || 0;
    }

    hideItemDetail();
    endPlayerTurn();
    refreshGameState();
}
/**
 * ä½œå‹•æ¸ˆã¿ã®ãƒ™ã‚¢ãƒˆãƒ©ãƒƒãƒ—ã‚’å†è¨­ç½®ã™ã‚‹
 */
function resetBearTrap() {
    if (isStunnedByPain()) { return; }
    const trap = placedObjects.find(p => p.x === player.x && p.y === player.y && p.type === 'bear_trap_sprung');
    if (!trap) return;

    snapshotStats();
    trap.type = 'bear_trap_armed';
    trap.name = 'ä»•æ›ã‘ã‚‰ã‚ŒãŸãƒ™ã‚¢ãƒˆãƒ©ãƒƒãƒ—';
    trap.graphic = 'images/beartrap_armed.png';

    log(getString("log_reset_trap"), true);
    
    endPlayerTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    updateTurnInfo();
    checkGameOver();
    updateCurrentLocationPanel(false);
}

/**
 * ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‹ã‚‰é ã–ã‘ã‚‹ã‚ˆã†ã«ç§»å‹•ã•ã›ã‚‹é–¢æ•°
 * @param {object} entity - ç§»å‹•ã™ã‚‹ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£
 * @param {number} targetX - ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®Xåº§æ¨™
 * @param {number} targetY - ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®Yåº§æ¨™
 */
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function moveEntityAwayFrom(entity, targetX, targetY) {
    const idealDx = Math.sign(entity.x - targetX);
    const idealDy = Math.sign(entity.y - targetY);

    let newX = entity.x + idealDx;
    let newY = entity.y + idealDy;

    // 30%ã®ç¢ºç‡ã§ãƒ‘ãƒ‹ãƒƒã‚¯ã«ãªã‚Šã€éåˆç†çš„ãªç§»å‹•ã‚’ã™ã‚‹
    if (Math.random() < 0.3) {
        const possibleMoves = [];
        // 8æ–¹å‘ã®ç§»å‹•å€™è£œã‚’è¿½åŠ 
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0) continue;
                possibleMoves.push({ dx, dy });
            }
        }

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«è¿‘ã¥ã‹ãªã„ç§»å‹•ã®ã¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
        const validMoves = possibleMoves.filter(move => {
            const nextX = entity.x + move.dx;
            const nextY = entity.y + move.dy;
            const currentDist = getDistance(entity.x, entity.y, targetX, targetY);
            const nextDist = getDistance(nextX, nextY, targetX, targetY);
            // è·é›¢ãŒç¾åœ¨ã¨åŒã˜ã‹ã€ã‚ˆã‚Šé ããªã‚‹ç§»å‹•ã®ã¿ã‚’è¨±å¯
            return nextDist >= currentDist;
        });

        if (validMoves.length > 0) {
            const randomMove = randChoice(validMoves);
            newX = entity.x + randomMove.dx;
            newY = entity.y + randomMove.dy;
        }
        // æœ‰åŠ¹ãªç§»å‹•ãŒãªã„å ´åˆã¯ã€å…ƒã®æœ€é©ãªç§»å‹•ã‚’ä½¿ç”¨
    }

    moveEntityTo(entity, newX, newY);
}
function moveEntityTo(entity, newX, newY) {
    console.log("ç§»å‹•ã•ã›ã‚‹NPC:", entity.name, " ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ãƒ©ã‚°è¨­å®šå‰:", entity.justMoved);
    if (newX < 0 || newY < 0 || newX >= mapSize || newY >= mapSize) return;

    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ãƒ»è¿½åŠ ç®‡æ‰€ã§ã™ â–¼â–¼â–¼
    const armedTrap = placedObjects.find(o => o.x === newX && o.y === newY && o.type === 'bear_trap_armed');
    if (armedTrap) {
        const damage = 50; // ãƒ€ãƒ¡ãƒ¼ã‚¸é‡
        entity.health -= damage;
        const entityName = getString(`item_${entity.name}_name`) || entity.name;
        
        // ç½ ã‚’ä½œå‹•æ¸ˆã¿ã®çŠ¶æ…‹ã«å¤‰æ›´
        armedTrap.type = 'bear_trap_sprung';
        armedTrap.name = 'ä½œå‹•æ¸ˆã¿ã®ãƒ™ã‚¢ãƒˆãƒ©ãƒƒãƒ—';
        armedTrap.graphic = 'images/beartrap_sprung.png';

        if (entity.health <= 0) {
            // ç½ ã§æ­»äº¡ã—ãŸå ´åˆ
            log(getString("log_trap_triggered_death", { entityName: entityName }));
            // æ­»ä½“å‡¦ç†
            if (entity.isAnimal && entity.loot) {
                const corpse = { x: entity.x, y: entity.y, type: 'corpse', name: `${entity.name}ã®æ­»ä½“`, graphic: 'images/corpse_bones.png', duration: 48, isAnimalCorpse: true, unbutchered: true, potentialLoot: entity.loot };
                placedObjects.push(corpse);
            } else if (!entity.isZombie) {
                const lootItems = [...(entity.inventory || []), ...(entity.equipment || [])];
                const corpse = { x: entity.x, y: entity.y, type: 'corpse', name: `${entity.name}ã®æ­»ä½“`, graphic: 'images/corpse_bones.png', duration: 24, isHumanCorpse: true, unsearched: true, potentialLoot: lootItems };
                placedObjects.push(corpse);
            }
            const entityIndex = entities.findIndex(e => e === entity);
            if (entityIndex > -1) entities.splice(entityIndex, 1);

        } else {
            // ç”Ÿå­˜ã—ãŸå ´åˆ
            log(getString("log_trap_triggered", { entityName: entityName }));
        }

        drawMap(); // ãƒãƒƒãƒ—ã‚’å†æç”»ã—ã¦ç½ ã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚’æ›´æ–°
        return; // ç½ ã«ã‹ã‹ã£ãŸNPCã¯ãã®å ´ã«ç•™ã¾ã‚‹
    }
    // â–²â–²â–² ä¿®æ­£ãƒ»è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²

    const barricade = placedObjects.find(o => o.x === newX && o.y === newY && o.type === 'barricade' && o.health > 0);
    if (barricade) {
        resolveEntityAttackOnObject(entity, barricade);
    } else if (!entities.some(e => e.x === newX && e.y === newY) && !(player.x === newX && player.y === newY)) {
        
    if (getDistance(player.x, player.y, entity.x, entity.y) <= getVisionRange() && hasLineOfSight(player.x, player.y, entity.x, entity.y)) {
        // â˜…â˜…â˜… ã‚µã‚¦ãƒ³ãƒ‰å†ç”Ÿã«é–¢ã™ã‚‹ã‚³ãƒ¼ãƒ‰ã‚’ã“ã“ã‹ã‚‰å‰Šé™¤ã—ã¾ã—ãŸ â˜…â˜…â˜…
        entity.justMoved = true; // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®ãƒ•ãƒ©ã‚°ã¯æ®‹ã—ã¾ã™
    }

        entity.x = newX;
        entity.y = newY;
    }
}
function startTargeting(item, index, source) {
    targetingState.active = true;
    targetingState.item = item;
    targetingState.itemIndex = index;
    targetingState.source = source;
    targetingState.range = item.throwRange || 5;

    const itemName = getItemDisplayName(item);
log(getString("log_select_throw_target", { itemName: itemName }));
    hideItemDetail();
    drawMap();
}

function cancelTargeting() {
    targetingState.active = false;
    log(getString("log_cancel_throw"));
    drawMap();
}

function handleTargetingClick(targetX, targetY) {
    if (Math.abs(targetX - player.x) > targetingState.range || Math.abs(targetY - player.y) > targetingState.range) {
        log("ãã“ã¾ã§ã¯å±Šã‹ãªã„ã€‚");
        cancelTargeting();
        return;
    }

    const item = targetingState.item;
    const itemIndex = targetingState.itemIndex;

    log(`${item.name}ã‚’ (${targetX}, ${targetY}) ã«æŠ•ã’ãŸã€‚`);
    
    // Create sound at the target location
    createSound(targetX, targetY, item.throwSoundRadius || 5);
    
    // Remove item from inventory
    const removedItem = player.inventory.splice(itemIndex, 1)[0];
    player.weight -= removedItem.weight;
    player.volume -= removedItem.volume;
    
    // Drop the item at the target location
    const locationKey = `${targetX},${targetY}`;
    if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
    droppedItems[locationKey].push(removedItem);

    cancelTargeting();
    advanceTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    updateTurnInfo();
    checkGameOver();
}

function setMovementMode(mode) {
    player.movementMode = mode;
    const modeName = getString(`move_${mode}`);
    const message = getString("log_movement_mode_changed", { modeName: modeName });

    const logDiv = document.getElementById("log");
    Array.from(logDiv.children).forEach(div => {
        div.style.color = "#666";
        div.style.fontWeight = "normal";
    });
    let div = document.createElement("div");
    div.innerHTML = message;
    div.classList.add("new");
    logDiv.appendChild(div);
    logDiv.scrollTop = logDiv.scrollHeight;

    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = message;
    const plainText = tempDiv.textContent || tempDiv.innerText || "";
    speak(plainText);

    updateMovementButtons();
}

// index.html å†…

function showBodyOdorTooltip(event) {
    const preview = document.getElementById("statusPreview");
    const description = getString("tooltip_body_odor_desc");
    let contentHtml = `<strong>${getString("tooltip_body_odor_title")}</strong><div style="margin-top: 5px;">${description}</div>`;
    preview.innerHTML = contentHtml;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}
function updateMovementButtons() {
    document.querySelectorAll('#movementControls button').forEach(btn => btn.classList.remove('active'));
    if (player.movementMode === 'walk') document.getElementById('moveWalkBtn').classList.add('active');
    else if (player.movementMode === 'run') document.getElementById('moveRunBtn').classList.add('active');
}

function washBody() {
    if (player.bodyOdor <= 0) {
        log(getString("log_wash_body_not_needed"));
        return;
    }

    const performWash = () => {
        snapshotStats();
        log(getString("log_wash_body_success"));
        createSound(player.x, player.y, 3, 'æ°´æµ´ã³');
        player.bodyOdor = 0;
        
        updatePlayerSmell();

        player.equipment.forEach(item => {
            if (item.type === 'clothing') {
                if (item.wetness === 'dry') item.wetness = 'wet';
                else if (item.wetness === 'wet') item.wetness = 'soaking_wet';
            }
        });
        log(getString("log_wash_clothes_wet"));

        updateTurnInfo();
        drawMap();
        updateStatus();
        updateItemPanels();
        updateCharacterBody();
        updateCharacterInfo();
        advanceTurn();
        checkGameOver();
    };

    if (currentTime.getHours() === 17) {
        speakAndConfirm(getString("confirm_wash_body_dusk"), performWash, () => {
            log(getString("log_wash_body_cancel"));
        });
    } else {
        performWash();
    }
}
function tillSoil(item, itemIndex, source) {
    if (isStunnedByPain()) { return; }
    const tile = map[player.y][player.x];
    
    if (placedObjects.some(o => o.x === player.x && o.y === player.y)) {
        log(getString("log_till_fail_blocked"));
        return;
    }

    // ã©ã®åœ°é¢ã‚’è€•ãã†ã¨ã—ã¦ã„ã‚‹ã‹ã§å‡¦ç†ã‚’åˆ†å²
    if (tile.loc.nameKey === 'location_plains') {
        // --- 1æ®µéšç›®: å¹³é‡ â†’ è€•ã•ã‚Œã¦ã„ãªã„ç•‘ ---
        snapshotStats();
        const untilledFieldTemplate = biomeLocations.Plains.find(loc => loc.nameKey === 'location_untilled_field');
        if (untilledFieldTemplate) {
            map[player.y][player.x].loc = { ...untilledFieldTemplate };
            log(getString("log_plains_tilled"), true);
        }
    } else if (tile.loc.nameKey === 'location_untilled_field') {
        // --- 2æ®µéšç›®: è€•ã•ã‚Œã¦ã„ãªã„ç•‘ â†’ è€•ã•ã‚ŒãŸç•‘ ---
        snapshotStats();
        placedObjects.push({
            x: player.x,
            y: player.y,
            type: 'tilled_field',
            name: 'è€•ã•ã‚ŒãŸç•‘',
            graphic: 'images/tilled_field.png',
            planted: null,
            growth: 0,
            growthTime: 5
        });
        log(getString("log_untilled_field_tilled"), true);
    } else {
        // --- ãã‚Œä»¥å¤–ã®å ´æ‰€ ---
        log(getString("log_till_fail_wrong_ground"));
        return;
    }

    // é¬ã®è€ä¹…å€¤ã‚’æ¸›ã‚‰ã™
    reduceItemDurability(item, 5, itemIndex, source);
    
    hideItemDetail();
    endPlayerTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    updateTurnInfo();
    checkGameOver();
    updateCurrentLocationPanel(false);
}
function placeResearchBench(item, itemIndex, source) {
    let isBlocked = false;
    // å±‹å¤–ã§ã®ã¿ãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒªã‚¹ãƒˆ
    const outdoorBlockers = ['workbench', 'junk_research_bench', 'barricade', 'shelter', 'wooden_box', 'sleeping_bag'];

    if (player.isInside || player.isInShelter) {
        // å±‹å†…ã§ã¯ã€åŒã˜ç¨®é¡ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ—¢ã«å­˜åœ¨ã™ã‚‹å ´åˆã®ã¿ãƒ–ãƒ­ãƒƒã‚¯
        isBlocked = placedObjects.some(o => o.x === player.x && o.y === player.y && o.type === 'junk_research_bench');
    } else {
        // å±‹å¤–ã§ã¯ã€ä»–ã®ä¸»è¦ãªè¨­ç½®ç‰©ãŒã‚ã‚Œã°ãƒ–ãƒ­ãƒƒã‚¯
        isBlocked = placedObjects.some(o => o.x === player.x && o.y === player.y && outdoorBlockers.includes(o.type));
    }

    if (isBlocked) {
        log(getString("log_workbench_blocked"));
        return;
    }
    
    snapshotStats();
    
    const sourceArray = source === 'inventory' ? player.inventory : droppedItems[`${player.x},${player.y}`];
    const removedItem = sourceArray.splice(itemIndex, 1)[0];

    if (source === 'inventory') {
        player.weight -= removedItem.weight;
        player.volume -= removedItem.volume;
    }

    log(getString("log_place_research_bench"));
    
    placedObjects.push({ 
        x: player.x, 
        y: player.y, 
        type: 'junk_research_bench', 
        name: 'junk_research_bench',  
        graphic: 'images/workbench.png'
    });
    
    drawMap();
    updateItemPanels();
    updateStatus();
    hideItemDetail();
}

// â–¼â–¼â–¼ `plantSeed` é–¢æ•°ã‚’ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function plantSeed(item, itemIndex, source) {
    if (isStunnedByPain()) { return; }
    const tilledField = placedObjects.find(o => o.x === player.x && o.y === player.y && o.type === 'tilled_field');
    
    // â˜…ä¿®æ­£ç‚¹ï¼šè€•ã•ã‚ŒãŸç•‘ãŒãªã„å ´åˆã®ãƒã‚§ãƒƒã‚¯
    if (!tilledField) {
        log(getString("log_plant_fail_not_tilled"));
        return; // å‡¦ç†ã‚’ä¸­æ–­
    }
    
    if (tilledField.planted) {
        log(getString("log_plant_fail_blocked"));
        return;
    }

    snapshotStats();
    
    const seedItem = player.inventory.splice(itemIndex, 1)[0];
    player.weight -= seedItem.weight;
    player.volume -= seedItem.volume;

    tilledField.planted = seedItem.plantResult;
    tilledField.isHarvestable = false;
    tilledField.graphic = 'images/seeds.png';

    log(getString("log_plant_success", { seedName: getItemDisplayName(seedItem) }));

    hideItemDetail();
    endPlayerTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    updateTurnInfo();
    checkGameOver();
    updateCurrentLocationPanel(false);
}
// â–²â–²â–² ç½®ãæ›ãˆã“ã“ã¾ã§ â–²â–²â–²

function harvestCrop() {
    if (isStunnedByPain()) { return; }
    const crop = placedObjects.find(o => o.x === player.x && o.y === player.y && o.isHarvestable);
    if (!crop) return;

    snapshotStats();
    
    const yieldAmount = Math.floor(Math.random() * 3) + 1;
    const cropTemplate = items.find(i => i.name === crop.planted);
    
    if (cropTemplate) {
        const cropDisplayName = getString(`item_${crop.planted}_name`) || crop.planted;
        log(getString("log_harvest_success", { cropName: cropDisplayName, count: yieldAmount }));
        
        for (let i = 0; i < yieldAmount; i++) {
            const newItem = { ...cropTemplate };
            if (player.weight + newItem.weight > player.maxWeight || player.volume + (newItem.volume || 0) > player.maxVolume) {
                log(getString("log_harvest_grounded"));
                const locationKey = `${player.x},${player.y}`;
                if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
                droppedItems[locationKey].push(newItem);
            } else {
                player.inventory.push(newItem);
                player.weight += newItem.weight || 0;
                player.volume += newItem.volume || 0;
            }
        }
    }

    const cropIndex = placedObjects.findIndex(o => o === crop);
    if (cropIndex > -1) {
        placedObjects.splice(cropIndex, 1);
    }
    
    endPlayerTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    updateTurnInfo();
    checkGameOver();
    updateCurrentLocationPanel(false);
}
function repairBarricade() {
    if (isStunnedByPain()) { return; }
    const barricade = placedObjects.find(p => p.x === player.x && p.y === player.y && p.type === 'barricade');
    if (!barricade) return;
    if (barricade.health >= barricade.maxHealth) {
        log(getString("log_repair_not_needed"));
        return;
    }
    snapshotStats();
    const oldHealth = barricade.health;
    barricade.health = Math.min(barricade.maxHealth, barricade.health + 20);
    log(getString("log_barricade_repaired", { oldHealth: oldHealth.toFixed(0), newHealth: barricade.health.toFixed(0) }));
    createSound(player.x, player.y, 4, 'ä¿®ç†');
    endPlayerTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    updateTurnInfo();
    checkGameOver();
    updateCurrentLocationPanel(false);
}

// Initial setup
// â–¼â–¼â–¼ æ—¢å­˜ã®ç ”ç©¶é–¢é€£ã®é–¢æ•°ç¾¤ã‚’ã€ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
let researchModeActive = false; // ç¾åœ¨ã€ç ”ç©¶å®Ÿè¡Œãƒ¢ãƒ¼ãƒ‰ã‹ã©ã†ã‹ã‚’ç®¡ç†ã™ã‚‹ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°

function openResearchPanel(isConducting = false) {
    researchModeActive = isConducting;
    document.getElementById('researchPanel').style.display = 'flex';
    renderResearchTree();
}

function closeResearchPanel() {
    researchModeActive = false;
    document.getElementById('researchPanel').style.display = 'none';
}

// â–¼â–¼â–¼ `selectResearch`ã‹ã‚‰`advanceResearchProgress`ã¾ã§ã®3ã¤ã®é–¢æ•°ã‚’ã€ã“ã®å†…å®¹ã§ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
function selectResearch(projectId) {
    if (player.research.currentProjectId === projectId) {
        player.research.currentProjectId = null;
        log(getString("research_log_deselect"));
    } else {
        player.research.currentProjectId = projectId;
        const project = researchProjects[projectId];
        log(getString("research_log_select", { researchName: getString(project.nameKey) }));
    }
    renderResearchTree();
}

function renderResearchTree() {
    const nodesContainer = document.getElementById('researchTreeNodes');
    const linesContainer = document.getElementById('researchTreeLines');
    nodesContainer.innerHTML = '';
    linesContainer.innerHTML = ''; // æ³¨: ã“ã®ä¿®æ­£ã«ã‚ˆã‚Šã€é …ç›®é–“ã‚’çµã¶ç·šã¯ä¸€æ™‚çš„ã«éè¡¨ç¤ºã«ãªã‚Šã¾ã™

    // ç ”ç©¶é …ç›®ã‚’éšå±¤ï¼ˆTierï¼‰ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã™ã‚‹
    const tiers = {};
    const memo = {};
    function getTier(projectId) {
        if (memo[projectId] !== undefined) return memo[projectId];
        const project = researchProjects[projectId];
        if (!project.prerequisites || project.prerequisites.length === 0) { return 0; }
        const maxPrereqTier = Math.max(...project.prerequisites.map(p => getTier(p)));
        return maxPrereqTier + 1;
    }
    for (const projectId in researchProjects) {
        const tier = getTier(projectId);
        if (!tiers[tier]) tiers[tier] = [];
        tiers[tier].push(projectId);
    }

    const verticalSpacing = 20; // â˜…â˜…â˜… ã“ã®æ•°å€¤ã‚’å¤‰æ›´ã™ã‚Œã°ã€ç¸¦ã®é–“éš”ãŒç¢ºå®Ÿã«å¤‰ã‚ã‚Šã¾ã™ â˜…â˜…â˜…

    // å„Tierï¼ˆåˆ—ï¼‰ã‚’ç”Ÿæˆ
    Object.keys(tiers).sort((a, b) => a - b).forEach(tier => {
        const columnProjects = tiers[tier];

        // å„Tierï¼ˆåˆ—ï¼‰ã®ãŸã‚ã®ã‚³ãƒ³ãƒ†ãƒŠDIVã‚’ä½œæˆ
        const columnDiv = document.createElement('div');
        columnDiv.className = 'research-column';
        columnDiv.style.gap = `${verticalSpacing}px`; // â˜…JavaScriptã‹ã‚‰ç¸¦ã®é–“éš”ã‚’ç›´æ¥è¨­å®š

        // åˆ—ã«å±ã™ã‚‹å„ç ”ç©¶é …ç›®ã‚’ç”Ÿæˆ
        columnProjects.forEach(projectId => {
            const project = researchProjects[projectId];
            const node = document.createElement('div');
            node.className = 'research-node';

            const isCompleted = player.research.completed.includes(projectId);
            const isCurrent = player.research.currentProjectId === projectId;
            const prereqsMet = project.prerequisites.every(p => player.research.completed.includes(p));
            let stateClass = isCompleted ? 'completed' : isCurrent ? 'in-progress' : prereqsMet ? 'available' : 'locked';
            node.classList.add(stateClass);

            if (stateClass === 'available' || stateClass === 'in-progress') {
                node.onclick = () => selectResearch(projectId);
                node.style.cursor = 'pointer';
            }

            node.innerHTML = `
                <div class="research-node-header">
                    ${getIconHTML(project.icon, 24)}
                    <h3>${getString(project.nameKey)}</h3>
                    ${isCompleted ? '<img src="images/checkmark.png" class="research-completed-check" alt="Completed">' : ''}
                </div>
                <div class="research-node-cost">${getString('research_cost')}: ${project.cost} ${getString('time_unit_turn')}</div>
                <div class="research-node-desc">${getString(project.descKey)}</div>
                <div class="research-node-unlocks">
                    <strong>${getString(project.unlocksKey)}</strong>
                    <div class="research-unlock-icons"></div>
                </div>
            `;

            // ï¼ˆä¸­èº«ã®ç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯ã¯å¤‰æ›´ãªã—ï¼‰
            const iconsContainer = node.querySelector('.research-unlock-icons');
            if (project.unlocks && project.unlocks.length > 0) {
                project.unlocks.forEach(itemId => {
                    const item = items.find(i => i.name === itemId);
                    if (item) {
                        const icon = document.createElement('img');
                        icon.src = item.graphic;
                        icon.className = 'unlock-icon';
                        icon.addEventListener('mouseenter', (e) => showRecipeTooltip(item, e));
                        icon.addEventListener('mouseleave', hideStatusPreview);
                        icon.addEventListener('mousemove', (e) => updatePreviewPosition(e));
                        iconsContainer.appendChild(icon);
                    }
                });
            }

            if (isCurrent) {
                const projectProgress = player.research.progress[projectId] || 0;
                const progress = (projectProgress / project.cost) * 100;
                const progressBarHTML = `<div class="research-progress-bar-container"><div class="research-progress-bar" style="width: ${progress}%;"></div></div>`;
                node.insertAdjacentHTML('beforeend', progressBarHTML);
                const researchBenchNearby = placedObjects.some(o => o.x === player.x && o.y === player.y && o.type === 'junk_research_bench');
                if (researchBenchNearby) {
                    const conductBtn = document.createElement('button');
                    conductBtn.className = 'research-conduct-btn';
                    conductBtn.textContent = getString('btn_conduct_research_inline');
                    conductBtn.onclick = (e) => { e.stopPropagation(); advanceResearchProgress(1); };
                    node.appendChild(conductBtn);
                }
            }

            columnDiv.appendChild(node);
        });
        nodesContainer.appendChild(columnDiv);
    });
}

function advanceResearchProgress(points) {
    if (isStunnedByPain()) { return; }
    const projectId = player.research.currentProjectId;
    if (!projectId) {
        log(getString("research_select_prompt"));
        return;
    }
    const researchBenchNearby = placedObjects.some(o => o.x === player.x && o.y === player.y && o.type === 'junk_research_bench');
    if (!researchBenchNearby) {
        log(getString("research_start_fail_no_bench"));
        closeResearchPanel();
        return;
    }
    
    snapshotStats();
    const project = researchProjects[projectId];

    if (!player.research.progress[projectId]) {
        player.research.progress[projectId] = 0;
    }
    player.research.progress[projectId] += points;
    const currentProgress = player.research.progress[projectId];
    
    log(getString("research_log_progress", { 
        researchName: getString(project.nameKey), 
        progress: currentProgress, 
        cost: project.cost 
    }));

    endPlayerTurn();

    if (currentProgress >= project.cost) {
        player.research.completed.push(projectId);
        player.research.currentProjectId = null;
        delete player.research.progress[projectId];
        
        log(getString("research_log_complete", { researchName: getString(project.nameKey) }), true);
        log(getString("research_log_new_unlocks"), true);
        updateCraftingPanel();
    }
    
    updateStatus();
    renderResearchTree();
}
/**
 * æ­»ä½“ã®è…æ•—ã‚„ã‚¾ãƒ³ãƒ“åŒ–ãªã©ã€æ™‚é–“çµŒéã§ç™ºç”Ÿã™ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆã‚’å‡¦ç†ã™ã‚‹ã‚¿ã‚¤ãƒãƒ¼ã‚’é–‹å§‹ã™ã‚‹
 */

document.addEventListener('DOMContentLoaded', async () => {
    console.log("ãƒ‡ãƒãƒƒã‚°: DOMã®èª­ã¿è¾¼ã¿ãŒå®Œäº†ã—ã¾ã—ãŸã€‚ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®šã‚’é–‹å§‹ã—ã¾ã™ã€‚");

    function setupSpeechSynthesis() {
      availableVoices = speechSynthesis.getVoices();
      if (availableVoices.length > 0) {
        console.log("åˆ©ç”¨å¯èƒ½ãªéŸ³å£°ãƒªã‚¹ãƒˆã‚’å–å¾—ã—ã¾ã—ãŸã€‚", availableVoices);
      } else {
        speechSynthesis.onvoiceschanged = () => {
          availableVoices = speechSynthesis.getVoices();
          console.log("åˆ©ç”¨å¯èƒ½ãªéŸ³å£°ãƒªã‚¹ãƒˆã‚’å†å–å¾—ã—ã¾ã—ãŸã€‚", availableVoices);
        };
      }
    }
    setupSpeechSynthesis();
    ambientGainNode = audioCtx.createGain();
    ambientGainNode.connect(audioCtx.destination);
    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰è¿½åŠ  â–¼â–¼â–¼
    combatBgmGainNode = audioCtx.createGain();
    combatBgmGainNode.connect(audioCtx.destination);
    // â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²
    const resumeAudio = () => {
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
        document.body.removeEventListener('click', resumeAudio);
    };
    document.body.addEventListener('click', resumeAudio);

    const pkg = require('./package.json');
    const versionDisplay = document.getElementById('version-display');
    if (versionDisplay) versionDisplay.textContent = `v${pkg.version}`;

    await loadLanguage(currentLanguage);

    const startScreen = document.getElementById('startScreen');
    const optionsScreen = document.getElementById('optionsScreen');
    const addSickness = (type, duration, name) => {
        if (!player.sicknesses.some(s => s.type === type)) {
            player.sicknesses.push({ type: type, duration: duration });
            log(`é–‹ç™ºè€…: ${name}ã‚’ç™ºç”Ÿã•ã›ã¾ã—ãŸã€‚`);
            updateStatus();
        } else {
            log(`é–‹ç™ºè€…: æ—¢ã«${name}ã‚’ç™ºç—‡ã—ã¦ã„ã¾ã™ã€‚`);
        }
    };

    document.getElementById('devAddFoodPoisoningBtn').onclick = () => addSickness('food_poisoning', 36, 'é£Ÿä¸­æ¯’');
    document.getElementById('devAddDiarrheaBtn').onclick = () => addSickness('diarrhea', 36, 'ä¸‹ç—¢');
    document.getElementById('devAddFeverBtn').onclick = () => addSickness('fever', 48, 'ç™ºç†±');
    document.getElementById('devAddInfectionBtn').onclick = () => addSickness('infection', 72, 'æ„ŸæŸ“ç—‡');
    document.getElementById('devAddItchBtn').onclick = () => addSickness('itch', 6, 'ã‹ã‚†ã¿');    
    document.getElementById('optionsBtn').addEventListener('click', () => {
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
        playSoundFile('sounds/ui_click.wav');
        openOptionsAndCaptureState();
    });

    document.getElementById('ingameOptionsBtn').addEventListener('click', () => {
        playSoundFile('sounds/ui_click.wav');
        openOptionsAndCaptureState();
        bringToFront(optionsScreen);
    });

    document.getElementById('applySettingsBtn').addEventListener('click', () => {
        playSoundFile('sounds/ui_confirm.wav');
        applyAndSaveSettings();
    });
// ã€ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’è¿½åŠ ã€‘
// é–‹ç™ºè€…ãƒ‘ãƒãƒ«ã®æ¤œç´¢ãƒãƒ¼ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
const devSearchInput = document.getElementById('devItemSearch'); // â˜…ã¾ãšè¦ç´ ã‚’å–å¾—
if (devSearchInput) { // â˜…è¦ç´ ãŒå­˜åœ¨ã™ã‚‹ã‹ã‚’ç¢ºèª
    devSearchInput.onkeyup = () => { // â˜…å­˜åœ¨ã™ã‚‹å ´åˆã®ã¿ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¨­å®š
        populateDevPanel(); // ã‚­ãƒ¼å…¥åŠ›ã®ãŸã³ã«ãƒªã‚¹ãƒˆã‚’å†æç”»
    };
} else {
    // ã‚‚ã—ãã‚Œã§ã‚‚è¦ç´ ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã€ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
    console.error("è‡´å‘½çš„ãªã‚¨ãƒ©ãƒ¼: ID 'devItemSearch' ã‚’æŒã¤é–‹ç™ºè€…ãƒ‘ãƒãƒ«ã®æ¤œç´¢ãƒãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚HTMLã®æ§‹é€ ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
}
    document.getElementById('backToMenuBtn').addEventListener('click', () => {
        playSoundFile('sounds/ui_cancel.wav');
        cancelSettingsChanges();
    });
    
    const langButtons = document.querySelectorAll('#languageSwitcher button');
    langButtons.forEach(button => {
        button.addEventListener('click', () => {
            playSoundFile('sounds/ui_click.wav');
            langButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
        });
    });
    
    document.querySelectorAll('.panel').forEach(panel => {
        const header = panel.querySelector(".panel-header");
        if (header) {
            panel.addEventListener("mousedown", () => bringToFront(panel));
            
            if (panel.id !== 'researchPanel' && panel.id !== 'itemDetailPanel') {
                header.addEventListener("click", () => { if (panel.classList.contains("minimized")) togglePanelSize(panel); });
                header.addEventListener("dblclick", () => { if (!panel.classList.contains("minimized")) togglePanelSize(panel); });
            }
        }
        makeDraggable(panel); 
        
        if (panel.id !== 'itemDetailPanel' && panel.id !== 'bodyPanel') {
            makeResizable(panel);
        }
    });

    document.getElementById('map').addEventListener('contextmenu', e => {
        e.preventDefault();
        if (targetingState.active) cancelTargeting();
    });

    document.getElementById('startGameBtn').addEventListener('click', () => {
        playSoundFile('sounds/ui_confirm.wav');
        initGame();
    });
    
    document.getElementById('loadGameBtn').addEventListener('click', () => {
        playSoundFile('sounds/ui_confirm.wav');
        loadGame();
    });
    
    document.getElementById('exitGameBtn').addEventListener('click', () => {
        stopMenuBGM();
        playSoundFile('sounds/ui_cancel.wav');
        setTimeout(() => window.close(), 300);
    });
    document.getElementById('devSpawnBtn').onclick = devSpawnItem;
    // â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ `devSpawnBtn` ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®ä¸‹ã«è¿½åŠ  â–¼â–¼â–¼
    document.getElementById('devShowSCSArrow').onchange = drawMap;
    document.getElementById('devShowNPCHintArrow').onchange = drawMap;
    document.getElementById('devShowResidentialArrow').onchange = drawMap;
    document.getElementById('devShowCommercialArrow').onchange = drawMap;
    document.getElementById('devShowIndustrialArrow').onchange = drawMap;
    document.getElementById('devShowCabinArrow').onchange = drawMap;
    document.getElementById('devShowTraderShopArrow').onchange = drawMap;
    // â–²â–²â–² è¿½åŠ ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²

// â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã§ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
// é–‹ç™ºè€…ãƒ‘ãƒãƒ«ã®è² å‚·è¿½åŠ ãƒœã‚¿ãƒ³ã®å‡¦ç†
document.getElementById('devAddBleedingBtn').onclick = () => {
    // æ—¢ã«å‡ºè¡€ã—ã¦ã„ã‚‹éƒ¨ä½ã®ãƒªã‚¹ãƒˆã‚’ä½œæˆ
    const injuredParts = player.injuries.filter(i => i.type === 'bleeding').map(i => i.part);
    // ã¾ã å‡ºè¡€ã—ã¦ã„ãªã„éƒ¨ä½ã®ãƒªã‚¹ãƒˆã‚’ä½œæˆ
    const availableParts = bodyParts.filter(part => !injuredParts.includes(part));

    if (availableParts.length > 0) {
        // ã¾ã å‡ºè¡€ã—ã¦ã„ãªã„éƒ¨ä½ãŒã‚ã‚Œã°ã€ãã“ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«é¸ã‚“ã§å‡ºè¡€ã•ã›ã‚‹
        const targetPart = randChoice(availableParts);
        player.injuries.push({ type: 'bleeding', part: targetPart });
        log("é–‹ç™ºè€…: æ–°ãŸãªéƒ¨ä½ã«å‡ºè¡€ã‚’ç™ºç”Ÿã•ã›ã¾ã—ãŸã€‚");
        updateStatus();
    } else {
        log("é–‹ç™ºè€…: å…¨ã¦ã®éƒ¨ä½ãŒæ—¢ã«å‡ºè¡€ã—ã¦ã„ã¾ã™ã€‚");
    }
};
document.getElementById('devAddBruiseBtn').onclick = () => {
    // æ—¢ã«æ‰“æ’²ã—ã¦ã„ã‚‹éƒ¨ä½ã®ãƒªã‚¹ãƒˆã‚’ä½œæˆ
    const injuredParts = player.injuries.filter(i => i.type === 'bruise').map(i => i.part);
    // ã¾ã æ‰“æ’²ã—ã¦ã„ãªã„éƒ¨ä½ã®ãƒªã‚¹ãƒˆã‚’ä½œæˆ
    const availableParts = bodyParts.filter(part => !injuredParts.includes(part));

    if (availableParts.length > 0) {
        // ã¾ã æ‰“æ’²ã—ã¦ã„ãªã„éƒ¨ä½ãŒã‚ã‚Œã°ã€ãã“ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«é¸ã‚“ã§æ‰“æ’²ã•ã›ã‚‹
        const targetPart = randChoice(availableParts);
        player.injuries.push({ type: 'bruise', duration: 24, part: targetPart });
        log("é–‹ç™ºè€…: æ–°ãŸãªéƒ¨ä½ã«æ‰“æ’²ã‚’ç™ºç”Ÿã•ã›ã¾ã—ãŸã€‚");
        updateStatus();
    } else {
        log("é–‹ç™ºè€…: å…¨ã¦ã®éƒ¨ä½ãŒæ—¢ã«æ‰“æ’²ã—ã¦ã„ã¾ã™ã€‚");
    }
};
document.getElementById('devAddFractureBtn').onclick = () => {
    const possibleFractureParts = ['rightArm', 'leftArm', 'rightLeg', 'leftLeg'];
    // æ—¢ã«éª¨æŠ˜ã—ã¦ã„ã‚‹éƒ¨ä½ã®ãƒªã‚¹ãƒˆã‚’ä½œæˆ
    const injuredParts = player.injuries.filter(i => i.type === 'fracture').map(i => i.part);
    // ã¾ã éª¨æŠ˜ã—ã¦ã„ãªã„å››è‚¢ã®ãƒªã‚¹ãƒˆã‚’ä½œæˆ
    const availableParts = possibleFractureParts.filter(part => !injuredParts.includes(part));
    
    if (availableParts.length > 0) {
        // ã¾ã éª¨æŠ˜ã—ã¦ã„ãªã„å››è‚¢ãŒã‚ã‚Œã°ã€ãã“ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«é¸ã‚“ã§éª¨æŠ˜ã•ã›ã‚‹
        const targetPart = randChoice(availableParts);
        player.injuries.push({ type: 'fracture', duration: 5, splinted: false, part: targetPart });
        log("é–‹ç™ºè€…: æ–°ãŸãªéƒ¨ä½ã«éª¨æŠ˜ã‚’ç™ºç”Ÿã•ã›ã¾ã—ãŸã€‚");
        updateStatus();
    } else {
        log("é–‹ç™ºè€…: å…¨ã¦ã®å››è‚¢ãŒæ—¢ã«éª¨æŠ˜ã—ã¦ã„ã¾ã™ã€‚");
    }
};
// â–²â–²â–² ç½®ãæ›ãˆã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²
    window.addEventListener('keydown', (event) => {
        // `(ãƒãƒƒã‚¯ã‚¯ã‚©ãƒ¼ãƒˆ)ã‚­ãƒ¼ãŒæŠ¼ã•ã‚ŒãŸã‚‰ãƒ‘ãƒãƒ«ã‚’é–‹é–‰
        if (event.key === '`') { 
            toggleDevPanel();
        }
    });   
    document.getElementById('playAgainBtn').addEventListener('click', initGame);
    document.getElementById('closeStorageBtn').addEventListener('click', closeStoragePanel);
    document.getElementById('pickupStorageBtn').addEventListener('click', pickupStorageBox);
    document.getElementById('sleepNowBtn').addEventListener('click', sleepForOneHour);
    document.getElementById('suicideBtn').addEventListener('click', () => speakAndConfirm(getString("confirm_suicide_q"), () => handleGameOver(getString("log_suicide_success")), () => log(getString("log_suicide_cancel"))));
    document.getElementById('waitTurnBtn').addEventListener('click', waitOneTurn);    
    document.getElementById('closeWorkbenchBtn').onclick = closeWorkbenchPanel;
    document.getElementById('openResearchBtn').onclick = () => {
    // æ­£ã—ã„ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ï¼ˆã“ã“ã«è¨˜è¿°ã•ã‚Œã¦ã„ã‚Œã°OKã§ã™ï¼‰
    // å„ãƒ‘ãƒãƒ«ã®é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’æ­£ã—ãè¨­å®š
    document.getElementById('researchPanelCloseBtn').onclick = closeResearchPanel;
    document.getElementById('explorationCloseBtn').onclick = closeExplorationPanel;
    document.getElementById('bodyPanelCloseBtn').onclick = () => {
        document.getElementById('bodyPanel').style.display = 'none';
    };
        const panel = document.getElementById('researchPanel');
        if (panel.style.display === 'none' || panel.style.display === '') {
            openResearchPanel(false);
            bringToFront(panel);
        } else {
            closeResearchPanel();
        }
    };
    
    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒãƒ‡ãƒãƒƒã‚°ã‚³ãƒ¼ãƒ‰ã‚’è¿½åŠ ã—ãŸç®‡æ‰€ã§ã™ â–¼â–¼â–¼
    console.log("ãƒ‡ãƒãƒƒã‚°: ãƒ‘ãƒãƒ«ã®é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ã‚’è¨­å®šã—ã¾ã™ã€‚");

    const researchCloseBtn = document.getElementById('researchPanelCloseBtn');
    console.log("ãƒ‡ãƒãƒƒã‚°: researchPanelCloseBtn ã®è¦ç´ :", researchCloseBtn);
    if (researchCloseBtn) {
        researchCloseBtn.onclick = closeResearchPanel;
    } else {
        console.error("ã‚¨ãƒ©ãƒ¼: ID 'researchPanelCloseBtn' ã®ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸï¼");
    }
// ã€ãƒ‡ãƒãƒƒã‚°ç”¨ã€‘èº«ä½“ãƒ‘ãƒãƒ«ã®åº§æ¨™å–å¾—
const bodyPanelForCoords = document.getElementById('bodyPanel');
if (bodyPanelForCoords) {
    bodyPanelForCoords.addEventListener('click', (event) => {
        const panelContent = bodyPanelForCoords.querySelector('.panel-content');
        if (!panelContent) return;

        // ãƒ‘ãƒãƒ«ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¨ãƒªã‚¢ã®å®Ÿéš›ã®ä½ç½®ã¨ã‚µã‚¤ã‚ºã‚’å–å¾—
        const rect = panelContent.getBoundingClientRect();
        
        // ã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸç”»é¢ä¸Šã®çµ¶å¯¾åº§æ¨™ã‹ã‚‰ã€ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¨ãƒªã‚¢ã®å·¦ä¸Šã®çµ¶å¯¾åº§æ¨™ã‚’å¼•ã
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        // ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«CSSã§ä½¿ãˆã‚‹å½¢å¼ã§åº§æ¨™ã‚’å‡ºåŠ›
        console.log(`èº«ä½“ãƒ‘ãƒãƒ«ã®ã‚¯ãƒªãƒƒã‚¯åº§æ¨™: left: ${x.toFixed(0)}px, top: ${y.toFixed(0)}px`);
    });
}
    // â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²
    const explorationCloseBtn = document.getElementById('explorationCloseBtn');
    console.log("ãƒ‡ãƒãƒƒã‚°: explorationCloseBtn ã®è¦ç´ :", explorationCloseBtn);
    if (explorationCloseBtn) {
        explorationCloseBtn.onclick = closeExplorationPanel;
    } else {
        console.error("ã‚¨ãƒ©ãƒ¼: ID 'explorationCloseBtn' ã®ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸï¼");
    }

    const bodyCloseBtn = document.getElementById('bodyPanelCloseBtn');
    console.log("ãƒ‡ãƒãƒƒã‚°: bodyPanelCloseBtn ã®è¦ç´ :", bodyCloseBtn);
    if (bodyCloseBtn) {
        bodyCloseBtn.onclick = () => {
            document.getElementById('bodyPanel').style.display = 'none';
        };
    } else {
        console.error("ã‚¨ãƒ©ãƒ¼: ID 'bodyPanelCloseBtn' ã®ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸï¼");
    }
    console.log("ãƒ‡ãƒãƒƒã‚°: ãƒ‘ãƒãƒ«ã®é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ã®è¨­å®šãŒå®Œäº†ã—ã¾ã—ãŸã€‚");
    // â–²â–²â–² ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²

    const setupButtonTooltip = (buttonId, titleKey, tooltipKey) => {
        const button = document.getElementById(buttonId);
        if (button) {
            button.addEventListener('mouseenter', (e) => showInfoTooltip(e, getString(titleKey), getString(tooltipKey)));
            button.addEventListener('mouseleave', hideInfoTooltip);
            button.addEventListener('mousemove', (e) => updatePreviewPosition(e));
        }
    };

    setupButtonTooltip('suicideBtn', 'char_info_suicide_button', 'tooltip_btn_suicide');
    setupButtonTooltip('waitTurnBtn', 'char_info_wait_button', 'tooltip_btn_wait');
    setupButtonTooltip('sleepNowBtn', 'char_info_sleep_button', 'tooltip_btn_sleep');
    setupButtonTooltip('saveGameBtn', 'char_info_save_button', 'tooltip_btn_save');
    setupButtonTooltip('ingameOptionsBtn', 'options', 'tooltip_btn_options');
    setupButtonTooltip('saveUILayoutBtn', 'btn_save_layout', 'tooltip_btn_save_layout');
    
    const setupItemDetailButtonTooltip = (buttonId, tooltipKey) => {
        const button = document.getElementById(buttonId);
        if(button) {
            button.addEventListener('mouseenter', (e) => showInfoTooltip(e, button.textContent, getString(tooltipKey)));
            button.addEventListener('mouseleave', hideInfoTooltip);
            button.addEventListener('mousemove', (e) => updatePreviewPosition(e));
        }
    };

    setupItemDetailButtonTooltip('useItemBtn', 'tooltip_btn_use');
    setupItemDetailButtonTooltip('eatItemBtn', 'tooltip_btn_eat');
    setupItemDetailButtonTooltip('drinkItemBtn', 'tooltip_btn_drink');
    setupItemDetailButtonTooltip('equipItemBtn', 'tooltip_btn_equip');
    setupItemDetailButtonTooltip('unequipItemBtn', 'tooltip_btn_unequip');
    setupItemDetailButtonTooltip('dropItemBtn', 'tooltip_btn_drop');
    setupItemDetailButtonTooltip('pickupItemBtn', 'tooltip_btn_pickup');
    setupItemDetailButtonTooltip('dismantleBtn', 'tooltip_btn_dismantle');
    setupItemDetailButtonTooltip('cookItemBtn', 'tooltip_btn_cook');
    setupItemDetailButtonTooltip('boilItemBtn', 'tooltip_btn_boil');
    setupItemDetailButtonTooltip('butcherItemBtn', 'tooltip_btn_butcher');
    setupItemDetailButtonTooltip('searchCorpseBtn', 'tooltip_btn_search');
    setupItemDetailButtonTooltip('wringClothBtn', 'tooltip_btn_wring');

    const statusLines = {
        'status_health': document.querySelector('[data-translate-key="status_health"]').parentElement,
        'status_hunger': document.querySelector('[data-translate-key="status_hunger"]').parentElement,
        'status_thirst': document.querySelector('[data-translate-key="status_thirst"]').parentElement,
        'status_sleep': document.querySelector('[data-translate-key="status_sleep"]').parentElement,
        'status_morale': document.querySelector('[data-translate-key="status_morale"]').parentElement,
        'status_body_temp': document.getElementById('bodyTempStatusLine'),
        'status_body_odor': document.getElementById('bodyOdorStatusLine'),
         // â–¼â–¼â–¼ ã“ã®3è¡Œã‚’è¿½åŠ  â–¼â–¼â–¼
        'status_blood_level': document.querySelector('[data-translate-key="status_blood_level"]').parentElement,
        'status_immune_system': document.querySelector('[data-translate-key="status_immune_system"]').parentElement,
        'status_pain_tolerance': document.querySelector('[data-translate-key="status_pain_tolerance"]').parentElement,
        // â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²
        'status_carbs': document.querySelector('[data-translate-key="status_carbs"]').parentElement,
        'status_protein': document.querySelector('[data-translate-key="status_protein"]').parentElement,
        'status_fat': document.querySelector('[data-translate-key="status_fat"]').parentElement,
        'status_vitamins': document.querySelector('[data-translate-key="status_vitamins"]').parentElement,
        'status_attack': document.querySelector('[data-translate-key="status_attack"]').parentElement,
        'status_defense': document.querySelector('[data-translate-key="status_defense"]').parentElement,
        'status_weight': document.querySelector('[data-translate-key="status_weight"]').parentElement,
        'status_volume': document.querySelector('[data-translate-key="status_volume"]').parentElement
    };

    for (const key in statusLines) {
        if (statusLines[key]) {
            statusLines[key].style.cursor = 'help';
            if (key !== 'status_body_temp') {
                statusLines[key].addEventListener('mouseenter', (e) => showInfoTooltip(e, getString(key), getString(`tooltip_${key}`)));
                statusLines[key].addEventListener('mouseleave', hideInfoTooltip);
                statusLines[key].addEventListener('mousemove', (e) => updatePreviewPosition(e));
            }
        }
    }

// â–¼â–¼â–¼ æ—¢å­˜ã® for (const key in statusLines) { ... } ãƒ«ãƒ¼ãƒ—ã¨ãã®å‘¨è¾ºã‚’ã€ã“ã®å†…å®¹ã§ä¸¸ã”ã¨ç½®ãæ›ãˆã¦ãã ã•ã„ â–¼â–¼â–¼
    const bodyTempLine = document.getElementById('bodyTempStatusLine');
    bodyTempLine.addEventListener('mouseenter', showBodyTempTooltip);
    bodyTempLine.addEventListener('mouseleave', hideStatusPreview);
    bodyTempLine.addEventListener('mousemove', (e) => updatePreviewPosition(e));
    
    // å„ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡Œã«ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã‚’è¨­å®š
    const setupStatTooltip = (key) => {
        const line = statusLines[key];
        if (line) {
            line.style.cursor = 'help';
            if (key === 'status_attack') {
                line.addEventListener('mouseenter', (e) => showStatusPanelStatTooltip('attack', e));
            } else if (key === 'status_defense') {
                line.addEventListener('mouseenter', (e) => showStatusPanelStatTooltip('defense', e));
            } else {
                line.addEventListener('mouseenter', (e) => showInfoTooltip(e, getString(key), getString(`tooltip_${key}`)));
            }
            line.addEventListener('mouseleave', hideInfoTooltip);
            line.addEventListener('mousemove', (e) => updatePreviewPosition(e));
        }
    };

    for (const key in statusLines) {
        // bodyTempStatusLineã¯å€‹åˆ¥ã§å‡¦ç†æ¸ˆã¿ãªã®ã§ã‚¹ã‚­ãƒƒãƒ—
        if (key !== 'status_body_temp') {
            setupStatTooltip(key);
        }
    }
// â–²â–²â–² ç½®ãæ›ãˆã¯ã“ã“ã¾ã§ â–²â–²â–²

    const walkBtn = document.getElementById('moveWalkBtn');
    const runBtn = document.getElementById('moveRunBtn');

    walkBtn.onclick = () => setMovementMode('walk');
    walkBtn.addEventListener('mouseenter', (e) => showInfoTooltip(e, getString('move_walk'), getString('move_tooltip_walk')));
    walkBtn.addEventListener('mouseleave', hideStatusPreview);
    walkBtn.addEventListener('mousemove', updatePreviewPosition);

    runBtn.onclick = () => setMovementMode('run');
    runBtn.addEventListener('mouseenter', (e) => showInfoTooltip(e, getString('move_run'), getString('move_tooltip_run')));
    runBtn.addEventListener('mouseleave', hideStatusPreview);
    runBtn.addEventListener('mousemove', updatePreviewPosition);

    document.getElementById('saveGameBtn').addEventListener('click', saveGame);
    
    document.getElementById('saveUILayoutBtn').addEventListener('click', saveUILayout);

    ipcRenderer.invoke('has-save-file').then(hasSave => {
        if (hasSave) {
            document.getElementById('loadGameBtn').style.display = 'inline-block';
        }
    });

    window.addEventListener('resize', drawMap);
    window.addEventListener('beforeunload', () => {
        speechSynthesis.cancel();
    });

    ipcRenderer.invoke('load-settings').then(settings => {
        if (settings) {
            console.log("ä¿å­˜ã•ã‚ŒãŸè¨­å®šã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸã€‚", settings);
            applyUISettings({ options: settings });
        }
    });
    
    ipcRenderer.invoke('load-ui-layout').then(uiSettings => {
        if (uiSettings) {
            console.log("ä¿å­˜ã•ã‚ŒãŸUIãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸã€‚");
            applyUISettings(uiSettings);
        }
    });

    document.getElementById('volumeSlider').addEventListener('input', (event) => {
        if (ambientGainNode) {
            const volume = parseFloat(event.target.value);
            ambientGainNode.gain.setTargetAtTime(volume, audioCtx.currentTime, 0.01);
        }
    });

    document.getElementById('voiceVolumeSlider').addEventListener('input', (event) => {
        clearTimeout(voicePreviewTimeout);
        const volume = parseFloat(event.target.value);
        if (volume > 0) {
            voicePreviewTimeout = setTimeout(() => {
                playSoundFile('sounds/grunt.wav', volume);
            }, 150);
        }
    });

    document.getElementById('speechVolumeSlider').addEventListener('input', (event) => {
        clearTimeout(speechPreviewTimeout);
        const volume = parseFloat(event.target.value);
        if (volume > 0) {
            speechPreviewTimeout = setTimeout(() => {
                speak(getString("options_speech_preview_text"));
            }, 200);
        }
    });

    function interruptAndClearSpeech() {
        speechSynthesis.cancel();
        speechQueue = [];
        isSpeechQueueActive = false;
    }
    
    window.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
            const optionsScreen = document.getElementById('optionsScreen');
            if (window.getComputedStyle(optionsScreen).display === 'flex') {
                cancelSettingsChanges();
            } else {
                openOptionsAndCaptureState();
                bringToFront(optionsScreen);
            }
        }
    });
   playMenuBGM();
   
    const researchContainer = document.getElementById('researchTreeContainer');
    let isPanning = false;
    let startX, startY, scrollLeft, scrollTop;

    researchContainer.addEventListener('mousedown', (e) => {
        if (e.target !== researchContainer && e.target !== document.getElementById('researchTreeNodes')) {
            return;
        }
        isPanning = true;
        researchContainer.style.cursor = 'grabbing';
        startX = e.pageX - researchContainer.offsetLeft;
        startY = e.pageY - researchContainer.offsetTop;
        scrollLeft = researchContainer.scrollLeft;
        scrollTop = researchContainer.scrollTop;
    });

    researchContainer.addEventListener('mouseleave', () => {
        isPanning = false;
        researchContainer.style.cursor = 'grab';
    });

    researchContainer.addEventListener('mouseup', () => {
        isPanning = false;
        researchContainer.style.cursor = 'grab';
    });

    researchContainer.addEventListener('mousemove', (e) => {
        if (!isPanning) return;
        e.preventDefault();
        const x = e.pageX - researchContainer.offsetLeft;
        const y = e.pageY - researchContainer.offsetTop;
        const walkX = (x - startX);
        const walkY = (y - startY);
        researchContainer.scrollLeft = scrollLeft - walkX;
        researchContainer.scrollTop = scrollTop - walkY;
    });
      // â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ–°ã—ãè¿½åŠ  â–¼â–¼-â–¼
    // å¤–éƒ¨ãƒªãƒ³ã‚¯ã‚’å®‰å…¨ã«é–‹ããŸã‚ã®å‡¦ç†
    const { shell } = require('electron');
    document.querySelectorAll('#externalLinksContainer a').forEach(link => {
        link.addEventListener('click', (event) => {
            event.preventDefault(); // é€šå¸¸ã®ã‚¯ãƒªãƒƒã‚¯å‹•ä½œã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
            const url = event.currentTarget.href;
            if (url) {
                shell.openExternal(url); // OSã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ–ãƒ©ã‚¦ã‚¶ã§URLã‚’é–‹ã
            }
        });
    });
// index.htmlã®DOMContentLoadedå†…

let combatBgmPreviewTimeout = null;
document.getElementById('combatBgmVolumeSlider').addEventListener('input', (event) => {
    clearTimeout(combatBgmPreviewTimeout);
    const volume = parseFloat(event.target.value);

    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â–¼â–¼â–¼
    // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªgainNodeãŒå­˜åœ¨ã™ã‚Œã°ã€ãã®éŸ³é‡ã‚’å³åº§ã«æ›´æ–°
    if (combatBgmGainNode) {
        combatBgmGainNode.gain.setTargetAtTime(volume, audioCtx.currentTime, 0.01);
    }
    // â–²â–²â–² ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²

    if (volume > 0) {
        combatBgmPreviewTimeout = setTimeout(() => {
            playSoundFile('sounds/ui_confirm.wav', volume);
        }, 150);
    }
});

});

/**
 * æ¢ç´¢ãƒ‘ãƒãƒ«å†…ã®å»ºç‰©ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã¨ãã®å‡¦ç†
 */
function exploreBuilding(tile, buildingIndex) {
    // ã©ã®å»ºç‰©ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸã‹ã‚’å–å¾—
    const building = tile.explorableLocations[buildingIndex];
    log(`'${getString(building.nameKey)}' ã‚’æ¢ç´¢ã™ã‚‹...`, false);
    
    // ã‚¢ã‚¤ãƒ†ãƒ ã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã«æ—¢å­˜ã®æ¢ç´¢é–¢æ•°ã‚’å‘¼ã³å‡ºã™
    searchCurrentLocation();
    
    // æ¢ç´¢æ¸ˆã¿ã®å»ºç‰©ã‚’ãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤
    tile.explorableLocations.splice(buildingIndex, 1);
    
    // ã‚‚ã—å…¨ã¦ã®å»ºç‰©ã‚’æ¢ç´¢ã—çµ‚ãˆãŸã‚‰ã€ãã®æ–½è¨­ã‚¿ã‚¤ãƒ«è‡ªä½“ã‚’ã€Œæ¢ç´¢æ¸ˆã¿ã€ã«ã™ã‚‹
    if (tile.explorableLocations.length === 0) {
        log(`ã“ã®æ–½è¨­ã®æ¢ç´¢ã§ãã‚‹å ´æ‰€ã¯ã‚‚ã†ãªã„ã‚ˆã†ã ã€‚`);
        tile.searched = true;
    }

    closeExplorationPanel(); // ãƒ‘ãƒãƒ«ã‚’é–‰ã˜ã‚‹
    updateCurrentLocationPanel(false); // ãƒœã‚¿ãƒ³ã®è¡¨ç¤ºã‚’æ›´æ–°
}

/**
 * æ–½è¨­æ¢ç´¢ãƒ‘ãƒãƒ«ã‚’é–‹ãé–¢æ•°
 */
function openExplorationPanel(tile) {
    const panel = document.getElementById('explorationPanel');
    const contentDiv = document.getElementById('explorationContent');
    contentDiv.innerHTML = '';

    if (!tile.explorableLocations) {
        const possibleLocations = buildingExplorationPools[tile.loc.nameKey] || [];
        if (possibleLocations.length === 0) return;

        const imageCount = Math.floor(Math.random() * 4) + 1;
        
        tile.explorableLocations = [];
        for (let i = 0; i < imageCount; i++) {
            const choice = randChoice(possibleLocations);
            tile.explorableLocations.push({
                ...choice,
                lootAmount: Math.floor(Math.random() * 81) + 20,
                safetyLevel: Math.floor(Math.random() * 91) + 10,
                sneakLevel: Math.floor(Math.random() * 91) + 10
            });
        }
    }
    
    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â–¼â–¼â–¼
    tile.explorableLocations.forEach((location, index) => {
        // 1. ç”»åƒã¨ãƒ†ã‚­ã‚¹ãƒˆã‚’ã¾ã¨ã‚ã‚‹ã‚³ãƒ³ãƒ†ãƒŠDIVã‚’ä½œæˆ
        const itemContainer = document.createElement('div');
        itemContainer.className = 'exploration-item';
        itemContainer.onclick = () => openExplorationPreviewPanel(tile, index);

        // 2. ç”»åƒã‚’ä½œæˆ
        const img = document.createElement('img');
        img.src = location.icon;

        // 3. å»ºç‰©ã®åå‰ã‚’è¡¨ç¤ºã™ã‚‹Pã‚¿ã‚°ã‚’ä½œæˆ
        const nameP = document.createElement('p');
        nameP.textContent = getString(location.nameKey);

        // 4. ã‚³ãƒ³ãƒ†ãƒŠã«ç”»åƒã¨åå‰ã‚’è¿½åŠ 
        itemContainer.appendChild(img);
        itemContainer.appendChild(nameP);

        // 5. æœ€çµ‚çš„ãªã‚³ãƒ³ãƒ†ãƒŠã‚’ãƒ‘ãƒãƒ«ã«è¿½åŠ 
        contentDiv.appendChild(itemContainer);
    });
    // â–²â–²â–² ä¿®æ­£ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²
    
    panel.style.display = 'flex';
    bringToFront(panel);
}

function openExplorationPreviewPanel(tile, buildingIndex) {
    const building = tile.explorableLocations[buildingIndex];
    if (!building) return;

    const panel = document.getElementById('explorationPreviewPanel');
    document.getElementById('explorationPreviewHeader').textContent = getString(building.nameKey);
    document.getElementById('explorationPreviewImage').src = building.icon;
    document.getElementById('explorationPreviewDesc').textContent = getString(`building_desc_${building.nameKey.replace('location_', '')}`);
    
    const lootBar = document.getElementById('lootBar');
    lootBar.style.width = `${building.lootAmount}%`;
    lootBar.style.background = building.lootAmount > 70 ? '#27ae60' : (building.lootAmount > 40 ? '#f1c40f' : '#e74c3c');
    
    const safetyBar = document.getElementById('safetyBar');
    safetyBar.style.width = `${building.safetyLevel}%`;
    safetyBar.style.background = building.safetyLevel > 70 ? '#27ae60' : (building.safetyLevel > 40 ? '#f1c40f' : '#e74c3c');

    const sneakBar = document.getElementById('sneakBar');
    sneakBar.style.width = `${building.sneakLevel}%`;
    sneakBar.style.background = building.sneakLevel > 70 ? '#27ae60' : (building.sneakLevel > 40 ? '#f1c40f' : '#e74c3c');

    // â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ–°ã—ãè¿½åŠ ã—ã¦ãã ã•ã„ â–¼â–¼â–¼
    const setupStatTooltip = (key) => {
        const element = panel.querySelector(`[data-translate-key="preview_label_${key}"]`);
        if (element) {
            element.style.cursor = 'help';
            element.addEventListener('mouseenter', (e) => showInfoTooltip(e, getString(`preview_label_${key}`), getString(`tooltip_preview_${key}`)));
            element.addEventListener('mouseleave', hideInfoTooltip);
            element.addEventListener('mousemove', (e) => updatePreviewPosition(e));
        }
    };
    setupStatTooltip('loot');
    setupStatTooltip('safety');
    setupStatTooltip('sneak');
    // â–²â–²â–² è¿½åŠ ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²

    document.getElementById('exploreConfirmBtn').onclick = () => resolveExploration(tile, buildingIndex);
    document.getElementById('exploreCancelBtn').onclick = closeExplorationPreviewPanel;

    panel.style.display = 'block';
    bringToFront(panel);
}
/**
 * æ¢ç´¢ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ‘ãƒãƒ«ã‚’é–‰ã˜ã‚‹é–¢æ•°
 */
function closeExplorationPreviewPanel() {
    document.getElementById('explorationPreviewPanel').style.display = 'none';
}

/**
 * å»ºç‰©ã®æ¢ç´¢ã‚’å®Ÿè¡Œã™ã‚‹é–¢æ•°
 */
/**
 * å»ºç‰©ã®æ¢ç´¢ã‚’å®Ÿè¡Œã™ã‚‹é–¢æ•°
 */
function resolveExploration(tile, buildingIndex) {
    const building = tile.explorableLocations[buildingIndex];
    
    log(`'${getString(building.nameKey)}' ã‚’æ¢ç´¢ã™ã‚‹...`, false);
    
    let encounterOccurred = false;

    // --- ã‚¹ãƒ‹ãƒ¼ã‚¯åˆ¤å®š (æ•µã¨ã®é­é‡) ---
    if (Math.random() * 100 > building.sneakLevel) {
        log("ï¼ ç‰©éŸ³ã‚’ç«‹ã¦ã¦ã—ã¾ã„ã€ä½•è€…ã‹ã®æ³¨æ„ã‚’å¼•ã„ã¦ã—ã¾ã£ãŸï¼", true);
        
        // â–¼â–¼â–¼ ã“ã®è¡Œã‚’æ–°ã—ãè¿½åŠ ã—ã¾ã—ãŸ â–¼â–¼â–¼
        createSound(player.x, player.y, 8, 'æ¢ç´¢');
        // â–²â–²â–² è¿½åŠ ã¯ã“ã“ã¾ã§ã§ã™ â–²â–²â–²

        const dangerEvents = buildingDangerEvents[building.nameKey] || [];
        const danger = randChoice(dangerEvents);
        
        if (danger) {
            let enemyType;
            if (danger.type === 'zombie') enemyType = 'Zombie';
            if (danger.type === 'raider') enemyType = 'Raider';

            if (enemyType) {
                const enemy = generateNPC(enemyType);
                enemy.x = player.x;
                enemy.y = player.y;
                entities.push(enemy);
                encounterOccurred = true;
                setTimeout(() => startCombat(enemy, false), 500);
            }
        }
    }

    // --- ã‚»ã‚¤ãƒ•ãƒ†ã‚£åˆ¤å®š (æ€ªæˆ‘) ---
    if (!encounterOccurred && Math.random() * 100 > building.safetyLevel) {
        const injuredParts = player.injuries.map(injury => injury.part);
        const availableParts = bodyParts.filter(part => !injuredParts.includes(part));
        
        if (availableParts.length > 0) {
            const targetPart = randChoice(availableParts);
            player.injuries.push({ type: 'bruise', duration: 24, part: targetPart });
            const translatedPartName = getString('part_' + targetPart);
            log(getString("log_explore_injury", { partName: translatedPartName }), true);
        } else {
            log(getString("log_explore_no_new_injury"), false);
        }
    }

    // --- ãƒ«ãƒ¼ãƒˆåˆ¤å®š (ã‚¢ã‚¤ãƒ†ãƒ ç™ºè¦‹) ---
    const numberOfItemsFound = Math.floor(Math.random() * 6);

    if (numberOfItemsFound > 0) {
        const locationKey = `${player.x},${player.y}`;
        if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
        
        const lootPool = buildingLootPools[building.nameKey] || [];
        
        if (lootPool.length > 0) {
            for (let i = 0; i < numberOfItemsFound; i++) {
                const itemName = randChoice(lootPool);
                const itemTemplate = items.find(it => it.name === itemName);
                if (itemTemplate) {
                    droppedItems[locationKey].push({ ...itemTemplate });
                }
            }
            log("ã„ãã¤ã‹ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’ç™ºè¦‹ã—ã€åœ°é¢ã«ç½®ã„ãŸã€‚", true);
        } else {
            log(getString("info_found_nothing"), false);
        }
    } else {
        log(getString("info_found_nothing"), false);
    }

    tile.explorableLocations.splice(buildingIndex, 1);
    
    if (tile.explorableLocations.length === 0) {
        log(`ã“ã®æ–½è¨­ã®æ¢ç´¢ã§ãã‚‹å ´æ‰€ã¯ã‚‚ã†ãªã„ã‚ˆã†ã ã€‚`);
        tile.searched = true;
    }

    closeExplorationPreviewPanel();
    closeExplorationPanel();
    
    if (!encounterOccurred) {
        snapshotStats();
        advanceTurn();
        updateTurnInfo();
        drawMap();
        updateStatus();
        updateItemPanels();
        updateCharacterBody();
        updateCharacterInfo();
        checkGameOver();
        updateCurrentLocationPanel(false);
        processSpeechQueue();
    }
}
/**
 * æ¢ç´¢ãƒ‘ãƒãƒ«ã‚’é–‰ã˜ã‚‹é–¢æ•°
 */
function closeExplorationPanel() {
    document.getElementById('explorationPanel').style.display = 'none';
    closeExplorationPreviewPanel(); // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚‚ä¸€ç·’ã«é–‰ã˜ã‚‹
}
</script>


</body>
</html>