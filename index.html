<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>ã‚¾ãƒ³ãƒ“ã‚µãƒã‚¤ãƒãƒ«ï¼ˆå¤§è¦æ¨¡ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆç‰ˆï¼‰</title>
<meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline'">
<style>
body {
  background: #111;
  color: #eee;
  font-family: monospace, monospace;
  margin: 0;
  user-select: none;
  height: 100vh;
  overflow: hidden;
  position: relative;
  transition: background-color 2s linear;
}
#startScreen, #gameClearScreen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #111;
  color: #eee;
  z-index: 10000;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
  font-family: sans-serif;
}
#startScreen h1 {
  font-size: 3em;
  color: #e74c3c;
  text-shadow: 0 0 10px #c0392b;
}
#startScreen button, #gameClearScreen button {
  padding: 15px 30px;
  font-size: 1.5em;
  background: #333;
  color: #eee;
  border: 1px solid #555;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.3s ease;
  margin-top: 20px;
}
#startScreen button:hover, #gameClearScreen button:hover {
  background: #555;
  border-color: #777;
  transform: scale(1.05);
}
#quitGameBtn {
    background: #a04040 !important;
    border-color: #c06060 !important;
}
#quitGameBtn:hover {
    background: #c0392b !important;
}
#gameClearScreen .gate-art {
  font-size: 1.5em;
  line-height: 1.2;
  white-space: pre;
  color: #f1c40f;
  margin-bottom: 20px;
}
#gameClearScreen h2 {
    font-size: 2.5em;
    margin-bottom: 20px;
}
#gameClearScreen p {
    font-size: 1.2em;
    margin-bottom: 30px;
}

.panel {
  position: absolute;
  background: #222;
  border-radius: 6px;
  border: 1px solid #444;
  padding: 10px;
  box-sizing: border-box;
  cursor: grab;
  user-select: none;
  z-index: 10;
  box-shadow: 0 0 15px #000a inset;
  overflow: hidden;
}
.panel .resize-handle {
  position: absolute;
  width: 16px;
  height: 16px;
  right: 2px;
  bottom: 2px;
  background: #888;
  border-radius: 4px;
  cursor: nwse-resize;
  z-index: 1000;
}
.panel .resize-handle:hover {
  background: #aaa;
}
.panel-header {
  font-weight: bold;
  margin-bottom: 6px;
  cursor: grab;
  user-select: none;
  padding-bottom: 4px;
  border-bottom: 1px solid #555;
  user-select:none;
  -webkit-user-select:none;
  -moz-user-select:none;
  -ms-user-select:none;
  display: flex;
  justify-content: space-between;
  align-items: center;
}
#mapHeaderInfo {
    font-size: 14px;
    font-weight: normal;
    color: #ccc;
    /* pointer-events: none; ã®è¡Œã‚’å‰Šé™¤ */
}
#mapHeaderInfo .temp-hot { color: #e74c3c; }
#mapHeaderInfo .temp-normal { color: #2ecc71; }
#mapHeaderInfo .temp-cold { color: #3498db; }
#mapHeaderInfo span { margin: 0 5px; }

#map {
  display: grid;
  grid-gap: 2px;
  width: 100%;
  height: 100%;
  overflow: visible;
  font-size: 12px;
  position: relative; /* For positioning entities */
}
.tile {
  width: 40px;
  height: 40px;
  display: flex;
  justify-content: center;
  align-items: center;
  cursor: pointer;
  border: 1px solid #333;
  background: #555;
  color: #eee;
  user-select: none;
  position: relative;
  transition: background-color 0.3s;
  font-size: 30px; /* â˜…ã“ã®ä¸€è¡Œã§ã‚¢ã‚¤ã‚³ãƒ³ã‚’å¤§ããã—ã¦ã„ã¾ã™ */
}
.tile.targeting {
    background-color: #8E44AD;
    box-shadow: 0 0 10px #8E44AD;
}
.tile.targeting:hover {
    background-color: #9B59B6;
}
.unexplored {
  background: #555;
  color: #555;
}
.explored {
  background: #777;
}
.memorized-tile {
  background: #5a3d24; /* è¨˜æ†¶ã‚’è¡¨ã™èŒ¶è‰² */
  color: #aaa; /* è¨˜æ†¶å†…ã®ã‚¢ã‚¤ã‚³ãƒ³ã‚’å°‘ã—æš—ãã™ã‚‹ */
}
.road-tile {
  background: #4a4a4a;
}
.player-tile {
  background: #2c3e50; /* Changed background for player tile */
  position: relative;
}
.map-overlay-icon {
    position: absolute;
    font-size: 32px;
    z-index: 60;
    text-shadow: 0 0 8px #000;
    pointer-events: all;
    cursor: help;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    height: 100%;
}
.map-overlay-icon.campfire {
    animation: flicker 1.5s infinite alternate;
}
.map-overlay-icon.unlit-campfire {
    filter: grayscale(100%) brightness(0.7);
}
@keyframes flicker {
  0%, 18%, 22%, 25%, 53%, 57%, 100% {
    text-shadow:
      0 0 4px #fff,
      0 0 11px #fff,
      0 0 19px #fff,
      0 0 40px #f09,
      0 0 80px #f09,
      0 0 90px #f09,
      0 0 100px #f09,
      0 0 150px #f09;
  }
  20%, 24%, 55% { text-shadow: none; }
}

.entity-icon {
    position: absolute;
    font-size: 24px;
    z-index: 40;
    text-shadow: 0 0 5px #000;
    pointer-events: all; /* Make icon hoverable */
    cursor: help;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    height: 100%;
}
.player-icon {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 24px;
  z-index: 50;
  text-shadow: 0 0 5px #000;
  pointer-events: none;
}
.player-icon.race-white { color: #f5f5dc; }
.player-icon.race-asian { color: #f7e7c6; }
.player-icon.race-black { color: #2e2621; }
.player-icon.race-middle-eastern { color: #8b5a2b; }

#playerDirectionArrow {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  border-left: 10px solid transparent;
  border-right: 10px solid transparent;
  border-bottom: 20px solid red;
  transform-origin: 50% 100%;
  z-index: 50;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s ease, transform 0.2s ease;
}
.status-line {
  margin-bottom: 6px;
  font-family: sans-serif;
  cursor: default;
}
.status-label {
  display: inline-block;
  width: 60px;
  font-weight: bold;
  color: #ccc;
}
.bar {
  display: inline-block;
  width: 150px;
  height: 10px;
  background: #333;
  margin-right: 6px;
  border-radius: 5px;
  vertical-align: middle;
  overflow: hidden;
}
.fill {
  height: 100%;
  background: lime;
  transition: width 0.3s ease;
}
.fill.hunger { background: #d35400; }
.fill.thirst { background: #2980b9; }
.fill.health { background: #27ae60; }
.fill.morale { background: #f1c40f; }
.fill.sleep { background: #8e44ad; }
.fill.weight { background: #7f8c8d; }
.fill.volume { background: #9b59b6; }
.fill.attack { background: #e67e22; }
.fill.defense { background: #2980b9; }
.fill.bodyTemp { background: #7f8c8d; }
#log {
  background: #000;
  height: 120px;
  overflow-y: auto;
  font-size: 12px;
  padding: 5px;
  margin-top: 6px;
  line-height: 1.3em;
  font-weight: normal;
  color: #888;
}
#log div.new {
  color: #eee;
  font-weight: bold;
}
.item-list {
  background: #111;
  padding: 5px;
  height: calc(100% - 25px);
  overflow-y: auto;
  margin-top: 6px;
  font-family: sans-serif;
  color: #eee;
}
.item {
  background: #333;
  padding: 5px;
  margin: 3px 0;
  cursor: pointer;
  font-size: 12px;
  border-radius: 4px;
}
.item:hover {
  background: #555;
}
.item button {
  background: #444;
  color: #eee;
  border: none;
  padding: 2px 5px;
  border-radius: 3px;
  cursor: pointer;
  opacity: 0.7;
 }
 .item button:hover {
  opacity: 1.0;
  background: #666;
 }
#currentLocationPanel .panel-content {
  color: #eee;
  font-family: monospace, monospace;
  white-space: pre;
  user-select: none;
  overflow: auto;
  min-height: 140px;
  text-align: center;
  font-size: 16px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}
#currentLocationPanel .location-name {
  font-family: sans-serif;
  font-size: 1.2em;
  margin-bottom: 5px;
}
#currentLocationPanel .ascii-art {
  font-size: 1.1em;
  line-height: 1.1;
  margin-top: 10px;
}
#itemDetailPanel {
  position: absolute;
  background: #222;
  border-radius: 6px;
  border: 1px solid #444;
  padding: 15px;
  box-shadow: 0 0 20px rgba(0,0,0,0.8);
  z-index: 1000;
  width: 300px;
  max-width: 90vw;
  font-family: sans-serif;
  display: none;
}
#itemDetailPanel .panel-header {
  font-size: 1.2em;
  border-bottom: 1px solid #555;
  padding-bottom: 8px;
  margin-bottom: 10px;
  cursor: grab;
}
#itemDetailPanel .item-detail-info {
  line-height: 1.6em;
  font-size: 14px;
}
#itemDetailPanel .item-detail-info strong {
  display: inline-block;
  width: 80px;
}
#itemDetailPanel .item-detail-actions {
  margin-top: 15px;
  text-align: right;
}
#itemDetailPanel button {
  background: #444;
  color: #eee;
  border: none;
  padding: 8px 15px;
  border-radius: 5px;
  cursor: pointer;
  margin-left: 5px;
}
#itemDetailPanel button:hover {
  background: #666;
}
.item-graphic-container {
  text-align: center;
  margin: 10px 0;
}
.item-graphic {
  font-size: 48px;
  line-height: 1;
}
.item-description {
  margin-bottom: 10px;
  border-bottom: 1px solid #555;
  padding-bottom: 10px;
}
.item-effect-positive { color: limegreen; }
.item-effect-negative { color: indianred; }
#statusPreview {
  position: fixed;
  background: rgba(34, 34, 34, 0.95);
  border: 1px solid #666;
  border-radius: 4px;
  padding: 8px;
  font-size: 12px;
  color: #eee;
  pointer-events: none;
  z-index: 9999;
  display: none;
  box-shadow: 0 2px 8px rgba(0,0,0,0.5);
  line-height: 1.5;
}
.preview-stat {
  margin: 2px 0;
  display: flex;
  align-items: center;
}
.preview-stat-name {
  width: 50px;
  display: inline-block;
}
.preview-change {
  margin-left: 5px;
  font-weight: bold;
}
.preview-change.positive { color: #27ae60; }
.preview-change.negative { color: #e74c3c; }
.preview-change.neutral { color: #95a5a6; }
.trait-pill {
    background: #444;
    color: #fff;
    padding: 3px 8px;
    margin-right: 4px;
    border-radius: 12px;
    font-size: 12px;
    display: inline-block;
    white-space: nowrap;
    cursor: help;
}
#physicalCondition {
  margin-top: 10px;
  font-family: sans-serif;
  font-size: 14px;
  line-height: 1.4;
  padding: 5px;
  border-top: 1px solid #555;
}
#physicalCondition span[onmouseenter] {
    cursor: help;
    text-decoration: underline dotted;
}
.condition-normal { color: #3498db; }
.condition-warning { color: #f1c40f; }
.condition-critical { color: #e74c3c; }

#physicalCondition strong {
  display: block;
  margin-bottom: 5px;
}
.panel.minimized {
  position: fixed !important;
  right: 10px;
  bottom: 10px;
  width: auto !important;
  height: auto !important;
  padding: 0;
  border: 1px solid #444;
  overflow: visible;
  z-index: 999 !important;
  min-width: 0 !important;
  max-width: none !important;
  max-height: none !important;
  transition: all 0.3s ease;
}
.panel.minimized .panel-header {
  border-bottom: none;
  padding: 5px 10px;
  margin: 0;
}
.panel.minimized .resize-handle {
  display: none;
}
.panel.minimized .panel-content,
.panel.minimized #map,
.panel.minimized #status,
.panel.minimized #turnInfoText,
.panel.minimized #log,
.panel.minimized .item-list,
.panel.minimized #craftingPanel .panel-content,
.panel.minimized #characterBasic,
.panel.minimized #charBody,
.panel.minimized #currentLocationBody {
  display: none;
}
.panel.minimized#itemDetailPanel {
  display: none !important;
}
#turnInfoText {
  line-height: 1.6;
}
#craftingList .item button {
    float: right;
}
#craftingList .item.un-craftable {
    background: #2a2a2a;
    color: #777;
    cursor: not-allowed;
}
#craftingList .item.un-craftable button {
    display: none;
}
.recipe-ingredients {
    font-size: 10px;
    color: #aaa;
    margin-left: 15px;
}
.crafting-category-header {
    font-weight: bold;
    color: #f1c40f;
    margin-top: 10px;
    padding-bottom: 3px;
    border-bottom: 1px solid #555;
    cursor: pointer;
    user-select: none;
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.recipe-container.collapsed {
    display: none;
}

#damagePop {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(1);
  font-size: 6em;
  font-weight: bold;
  color: #e74c3c;
  text-shadow: 0 0 10px #000;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.5s ease-out, transform 0.5s ease-out;
  z-index: 9999;
}
#combatPanel {
    box-sizing: border-box;
    font-family: sans-serif;
}
#combatContent {
    display: flex;
    height: calc(100% - 30px);
    padding-top: 10px;
}
#combatPlayer, #combatEnemy {
    flex: 1;
    padding: 10px;
    text-align: center;
    position: relative;
}
#combatLogContainer {
    flex: 2;
    display: flex;
    flex-direction: column;
    padding: 0 10px;
}
#combatLog {
    flex-grow: 1;
    background: #000;
    color: #eee;
    font-size: 12px;
    padding: 10px;
    overflow-y: auto;
    margin-bottom: 10px;
    border: 1px solid #444;
    border-radius: 4px;
}
#combatActions {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
}
#combatActions button {
    width: 100%;
    padding: 10px;
    background: #444;
    color: #eee;
    border: none;
    cursor: pointer;
    border-radius: 4px;
    font-size: 14px;
    transition: background 0.2s;
}
#combatActions button:hover:not(:disabled) {
    background: #666;
}
#combatActions button:disabled {
    background: #333;
    color: #777;
    cursor: not-allowed;
}
#combatActions button.fire-btn {
    background: #c0392b;
}
#combatActions button.fire-btn:hover:not(:disabled) {
    background: #e74c3c;
}

#combatPlayerEquipment, #combatEnemyEquipment {
    margin-top: 15px;
    text-align: left;
    font-size: 12px;
    border-top: 1px solid #555;
    padding-top: 10px;
}
#combatPlayerInjuries {
    margin-top: 10px;
    text-align: left;
    font-size: 12px;
    color: indianred;
    border-top: 1px solid #555;
    padding-top: 10px;
}
#combatEquipmentList, #combatEnemyEquipmentList {
    margin-top: 5px;
    line-height: 1.5;
}
#combatPlayerStats div {
    cursor: help;
}

.ascii-art-container {
    white-space: pre;
    font-family: monospace, monospace;
    font-size: 2em;
    margin: 10px 0;
    transition: color 0.5s ease;
}
.hp-high { color: #eee; }
.hp-medium { color: #f1c40f; }
.hp-low { color: #e67e22; }
.hp-critical { color: #e74c3c; }


#comparisonModal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #333;
    color: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.6);
    z-index: 2001;
    font-family: sans-serif;
    width: 450px;
}
#comparisonModal h3 {
    text-align: center;
    margin-top: 0;
    margin-bottom: 15px;
    border-bottom: 1px solid #555;
    padding-bottom: 10px;
}
.comparison-container {
    display: flex;
    justify-content: space-between;
    margin-bottom: 20px;
}
.comparison-item {
    width: 48%;
    padding: 10px;
    box-sizing: border-box;
    background: #222;
    border-radius: 5px;
    text-align: center;
}
.comparison-item h4 {
    margin: 0 0 10px 0;
    font-size: 1em;
}
.comparison-item-graphic {
    font-size: 2.5em;
    margin-bottom: 10px;
}
.comparison-item-name {
    font-weight: bold;
    margin-bottom: 10px;
}
.comparison-stats {
    text-align: left;
    font-size: 0.9em;
}
.comparison-stats div {
    margin-bottom: 5px;
}
.stat-positive { color: limegreen; }
.stat-negative { color: indianred; }
.stat-neutral { color: #ccc; }
.comparison-actions {
    text-align: right;
}
.comparison-actions button {
    background: #444;
    color: #eee;
    border: none;
    padding: 8px 15px;
    border-radius: 5px;
    cursor: pointer;
    margin-left: 10px;
}
.comparison-actions button:hover {
    background: #666;
}
#dialoguePanel {
    width: 500px;
    height: 350px;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 1001;
}
#dialogueContent {
    display: flex;
    height: calc(100% - 30px);
    padding-top: 10px;
}
#dialogueNPC {
    flex: 1;
    text-align: center;
}
#dialogueNPC pre {
    font-size: 2.5em;
}
#dialogueTextContainer {
    flex: 2;
    display: flex;
    flex-direction: column;
    padding: 0 10px;
}
#dialogueText {
    flex-grow: 1;
    background: #111;
    padding: 10px;
    border: 1px solid #444;
    border-radius: 4px;
    margin-bottom: 10px;
    overflow-y: auto;
}
#dialogueActions {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
}
#dialogueActions button {
    padding: 10px;
    background-color: #444;
    color: #eee;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}
#dialogueActions button:hover {
    background: #666;
}
#tradePanel, #storagePanel {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 80vw;
    max-width: 800px;
    height: 80vh;
    max-height: 600px;
    z-index: 1002;
    display: flex;
    flex-direction: column;
}
.trade-main, .storage-main {
    display: flex;
    flex-grow: 1;
    gap: 10px;
    overflow: hidden;
}
.trade-column, .storage-column {
    flex: 1;
    display: flex;
    flex-direction: column;
    background: #333;
    padding: 10px;
    border-radius: 5px;
}
.trade-area {
    border: 2px dashed #555;
    min-height: 120px;
    flex-shrink: 0;
    padding: 5px;
    border-radius: 4px;
    overflow-y: auto;
}
.storage-area {
    flex-grow: 1;
    overflow-y: auto;
    border: 1px solid #555;
    padding: 5px;
    border-radius: 4px;
}
.trade-inventory, .storage-inventory {
    flex-grow: 1;
    overflow-y: auto;
    border-top: 1px solid #555;
    margin-top: 10px;
    padding-top: 10px;
}
.trade-footer, .storage-footer {
    padding-top: 10px;
    text-align: center;
}
.trade-footer button, .storage-footer button {
    padding: 10px 20px;
    margin: 0 5px;
}
.trade-value {
    font-weight: bold;
    margin: 5px 0;
}
#suicideBtn {
    width: 100%;
    padding: 8px;
    margin-top: 10px;
    background-color: #a04040;
    color: #eee;
    border: 1px solid #c06060;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
}
#suicideBtn:hover {
    background-color: #c0392b;
}
/* â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦è¿½åŠ  â–¼â–¼â–¼ */
#waitTurnBtn {
    width: 100%;
    padding: 8px;
    margin-top: 5px; /* ä¸Šã®ãƒœã‚¿ãƒ³ã¨ã®é–“éš”ã‚’èª¿æ•´ */
    background-color: #4a4a52;
    color: #eee;
    border: 1px solid #666;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
}
#waitTurnBtn:hover {
    background-color: #6c6c74;
}
/* â–²â–²â–² ã“ã“ã¾ã§ â–²â–²â–² */
#locationActions {
    margin-top: 10px;
    border-top: 1px solid #555;
    padding-top: 5px;
}
#locationActions button {
    width: 100%;
    padding: 6px;
    margin-top: 5px;
    background: #4a4a52;
    color: #eee;
    border: 1px solid #666;
    border-radius: 3px;
    cursor: pointer;
}
#locationActions button:hover:not(:disabled) {
    background: #6c6c74;
}
#locationActions button:disabled {
    background: #333;
    color: #777;
    cursor: not-allowed;
}
#movementControls {
    margin-top: 5px;
    display: flex;
    justify-content: space-between;
}
#movementControls button {
    flex-grow: 1;
    font-size: 10px;
    padding: 3px;
    margin: 0 1px;
    border: 1px solid #666;
    background: #4a4a52;
    color: #eee;
    cursor: pointer;
}
#movementControls button.active {
    background: #2ecc71;
    border-color: #27ae60;
    color: #111;
}

/* --- Weather Animation --- */
#weather-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 9998;
  overflow: hidden;
  display: none;
}

.drop {
  position: absolute;
  bottom: 100%;
  width: 2px;
  height: 80px;
  background: linear-gradient(to bottom, rgba(255, 255, 255, 0), rgba(170, 180, 200, 0.4));
  animation: fall linear infinite;
}

#weather-container.storm .drop {
    width: 3px;
    height: 120px;
    animation-name: fall-storm;
}

#lightning-flash {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: #fff;
    opacity: 0;
    z-index: 9999;
    pointer-events: none;
}

#lightning-flash.active {
    animation: lightning-strike 0.3s ease-out;
}

@keyframes fall {
  to {
    transform: translateY(120vh);
  }
}

@keyframes fall-storm {
  to {
    transform: translate(-30vw, 120vh); /* æ–œã‚ã«ç§»å‹• */
  }
}

@keyframes lightning-strike {
  0% { opacity: 0; }
  10% { opacity: 0.8; }
  15% { opacity: 0.2; }
  20% { opacity: 0.9; }
  100% { opacity: 0; }
}
/* --- Cloud Animation --- */
#cloud-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 9997; /* é›¨ã‚ˆã‚Šä¸‹ã€èƒŒæ™¯ã‚ˆã‚Šä¸Š */
  overflow: hidden;
  display: none; /* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯éè¡¨ç¤º */
}

.cloud {
  position: absolute;
  background: #d4d9de;
  border-radius: 100px;
  opacity: 0.25; /* ã†ã£ã™ã‚‰ã¨ã—ãŸé›² */
  animation: move-cloud linear infinite;
  width: 200px;
  height: 60px;
}

/* é›²ã®ãµã‚ãµã‚ã—ãŸå½¢ã‚’ç–‘ä¼¼è¦ç´ ã§ä½œæˆ */
.cloud:before, .cloud:after {
  content: '';
  position: absolute;
  background: #d4d9de;
  width: 100px;
  height: 80px;
  top: -40px;
  left: 25px;
  border-radius: 100px;
  transform: rotate(30deg);
}

.cloud:after {
  width: 120px;
  height: 120px;
  top: -65px;
  left: auto;
  right: 15px;
}

@keyframes move-cloud {
  0% {
    transform: translateX(-300px); /* ç”»é¢å·¦å¤–ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆ */
  }
  100% {
    transform: translateX(110vw); /* ç”»é¢å³å¤–ã¸ç§»å‹• */
  }
}
</style>
</head>
<body>

<div id="weather-container"></div>
<div id="lightning-flash"></div>
<div id="cloud-container"></div>

<div id="startScreen">
    <pre style="color: #555; font-family: monospace; line-height: 0.9; margin-bottom: 20px; text-shadow: 1px 1px #000;">
   Z
  /|\
  / \
  vVw          _______________________
         /|      "                |`.
 wW     | |         _______       |  `.
vV____,-| |________/_______\,____ |    \
 / O "  | | `-              `| O  |\    \
 \______|_|__________________|_,-'/     |
wW `-----(_)`----------'-(_)`' vV      |
 vVwW                          vV       /
                (@)           wV       /
      vV       /`|`\                  /
              |  |  |      vV        /
     wW vV    `--'--'               /
-------------------------------------------
- - - - - - - - - - - - - - - - - - - - - -
</pre>
    <h1>çµ¶æœ›ã‚µãƒã‚¤ãƒãƒ«</h1>
    <p>ãƒãƒ¼ãƒ‰ã‚³ã‚¢ã‚µãƒã‚¤ãƒãƒ«ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</p>

    <div style="margin-top: 30px; font-size: 1.2em;">
      <label for="enableSpeechToggle">éŸ³å£°èª­ã¿ä¸Šã’ã‚’æœ‰åŠ¹ã«ã™ã‚‹</label>
      <input type="checkbox" id="enableSpeechToggle" checked style="width: 18px; height: 18px; vertical-align: middle; margin-left: 10px;">
    </div>

    <button id="startGameBtn">ã‚²ãƒ¼ãƒ é–‹å§‹</button>

<button id="loadGameBtn" style="display: none;">ç¶šãã‹ã‚‰</button>
    <button id="quitGameBtn">ã‚²ãƒ¼ãƒ ã‚’ã‚„ã‚ã‚‹</button>
</div>

<div id="gameClearScreen" style="display: none;">
    <pre id="gateArt" class="gate-art"></pre>
    <h2 id="clearHeader">GAME CLEAR</h2>
    <p id="clearMessage"></p>
    <button id="playAgainBtn">ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤</button>
</div>


<div id="mapPanel" class="panel" style="top:10px; left:10px; width:440px; height:460px; display:flex; flex-direction: column;">
  <div class="panel-header">
    <span>ãƒãƒƒãƒ—</span>
    <span id="mapHeaderInfo"></span>
  </div>
  <div id="map" style="flex:1; overflow:auto;"></div>
  <div id="playerDirectionArrow"></div> <div class="resize-handle"></div>
</div>

<div id="statusPanel" class="panel" style="top:10px; left:460px; width:360px; height:auto; overflow-y:auto; position:relative;">
  <div class="panel-header">ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</div>
  <div id="status">
    <div class="status-line">
      <span class="status-label">ç©ºè…¹</span>
      <div class="bar"><div id="hungerBar" class="fill hunger"></div></div>
      <span id="hungerVal" class="status-value"></span>
    </div>
    <div class="status-line">
      <span class="status-label">æ¸‡ã</span>
      <div class="bar"><div id="thirstBar" class="fill thirst"></div></div>
      <span id="thirstVal" class="status-value"></span>
    </div>
    <div class="status-line">
      <span class="status-label">ä½“åŠ›</span>
      <div class="bar"><div id="healthBar" class="fill health"></div></div>
      <span id="healthVal" class="status-value"></span>
    </div>
    <div class="status-line">
      <span class="status-label">æ°—åŠ›</span>
      <div class="bar"><div id="moraleBar" class="fill morale"></div></div>
      <span id="moraleVal" class="status-value"></span>
    </div>
    <div class="status-line" style="display: flex; align-items: center;">
      <span class="status-label">ç¡çœ </span>
      <div class="bar"><div id="sleepBar" class="fill sleep"></div></div>
      <span id="sleepVal" class="status-value" style="width: 70px;"></span>
      <button id="sleepNowBtn" style="padding: 1px 6px; font-size: 10px; margin-left: auto; background: #4a4a52; color: #eee; border: 1px solid #666; border-radius: 3px; cursor: pointer;">å¯ã‚‹</button>
    </div>
    <div id="bodyTempStatusLine" class="status-line" style="cursor: help;">
      <span class="status-label">ä½“æ¸©</span>
      <div class="bar"><div id="bodyTempBar" class="fill bodyTemp"></div></div>
      <span id="bodyTempVal" class="status-value"></span>
    </div>
    <div class="status-line">
      <span class="status-label">é‡ã•</span>
      <div class="bar"><div id="weightBar" class="fill weight"></div></div>
      <span id="weightVal" class="status-value"></span>
    </div>
    <div class="status-line">
        <span class="status-label">å®¹é‡</span>
        <div class="bar"><div id="volumeBar" class="fill volume"></div></div>
        <span id="volumeVal" class="status-value"></span>
    </div>
    <div class="status-line">
      <span class="status-label">æ”»æ’ƒåŠ›</span>
      <div class="bar"><div id="attackBar" class="fill attack"></div></div>
      <span id="attackVal" class="status-value"></span>
    </div>
<div class="status-line">
      <span class="status-label">é˜²å¾¡åŠ›</span>
      <div class="bar"><div id="defenseBar" class="fill defense"></div></div>
      <span id="defenseVal" class="status-value"></span>
    </div>
    <div id="bodyOdorStatusLine" class="status-line" style="cursor: help;">
      <span class="status-label">ä½“è‡­</span>
      <div class="bar"><div id="bodyOdorBar" class="fill"></div></div>
      <span id="bodyOdorVal" class="status-value"></span>
    </div>
  </div>
  <div id="physicalCondition"></div>
  <div class="resize-handle"></div>
</div>

<div id="turnPanel" class="panel" style="top:435px; left:460px; width:160px;">
  <div class="panel-header">æ™‚é–“</div>
  <div id="turnInfoText"></div>
  <pre id="compass" style="text-align: center; margin-top: 5px; color: #aaa; font-size: 14px; line-height: 1.1;">   N
   |
 W-+-E
   |
   S</pre>
<div id="movementControls">
      <button id="moveWalkBtn" class="active">æ­©è¡Œ</button>
      <button id="moveRunBtn">èµ°è¡Œ</button>
  </div>
  <div class="resize-handle"></div>
</div>

<div id="logPanel" class="panel" style="top:300px; left:460px; width:360px; height:125px; overflow-y:auto;">
  <div class="panel-header">æ—¥è¨˜</div>
  <div id="log"></div>
  <div class="resize-handle"></div>
</div>

<div id="inventoryPanel" class="panel" style="top:480px; left:10px; width:245px; height:250px; display:flex; flex-direction: column;">
  <div class="panel-header">æ‰€æŒå“</div>
  <div class="panel-content" style="height: calc(100% - 22px);">
      <div id="inventory" class="item-list" style="max-height: 100%;"></div>
  </div>
  <div class="resize-handle"></div>
</div>

<div id="equipmentPanel" class="panel" style="top:480px; left:265px; width:245px; height:250px; display:flex; flex-direction: column;">
  <div class="panel-header">è£…å‚™å“</div>
  <div class="panel-content" style="height: calc(100% - 22px);">
      <div id="equipment" class="item-list" style="max-height: 100%;"></div>
  </div>
  <div class="resize-handle"></div>
</div>
<div id="craftingPanel" class="panel" style="top:480px; left: 520px; width: 300px; height: 250px; display:flex; flex-direction: column;">
    <div class="panel-header">ã‚¯ãƒ©ãƒ•ãƒˆ</div>
    <div class="panel-content" style="height: calc(100% - 22px);">
        <div id="craftingList" style="max-height: 100%;" class="item-list"></div>
    </div>
    <div class="resize-handle"></div>
</div>


<div id="characterPanel" class="panel" style="top:10px; left:830px; width:220px; height:340px; overflow-y:auto;">
  <div class="panel-header">ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼æƒ…å ±</div>
  <div id="characterBasic">
    <div><strong>åå‰:</strong> <span id="charName"></span></div>
    <div><strong>å¹´é½¢:</strong> <span id="charAge"></span> æ­³</div>
    <div><strong>æ€§åˆ¥:</strong> <span id="charGender"></span></div>
    <div><strong>è·æ¥­:</strong> <span id="charJob"></span></div>
    <div style="margin-top: 5px;"><strong>äººç¨®:</strong> <span id="charRace"></span></div>
    <div style="margin-top: 5px;"><strong>ç‰¹æ€§:</strong> <span id="charTraits"></span></div>
    <div id="memoryContainer" style="margin-top: 10px; border-top: 1px solid #555; padding-top: 5px;"></div>
  </div>
  <pre id="charBody" class="asciiBody"></pre>
  <button id="suicideBtn">è‡ªã‚‰å‘½ã‚’çµ¶ã¤</button>
  <button id="waitTurnBtn">1ã‚¿ãƒ¼ãƒ³å¾…æ©Ÿ</button>
<button id="saveGameBtn" style="width:100%; padding: 8px; margin-top: 5px; background-color: #4a524b; color: #eee; border: 1px solid #666; border-radius: 4px; cursor: pointer; font-weight: bold;">ã‚»ãƒ¼ãƒ–</button>

 <div class="resize-handle"></div>
</div>

<div id="currentLocationPanel" class="panel" style="top:360px; left:830px; width:200px; height:400px; overflow: hidden; display:flex; flex-direction: column;">
  <div class="panel-header">ç¾åœ¨ã®å ´æ‰€</div>
  <div id="currentLocationBody" class="panel-content">
    <div id="locationName" class="location-name"></div>
    <pre id="locationAscii" class="ascii-art"></pre>
    <div id="locationActions"></div>
  </div>
  <div style="font-family: sans-serif; font-size: 14px; margin-top: 10px; border-top: 1px solid #555; padding-top: 5px; flex-grow: 1; display: flex; flex-direction: column;">
    <strong>è½ã¡ã¦ã„ã‚‹ã‚¢ã‚¤ãƒ†ãƒ :</strong>
    <div id="droppedItemsList" class="item-list" style="flex-grow: 1;"></div>
  </div>
  <div class="resize-handle"></div>
</div>

<div id="damagePop"></div>

<div id="statusPreview">
</div>

<div id="minimapPanel" class="panel" style="top:10px; left:1060px; width:220px; height:240px; display:flex; flex-direction: column;">
  <div class="panel-header" style="display: flex; justify-content: space-between; align-items: center;">
    <span>ãƒŸãƒ‹ãƒãƒƒãƒ—</span>
  </div>
  <div class="panel-content" style="padding: 5px; flex-grow: 1;">
    <canvas id="minimapCanvas" style="width: 100%; height: 100%; background: #000;"></canvas>
  </div>
  </div>

<div id="itemDetailPanel" class="panel" style="top:50%; left:50%; transform: translate(-50%, -50%); width:300px; height:auto; display:none;">
  <div id="itemDetailHeader" class="panel-header"></div>
  <div class="item-graphic-container">
    <span id="itemDetailGraphic" class="item-graphic"></span>
  </div>
  <div id="itemDetailContent" class="item-detail-info"></div>
  <div id="itemDetailActions" class="item-detail-actions">
    <button id="useItemBtn" style="display:none;">ä½¿ã†</button>
    <button id="throwItemBtn" style="display:none;">æŠ•ã’ã‚‹</button>
    <button id="repairItemBtn" style="display:none;">ä¿®ç†ã™ã‚‹</button>
    <button id="startFireBtn" style="display:none;">ç«ã‚’ãŠã“ã™</button>
    <button id="openItemBtn" style="display:none;">é–‹ã‘ã‚‹</button>
    <button id="forceOpenItemBtn" style="display:none;">ç„¡ç†ã‚„ã‚Šé–‹ã‘ã‚‹</button>
    <button id="emptyItemBtn" style="display:none;">ç©ºã«ã™ã‚‹</button>
    <button id="drinkItemBtn" style="display:none;">é£²ã‚€</button>
    <button id="fillItemBtn" style="display:none;">æ±²ã‚€</button>
    <button id="cookItemBtn" style="display:none;">ç„¼ã</button>
    <button id="boilItemBtn" style="display:none;">æ²¸ã‹ã™</button>
    <button id="addFuelBtn" style="display:none;">ãã¹ã‚‹</button>
    <button id="craftTorchBtn" style="display:none;">æ¾æ˜ã‚’ä½œã‚‹</button>
    <button id="wipeClothBtn" style="display:none;">æœã‚’æ‹­ã</button>
    <button id="wringClothBtn" style="display:none;">çµã‚‹</button>
    <button id="equipItemBtn" style="display:none;">è£…å‚™ã™ã‚‹</button>
    <button id="unequipItemBtn" style="display:none;">å¤–ã™</button>
    <button id="reloadGunBtn" style="display:none;">è£…å¡«ã™ã‚‹</button>
    <button id="unloadGunBtn" style="display:none;">è£…å¡«è§£é™¤</button>
    <button id="attachBayonetBtn" style="display:none;">ãƒŠã‚¤ãƒ•ã‚’è£…ç€</button>
    <button id="dropItemBtn" style="display:none;">è½ã¨ã™</button>
    <button id="pickupItemBtn" style="display:none;">æ‹¾ã†</button>
    <button id="butcherItemBtn" style="display:none;">è§£ä½“ã™ã‚‹</button>
    <button id="searchCorpseBtn" style="display:none;">æ¼ã‚‹</button>
    <button id="dismantleBtn" style="display:none;">è§£ä½“ã™ã‚‹</button>
    <button id="closeItemDetailBtn">é–‰ã˜ã‚‹</button>
  </div>
  <div class="resize-handle"></div>
</div>

<div id="combatPanel" class="panel" style="display: none; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 700px; height: 450px; z-index: 1001;">
  <div class="panel-header">æˆ¦é—˜</div>
  <div id="combatContent">
    <div id="combatPlayer">
      <h3>ã‚ãªãŸ</h3>
      <pre id="combatPlayerAscii" class="ascii-art-container"></pre>
      <div id="combatPlayerStats" style="text-align: left; margin-left: 20px;">
          <div id="combatHealthContainer">ä½“åŠ›: <span id="combatPlayerHealth"></span></div>
          <div id="combatAttackContainer" style="cursor: help;">æ”»æ’ƒåŠ›: <span id="combatPlayerAttack"></span></div>
          <div id="combatDefenseContainer" style="cursor: help;">é˜²å¾¡åŠ›: <span id="combatPlayerDefense"></span></div>
      </div>
      <div id="combatPlayerEquipment">
        <strong>è£…å‚™:</strong>
        <div id="combatEquipmentList"></div>
      </div>
      <div id="combatPlayerInjuries"></div>
    </div>
    <div id="combatLogContainer">
        <div id="combatLog"></div>
        <div id="combatActions">
          <button id="attackMainBtn">æ”»æ’ƒ (å³æ‰‹)</button>
          <button id="attackOffBtn">æ”»æ’ƒ (å·¦æ‰‹)</button>
          <button id="fireBtn" class="fire-btn">ç™ºç ²</button>
          <button id="runBtn">é€ƒã’ã‚‹</button>
        </div>
    </div>
    <div id="combatEnemy">
      <h3 id="combatEnemyName">ã‚¾ãƒ³ãƒ“</h3>
      <pre id="combatEnemyAscii" class="ascii-art-container"></pre>
      <div>ä½“åŠ›: <span id="combatEnemyHealth"></span></div>
      <div id="combatEnemyEquipment" style="display: none;">
        <strong>è£…å‚™:</strong>
        <div id="combatEnemyEquipmentList"></div>
      </div>
    </div>
  </div>
  <div class="resize-handle"></div> </div>

<div id="dialoguePanel" class="panel" style="display: none;">
    <div class="panel-header" id="dialoguePanelHeader">ç”Ÿå­˜è€…ã¨ã®é­é‡</div>
    <div id="dialogueContent">
        <div id="dialogueNPC">
            <h3 id="dialogueNpcName"></h3>
            <pre id="dialogueNpcAscii"></pre>
        </div>
        <div id="dialogueTextContainer">
            <div id="dialogueText"></div>
            <div id="dialogueActions">
                <button id="dialogueTradeBtn">äº¤æ¸‰ã™ã‚‹</button>
                <button id="dialogueFightBtn">æˆ¦é—˜ã™ã‚‹</button>
                <button id="dialogueLeaveBtn">ç«‹ã¡å»ã‚‹</button>
                <button id="dialogueInfoBtn" style="display:none;">æƒ…å ±ã‚’èã</button>
            </div>
        </div>
    </div>
</div>

<div id="tradePanel" class="panel" style="display: none;">
    <div class="panel-header">äº¤æ¸‰</div>
    <div class="trade-main">
        <div class="trade-column">
            <h4>ã‚ãªãŸã®æä¾›ã‚¢ã‚¤ãƒ†ãƒ  (<span id="playerTradeValue">0</span>)</h4>
            <div id="playerOfferArea" class="trade-area"></div>
            <h5>ã‚ãªãŸã®æ‰€æŒå“</h5>
            <div id="playerTradeInventory" class="trade-inventory"></div>
             <h5>ã‚ãªãŸã®è£…å‚™å“</h5>
            <div id="playerTradeEquipment" class="trade-inventory"></div>
        </div>
        <div class="trade-column">
            <h4>ç›¸æ‰‹ã®æä¾›ã‚¢ã‚¤ãƒ†ãƒ  (<span id="npcTradeValue">0</span>)</h4>
            <div id="npcOfferArea" class="trade-area"></div>
            <h5>ç›¸æ‰‹ã®æ‰€æŒå“</h5>
            <div id="npcTradeInventory" class="trade-inventory"></div>
            <h5>ç›¸æ‰‹ã®è£…å‚™å“</h5>
            <div id="npcTradeEquipment" class="trade-inventory"></div>
        </div>
    </div>
    <div class="trade-footer">
        <button id="executeTradeBtn" disabled>äº¤æ¸‰æˆç«‹</button>
        <button id="cancelTradeBtn">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
    </div>
</div>

<div id="storagePanel" class="panel" style="display: none;">
    <div class="panel-header" id="storagePanelHeader">æœ¨ç®±</div>
    <div class="storage-main">
        <div class="storage-column">
            <h4 id="storageBoxTitle">æœ¨ç®±ã®ä¸­èº« (0/10)</h4>
            <div id="storageBoxArea" class="storage-area"></div>
        </div>
        <div class="storage-column">
            <h4>ã‚ãªãŸã®æ‰€æŒå“</h4>
            <div id="storagePlayerInventory" class="storage-area"></div>
        </div>
    </div>
    <div class="storage-footer">
        <button id="pickupStorageBtn">æ‹¾ã†</button>
        <button id="closeStorageBtn">é–‰ã˜ã‚‹</button>
    </div>
</div>


<script>
// â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ã€<script>ã‚¿ã‚°ã®å…ˆé ­ã«è¿½åŠ  â–¼â–¼â–¼

// Electronã®æ©Ÿèƒ½ã‚’ä½¿ã†ãŸã‚ã®ãŠã¾ã˜ãªã„
// â–¼â–¼â–¼ ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã«ç½®ãæ›ãˆã‚‹ â–¼â–¼â–¼

const { ipcRenderer } = require('electron');

function getGameState() {
  return {
    player: player,
    map: map,
    entities: entities,
    placedObjects: placedObjects,
    droppedItems: droppedItems,
    turn: turn,
    currentTime: currentTime,
    character: character,
    salvationCityCoords: salvationCityCoords,
    salvationCityDiscovered: salvationCityDiscovered,
    currentWeather: currentWeather,
    currentTemperature: currentTemperature,
    currentSeason: currentSeason,
  };
}

function applyGameState(state) {
  if (!state) return;
  player = state.player;
  map = state.map;
  entities = state.entities;
  placedObjects = state.placedObjects;
  droppedItems = state.droppedItems;
  turn = state.turn;
  currentTime = new Date(state.currentTime);
  character = state.character;
  salvationCityCoords = state.salvationCityCoords;
  salvationCityDiscovered = state.salvationCityDiscovered;
  currentWeather = state.currentWeather;
  currentTemperature = state.currentTemperature;
  currentSeason = state.currentSeason;

  calculateMaxStats(); // æœ€å¤§ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å†è¨ˆç®—

  // ã‚²ãƒ¼ãƒ ç”»é¢ã‚’å†æç”»ã—ã¦ã€ãƒ­ãƒ¼ãƒ‰ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’åæ˜ 
  updateTurnInfo();
  drawMap();
  drawMinimap();
  updateStatus();
  updateItemPanels();
  updateCharacterBody();
  updateCharacterInfo();
  updateCurrentLocationPanel(false);
  updateBackgroundColor();
  log("ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸã€‚");
}

async function saveGame() {
  const gameState = getGameState();
  await ipcRenderer.invoke('save-game', gameState);
  log("é€²è¡ŒçŠ¶æ³ã‚’ã‚»ãƒ¼ãƒ–ã—ã¾ã—ãŸã€‚", true);
}

async function loadGame() {
  isLoading = true; // ãƒ­ãƒ¼ãƒ‰å‡¦ç†ã‚’é–‹å§‹
  try {
    const gameState = await ipcRenderer.invoke('load-game');
    if (gameState) {
      applyGameState(gameState);
      document.getElementById('startScreen').style.display = 'none';
      const panels = ["mapPanel", "statusPanel", "turnPanel", "logPanel", "inventoryPanel", "equipmentPanel", "craftingPanel", "characterPanel", "currentLocationPanel", "minimapPanel"];
      panels.forEach(id => {
          const panel = document.getElementById(id);
          if (panel) {
              panel.style.display = 'block';
               if (['mapPanel', 'inventoryPanel', 'equipmentPanel', 'minimapPanel', 'craftingPanel', 'currentLocationPanel'].includes(id)) {
                  panel.style.display = 'flex';
              }
          }
      });
    } else {
      log("ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚");
    }
  } finally {
    isLoading = false; // ãƒ­ãƒ¼ãƒ‰å‡¦ç†ãŒå®Œäº†ï¼ˆã¾ãŸã¯å¤±æ•—ï¼‰ã—ãŸã‚‰ã€å¿…ãšãƒ•ãƒ©ã‚°ã‚’ä¸‹ã‚ã™
  }
}

// ã“ã“ã‹ã‚‰ä¸‹ãŒå…ƒã€…ã®ã‚²ãƒ¼ãƒ ã‚³ãƒ¼ãƒ‰ã§ã™
let targetingState = {
    active: false,
    item: null,
    itemIndex: -1,
    source: '',
    range: 0,
    callback: null
};

let mapIconIntervals = []; 
let isLoading = false; // â† ã“ã®è¡Œã‚’è¿½åŠ 
let maxZIndex = 10;
let minimapZoomLevel = 2;
let isSpeechEnabled = true; 
const minimizedPanels = [];
let logSpeechQueue = []; 
let currentItemDetail = null;
let lightningTimeout = null;
let currentWeather = { icon: "â˜€ï¸", name: "å¿«æ™´", chance: 50 };
let currentTemperature = 25;
let isInteractionActive = false;
let currentEnemy = null;
let currentNPC = null;
let playerStatsBeforeAction = {};
let salvationCityCoords = { x: -1, y: -1 };
let salvationCityDiscovered = false;
let entities = [];
let currentSoundLevel = 0;
let currentPlayerSmell = 0;
let previousPlayerSmell = 0;
let previousSoundLevel = 0;
let placedObjects = []; 

const salvationCityLocation = {
    name: "ã‚µãƒ«ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ã‚·ãƒ†ã‚£",
    icon: "ğŸŒŸ",
    loot: 0,
    zombie: 0,
    ascii: `
  /\\||/\\
 | (++) |
  \\||||/
   ||||
   ||||`
};

// ... (ã“ã“ã‹ã‚‰ä¸‹ã®å…ƒã€…ã®ã‚²ãƒ¼ãƒ ã‚³ãƒ¼ãƒ‰ã¯å¤‰æ›´ä¸è¦ã§ã™)
// ... ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã¯ document.addEventListener ã®ç›´å‰ã§çµ‚ã‚ã‚Šã¾ã™


function bringToFront(elm) {
  maxZIndex++;
  elm.style.zIndex = maxZIndex;
}

function togglePanelSize(elm) {
  const header = elm.querySelector(".panel-header");
  const headerHeight = header.offsetHeight + 10;
  const margin = 10;

  if (elm.classList.contains("minimized")) {
    elm.classList.remove("minimized");
    elm.style.removeProperty("right");
    elm.style.removeProperty("bottom");
    elm.style.width = elm.dataset.originalWidth;
    elm.style.height = elm.dataset.originalHeight;
    elm.style.left = elm.dataset.originalLeft;
    elm.style.top = elm.dataset.originalTop;
    elm.querySelector(".resize-handle").style.display = "block";
    elm.style.overflow = "";
    const index = minimizedPanels.indexOf(elm);
    if (index > -1) {
      minimizedPanels.splice(index, 1);
    }
    restackMinimizedPanels();
    bringToFront(elm);
  } else {
    elm.dataset.originalWidth = elm.style.width;
    elm.dataset.originalHeight = elm.style.height;
    elm.dataset.originalLeft = elm.style.left;
    elm.dataset.originalTop = elm.style.top;
    elm.classList.add("minimized");
    elm.style.width = `${elm.offsetWidth}px`;
    elm.style.height = `${headerHeight}px`;
    elm.style.left = '';
    elm.style.top = '';
    elm.querySelector(".resize-handle").style.display = "none";
    elm.style.overflow = "hidden";
    minimizedPanels.push(elm);
    restackMinimizedPanels();
    bringToFront(elm);
  }
}

function restackMinimizedPanels() {
  const margin = 10;
  let totalWidth = 0;
  for (let i = minimizedPanels.length - 1; i >= 0; i--) {
    const panel = minimizedPanels[i];
    panel.style.right = `${margin + totalWidth}px`;
    panel.style.bottom = `${margin}px`;
    totalWidth += panel.offsetWidth + margin;
  }
}

function makeDraggable(elm) {
  const header = elm.querySelector(".panel-header");
  if (!header) return;
  header.style.cursor = "grab";
  let startX, startY, initialLeft, initialTop;
  const dragMouseDown = (e) => {
    e.preventDefault();
    if(elm.classList.contains("minimized")) return;
    bringToFront(elm);
    startX = e.clientX;
    startY = e.clientY;
    initialLeft = parseFloat(getComputedStyle(elm).left);
    initialTop = parseFloat(getComputedStyle(elm).top);
    header.style.cursor = "grabbing";
    window.addEventListener("mousemove", elementDrag);
    window.addEventListener("mouseup", closeDragElement);
  };
  const elementDrag = (e) => {
    e.preventDefault();
    let deltaX = e.clientX - startX;
    let deltaY = e.clientY - startY;
    let newLeft = initialLeft + deltaX;
    let newTop = initialTop + deltaY;
    newTop = Math.max(0, newTop);
    newLeft = Math.max(0, newLeft);
    newTop = Math.min(window.innerHeight - elm.offsetHeight, newTop);
    newLeft = Math.min(window.innerWidth - elm.offsetWidth, newLeft);
    elm.style.left = newLeft + "px";
    elm.style.top = newTop + "px";
  };
  const closeDragElement = () => {
    header.style.cursor = "grab";
    window.removeEventListener("mousemove", elementDrag);
    window.removeEventListener("mouseup", closeDragElement);
  };
  header.addEventListener("mousedown", dragMouseDown);
}

function makeResizable(elm) {
  const handle = elm.querySelector(".resize-handle");
  if (!handle) return;
  let pos = {x:0, y:0, w:0, h:0};
  const resizeMouseDown = (e) => {
    e.preventDefault();
    if(elm.classList.contains("minimized")) return;
    bringToFront(elm);
    pos.x = e.clientX;
    pos.y = e.clientY;
    pos.w = elm.offsetWidth;
    pos.h = elm.offsetHeight;
    window.addEventListener("mousemove", elementResize);
    window.addEventListener("mouseup", closeResizeElement);
  };
  const elementResize = (e) => {
    e.preventDefault();
    let dx = e.clientX - pos.x;
    let dy = e.clientY - pos.y;
    let newW = pos.w + dx;
    let newH = pos.h + dy;
    if (newW < 100) newW = 100;
    if (newH < 80) newH = 80;
    elm.style.width = newW + "px";
    elm.style.height = newH + "px";
    if (elm.id === "mapPanel") {
      drawMap();
    }
    if (elm.id === "minimapPanel") {
        drawMinimap();
    }
  };
  const closeResizeElement = () => {
    window.removeEventListener("mousemove", elementResize);
    window.removeEventListener("mouseup", closeResizeElement);
  };
  handle.addEventListener("mousedown", resizeMouseDown);
}

const characterTraits = [
  { name: "å¼·é­ãªè‚‰ä½“", desc: "é«˜ã„ä½“åŠ›ã¨æŒã¦ã‚‹é‡é‡ãŒå¢—ãˆã‚‹ã‚¿ãƒ•ãªä½“è³ªã€‚", effects: { health: 20, maxWeight: 5 } },
  { name: "å­¦ç¿’èƒ½åŠ›ãŒé«˜ã„", desc: "æ–°ã—ã„çŠ¶æ³ã¸ã®é©å¿œåŠ›ãŒé«˜ãã€ç²¾ç¥çš„ã«å®‰å®šã—ã¦ã„ã‚‹ã€‚", effects: { morale: 20 } },
  { name: "ç²¾ç¥åŠ›ãŒå¼·ã„", desc: "æ¥µé™çŠ¶æ…‹ã§ã‚‚å†·é™ã•ã‚’ä¿ã¡ã‚„ã™ã„ãŒã€å°‘ã—ç¡çœ ãŒå¿…è¦ã«ãªã‚‹ã€‚", effects: { morale: 30, sleep: -10 } },
  { name: "ä¸çœ ç—‡", desc: "çœ ã‚‹ã“ã¨ãŒè‹¦æ‰‹ãªãŸã‚ã€æ´»å‹•æ™‚é–“ãŒé•·ã„ãŒã€ç²¾ç¥çš„ã«ä¸å®‰å®šã«ãªã‚Šã‚„ã™ã„ã€‚", effects: { sleep: 40, morale: -20 } },
  { name: "ç—…å¼±", desc: "ç”Ÿã¾ã‚Œã¤ãä½“ãŒå¼±ãã€ç—…æ°—ã«ã‹ã‹ã‚Šã‚„ã™ã„ã€‚", effects: { health: -20, maxWeight: -5, morale: -15 } },
  { name: "ç›®ãŒã„ã„", desc: "å„ªã‚ŒãŸè¦–åŠ›ã‚’æŒã¡ã€é ãã¾ã§è¦‹æ¸¡ã›ã‚‹ã€‚", effects: { vision: 1 } },
  { name: "ç›®ãŒæ‚ªã„", desc: "è¦–åŠ›ãŒå¼±ãã€å‘¨å›²ã®çŠ¶æ³ã‚’æŠŠæ¡ã—ã¥ã‚‰ã„ã€‚", effects: { vision: -1 } },
];

let character = {
  fullName: "",
  age: 0,
  gender: "",
  job: "",
  race: "",
  traits: [],
  salvationCityHint: ""
};

const characterProfiles = [
    // Asian
    { name: "ã‚¢ã‚­ãƒ©ãƒ»ãƒŠã‚«ãƒ¤ãƒ", gender: "ç”·æ€§", race: "ã‚¢ã‚¸ã‚¢äºº" },
    { name: "ãƒªãƒ§ã‚¦ã‚³ãƒ»ã‚¿ãƒŠã‚«", gender: "å¥³æ€§", race: "ã‚¢ã‚¸ã‚¢äºº" },
    { name: "ã‚±ãƒ³ã‚¸ãƒ»ã‚µãƒˆã‚¦", gender: "ç”·æ€§", race: "ã‚¢ã‚¸ã‚¢äºº" },
    { name: "ãƒã‚µã‚·ãƒ»ã‚¤ã‚·ãƒ€", gender: "ç”·æ€§", race: "ã‚¢ã‚¸ã‚¢äºº" },
    { name: "ãƒŸã‚­ãƒ»ã‚¹ã‚ºã‚­", gender: "å¥³æ€§", race: "ã‚¢ã‚¸ã‚¢äºº" },
    // White
    { name: "ã‚¸ãƒ§ãƒ³ãƒ»ã‚¹ãƒŸã‚¹", gender: "ç”·æ€§", race: "ç™½äºº" },
    { name: "ã‚¨ãƒŸãƒªãƒ¼ãƒ»ã‚¸ãƒ§ãƒ¼ãƒ³ã‚º", gender: "å¥³æ€§", race: "ç™½äºº" },
    { name: "ãƒã‚¤ã‚±ãƒ«ãƒ»ãƒ–ãƒ©ã‚¦ãƒ³", gender: "ç”·æ€§", race: "ç™½äºº" },
    { name: "ã‚µãƒ©ãƒ»ãƒ‡ã‚¤ãƒ“ã‚¹", gender: "å¥³æ€§", race: "ç™½äºº" },
    { name: "ã‚¯ãƒªã‚¹ãƒ»ã‚¦ã‚£ãƒ«ã‚½ãƒ³", gender: "ç”·æ€§", race: "ç™½äºº" },
    // Middle-Eastern
    { name: "ã‚¢ãƒãƒãƒ‰ãƒ»ãƒãƒƒã‚µãƒ³", gender: "ç”·æ€§", race: "ä¸­æ±ç³»" },
    { name: "ãƒ•ã‚¡ãƒ†ã‚£ãƒãƒ»ã‚«ãƒ¼ãƒ³", gender: "å¥³æ€§", race: "ä¸­æ±ç³»" },
    { name: "ãƒ¦ã‚¹ãƒ•ãƒ»ã‚¢ãƒª", gender: "ç”·æ€§", race: "ä¸­æ±ç³»" },
    { name: "ã‚¶ã‚¤ãƒŠãƒ–ãƒ»ã‚¢ãƒƒãƒã‚¹", gender: "å¥³æ€§", race: "ä¸­æ±ç³»" },
    { name: "ãƒ©ã‚·ãƒƒãƒ‰ãƒ»ã‚µã‚¤ãƒ¼ãƒ‰", gender: "ç”·æ€§", race: "ä¸­æ±ç³»" },
    // Black
    { name: "ã‚¸ãƒ£ãƒãƒ¼ãƒ«ãƒ»ã‚¦ã‚£ãƒªã‚¢ãƒ ã‚º", gender: "ç”·æ€§", race: "é»’äºº" },
    { name: "ã‚¢ãƒªãƒ¼ãƒ¤ãƒ»ã‚¸ãƒ£ã‚¯ã‚½ãƒ³", gender: "å¥³æ€§", race: "é»’äºº" },
    { name: "ã‚±ã‚¤ãƒ¬ãƒ–ãƒ»ã‚¸ãƒ§ãƒ³ã‚½ãƒ³", gender: "ç”·æ€§", race: "é»’äºº" },
    { name: "ã‚¤ãƒãƒ³ãƒ»ã‚¢ãƒ‡ãƒãƒ¨", gender: "å¥³æ€§", race: "é»’äºº" }
];

const jobs = [
  "ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢", "åŒ»å¸«", "è»äºº", "æ•™å¸«", "ã‚¢ã‚¹ãƒªãƒ¼ãƒˆ",
  "è­¦å¯Ÿå®˜", "çœ‹è­·å¸«", "ã‚·ã‚§ãƒ•", "å­¦ç”Ÿ", "ä¼šç¤¾å“¡"
];

function generateRandomCharacter() {
  const profile = randChoice(characterProfiles);
  character.fullName = profile.name;
  character.gender = profile.gender;
  character.race = profile.race;
  
  character.age = Math.floor(Math.random() * 43) + 18; // 18æ­³ã‹ã‚‰60æ­³
  character.job = randChoice(jobs);
  
  let traitPool = [...characterTraits];
  const selectedTraits = [];
  const numberOfTraits = Math.random() < 0.5 ? 1 : 2; // 50%ã®ç¢ºç‡ã§1ã¤ã€50%ã®ç¢ºç‡ã§2ã¤
  
  for (let i = 0; i < numberOfTraits; i++) {
    if(traitPool.length === 0) break;
    const traitIndex = Math.floor(Math.random() * traitPool.length);
    const selected = traitPool.splice(traitIndex, 1)[0];
    selectedTraits.push(selected.name);

    if (selected.name === "ç›®ãŒã„ã„") {
        traitPool = traitPool.filter(t => t.name !== "ç›®ãŒæ‚ªã„");
    }
    if (selected.name === "ç›®ãŒæ‚ªã„") {
        traitPool = traitPool.filter(t => t.name !== "ç›®ãŒã„ã„");
    }
  }
  character.traits = selectedTraits;
  character.salvationCityHint = "";
}

const mapSize = 200;
const viewportSize = 13;
let maxStats = {};
const baseMaxStat = 100;

function calculateMaxStats() {
  const age = character.age;
  const gender = character.gender;
  const job = character.job;
  const race = character.race;
  const traits = character.traits;
  
 maxStats = {
    hunger: baseMaxStat,
    thirst: baseMaxStat,
    health: baseMaxStat,
    morale: baseMaxStat,
    sleep: baseMaxStat,
    bodyTemp: 41,
    maxWeight: 10,
    maxVolume: 10,
    vision: 5,
    bodyOdor: 100
  };
  
  if (job === 'è»äºº' || job === 'ã‚¢ã‚¹ãƒªãƒ¼ãƒˆ') maxStats.maxWeight += 8;
  if (job === 'ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢' || job === 'ã‚·ã‚§ãƒ•') maxStats.maxWeight += 3;
  if (job === 'å­¦ç”Ÿ' || job === 'æ•™å¸«') maxStats.maxWeight -= 2;

  if (gender === "ç”·æ€§") maxStats.maxWeight += 4;

  if (age < 20) {
    maxStats.health += 20; maxStats.sleep += 15; maxStats.morale -= 10;
  } else if (age >= 20 && age < 40) {
    maxStats.health += 10;
  } else if (age >= 40 && age < 60) {
    maxStats.health -= 15; maxStats.morale += 15;
  } else {
    maxStats.health -= 30; maxStats.sleep -= 20; maxStats.morale += 10;
  }
  
  if (gender === "ç”·æ€§") {
    maxStats.health += 10; maxStats.hunger += 10;
  } else if (gender === "å¥³æ€§") {
    maxStats.morale += 10; maxStats.sleep += 5;
  }
  
  traits.forEach(traitName => {
    const trait = characterTraits.find(t => t.name === traitName);
    if (trait && trait.effects) {
      for(const stat in trait.effects){
          if(stat === 'maxWeight' || stat === 'vision') {
               maxStats[stat] = (maxStats[stat] || 0) + trait.effects[stat];
          } else {
               maxStats[stat] = (maxStats[stat] || baseMaxStat) + trait.effects[stat];
          }
      }
    }
  });

  Object.keys(maxStats).forEach(stat => {
    if (stat !== 'bodyTemp' && stat !== 'maxWeight' && stat !== 'vision' && stat !== 'maxVolume' && stat !== 'bodyOdor') {
      maxStats[stat] = Math.max(50, Math.min(200, maxStats[stat]));
    }
  });
}

const fieldLocation = { name: "ç•‘", icon: "ç•‘", loot: 40, zombie: 2, ascii: `~~~~~~\n #####\n~#ğŸŒ½#~\n #####\n~~~~~~` };

// MODIFIED: Added vision blocking property
const biomeLocations = {
    Plains: [
        { name: "å¹³é‡", icon: "ğŸŒ¾", loot: 5, zombie: 8, ascii: `  ~~~~~\n ~     ~\n~   ğŸŒ¾  ~\n ~     ~\n  ~~~~~`, blocksVision: false },
        { name: "å¹³é‡", icon: "ğŸŒ¾", loot: 5, zombie: 8, ascii: `  ~~~~~\n ~     ~\n~   ğŸŒ¾  ~\n ~     ~\n  ~~~~~`, blocksVision: false },
        { name: "å¹³é‡", icon: "ğŸŒ¾", loot: 5, zombie: 8, ascii: `  ~~~~~\n ~     ~\n~   ğŸŒ¾  ~\n ~     ~\n  ~~~~~`, blocksVision: false },
        { name: "å¹³é‡", icon: "ğŸŒ¾", loot: 5, zombie: 8, ascii: `  ~~~~~\n ~     ~\n~   ğŸŒ¾  ~\n ~     ~\n  ~~~~~`, blocksVision: false },
        { name: "å¹³é‡", icon: "ğŸŒ¾", loot: 5, zombie: 8, ascii: `  ~~~~~\n ~     ~\n~   ğŸŒ¾  ~\n ~     ~\n  ~~~~~`, blocksVision: false },
        { name: "å¹³é‡", icon: "ğŸŒ¾", loot: 5, zombie: 8, ascii: `  ~~~~~\n ~     ~\n~   ğŸŒ¾  ~\n ~     ~\n  ~~~~~`, blocksVision: false },
        { name: "å¹³é‡", icon: "ğŸŒ¾", loot: 5, zombie: 8, ascii: `  ~~~~~\n ~     ~\n~   ğŸŒ¾  ~\n ~     ~\n  ~~~~~`, blocksVision: false },
        { name: "æ± ", icon: "ğŸ’§", loot: 2, zombie: 2, ascii: `  ~~~~~\n /     \\\n|  ğŸ’§   |\n \\_____/`, blocksVision: false },
        { name: "å²©", icon: "ğŸª¨", loot: 3, zombie: 3, ascii: `   /\\ \n  /  \\ \n /____\\`, blocksVision: false },
        { ...fieldLocation, blocksVision: false }
    ],
    Forest: [
        { name: "æ£®æ—", icon: "ğŸŒ²", loot: 15, zombie: 15, ascii: `   ğŸŒ²ğŸŒ²\n  ğŸŒ²  ğŸŒ²\n ğŸŒ²ğŸŒ²ğŸŒ²\n   | |`, blocksVision: true },
        { name: "å°å±‹", icon: "ğŸ›–", loot: 40, zombie: 5, ascii: `   /\\\n  /  \\\n |----|\n |[]_ |\n |____|`, blocksVision: true },
        { name: "å²©", icon: "ğŸª¨", loot: 3, zombie: 3, ascii: `   /\\ \n  /  \\ \n /____\\`, blocksVision: false },
        { ...fieldLocation, blocksVision: false }
    ],
    Town: [
        { name: "å®¶", icon: "ğŸ ", loot: 30, zombie: 25, ascii: `  /\\\n /__\\\n|'--'|\n| [] |\n|____|`, blocksVision: true },
        { name: "åº—", icon: "ğŸª", loot: 60, zombie: 35, ascii: ` _______\n|       |\n| SALE  |\n|_______|\n|  [] ||`, blocksVision: true },
        { name: "ç—…é™¢", icon: "ğŸ¥", loot: 70, zombie: 40, ascii: `  _____\n |+ + +|\n |+_+_+|\n |     |\n |_____|`, blocksVision: true },
        { name: "å…¬åœ’", icon: "ğŸŒ³", loot: 10, zombie: 10, ascii: `  ğŸŒ²ğŸŒ³ğŸŒ³\n   ____\n  /    \\\n |  ğŸï¸  |\n  \\____/`, blocksVision: false },
        { name: "ç©ºãåœ°", icon: "â¬œ", loot: 5, zombie: 5, ascii: `  ______\n |      |\n |  ç©ºãåœ° |\n |______|`, blocksVision: false }
    ],
    Road: [ { name: "èˆ—è£…è·¯", icon: "ğŸ›£ï¸", loot: 15, zombie: 3, ascii: `|       |\n|-------|\n|   |   |\n|-------|\n|       |`, blocksVision: false} ],
    TraderShop: { name: "ãƒˆãƒ¬ãƒ¼ãƒ€ãƒ¼ã‚·ãƒ§ãƒƒãƒ—", icon: "ğŸª", loot: 0, zombie: 0, ascii: ` _______\n| TRADE |\n|  $$$  |\n|_______|\n|  [] ||`, isShop: true, blocksVision: true }
};


const playerAsciiStates = {
    high: `  O\n /|\\\n / \\`,
    medium: `  o\n /|\\\n / >`,
    low: `  o\n /|~\n / \\`,
    critical: `  x\n _|_ \n / \\ `
}, charBodyDead = `   \n   X\n <--- \n / \\ `;

const zombieAscii = {
    high: `  _ğŸ’€_\n /| |\\\n /  |`,
    medium: `  _ğŸ’€_\n /| |~\n /  |`,
    low: `  _â˜ _\n /|_ | \n /  `,
    critical: `  _â˜ _\n  |   \n  /  `
};

const HANDMADE_TAG = "handmade";
const NO_LOOT_TAG = "no_loot";
const items = [
    // === NEW ITEMS (ENGINEER) ===
    { name: "ä½œæ¥­ç€", desc: "åšæ‰‹ã®ç”Ÿåœ°ã§ä½œã‚‰ã‚ŒãŸä¸ˆå¤«ãªæœã€‚å¤šå°‘ã®å±é™ºã‹ã‚‰èº«ã‚’å®ˆã‚‹ã€‚", type: "clothing", slot: "body_outer", defense: 4, insulation: 2.5, durability: 100, weight: 2.0, volume: 5.0, graphic: "ğŸ‘”", value: 50, wetness: 'dry' },
    { name: "å®‰å…¨ãƒ˜ãƒ«ãƒ¡ãƒƒãƒˆ", desc: "é ­éƒ¨ã‚’ä¿è­·ã™ã‚‹å·¥æ¥­ç”¨ã®ãƒ˜ãƒ«ãƒ¡ãƒƒãƒˆã€‚", type: "equipment", slot: "head", defense: 8, insulation: 0.5, durability: 100, weight: 1.5, volume: 4.0, graphic: "ğŸ‘·", value: 30 },
    { name: "ãƒ„ãƒ¼ãƒ«ãƒ™ãƒ«ãƒˆ", desc: "å·¥å…·ã‚’æºå¸¯ã™ã‚‹ãŸã‚ã®ãƒ™ãƒ«ãƒˆã€‚æœ€å¤§é‡é‡ã¨å®¹é‡ãŒå°‘ã—å¢—ãˆã‚‹ã€‚", type: "equipment", slot: "pochette", durability: 80, weight: 0.8, volume: 1.5, graphic: "ğŸ› ï¸", value: 45, effects: { maxWeight: 5, maxVolume: 5 } },
    { name: "ãƒ€ã‚¯ãƒˆãƒ†ãƒ¼ãƒ—", desc: "éå¸¸ã«å¼·åŠ›ãªç²˜ç€ãƒ†ãƒ¼ãƒ—ã€‚è£…å‚™å“ã®å¿œæ€¥ä¿®ç†ã«ä½¿ãˆã‚‹ã€‚", type: "consumable", useAction: 'repairItem', weight: 0.3, volume: 0.8, graphic: "ğŸ©¹", value: 25 },

    // === NEW ITEMS (DOCTOR / NURSE) ===
    { name: "ãƒ¡ã‚¹", desc: "åŒ»ç™‚ç”¨ã®å°åˆ€ã€‚åˆ‡ã‚Œå‘³ã¯é‹­ã„ãŒã€æ­¦å™¨ã¨ã—ã¦ã¯ã‚‚ã‚ã„ã€‚", type: "equipment", slot: "weapon", handedness: "one", attack: 12, defense: 0, durability: 40, weight: 0.1, volume: 0.2, graphic: "ğŸ”ª", value: 20, isBlade: true },
    { name: "ç™½è¡£", desc: "åŒ»å¸«ã‚„çœ‹è­·å¸«ãŒç€ã‚‹ç™½ã„ã‚³ãƒ¼ãƒˆã€‚å‹•ãã‚„ã™ã„ãŒã€é˜²å¯’æ€§ã¯ä½ã„ã€‚", type: "clothing", slot: "body_outer", defense: 1, insulation: 1.0, durability: 80, weight: 0.8, volume: 3.0, graphic: "ğŸ¥¼", value: 20, wetness: 'dry' },
    { name: "ãƒã‚¹ã‚¯", desc: "åŒ»ç™‚ç”¨ãƒã‚¹ã‚¯ã€‚æ°—ä¼‘ã‚ç¨‹åº¦ã®ä¿æ¸©æ€§ãŒã‚ã‚‹ã€‚", type: "clothing", slot: "head", defense: 0, insulation: 0.2, durability: 100, weight: 0.05, volume: 0.1, graphic: "ğŸ˜·", value: 5, wetness: 'dry' },
    { name: "æ•‘æ€¥ã‚­ãƒƒãƒˆ", desc: "æ§˜ã€…ãªå¿œæ€¥å‡¦ç½®ãŒã§ãã‚‹åŒ»ç™‚å“ã‚»ãƒƒãƒˆã€‚ä½“åŠ›ã‚’å¤§ããå›å¾©ã™ã‚‹ã€‚", type: "consumable", effects: { health: 50 }, weight: 0.8, volume: 2.0, graphic: "âš•ï¸", value: 80 },
    { name: "èƒƒè…¸è–¬", desc: "é£Ÿä¸­æ¯’ã‚„è…¹ç—›ã‚’å’Œã‚‰ã’ã‚‹è–¬ã€‚", type: "consumable", useAction: 'cureFoodPoisoning', weight: 0.1, volume: 0.2, graphic: "ğŸ’Š", value: 50 },
    { name: "ãƒã‚µãƒŸ", desc: "åŒ»ç™‚ç”¨ã®ã¯ã•ã¿ã€‚è­·èº«ç”¨ã¨ã—ã¦ã¯å¿ƒã‚‚ã¨ãªã„ã€‚", type: "equipment", slot: "weapon", handedness: "one", attack: 6, defense: 0, durability: 60, weight: 0.2, volume: 0.4, graphic: "âœ‚ï¸", value: 10, isBlade: true },

    // === NEW ITEMS (SOLDIER) ===
    { name: "ã‚³ãƒ³ãƒãƒƒãƒˆãƒŠã‚¤ãƒ•", desc: "è»ç”¨ã®é ‘ä¸ˆãªãƒŠã‚¤ãƒ•ã€‚æˆ¦é—˜ã«ç‰¹åŒ–ã—ã¦ã„ã‚‹ã€‚", type: "equipment", slot: "weapon", handedness: "one", attack: 18, defense: 0, durability: 100, weight: 0.6, volume: 1.0, graphic: "ğŸ—¡ï¸", value: 60, isBlade: true },

    // === NEW ITEMS (TEACHER / STUDENT) ===
    { name: "ãƒ¢ãƒƒãƒ—", desc: "åºŠæƒé™¤ã«ä½¿ã†é“å…·ã€‚é•·ã„æŸ„ã¯ã‚¾ãƒ³ãƒ“ã¨ã®è·é›¢ã‚’ä¿ã¤ã®ã«å½¹ç«‹ã¤ã€‚", type: "equipment", slot: "weapon", handedness: "two", attack: 6, defense: 0, durability: 50, weight: 1.2, volume: 5.0, graphic: "ğŸ§¹", value: 10 },
    { name: "ã‚¸ãƒ£ãƒ¼ã‚¸", desc: "å‹•ãã‚„ã™ã„ã‚¹ãƒãƒ¼ãƒ„ã‚¦ã‚§ã‚¢ã€‚å®Ÿç”¨æ€§ã¯é«˜ã„ã€‚", type: "clothing", slot: "body_outer", defense: 2, insulation: 1.8, durability: 90, weight: 1.0, volume: 3.5, graphic: "ğŸ‘•", value: 25, wetness: 'dry' },
    { name: "ãƒãƒƒã‚¯ãƒ‘ãƒƒã‚¯", desc: "ä¸€èˆ¬çš„ãªãƒãƒƒã‚¯ãƒ‘ãƒƒã‚¯ã€‚å¤šãã®è·ç‰©ã‚’é‹ã¹ã‚‹ã€‚", type: "equipment", slot: "back", durability: 100, weight: 1.5, volume: 2.0, graphic: "ğŸ’", value: 60, effects: { maxWeight: 15, maxVolume: 20 } },

    // === NEW ITEMS (ATHLETE) ===
    { name: "ãƒ†ãƒ‹ã‚¹ãƒ©ã‚±ãƒƒãƒˆ", desc: "è»½é‡ã§æŒ¯ã‚Šã‚„ã™ã„ãŒã€æ­¦å™¨ã¨ã—ã¦ã®è€ä¹…æ€§ã¯ä½ã„ã€‚", type: "equipment", slot: "weapon", handedness: "one", attack: 8, defense: 0, durability: 25, weight: 0.4, volume: 3.0, graphic: "ğŸ¾", value: 15 },
    { name: "é‡çƒã®ãƒãƒƒãƒˆ", desc: "å¼·åŠ›ãªéˆå™¨ã€‚æ‰±ã„ã‚„ã™ãã€å¨åŠ›ã‚‚é«˜ã„ã€‚", type: "equipment", slot: "weapon", handedness: "two", attack: 15, defense: 0, durability: 80, weight: 1.5, volume: 4.0, graphic: "âš¾", value: 40 },
    { name: "ã‚¨ãƒŠã‚¸ãƒ¼ãƒ‰ãƒªãƒ³ã‚¯", desc: "ç–²åŠ´ã‚’å¹ãé£›ã°ã™ç‚­é…¸é£²æ–™ã€‚ç©ºè…¹ã¨æ¸‡ãã‚’å°‘ã—ç™’ã™ã€‚", type: "consumable", effects: { hunger: 5, thirst: 20, sleep: 5 }, weight: 0.4, volume: 0.8, graphic: "ğŸ¥¤", value: 18 },
    { name: "ãƒ—ãƒ­ãƒ†ã‚¤ãƒ³ãƒãƒ¼", desc: "æ‰‹è»½ã«æ „é¤Šè£œçµ¦ãŒã§ãã‚‹é£Ÿå“ã€‚ç©ºè…¹ã‚’ã—ã£ã‹ã‚Šæº€ãŸã™ã€‚", type: "consumable", effects: { hunger: 30 }, weight: 0.1, volume: 0.3, graphic: "ğŸ«", value: 22 },

    // === NEW ITEMS (POLICE OFFICER) ===
    { name: "è­¦æ£’", desc: "è­¦å¯Ÿå®˜ãŒä½¿ã†é ‘ä¸ˆãªæ£æ£’ã€‚å„ªã‚ŒãŸè¿‘æ¥æ­¦å™¨ã€‚", type: "equipment", slot: "weapon", handedness: "one", attack: 14, defense: 0, durability: 100, weight: 0.9, volume: 1.5, graphic: "ğŸ¦¯", value: 45 },

    // === NEW ITEMS (CHEF) ===
    { name: "åŒ…ä¸", desc: "é‹­ã„åˆ‡ã‚Œå‘³ã®æ–™ç†ç”¨åˆƒç‰©ã€‚æ­¦å™¨ã¨ã—ã¦ã‚‚éå¸¸ã«æœ‰åŠ¹ã€‚", type: "equipment", slot: "weapon", handedness: "one", attack: 15, defense: 0, durability: 80, weight: 0.4, volume: 0.7, graphic: "ğŸ”ª", value: 40, isBlade: true },
    { name: "ã‚³ãƒƒã‚¯ã‚³ãƒ¼ãƒˆ", desc: "åšæ‰‹ã®èª¿ç†æœã€‚ä¿æ¸©æ€§ã¯ä½ã„ãŒä¸ˆå¤«ã€‚", type: "clothing", slot: "body_outer", defense: 2, insulation: 1.2, durability: 100, weight: 1.2, volume: 4.0, graphic: "ğŸ‘¨â€ğŸ³", value: 28, wetness: 'dry' },

    // === NEW ITEMS (OFFICE WORKER) ===
    { name: "ã‚¹ãƒ¼ãƒ„ã®ã‚¸ãƒ£ã‚±ãƒƒãƒˆ", desc: "ã‚ªãƒ•ã‚£ã‚¹ãƒ¯ãƒ¼ã‚«ãƒ¼ã®æœè£…ã€‚ä¿æ¸©æ€§ã¯ãã“ãã“ã‚ã‚‹ã€‚", type: "clothing", slot: "body_outer", defense: 1, insulation: 1.5, durability: 70, weight: 1.1, volume: 3.5, graphic: "ğŸ§¥", value: 20, wetness: 'dry' },

    // === EXISTING ITEMS ===
    // Consumables
    { name: "åŒ…å¸¯", desc: "å‚·ã‚’æ²»ã™", type: "consumable", effects: { health: 20 }, weight: 0.2, volume: 0.5, graphic: "ğŸ©¹", value: 20 },
    { name: "ç°¡å˜ãªåŒ…å¸¯", desc: "å‚·ã‚’å°‘ã—ã ã‘æ²»ã™å¿œæ€¥å‡¦ç½®å“ã€‚", type: "consumable", effects: { health: 10 }, weight: 0.1, volume: 0.2, graphic: "ğŸŒ¿", value: 8, tags: [HANDMADE_TAG, NO_LOOT_TAG] },
    { name: "ãƒ‘ãƒ³", desc: "ç©ºè…¹ã‚’æº€ãŸã™", type: "consumable", effects: { hunger: 25 }, freshness: 100, weight: 0.5, volume: 1.5, graphic: "ğŸ", value: 15, smell: 2 },
    { name: "ç”Ÿè‚‰", desc: "ç„¼ã‘ã°é£Ÿã¹ã‚‰ã‚Œã‚‹æ–°é®®ãªè‚‰ã€‚ç”Ÿã§é£Ÿã¹ã‚‹ã¨å±é™ºã€‚", type: "consumable", effects: { hunger: 10, health: -15 }, freshness: 100, weight: 0.8, volume: 1.0, graphic: "ğŸ¥©", value: 8, tags: [NO_LOOT_TAG], smell: 10 },
    { name: "ç„¼ã„ãŸè‚‰", desc: "æ „é¤Šä¾¡ã®é«˜ã„å®‰å…¨ãªé£Ÿæ–™ã€‚", type: "consumable", effects: { hunger: 40, morale: 5 }, freshness: 100, weight: 0.7, volume: 1.0, graphic: "ğŸ–", value: 25, tags: [NO_LOOT_TAG], smell: 5 },
    { name: "ç¼¶è©°(è±†)", desc: "è±†ã®ç¼¶è©°ã€‚é–‹ã‘ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚", type: "consumable", isSealed: true, sealedEffects: { hunger: 30 }, freshness: 1000, weight: 0.5, volume: 1.0, graphic: "ğŸ¥«", value: 20 },
    
    // Medicines
    { name: "æ•´è…¸å‰¤", desc: "é£Ÿä¸­æ¯’ã‚’å’Œã‚‰ã’ã‚‹è–¬ã€‚", type: "consumable", useAction: 'cureFoodPoisoning', weight: 0.1, volume: 0.2, graphic: "ğŸ’Š", value: 50 },
    { name: "ä¸‹ç—¢æ­¢ã‚", desc: "ä¸‹ç—¢ã‚’æŠ‘ãˆã‚‹è–¬ã€‚", type: "consumable", useAction: 'cureDiarrhea', weight: 0.1, volume: 0.2, graphic: "ğŸ’Š", value: 50 },
    { name: "è§£ç†±å‰¤", desc: "ç†±ã‚’ä¸‹ã’ã‚‹ãŸã‚ã®è–¬ã€‚", type: "consumable", useAction: 'cureFever', weight: 0.1, volume: 0.2, graphic: "ğŸ’Š", value: 60 },

    // New Foods
    { name: "ã‚­ãƒã‚³", desc: "é£Ÿã¹ã‚‰ã‚Œã‚‹ã‚­ãƒã‚³ã€‚ç”Ÿã§é£Ÿã¹ã‚‹ã¨æ¯’ã«ã‚ãŸã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚", type: "consumable", effects: { hunger: 8 }, riskOfSickness: 0.3, weight: 0.1, volume: 0.5, graphic: "ğŸ„", value: 6, tags: [NO_LOOT_TAG], smell: 1 },
    { name: "ç„¼ã„ãŸã‚­ãƒã‚³", desc: "é¦™ã°ã—ãç„¼ã‹ã‚ŒãŸã‚­ãƒã‚³ã€‚å®‰å…¨ã§ç¾å‘³ã—ã„ã€‚", type: "consumable", effects: { hunger: 15, morale: 3 }, weight: 0.1, volume: 0.5, graphic: "ğŸ„â€ğŸ”¥", value: 12, tags: [NO_LOOT_TAG], smell: 3 },
    { name: "ãƒˆã‚¦ãƒ¢ãƒ­ã‚³ã‚·", desc: "ç”˜ã„ãƒˆã‚¦ãƒ¢ãƒ­ã‚³ã‚·ã€‚ç”Ÿã§é£Ÿã¹ã‚‹ã¨ãŠè…¹ã‚’å£Šã™ã‹ã‚‚ã€‚", type: "consumable", effects: { hunger: 10 }, riskOfSickness: 0.2, weight: 0.4, volume: 1.2, graphic: "ğŸŒ½", value: 8, tags: [NO_LOOT_TAG], smell: 1 },
    { name: "ç„¼ã„ãŸãƒˆã‚¦ãƒ¢ãƒ­ã‚³ã‚·", desc: "ç”˜ãç„¼ã‹ã‚ŒãŸãƒˆã‚¦ãƒ¢ãƒ­ã‚³ã‚·ã€‚ã¨ã¦ã‚‚ç¾å‘³ã—ã„ã€‚", type: "consumable", effects: { hunger: 25, morale: 5 }, weight: 0.4, volume: 1.2, graphic: "ğŸŒ½ğŸ”¥", value: 16, tags: [NO_LOOT_TAG], smell: 4 },
    { name: "ã‚¸ãƒ£ã‚¬ã‚¤ãƒ¢", desc: "ç”Ÿã®ã‚¸ãƒ£ã‚¬ã‚¤ãƒ¢ã€‚èª¿ç†ã—ãŸã»ã†ãŒè‰¯ã•ãã†ã ã€‚", type: "consumable", effects: { hunger: 8 }, riskOfSickness: 0.25, weight: 0.3, volume: 0.8, graphic: "ğŸ¥”", value: 5, tags: [NO_LOOT_TAG], smell: 1 },
    { name: "ç„¼ã„ãŸã‚¸ãƒ£ã‚¬ã‚¤ãƒ¢", desc: "ãƒ›ã‚¯ãƒ›ã‚¯ã®ãƒ™ã‚¤ã‚¯ãƒ‰ãƒãƒ†ãƒˆã€‚ä½“ãŒæ¸©ã¾ã‚‹ã€‚", type: "consumable", effects: { hunger: 20, morale: 4 }, weight: 0.3, volume: 0.8, graphic: "ğŸ¥”ğŸ”¥", value: 10, tags: [NO_LOOT_TAG], smell: 3 },
    { name: "ãƒ‹ãƒ³ã‚¸ãƒ³", desc: "æ–°é®®ãªãƒ‹ãƒ³ã‚¸ãƒ³ã€‚æ³¥ã‚’è½ã¨ã›ã°é£Ÿã¹ã‚‰ã‚Œãã†ã€‚", type: "consumable", effects: { hunger: 6 }, riskOfSickness: 0.1, weight: 0.2, volume: 0.6, graphic: "ğŸ¥•", value: 5, tags: [NO_LOOT_TAG], smell: 1 },
    { name: "ç„¼ã„ãŸãƒ‹ãƒ³ã‚¸ãƒ³", desc: "ç”˜ã¿ãŒå¢—ã—ãŸç„¼ããƒ‹ãƒ³ã‚¸ãƒ³ã€‚", type: "consumable", effects: { hunger: 12, morale: 2 }, weight: 0.2, volume: 0.6, graphic: "ğŸ¥•ğŸ”¥", value: 10, tags: [NO_LOOT_TAG], smell: 3 },

    // Tools
    { name: "ãŸãç«ã‚­ãƒƒãƒˆ", desc: "ãŸãç«ã®åœŸå°ã‚’è¨­ç½®ã™ã‚‹ã€‚ç«ã‚’ã¤ã‘ã‚‹ã«ã¯åˆ¥ã®é“å…·ãŒå¿…è¦ã€‚", type: "tool", useAction: 'placeUnlitCampfire', weight: 1.5, volume: 5.0, graphic: "ğŸ”¥", value: 30, tags: [HANDMADE_TAG, NO_LOOT_TAG] },
    { name: "å¯è¢‹", desc: "åœ°é¢ã«è¨­ç½®ã—ã¦çœ ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚ç¡çœ ã®å›å¾©åŠ¹ç‡ãŒé«˜ã„ã€‚", type: "tool", useAction: 'placeSleepingBag', weight: 1, volume: 4.0, graphic: "ğŸ›Œ", value: 40, tags: [HANDMADE_TAG] },
    { name: "ç¼¶åˆ‡ã‚Š", desc: "ç¼¶è©°ã‚’å®‰å…¨ã«é–‹ã‘ã‚‹ãŸã‚ã®é“å…·ã€‚", type: "tool", durability: 100, weight: 0.3, volume: 0.5, graphic: "ğŸ”§", value: 15 },
    { name: "ãƒ©ã‚¤ã‚¿ãƒ¼", desc: "ç«ã‚’ãŠã“ã™ãŸã‚ã®é“å…·ã€‚ç‡ƒæ–™ã«ã¯é™ã‚ŠãŒã‚ã‚‹ã€‚", type: "tool", useAction: 'startFire', weight: 0.1, volume: 0.2, graphic: "ğŸ”¥", value: 40, durability: 100 },
    { name: "ç«æ‰“çŸ³", desc: "ç«èŠ±ã‚’æ•£ã‚‰ã—ã¦ç«ã‚’ãŠã“ã™çŸ³ã€‚ä½¿ã†ãŸã³ã«å°‘ã—ãšã¤å‰Šã‚Œã¦ã„ãã€‚", type: "tool", useAction: 'startFire', durability: 100, weight: 0.4, volume: 0.5, graphic: "ğŸª¨", value: 25 },
    { name: "ç«èµ·ã“ã—å™¨", desc: "æœ¨ã®æ‘©æ“¦ã§ç«ã‚’ãŠã“ã™åŸå§‹çš„ãªé“å…·ã€‚", type: "tool", useAction: 'startFire', weight: 0.8, volume: 3.0, graphic: "ğŸªµ", value: 15, durability: 100, tags: [HANDMADE_TAG, NO_LOOT_TAG] },
    { name: "æ·»ãˆæœ¨", desc: "éª¨æŠ˜ã‚’å›ºå®šã™ã‚‹ãŸã‚ã®å¿œæ€¥å‡¦ç½®å…·ã€‚", type: "consumable", useAction: 'applySplint', weight: 0.5, volume: 1.5, graphic: "ğŸ©¹", value: 15, tags: [HANDMADE_TAG, NO_LOOT_TAG] },
    { name: "ã‚¿ã‚ªãƒ«", desc: "æ¿¡ã‚ŒãŸä½“ã‚„è¡£æœã‚’æ‹­ããŸã‚ã®å¸ƒã€‚", type: "tool", useAction: 'wipeClothes', weight: 0.4, volume: 1.5, graphic: "ğŸ§–", value: 18 },

    // Water and Containers
    { name: "æ°´ç­’", desc: "æ°´ã‚’æŒã¡é‹ã¶ãŸã‚ã®å®¹å™¨ã€‚", type: "container", capacity: 2, durability: 100, weight: 0.5, volume: 2.0, graphic: "ğŸ’§", value: 15, content: null },
    { name: "æ‰‹ä½œã‚Šæ°´ç­’", desc: "æ¯›çš®ã§ä½œã£ãŸæ°´ç­’ã€‚å°‘ã—æ°´æ¼ã‚Œã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚", type: "container", capacity: 2, durability: 70, weight: 0.4, volume: 2.0, graphic: "ğŸš°", value: 12, tags: [HANDMADE_TAG, NO_LOOT_TAG], content: null },
    { name: "ãƒšãƒƒãƒˆãƒœãƒˆãƒ«", desc: "æ°´ã‚’æŒã¡é‹ã¹ã‚‹ä¾¿åˆ©ãªå®¹å™¨ã€‚", type: "container", capacity: 1, durability: 50, weight: 0.1, volume: 1.5, graphic: "ğŸ¾", value: 5, content: null },
    { name: "ç©ºãç¼¶", desc: "æ°´ã‚’æŒã¡é‹ã¹ã‚‹ãŒé‡ã¯å°‘ãªã„ã€‚", type: "container", capacity: 1, durability: 30, weight: 0.1, volume: 1.0, graphic: "ğŸ¥«", value: 2, content: null },
    { name: "æ±šã‚ŒãŸæ°´", desc: "æ°´æºã€‚ãã®ã¾ã¾é£²ã‚€ã‹ã€å®¹å™¨ã«æ±²ã‚ã‚‹ã€‚", type: "water_source", weight: 0, volume: 0, graphic: "ğŸ’§", value: 0, tags: [NO_LOOT_TAG]},

    // Melee Equipment
    { name: "ãƒŠã‚¤ãƒ•", desc: "æˆ¦é—˜ã‚„èª¿ç†ã«ä½¿ãˆã‚‹ä¸‡èƒ½ãªåˆƒç‰©ã€‚", type: "equipment", slot: "weapon", handedness: "one", attack: 15, defense: 0, durability: 100, weight: 0.5, volume: 0.8, graphic: "ğŸ”ª", value: 40, isBlade: true },
    { name: "çŸ³æ–§", desc: "åŸå§‹çš„ãªæ–§ã€‚æ”»æ’ƒåŠ›ãŒå°‘ã—ä¸ŠãŒã‚‹ã€‚", type: "equipment", slot: "weapon", handedness: "one", attack: 12, defense: 0, durability: 50, weight: 1.5, volume: 3.0, graphic: "ğŸª“", value: 25, tags: [HANDMADE_TAG, NO_LOOT_TAG], isBlade: true, isAxe: true },
    { name: "æ‰‹ä½œã‚ŠçŸ³ãƒŠã‚¤ãƒ•", desc: "çŸ³ã‚’ç •ã„ã¦ä½œã£ãŸãƒŠã‚¤ãƒ•ã€‚ã‚‚ã‚ã„ãŒç„¡ã„ã‚ˆã‚Šã¯ã¾ã—ã€‚", type: "equipment", slot: "weapon", handedness: "one", attack: 8, defense: 0, durability: 30, weight: 0.3, volume: 0.6, graphic: "ğŸ”ª", value: 10, tags: [HANDMADE_TAG, NO_LOOT_TAG], isBlade: true },
    { name: "æ‰‹ä½œã‚Šã‚¹ãƒ”ã‚¢", desc: "æã®å…ˆç«¯ã‚’å°–ã‚‰ã›ãŸã ã‘ã®ç°¡å˜ãªæ§ã€‚ãƒªãƒ¼ãƒãŒå°‘ã—é•·ã„ã€‚", type: "equipment", slot: "weapon", handedness: "two", attack: 10, defense: 0, durability: 40, weight: 1.0, volume: 4.0, graphic: "â€”", value: 12, tags: [HANDMADE_TAG, NO_LOOT_TAG] },
    { name: "æ¾æ˜", desc: "å‘¨å›²ã‚’ç…§ã‚‰ã™æ˜ã‹ã‚Šã€‚6ã‚¿ãƒ¼ãƒ³ã§ç‡ƒãˆå°½ãã‚‹ã€‚", type: "equipment", slot: "weapon", handedness: "one", attack: 2, defense: 0, durability: 100, weight: 0.6, volume: 2.5, graphic: "íšƒ", value: 10, tags: [HANDMADE_TAG, NO_LOOT_TAG], duration: 6, isTorch: true, useAction: 'startFire' },
    
    // Firearms & Ammo
    { name: "ãƒ”ã‚¹ãƒˆãƒ«", desc: "å°å‹ã®æ‹³éŠƒã€‚è¿‘è·é›¢ã§ã®æˆ¦é—˜ã«é©ã—ã¦ã„ã‚‹ã€‚", type: "equipment", slot: "weapon", handedness: "one", attack: 4, fireDamage: 40, durability: 100, weight: 1.2, volume: 2.0, graphic: "ğŸ”«", value: 150, ammoType: 'pistol', ammoCapacity: 7, loadedAmmo: 0 },
    { name: "ã‚·ãƒ§ãƒƒãƒˆã‚¬ãƒ³", desc: "æ•£å¼¾éŠƒã€‚è¿‘è·é›¢ã§çµ¶å¤§ãªå¨åŠ›ã‚’èª‡ã‚‹ãŒã€è£…å¼¾æ•°ã¯å°‘ãªã„ã€‚", type: "equipment", slot: "weapon", handedness: "two", attack: 6, fireDamage: 65, durability: 100, weight: 3.5, volume: 6.0, graphic: "ìƒ·", value: 200, ammoType: 'shotgun', ammoCapacity: 5, loadedAmmo: 0 },
    { name: "ãƒ©ã‚¤ãƒ•ãƒ«", desc: "é«˜ç²¾åº¦ãªãƒ©ã‚¤ãƒ•ãƒ«ã€‚é è·é›¢ã®æ•µã‚’ç‹™ãˆã‚‹ã€‚", type: "equipment", slot: "weapon", handedness: "two", attack: 5, fireDamage: 55, durability: 100, weight: 4.0, volume: 10.0, graphic: "ï¸»â•¦â•¤â”€", value: 220, ammoType: 'rifle', ammoCapacity: 5, loadedAmmo: 0, bayonetAttached: false },
    { name: "ãƒ”ã‚¹ãƒˆãƒ«ã®å¼¾", desc: "ãƒ”ã‚¹ãƒˆãƒ«ç”¨ã®å¼¾è–¬ã€‚", type: "ammo", ammoType: "pistol", weight: 0.02, volume: 0.1, graphic: "â€¢", value: 8 },
    { name: "ã‚·ãƒ§ãƒƒãƒˆã‚¬ãƒ³ã®å¼¾", desc: "ã‚·ãƒ§ãƒƒãƒˆã‚¬ãƒ³ç”¨ã®å¼¾è–¬ã€‚", type: "ammo", ammoType: "shotgun", weight: 0.05, volume: 0.2, graphic: "â¦¿", value: 12 },
    { name: "ãƒ©ã‚¤ãƒ•ãƒ«ã®å¼¾", desc: "ãƒ©ã‚¤ãƒ•ãƒ«ç”¨ã®å¼¾è–¬ã€‚", type: "ammo", ammoType: "rifle", weight: 0.03, volume: 0.1, graphic: "â€•", value: 10 },

    // Other Equipment
    { name: "ãƒ˜ãƒ«ãƒ¡ãƒƒãƒˆ", desc: "é ­éƒ¨ã‚’ä¿è­·ã™ã‚‹", type: "equipment", slot: "head", defense: 10, durability: 100, insulation: 1.5, weight: 2.5, volume: 4.0, graphic: "ğŸª–", value: 35 },
    { name: "ãƒ¡ã‚¬ãƒ", desc: "è¦–åŠ›ã‚’è£œæ­£ã™ã‚‹ã€‚ç›®ãŒæ‚ªã„ç‰¹æ€§ã‚’æ‰“ã¡æ¶ˆã™ã€‚", type: "equipment", slot: "eyes", durability: 60, weight: 0.1, volume: 0.5, graphic: "ğŸ‘“", value: 30 },

    // Backpacks
    { name: "æ‰‹ä½œã‚Šã®ãƒã‚·ã‚§ãƒƒãƒˆ", desc: "è…°ã«å·»ãå°ã•ãªãƒãƒƒã‚°ã€‚æœ€å¤§é‡é‡ãŒå°‘ã—å¢—ãˆã‚‹ã€‚", type: "equipment", slot: "pochette", weight: 0.4, volume: 1.0, graphic: "ğŸ‘œ", value: 20, tags: [HANDMADE_TAG, NO_LOOT_TAG], effects: { maxWeight: 3, maxVolume: 5 }, durability: 80 },
    { name: "å¤§ããªãƒãƒƒã‚¯ãƒ‘ãƒƒã‚¯", desc: "å¤§å®¹é‡ã®ãƒãƒƒã‚¯ãƒ‘ãƒƒã‚¯ã€‚æœ€å¤§é‡é‡ãŒå¤§å¹…ã«å¢—ãˆã‚‹ã€‚", type: "equipment", slot: "back", durability: 100, weight: 2, volume: 2.0, graphic: "ğŸ’", value: 90, effects: { maxWeight: 20, maxVolume: 25 } },
    
    // Clothing
    { name: "Tã‚·ãƒ£ãƒ„", desc: "è»½ã„è¡£æœã€‚é‡ã­ç€ã§ãã‚‹ã€‚", type: "clothing", slot: "body_inner", defense: 1, durability: 100, insulation: 0.5, weight: 0.3, volume: 1.0, graphic: "ğŸ‘•", value: 10, wetness: 'dry' },
    { name: "ã‚³ãƒ¼ãƒˆ", desc: "æš–ã‹ãã€é˜²å¯’ã«å„ªã‚Œã‚‹ã€‚", type: "clothing", slot: "body_outer", defense: 3, durability: 100, insulation: 4.0, weight: 2.5, volume: 6.0, graphic: "ğŸ§¥", value: 60, wetness: 'dry' },
    { name: "é˜²å¼¾ãƒ™ã‚¹ãƒˆ", desc: "éŠƒå¼¾ã‹ã‚‰èº«ã‚’å®ˆã‚‹ãƒ™ã‚¹ãƒˆã€‚è¡æ’ƒã«ã¯å¼·ã„ãŒé‡ã„ã€‚", type: "clothing", slot: "body_outer", defense: 25, durability: 100, insulation: 1.0, weight: 8.0, volume: 5.0, graphic: "ğŸ¦º", value: 120, wetness: 'dry' },
    { name: "ã‚ºãƒœãƒ³", desc: "ä¸‹åŠèº«ã‚’ä¿è­·ã™ã‚‹ã€‚", type: "clothing", slot: "legs", defense: 2, durability: 100, insulation: 2.0, weight: 1.2, volume: 3.0, graphic: "ğŸ‘–", value: 25, wetness: 'dry' },
    { name: "å¸½å­", desc: "é ­éƒ¨ã‚’æš–ã‚ã‚‹ã€‚", type: "clothing", slot: "head", defense: 0, durability: 100, insulation: 1.2, weight: 0.3, volume: 1.5, graphic: "ğŸ§¢", value: 15, wetness: 'dry' },
    { name: "æ‰‹ä½œã‚Šã®æ‰‹è¢‹", desc: "æ‰‹ã‚’ä¿è­·ã—ã€å°‘ã—æš–ã‹ã„ã€‚", type: "clothing", slot: "hands", defense: 1, durability: 60, insulation: 0.8, weight: 0.2, volume: 0.8, graphic: "ğŸ§¤", value: 12, tags: [HANDMADE_TAG, NO_LOOT_TAG], wetness: 'dry' },
    { name: "æ‰‹ä½œã‚Šã®å¸½å­", desc: "é ­ã‚’å°‘ã—ã ã‘æš–ã‚ã‚‹ã€‚", type: "clothing", slot: "head", defense: 0, durability: 70, insulation: 1.0, weight: 0.2, volume: 1.2, graphic: "ğŸ‘’", value: 18, tags: [HANDMADE_TAG, NO_LOOT_TAG], wetness: 'dry' },
    { name: "æ‰‹ä½œã‚Šã®æœ", desc: "ä½“ã‚’è¦†ã†ç°¡å˜ãªæœã€‚", type: "clothing", slot: "body_inner", defense: 1, durability: 60, insulation: 1.5, weight: 0.8, volume: 2.0, graphic: "ğŸ‘š", value: 25, tags: [HANDMADE_TAG, NO_LOOT_TAG], wetness: 'dry' },
    { name: "æ‰‹ä½œã‚Šã®ã‚ºãƒœãƒ³", desc: "è„šã‚’è¦†ã†ç°¡å˜ãªã‚ºãƒœãƒ³ã€‚", type: "clothing", slot: "legs", defense: 1, durability: 60, insulation: 1.2, weight: 0.7, volume: 2.5, graphic: "ğŸ‘–", value: 25, tags: [HANDMADE_TAG, NO_LOOT_TAG], wetness: 'dry' },
    { name: "æ‰‹ä½œã‚Šã®ã‚³ãƒ¼ãƒˆ", desc: "è¤‡æ•°ã®æ¯›çš®ã‚’ç¹‹ãåˆã‚ã›ãŸæš–ã‹ã„ã‚³ãƒ¼ãƒˆã€‚", type: "clothing", slot: "body_outer", defense: 2, durability: 50, insulation: 3.0, weight: 2.0, volume: 5.0, graphic: "ğŸ§¥", value: 50, tags: [HANDMADE_TAG, NO_LOOT_TAG], wetness: 'dry' },
    { name: "ã‚¹ãƒ‹ãƒ¼ã‚«ãƒ¼", desc: "ã©ã“ã«ã§ã‚‚ã‚ã‚‹ä¸€èˆ¬çš„ãªé‹å‹•é´ã€‚å‹•ãã‚„ã™ã„ãŒã€ä¿è­·æ€§èƒ½ã¯ä½ã„ã€‚", type: "clothing", slot: "feet", defense: 2, insulation: 0.5, soundModifier: 0.8, durability: 80, weight: 0.8, volume: 1.5, value: 20, wetness: 'dry' },
    { name: "é©é´", desc: "ã‚ªãƒ•ã‚£ã‚¹ãƒ¯ãƒ¼ã‚«ãƒ¼ãŒå±¥ã„ã¦ã„ãŸã§ã‚ã‚ã†é©é´ã€‚ç¡¬ãã€æ­©ãã¨ã‚³ãƒ„ã‚³ãƒ„ã¨éŸ³ãŒéŸ¿ãã€‚", type: "clothing", slot: "feet", defense: 3, insulation: 0.8, soundModifier: 1.5, durability: 70, weight: 1.2, volume: 2.0, value: 25, wetness: 'dry' },
    { name: "ãƒ¯ãƒ¼ã‚¯ãƒ–ãƒ¼ãƒ„", desc: "ã¤ã¾å…ˆã«é‰„å¿ƒãŒå…¥ã£ãŸå®‰å…¨é´ã€‚éå¸¸ã«é ‘ä¸ˆã§é˜²å¾¡åŠ›ãŒé«˜ã„ãŒã€é‡ãã¦å¤§ããªéŸ³ãŒã™ã‚‹ã€‚", type: "clothing", slot: "feet", defense: 8, insulation: 1.5, soundModifier: 2.0, durability: 100, weight: 2.5, volume: 3.0, value: 50, wetness: 'dry' },
    { name: "ç™»å±±é´", desc: "é•·è·é›¢ã®æ­©è¡Œã‚’æƒ³å®šã—ãŸä¸ˆå¤«ãªé´ã€‚æ‚ªè·¯ã§ã‚‚æ­©ãã‚„ã™ãã€ä¿æ¸©æ€§ã‚„é˜²å¾¡åŠ›ã®ãƒãƒ©ãƒ³ã‚¹ãŒè‰¯ã„ã€‚", type: "clothing", slot: "feet", defense: 6, insulation: 2.0, soundModifier: 1.2, durability: 90, weight: 1.8, volume: 2.5, value: 60, wetness: 'dry' },
    { name: "ã‚³ãƒ³ãƒãƒƒãƒˆãƒ–ãƒ¼ãƒ„", desc: "è»ç”¨ã«è¨­è¨ˆã•ã‚ŒãŸãƒ–ãƒ¼ãƒ„ã€‚é«˜ã„é˜²å¾¡åŠ›ã‚’æŒã¡ãªãŒã‚‰ã€è¶³éŸ³ã¯æ¯”è¼ƒçš„é™ã‹ã«ä¿ã¦ã‚‹ã€‚å¸Œå°‘å“ã€‚", type: "clothing", slot: "feet", defense: 7, insulation: 1.8, soundModifier: 1.0, durability: 100, weight: 2.0, volume: 2.5, value: 85, wetness: 'dry' },

    // Materials
    { name: "çŸ³", desc: "ã‚¯ãƒ©ãƒ•ãƒˆã®ææ–™ã«ãªã‚‹ç¡¬ã„çŸ³ã€‚æŠ•ã’ã¦é™½å‹•ã«ä½¿ã†ã“ã¨ã‚‚ã§ãã‚‹ã€‚", type: "material", weight: 1, volume: 0.5, graphic: "ğŸª¨", value: 5, throwable: true, throwRange: 5, throwSoundRadius: 5 },
    { name: "æ", desc: "ã‚¯ãƒ©ãƒ•ãƒˆã®ææ–™ã«ãªã‚‹æœ¨ã®æã€‚", type: "material", weight: 0.5, volume: 2.0, graphic: "ğŸªµ", value: 3 },
    { name: "å¸ƒåˆ‡ã‚Œ", desc: "ã‚¯ãƒ©ãƒ•ãƒˆã®ææ–™ã«ãªã‚‹å¸ƒã®åˆ‡ã‚Œç«¯ã€‚æ¿¡ã‚ŒãŸæœã‚’æ‹­ãã“ã¨ã‚‚ã§ãã‚‹ã€‚", type: "material", useAction: 'wipeClothes', weight: 0.1, volume: 0.2, graphic: "ğŸ“œ", value: 4 },
    { name: "æ¯›çš®", desc: "ã‚¯ãƒ©ãƒ•ãƒˆã®ææ–™ã«ãªã‚‹å‹•ç‰©ã®æ¯›çš®ã€‚", type: "material", weight: 0.8, volume: 0.8, graphic: "ğŸŸ«", value: 15, tags: [NO_LOOT_TAG] },
    { name: "å¤§ããªè‘‰", desc: "ã‚¯ãƒ©ãƒ•ãƒˆã®ææ–™ã«ãªã‚‹å¤§ããã¦ä¸ˆå¤«ãªè‘‰ã€‚", type: "material", weight: 0.1, volume: 1.5, graphic: "ğŸƒ", value: 4 },
    { name: "æœ¨ç®±", desc: "ã‚¢ã‚¤ãƒ†ãƒ ã‚’10å€‹ä¿ç®¡ã§ãã‚‹ç®±ã€‚è¨­ç½®ã—ã¦ä½¿ã†ã€‚", type: "tool", useAction: 'placeWoodenBox', weight: 5, volume: 15.0, graphic: "ğŸ“¦", value: 60, tags: [HANDMADE_TAG, NO_LOOT_TAG] },
    { name: "ä¸¸å¤ª", desc: "é ‘ä¸ˆãªä¸¸å¤ªã€‚ãƒãƒªã‚±ãƒ¼ãƒ‰ãªã©ã®ã‚¯ãƒ©ãƒ•ãƒˆã«ä½¿ãˆã‚‹ã€‚", type: "material", weight: 4.0, volume: 5.0, graphic: "ğŸªµ", value: 15 },
    { name: "ãƒãƒªã‚±ãƒ¼ãƒ‰", desc: "ä¸¸å¤ªã‚’çµ„ã‚“ã§ä½œã£ãŸç²—é›‘ãªéšœå®³ç‰©ã€‚è¨­ç½®ã—ã¦æ•µã®ä¾µæ”»ã‚’ä¸€æ™‚çš„ã«é˜²ãã€‚æŒã¡é‹ã³ã‚‚å¯èƒ½ã€‚", type: "tool", useAction: 'placeBarricadeItem', weight: 4.0, volume: 5.0, graphic: "ğŸš§", value: 45, tags: ["no_loot", "handmade"] },
];

const cookingMap = {
    "ç”Ÿè‚‰": "ç„¼ã„ãŸè‚‰",
    "ã‚­ãƒã‚³": "ç„¼ã„ãŸã‚­ãƒã‚³",
    "ãƒˆã‚¦ãƒ¢ãƒ­ã‚³ã‚·": "ç„¼ã„ãŸãƒˆã‚¦ãƒ¢ãƒ­ã‚³ã‚·",
    "ã‚¸ãƒ£ã‚¬ã‚¤ãƒ¢": "ç„¼ã„ãŸã‚¸ãƒ£ã‚¬ã‚¤ãƒ¢",
    "ãƒ‹ãƒ³ã‚¸ãƒ³": "ç„¼ã„ãŸãƒ‹ãƒ³ã‚¸ãƒ³",
};

const recipes = [
    { result: "çŸ³æ–§", ingredients: [{ name: "çŸ³", count: 1 }, { name: "æ", count: 1 }] },
    { result: "æ‰‹ä½œã‚ŠçŸ³ãƒŠã‚¤ãƒ•", ingredients: [{ name: "çŸ³", count: 2 }] },
    { result: "æ‰‹ä½œã‚Šã‚¹ãƒ”ã‚¢", ingredients: [{ name: "æ", count: 2 }] },
    { result: "ç«èµ·ã“ã—å™¨", ingredients: [{ name: "æ", count: 3 }] },
    { result: "ãŸãç«ã‚­ãƒƒãƒˆ", ingredients: [{ name: "çŸ³", count: 2 }, { name: "æ", count: 2 }] },
    { result: "ç°¡å˜ãªåŒ…å¸¯", ingredients: [{ name: "å¸ƒåˆ‡ã‚Œ", count: 2 }] },
    { result: "æ‰‹ä½œã‚Šã®ãƒã‚·ã‚§ãƒƒãƒˆ", ingredients: [{ name: "æ¯›çš®", count: 1 }] },
    { result: "æ‰‹ä½œã‚Šã®æ‰‹è¢‹", ingredients: [{ name: "æ¯›çš®", count: 1 }] },
    { result: "æ‰‹ä½œã‚Šã®å¸½å­", ingredients: [{ name: "æ¯›çš®", count: 2 }] },
    { result: "æ‰‹ä½œã‚Šæ°´ç­’", ingredients: [{ name: "æ¯›çš®", count: 2 }] },
    { result: "æ‰‹ä½œã‚Šã®æœ", ingredients: [{ name: "æ¯›çš®", count: 3 }] },
    { result: "æ‰‹ä½œã‚Šã®ã‚ºãƒœãƒ³", ingredients: [{ name: "æ¯›çš®", count: 3 }] },
    { result: "æ‰‹ä½œã‚Šã®ã‚³ãƒ¼ãƒˆ", ingredients: [{ name: "æ¯›çš®", count: 5 }] },
    { result: "æœ¨ç®±", ingredients: [{ name: "æ", count: 5 }] },
    { result: "å¯è¢‹", ingredients: [{ name: "å¤§ããªè‘‰", count: 2 }] },
    { result: "æ·»ãˆæœ¨", ingredients: [{ name: "æ", count: 3 }] },
    { result: "ãƒãƒªã‚±ãƒ¼ãƒ‰", ingredients: [{ name: "ä¸¸å¤ª", count: 3 }] },
];

const dismantleRecipes = {
    "åŒ…å¸¯": [{ name: "å¸ƒåˆ‡ã‚Œ", count: 1 }],
    "Tã‚·ãƒ£ãƒ„": [{ name: "å¸ƒåˆ‡ã‚Œ", count: 1 }],
    "ã‚ºãƒœãƒ³": [{ name: "å¸ƒåˆ‡ã‚Œ", count: 1 }],
    "æ·»ãˆæœ¨": [{ name: "æ", count: 1 }],
    "ãƒ¢ãƒƒãƒ—": [{ name: "æ", count: 1 }],
    "ãƒ†ãƒ‹ã‚¹ãƒ©ã‚±ãƒƒãƒˆ": [{ name: "æ", count: 1 }],
    "é‡çƒã®ãƒãƒƒãƒˆ": [{ name: "æ", count: 1 }],
    "ä½œæ¥­ç€": [{ name: "å¸ƒåˆ‡ã‚Œ", count: 2 }],
    "ç™½è¡£": [{ name: "å¸ƒåˆ‡ã‚Œ", count: 2 }],
    "ã‚¹ãƒ¼ãƒ„ã®ã‚¸ãƒ£ã‚±ãƒƒãƒˆ": [{ name: "å¸ƒåˆ‡ã‚Œ", count: 2 }],
    "ã‚¸ãƒ£ãƒ¼ã‚¸": [{ name: "å¸ƒåˆ‡ã‚Œ", count: 2 }],
    "ã‚³ãƒƒã‚¯ã‚³ãƒ¼ãƒˆ": [{ name: "å¸ƒåˆ‡ã‚Œ", count: 2 }],
    "ã‚³ãƒ¼ãƒˆ": [{ name: "å¸ƒåˆ‡ã‚Œ", count: 2 }],
    "ãƒ„ãƒ¼ãƒ«ãƒ™ãƒ«ãƒˆ": [{ name: "æ¯›çš®", count: 1 }],
    "æ‰‹ä½œã‚Šã®ãƒã‚·ã‚§ãƒƒãƒˆ": [{ name: "æ¯›çš®", count: 1 }],
    "æ‰‹ä½œã‚Šã®æœ": [{ name: "æ¯›çš®", count: 1 }],
    "æ‰‹ä½œã‚Šã®ã‚ºãƒœãƒ³": [{ name: "æ¯›çš®", count: 1 }],
    "ãƒãƒƒã‚¯ãƒ‘ãƒƒã‚¯": [{ name: "æ¯›çš®", count: 1 }, { name: "å¸ƒåˆ‡ã‚Œ", count: 2 }],
    "å¤§ããªãƒãƒƒã‚¯ãƒ‘ãƒƒã‚¯": [{ name: "æ¯›çš®", count: 2 }, { name: "å¸ƒåˆ‡ã‚Œ", count: 3 }],
    "é˜²å¼¾ãƒ™ã‚¹ãƒˆ": [{ name: "æ¯›çš®", count: 2 }, { name: "å¸ƒåˆ‡ã‚Œ", count: 3 }],
    "æ‰‹ä½œã‚Šã®ã‚³ãƒ¼ãƒˆ": [{ name: "æ¯›çš®", count: 2 }]
};


// NEW: Starting equipment pools for each job
const jobStartingPools = {
    "ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢": ["ä½œæ¥­ç€", "å®‰å…¨ãƒ˜ãƒ«ãƒ¡ãƒƒãƒˆ", "ãƒ„ãƒ¼ãƒ«ãƒ™ãƒ«ãƒˆ", "ãƒ€ã‚¯ãƒˆãƒ†ãƒ¼ãƒ—"],
    "åŒ»å¸«": ["ãƒ¡ã‚¹", "ç™½è¡£", "ãƒã‚¹ã‚¯", "æ•‘æ€¥ã‚­ãƒƒãƒˆ", "åŒ…å¸¯", "è§£ç†±å‰¤", "ä¸‹ç—¢æ­¢ã‚", "èƒƒè…¸è–¬"],
    "è»äºº": ["ã‚³ãƒ³ãƒãƒƒãƒˆãƒŠã‚¤ãƒ•", "ãƒ˜ãƒ«ãƒ¡ãƒƒãƒˆ", "æ°´ç­’"],
    "æ•™å¸«": ["ãƒ¢ãƒƒãƒ—", "ã‚¸ãƒ£ãƒ¼ã‚¸", "æ•‘æ€¥ã‚»ãƒƒãƒˆ"],
    "ã‚¢ã‚¹ãƒªãƒ¼ãƒˆ": ["ãƒ†ãƒ‹ã‚¹ãƒ©ã‚±ãƒƒãƒˆ", "é‡çƒã®ãƒãƒƒãƒˆ", "ã‚¸ãƒ£ãƒ¼ã‚¸", "ã‚¨ãƒŠã‚¸ãƒ¼ãƒ‰ãƒªãƒ³ã‚¯", "ãƒ—ãƒ­ãƒ†ã‚¤ãƒ³ãƒãƒ¼"],
    "è­¦å¯Ÿå®˜": ["ãƒ”ã‚¹ãƒˆãƒ«", "è­¦æ£’", "é˜²å¼¾ãƒ™ã‚¹ãƒˆ", "ãƒ”ã‚¹ãƒˆãƒ«ã®å¼¾"],
    "çœ‹è­·å¸«": ["ãƒã‚µãƒŸ", "ç™½è¡£", "æ•‘æ€¥ã‚­ãƒƒãƒˆ", "åŒ…å¸¯", "è§£ç†±å‰¤", "ä¸‹ç—¢æ­¢ã‚", "èƒƒè…¸è–¬"],
    "ã‚·ã‚§ãƒ•": ["åŒ…ä¸", "ã‚³ãƒƒã‚¯ã‚³ãƒ¼ãƒˆ", "ç¼¶è©°(è±†)", "ç”Ÿè‚‰", "ãƒ©ã‚¤ã‚¿ãƒ¼"],
    "å­¦ç”Ÿ": ["ãƒ¢ãƒƒãƒ—", "é‡çƒã®ãƒãƒƒãƒˆ", "ã‚¸ãƒ£ãƒ¼ã‚¸", "ãƒãƒƒã‚¯ãƒ‘ãƒƒã‚¯"],
    "ä¼šç¤¾å“¡": ["ãƒã‚µãƒŸ", "ã‚¹ãƒ¼ãƒ„ã®ã‚¸ãƒ£ã‚±ãƒƒãƒˆ", "æ°´ç­’", "ç¼¶è©°(è±†)"]
};


const npcTemplates = [
    { type: 'Trader', name: 'å•†äºº', icon: 'â˜º', health: 70, baseAttack: 5, baseDefense: 5, visionRange: 3, knowsSalvationCity: false, willSteal: 0.1,
        ascii: {
            high: `  â˜º\n /|] \n / \\`,
            medium: `  Â©\n /|] \n / >`,
            low: `  Â©\n /|_ \n / \\`,
            critical: `  ğŸ˜µ\n _|_ \n / \\`
        },
        dialogue: { greeting: "ã‚„ã‚ã€æ—…ã®äººã€‚ä½•ã‹äº¤æ›ã§ãã‚‹ã‚‚ã®ã¯ã‚ã‚‹ã‹ã„ï¼Ÿ", fight: "ãŠã„ãŠã„ã€æ—©ã¾ã‚‹ãªï¼", leave: "ãã†ã‹ã„ã€‚ã¾ã‚ã€æ°—ã‚’ã¤ã‘ã¦ãªã€‚" }
    },
    { type: 'Survivor', name: 'ç”Ÿå­˜è€…', icon: 'ğŸ˜Ÿ', health: 50, baseAttack: 8, baseDefense: 3, visionRange: 3, willSteal: 0.3,
        ascii: {
            high: `  ğŸ˜Ÿ\n /|\\ \n / \\`,
            medium: `  Â°_Â°\n /|\\ \n / >`,
            low: `  Â°_Â°\n /|~ \n / \\`,
            critical: `  x_x\n _|_ \n / \\`
        },
        dialogue: { greeting: "ã ã€èª°ã ï¼...ãªã‚“ã ã€äººé–“ã‹ã€‚ä½•ã‹ç”¨ã‹ï¼Ÿ", fight: "ã‚„ã‚ã¦ãã‚Œï¼å¿…æ­»ãªã‚“ã ï¼", leave: "ãã†ã‹...ã˜ã‚ƒã‚ãªã€‚" }
    },
    { type: 'Raider', name: 'ç•¥å¥ªè€…', icon: 'ğŸ˜ ', health: 80, baseAttack: 12, baseDefense: 8, visionRange: 3, willSteal: 1.0,
        ascii: {
            high: `  ğŸ˜ \n /|\\ \n / \\`,
            medium: `  Ã²_Ã³\n /|\\ \n / >`,
            low: `  Ã²_Ã³\n /|~ \n / \\`,
            critical: `  x_x\n _|_ \n / \\`
        },
        dialogue: { greeting: "ãŠã„ã€æ­¢ã¾ã‚Œã€‚èº«ãã‚‹ã¿ç½®ã„ã¦ã„ã£ã¦ã‚‚ã‚‰ãŠã†ã‹ã€‚", fight: "é¦¬é¹¿ã‚ï¼æ­»ã«ãŸã„ã‚‰ã—ã„ãªï¼", leave: "ãƒãƒƒ...è¦šãˆã¦ã‚ã‚ˆã€‚" }
    }
];

const wildlifeTemplates = [
    { type: 'Bear', name: 'ç†Š', icon: 'ğŸ»', health: 120, attack: 20, defense: 8, visionRange: 5, isAnimal: true, 
        ascii: {
            high: ` (\\_(-_-)_/)\n   _\\_â€_/_  \n  /___â€___\\`,
            medium: ` (\\_(-o-)_/)\n   _\\_â€_/_  \n  /__ â€__ \\`,
            low: ` (\\_(>_<)_/)\n   _\\_â€_/_  \n  /  â€   \\`,
            critical: ` (\\_(x_x)_/)\n   _\\_â€_/_  `
        }, 
        loot: { meat: 8, fur: 5 }, biomes: ['Forest'] 
    },
    { type: 'Wolf', name: 'ç‹¼', icon: 'ğŸº', health: 60, attack: 15, defense: 4, visionRange: 6, isAnimal: true, 
        ascii: {
            high: `  /\\_/\\ \n ( o.o ) \n > ^ <`,
            medium: `  /\\_/\\ \n ( o.o ) \n > ~ <`,
            low: `  /\\_/\\ \n ( >.< ) \n > ~ <`,
            critical: `  /\\_/\\ \n ( x.x ) \n > , <`
        }, 
        loot: { meat: 4, fur: 3 }, biomes: ['Forest', 'Plains'] 
    },
    { type: 'Deer', name: 'é¹¿', icon: 'ğŸ¦Œ', health: 40, attack: 5, defense: 2, visionRange: 7, isAnimal: true, flees: true, 
        ascii: {
            high: `  Y Y  \n (o.o) \n  > <`,
            medium: `  Y Y  \n (o.o) \n  > ~`,
            low: `  Y Y  \n (>.<) \n  > ,`,
            critical: `  Y Y  \n (x.x) `
        }, 
        loot: { meat: 5, fur: 2 }, biomes: ['Plains', 'Forest'] 
    },
    { type: 'Rabbit', name: 'ã‚¦ã‚µã‚®', icon: 'ğŸ‡', health: 15, attack: 1, defense: 0, visionRange: 6, isAnimal: true, flees: true, 
        ascii: {
            high: `  /\\ /\\ \n ( o.o ) \n c(___)"`,
            medium: `  /\\ /\\ \n ( o.o ) \n c(___)'`,
            low: `  /\\ /\\ \n ( >.< ) \n c(___)'`,
            critical: `  /\\ /\\ \n ( x.x )`
        }, 
        loot: { meat: 1, fur: 1 }, biomes: ['Plains'] 
    }
];

function randChoice(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

let map = [];
let turn = 0;
let currentSeason = 'æ˜¥';
let isNight = false;
let currentTime = new Date();
let droppedItems = {};

const seasons = ['æ˜¥', 'å¤', 'ç§‹', 'å†¬'];

let player = {
  x: 0, y: 0, hunger: 0, thirst: 0, health: 0, morale: 0, sleep: 0,
  bodyTemp: 36.5, weight: 0, maxWeight: 10, volume: 0, maxVolume: 10, bodyOdor: 0,
  vision: 2, inventory: [], equipment: [], injuries: [], sicknesses: [], hypothermiaTurns: 0, feverImmunityTurns: 0,
  baseAttack: 10, baseDefense: 5, attack: 10, defense: 5, insulation: 0,
  isInside: false,
  movementMode: 'walk'
};

function snapshotStats() {
    playerStatsBeforeAction = JSON.parse(JSON.stringify(player));
}

function speak(text, onEndCallback) {
  if (!isSpeechEnabled) {
    if (onEndCallback) {
      setTimeout(onEndCallback, 100); 
    }
    return;
  }

  if ('speechSynthesis' in window && text) {
    const utter = new SpeechSynthesisUtterance(text);
    utter.rate = 1.5;
    utter.lang = 'ja-JP';
    if (onEndCallback) { utter.onend = onEndCallback; }
    speechSynthesis.cancel();
    speechSynthesis.speak(utter);
  } else if (onEndCallback) { 
    setTimeout(onEndCallback, 500); 
  }
}

// ã€ã“ã“ã«è¿½åŠ ã™ã‚‹æ–°ã—ã„é–¢æ•°ã€‘
// ã€ã“ã“ã«è¿½åŠ ã™ã‚‹æ–°ã—ã„é–¢æ•°ã€‘
function speakQueuedLogs() {
    // logé–¢æ•°ã§å³æ™‚èª­ã¿ä¸Šã’ã‚’è¡Œã†ãŸã‚ã€ã“ã®é–¢æ•°ã¯ä¸è¦ã«ãªã‚Šã¾ã—ãŸã€‚
    // å¿µã®ãŸã‚ã‚­ãƒ¥ãƒ¼ã‚’ç©ºã«ã™ã‚‹å‡¦ç†ã ã‘æ®‹ã—ã¾ã™ã€‚
    logSpeechQueue = [];
}

function speakAndAlert(text) { speak(text); showModal(text); }

function speakAndConfirm(text, onConfirm, onCancel) {
    // Create a temporary element to strip HTML for speech synthesis
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = text;
    const plainText = tempDiv.textContent || tempDiv.innerText || "";
    speak(plainText); // Speak the plain text version
    showConfirmationModal(text, onConfirm, onCancel); // Show the HTML version in the modal
}

function showModal(message) {
  const modalDiv = document.createElement("div");
  modalDiv.style.cssText = `position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #333; color: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.5); z-index: 2000;`;
  modalDiv.innerHTML = `<p>${message}</p><button onclick="this.parentElement.remove();">OK</button>`;
  document.body.appendChild(modalDiv);
}

function showConfirmationModal(message, onConfirm, onCancel) {
  isInteractionActive = true;
  const modalDiv = document.createElement("div");
  modalDiv.style.cssText = `position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #333; color: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.5); z-index: 2000;`;
  modalDiv.innerHTML = `<p>${message}</p><button id="confirmYes" style="margin-right: 10px;">ã¯ã„</button><button id="confirmNo">ã„ã„ãˆ</button>`;
  document.body.appendChild(modalDiv);
  modalDiv.querySelector("#confirmYes").onclick = () => { modalDiv.remove(); isInteractionActive = false; if(onConfirm) onConfirm(); };
  modalDiv.querySelector("#confirmNo").onclick = () => { modalDiv.remove(); isInteractionActive = false; if(onCancel) onCancel(); };
}

function showItemComparisonModal(newItem, oldItem, onConfirm, onCancel) {
    isInteractionActive = true;
    const existingModal = document.getElementById("comparisonModal");
    if (existingModal) existingModal.remove();

    const modalDiv = document.createElement("div");
    modalDiv.id = "comparisonModal";
    
    const renderItem = (item, type) => {
        let statsHtml = '';
        const stats = ['attack', 'defense', 'insulation', 'weight', 'volume'];
        const otherItem = type === 'new' ? oldItem : newItem;

        stats.forEach(stat => {
            const val = item[stat] === undefined ? '-' : item[stat];
            const otherVal = otherItem[stat] === undefined ? '-' : otherItem[stat];
            let statClass = 'stat-neutral';
            
            if(val !== '-' && otherVal !== '-') {
                let a = (stat === 'weight' || stat === 'volume') ? otherVal : val;
                let b = (stat === 'weight' || stat === 'volume') ? val : otherVal;
                if (a > b) statClass = 'stat-positive';
                if (a < b) statClass = 'stat-negative';
            }
            statsHtml += `<div class="${statClass}">${getStatName(stat)}: ${val}</div>`;
        });
        const durability = item.durability !== undefined ? `<div>è€ä¹…åº¦: ${item.durability.toFixed(0)}%</div>` : '';

        return `<div class="comparison-item"><h4>${type === 'new' ? 'è£…å‚™ã™ã‚‹ã‚¢ã‚¤ãƒ†ãƒ ' : 'ç¾åœ¨ã®è£…å‚™'}</h4><div class="comparison-item-graphic">${item.graphic}</div><div class="comparison-item-name">${getItemDisplayName(item)}</div><div class="comparison-stats">${statsHtml}${durability}</div></div>`;
    };

    modalDiv.innerHTML = `<h3>è£…å‚™ã‚’äº¤æ›ã—ã¾ã™ã‹ï¼Ÿ</h3><div class="comparison-container">${renderItem(newItem, 'new')}${renderItem(oldItem, 'old')}</div><div class="comparison-actions"><button id="confirmSwapBtn">ã¯ã„</button><button id="cancelSwapBtn">ã„ã„ãˆ</button></div>`;

    document.body.appendChild(modalDiv);
    document.getElementById("confirmSwapBtn").onclick = () => { modalDiv.remove(); isInteractionActive = false; if (onConfirm) onConfirm(); };
    document.getElementById("cancelSwapBtn").onclick = () => { modalDiv.remove(); isInteractionActive = false; if (onCancel) onCancel(); };
}


function generateBackstory() {
  const { fullName, age, gender, job, race, traits } = character;
  let story = `ç§${fullName}ã€‚${age}æ­³ã€‚${gender === 'ç”·æ€§' ? 'ç”·æ€§' : 'å¥³æ€§'}ã ã€‚`;
  const jobStories = { "ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢": [`ã‹ã¤ã¦ã¯ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã‚’è¨­è¨ˆã—ã¦ã„ãŸã€‚è«–ç†çš„ãªæ€è€ƒåŠ›ã¯ã€ã“ã®ä¸–ç•Œã®è¬ã‚’è§£ãã®ã«å½¹ç«‹ã¤ã¯ãšã ã€‚`], "åŒ»å¸«": [`åŒ»ç™‚å¾“äº‹è€…ã¨ã—ã¦ã€å¤šãã®å‘½ã‚’æ•‘ã£ã¦ããŸã€‚è² å‚·è€…ã®æ‰‹å½“ã¦ã¯å¾—æ„ã ãŒã€ä»Šã¯è‡ªåˆ†ã®èº«ã‚’å®ˆã‚‹ã®ã«ç²¾ä¸€æ¯ã ã€‚`], "è»äºº": [`é•·å¹´ã®è»éšŠçµŒé¨“ã§ã€æˆ¦é—˜ã¨ã‚µãƒã‚¤ãƒãƒ«ã‚¹ã‚­ãƒ«ã¯èº«ã«ã¤ã„ã¦ã„ã‚‹ã€‚ã“ã®æ··ä¹±ã®ä¸­ã€è¦å¾‹ã¨å†·é™ã•ãŒå‘½ç¶±ã ã€‚`], "æ•™å¸«": [`å­ä¾›ãŸã¡ã«æœªæ¥ã‚’æ•™ãˆã¦ã„ãŸã€‚å½¼ã‚‰ã®ç¬‘é¡”ã‚’ã‚‚ã†ä¸€åº¦è¦‹ã‚‹ãŸã‚ã€ç”Ÿãæ®‹ã‚‰ãªã‘ã‚Œã°ãªã‚‰ãªã„ã€‚`], "ã‚¢ã‚¹ãƒªãƒ¼ãƒˆ": [`æ—¥ã€…ã®é›éŒ¬ã§ã€èª°ã«ã‚‚è² ã‘ãªã„å¼·é­ãªè‚‰ä½“ã‚’æ‰‹ã«å…¥ã‚ŒãŸã€‚ã“ã®èº«ä½“èƒ½åŠ›ãŒã€ãã£ã¨ç”Ÿãã‚‹å¸Œæœ›ã«ã¤ãªãŒã‚‹ã€‚`], "è­¦å¯Ÿå®˜": [`å¸‚æ°‘ã‚’å®ˆã‚‹ã®ãŒä½¿å‘½ã ã£ãŸã€‚ä»Šã€ã“ã®è’å»ƒã—ãŸä¸–ç•Œã§ã€æ­£ç¾©ã¨ã¯ä½•ã‹ã‚’è‡ªå•ã—ã¦ã„ã‚‹ã€‚`], "çœ‹è­·å¸«": [`äººã®ç—›ã¿ã‚’å’Œã‚‰ã’ã‚‹ã®ãŒä»•äº‹ã ã£ãŸã€‚ä»Šã¯ã€ã“ã®åœ°ç„ã®ã‚ˆã†ãªçŠ¶æ³ã§ã€äººã€…ã‚’åŠ©ã‘ã‚‹è¡“ã‚’æ¢ã—ã¦ã„ã‚‹ã€‚`], "ã‚·ã‚§ãƒ•": [`ç¾å‘³ã—ã„æ–™ç†ã§äººã€…ã‚’å¹¸ã›ã«ã—ã¦ã„ãŸã€‚é£Ÿæ–™ã‚’è¦‹ã¤ã‘ã€èª¿ç†ã™ã‚‹èƒ½åŠ›ã¯ã€ã“ã®ä¸–ç•Œã§ã‚‚ãã£ã¨å½¹ã«ç«‹ã¤ã¯ãšã ã€‚`], "å­¦ç”Ÿ": [`å­¦ã¶ã“ã¨ãŒå…¨ã¦ã ã£ãŸã€‚ã“ã®ä¸–ç•Œã§ç”Ÿãæ®‹ã‚‹ã«ã¯ã€æ•™ç§‘æ›¸ã«ã¯è¼‰ã£ã¦ã„ãªã„çŸ¥è­˜ãŒå¿…è¦ã ã€‚`], "ä¼šç¤¾å“¡": [`æ¯æ—¥ã€æº€å“¡é›»è»Šã«æºã‚‰ã‚Œã€å®šæ™‚ã‚’å¾…ã£ã¦ã„ãŸã€‚ä»Šã¯ã€ã“ã®çµ‚ã‚ã‚Šãªãã‚µãƒã‚¤ãƒãƒ«ã¨ã„ã†åã®å‡ºç¤¾ã‚’ç¶šã‘ã¦ã„ã‚‹ã€‚`] };
  const raceStories = { "ç™½äºº": [`æ•…éƒ·ã¯é ã„ç•°å›½ã®åœ°ã€‚ã“ã®è¦‹çŸ¥ã‚‰ã¬åœŸåœ°ã§ç”Ÿãæ®‹ã‚‹ãŸã‚ã€å¿…æ­»ã«è¶³æ»ã„ã¦ã„ã‚‹ã€‚`], "ã‚¢ã‚¸ã‚¢äºº": [`æ±æ´‹ã®å³¶å›½ã‹ã‚‰æ¥ãŸã€‚æ•…éƒ·ã®æ–‡åŒ–ã‚’èƒ¸ã«ã€ã“ã®æœªæ›½æœ‰ã®äº‹æ…‹ã«ç«‹ã¡å‘ã‹ã†ã€‚`], "é»’äºº": [`åŠ›å¼·ã„ãƒ«ãƒ¼ãƒ„ã‚’æŒã¤ã€‚ä½“æ ¼ã«æµã¾ã‚Œã€ã“ã®å³ã—ã„ç’°å¢ƒã§ã‚‚ç”ŸãæŠœãè‡ªä¿¡ãŒã‚ã‚‹ã€‚`], "ä¸­æ±ç³»": [`ç¼ç†±ã®ç ‚æ¼ ã‚’æ€ã‚ã›ã‚‹æ•…éƒ·ã®è¨˜æ†¶ãŒã€ä»Šã®ä¹¾ãã‚’è€ãˆã‚‹åŠ›ã¨ãªã£ã¦ã„ã‚‹ã€‚`] };
  const traitStories = { "å¼·é­ãªè‚‰ä½“": [`ç”Ÿã¾ã‚Œã¤ãä½“ãŒä¸ˆå¤«ã§ã€å°‘ã€…ã®ã“ã¨ã§ã¯ã¸ã“ãŸã‚Œãªã„ã€‚`], "å­¦ç¿’èƒ½åŠ›ãŒé«˜ã„": [`æ–°ã—ã„çŸ¥è­˜ã‚’ç´ æ—©ãå¸åã—ã€å›°é›£ãªçŠ¶æ³ã«ã‚‚é©å¿œã™ã‚‹ã€‚`], "ç²¾ç¥åŠ›ãŒå¼·ã„": [`ã©ã‚“ãªçµ¶æœ›çš„ãªçŠ¶æ³ã§ã‚‚ã€å¿ƒã‚’å¼·ãä¿ã¤ã“ã¨ãŒã§ãã‚‹ã€‚`], "ä¸çœ ç—‡": [`çœ ã‚‹ã“ã¨ãŒè‹¦æ‰‹ãªãŸã‚ã€å¤œé€šã—è­¦æˆ’ã§ãã‚‹ã€‚ã ãŒã€ãã‚ŒãŒè‰¯ã„ã“ã¨ãªã®ã‹ã€æ‚ªã„ã“ã¨ãªã®ã‹ã€ä»Šã¯åˆ†ã‹ã‚‰ãªã„ã€‚`], "ç—…å¼±": [`å…ƒã€…ä½“ãŒå¼±ãã€äººä¸€å€æ…é‡ã«è¡Œå‹•ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚`], "ç›®ãŒã„ã„": [`ä»–ã®äººã«ã¯è¦‹ãˆãªã„ã‚‚ã®ãŒè¦‹ãˆã‚‹ã€‚ã“ã®ç›®ã¯ç§ã®æ­¦å™¨ã ã€‚`], "ç›®ãŒæ‚ªã„": [`ä¸–ç•ŒãŒã¼ã‚„ã‘ã¦è¦‹ãˆã‚‹ã€‚ç´°ã‹ã„ä½œæ¥­ã‚„é ãã®ç¢ºèªã¯è‹¦æ‰‹ã ã€‚`] };
  story += randChoice(jobStories[job] || [ `ç§ã®è·æ¥­ã¯${job}ã ã€‚` ]);
  story += randChoice(raceStories[race] || [ `äººç¨®ã¯${race}ã ã€‚` ]);
  if (traits.length > 0) {
    story += "ç§ã®ç‰¹æ€§ã¯ã€";
    traits.forEach((trait, index) => {
      story += randChoice(traitStories[trait] || [ trait ]);
      if (index < traits.length - 1) story += "ãã—ã¦ã€";
    });
    story += "ã€‚";
  }
  story += `ã“ã®çµ¶æœ›çš„ãªçŠ¶æ³ã§ã€ç§ã¯ãŸã ç”Ÿãæ®‹ã‚‹ãŸã‚ã«æˆ¦ã„ç¶šã‘ã‚‹ã€‚`;
  return story;
}

function generateInitialCorpses() {
    const numCorpses = Math.floor(mapSize * mapSize * 0.015);
    
    for (let i = 0; i < numCorpses; i++) {
        let x, y, locationKey;
        do {
            x = Math.floor(Math.random() * mapSize);
            y = Math.floor(Math.random() * mapSize);
            locationKey = `${x},${y}`;
        } while ((x === player.x && y === player.y) || placedObjects.some(p => p.x === x && p.y === y));

        const isHuman = Math.random() < 0.5;

        if (isHuman) {
            let corpseLoot = [];
            const numItems = Math.floor(Math.random() * 3) + 1;
            const lootableItems = items.filter(item => !item.tags || (!item.tags.includes(NO_LOOT_TAG) && !item.tags.includes(HANDMADE_TAG)));
            for (let j = 0; j < numItems; j++) {
                if (lootableItems.length === 0) break;
                let newItem = JSON.parse(JSON.stringify(randChoice(lootableItems)));
                if (newItem.freshness !== undefined) newItem.freshness = Math.floor(Math.random() * 40);
                if (newItem.durability !== undefined) newItem.durability = Math.floor(Math.random() * 50) + 10;
                corpseLoot.push(newItem);
            }

            if (corpseLoot.length > 0) {
                const corpse = {
                    x: x, y: y, type: 'corpse', name: 'å¤ã„æ­»ä½“', graphic: 'ğŸ¦´',
                    duration: Math.floor(Math.random() * 24) + 24,
                    isHumanCorpse: true, unsearched: true, potentialLoot: corpseLoot
                };
                placedObjects.push(corpse);
            }
        } else { // Animal corpse
            const corpse = {
                x: x, y: y, type: 'corpse', name: 'å‹•ç‰©ã®æ­»éª¸', graphic: 'ğŸ¦´',
                duration: Math.floor(Math.random() * 24) + 48,
                isAnimalCorpse: true, unbutchered: true,
                potentialLoot: { 
                    meat: Math.floor(Math.random() * 3) + 1, 
                    fur: Math.floor(Math.random() * 2)
                }
            };
            placedObjects.push(corpse);
        }
    }
}

function genMap() {
    generateRandomCharacter();
    calculateMaxStats();
    map = []; entities = []; placedObjects = [];
    let biomeMap = Array(mapSize).fill(null).map(() => Array(mapSize).fill('Plains'));
    let townCenters = [];
    const numTowns = Math.floor(mapSize / 25), numForests = Math.floor(mapSize / 15);
    const townRadius = Math.floor(mapSize / 30), forestRadius = Math.floor(mapSize / 10);
    for(let i = 0; i < numTowns; i++) {
        const townX = Math.floor(Math.random() * mapSize), townY = Math.floor(Math.random() * mapSize);
        townCenters.push({x: townX, y: townY});
        for(let y = 0; y < mapSize; y++) for(let x = 0; x < mapSize; x++) if (Math.sqrt(Math.pow(x-townX, 2) + Math.pow(y-townY, 2)) < townRadius) biomeMap[y][x] = 'Town';
    }
    for(let i = 0; i < numForests; i++) {
        const forestX = Math.floor(Math.random() * mapSize), forestY = Math.floor(Math.random() * mapSize);
        for(let y = 0; y < mapSize; y++) for(let x = 0; x < mapSize; x++) if (Math.sqrt(Math.pow(x-forestX, 2) + Math.pow(y-forestY, 2)) < forestRadius * (1 + (Math.random() - 0.5) * 0.5) && biomeMap[y][x] === 'Plains') biomeMap[y][x] = 'Forest';
    }
    for(let i = 0; i < townCenters.length - 1; i++) {
        let start = townCenters[i], end = townCenters[i+1], current = {...start};
        while(current.x !== end.x || current.y !== end.y) {
            if(Math.abs(end.x - current.x) > Math.abs(end.y - current.y)) current.x += Math.sign(end.x - current.x); else current.y += Math.sign(end.y - current.y);
            if(biomeMap[current.y][current.x] !== 'Town') biomeMap[current.y][current.x] = 'Road';
        }
    }

    let cabinCoords = []; // å°å±‹ã®åº§æ¨™ã‚’è¨˜éŒ²ã™ã‚‹é…åˆ—
    const MIN_CABIN_DISTANCE = 6; // å°å±‹é–“ã®æœ€ä½è·é›¢ï¼ˆã‚¿ã‚¤ãƒ«æ•°ï¼‰

    for(let y=0; y<mapSize; y++) {
        const row = [];
        for(let x=0; x<mapSize; x++) {
            const biome = biomeMap[y][x];
            let loc;

            if (biome === 'Forest') {
                const isTooCloseToCabin = cabinCoords.some(coord => getDistance(x, y, coord.x, coord.y) < MIN_CABIN_DISTANCE);
                
                if (isTooCloseToCabin) {
                    const nonCabinForestLocations = biomeLocations.Forest.filter(l => l.name !== "å°å±‹");
                    loc = randChoice(nonCabinForestLocations);
                } else {
                    loc = randChoice(biomeLocations.Forest);
                    if (loc.name === "å°å±‹") {
                        cabinCoords.push({x: x, y: y});
                    }
                }
            } else {
                loc = (biome === 'Town') ? (Math.random() < 0.1 ? biomeLocations.TraderShop : randChoice(biomeLocations.Town)) : (biome === 'Road') ? randChoice(biomeLocations.Road) : randChoice(biomeLocations.Plains);
            }

            const tileData = { loc: {...loc}, explored: false, biome: biome, searched: false };
            if (tileData.loc.name === 'æ£®æ—') {
                tileData.logSupply = Math.floor(Math.random() * 3) + 1;
            }
            row.push(tileData);
        }
        map.push(row);
    }
    player.x = Math.floor(Math.random() * mapSize); player.y = Math.floor(Math.random() * mapSize);
    
    droppedItems = {};
    generateInitialCorpses(); 
    
    let scX, scY;
    do { 
        scX = Math.floor(Math.random() * mapSize); 
        scY = Math.floor(Math.random() * mapSize);
    } while (map[scY][scX].biome === 'Town' || Math.sqrt(Math.pow(scX - player.x, 2) + Math.pow(scY - player.y, 2)) <= 20 || placedObjects.some(p => p.x === scX && p.y === scY));

    salvationCityCoords = { x: scX, y: scY };
    map[scY][scX] = { loc: salvationCityLocation, explored: false, biome: 'Plains', searched: false };
    salvationCityDiscovered = false;
    const numEntities = mapSize * mapSize * 0.05; 
    for (let i = 0; i < numEntities; i++) {
        let x, y;
        do { 
            x = Math.floor(Math.random() * mapSize); 
            y = Math.floor(Math.random() * mapSize); 
        } while (
            (x === player.x && y === player.y) || 
            entities.some(e => e.x === x && e.y === y) || 
            placedObjects.some(p => p.x === x && p.y === y)
        );
        const entityType = Math.random(), biome = map[y][x].biome;
        
        if (entityType < 0.4) {
            entities.push({ type: 'Zombie', name: 'ã‚¾ãƒ³ãƒ“', icon: 'ğŸ’€', x, y, health: 50 + Math.floor(Math.random() * 30), attack: 8 + Math.floor(Math.random() * 8), defense: 2, visionRange: 3, isZombie: true, stunnedTurns: 0, aiState: 'wandering', target: null, investigationTarget: null });
        } else if (entityType < 0.6) {
             const possibleWildlife = wildlifeTemplates.filter(w => w.biomes.includes(biome));
             if (possibleWildlife.length > 0) {
                 const newWildlife = { ...JSON.parse(JSON.stringify(randChoice(possibleWildlife))), x, y, stunnedTurns: 0, aiState: 'wandering', target: null, investigationTarget: null };
                 entities.push(newWildlife);
             }
        } else {
            const npc = generateNPC(); npc.x = x; npc.y = y; npc.stunnedTurns = 0;
            npc.aiState = 'wandering'; npc.target = null; npc.investigationTarget = null;
            entities.push(npc);
        }
    }

    ensureKnowledgeableTrader();
    updateExploration();

turn = 0;

// ãƒ©ãƒ³ãƒ€ãƒ ã«å­£ç¯€ã‚’é¸æŠ
currentSeason = randChoice(seasons);

currentTime = new Date();
currentTime.setFullYear(2025);

// é¸æŠã•ã‚ŒãŸå­£ç¯€ã«å¿œã˜ã¦æ—¥ä»˜ã‚’è¨­å®š
switch (currentSeason) {
    case 'æ˜¥':
        currentTime.setMonth(2, 21); // 3æœˆ21æ—¥
        break;
    case 'å¤':
        currentTime.setMonth(5, 21); // 6æœˆ21æ—¥
        break;
    case 'ç§‹':
        currentTime.setMonth(8, 22); // 9æœˆ22æ—¥
        break;
    case 'å†¬':
        currentTime.setMonth(11, 21); // 12æœˆ21æ—¥
        break;
}

currentTime.setHours(8, 0, 0, 0);
isNight = false;

const weatherOptions = [ { name: "å¿«æ™´", icon: "â˜€ï¸", chance: 50, tempMod: 2 }, { name: "æ›‡ã‚Š", icon: "â˜ï¸", chance: 25, tempMod: 0 }, { name: "é›¨", icon: "ğŸŒ§ï¸", chance: 15, tempMod: -3 }, { name: "åµ", icon: "â›ˆï¸", chance: 10, tempMod: -5 } ];
    let totalChance = weatherOptions.reduce((sum, w) => sum + w.chance, 0), randomValue = Math.random() * totalChance, accumulatedChance = 0;
    for (const weather of weatherOptions) {
        accumulatedChance += weather.chance;
        if (randomValue <= accumulatedChance) {
            currentWeather = weather;
            break;
        }
    }
    
    player.hunger = Math.floor(maxStats.hunger * (0.6 + Math.random() * 0.3));
    player.thirst = Math.floor(maxStats.thirst * (0.7 + Math.random() * 0.2));
    player.health = Math.floor(maxStats.health * (0.8 + Math.random() * 0.15));
    player.morale = Math.floor(maxStats.morale * (0.4 + Math.random() * 0.4));
    player.sleep = Math.floor(maxStats.sleep * (0.5 + Math.random() * 0.3));
    player.bodyTemp = 36.5 + (Math.random() * 0.4 - 0.2);
    player.bodyOdor = 0;
    player.weight = 0;
    player.maxWeight = maxStats.maxWeight;
    player.volume = 0;
    player.maxVolume = maxStats.maxVolume;
    player.vision = maxStats.vision || 2;
    player.inventory = []; player.equipment = []; player.injuries = []; player.sicknesses = [];
    player.baseAttack = 10; player.baseDefense = 5; player.attack = 10; defense: 5;

    const startingItemPool = jobStartingPools[character.job];
    if (startingItemPool) {
        const itemName = randChoice(startingItemPool);
        const itemTemplate = items.find(i => i.name === itemName);
        if (itemTemplate) {
            const newItem = JSON.parse(JSON.stringify(itemTemplate));
            if (newItem.type === 'container') {
                newItem.content = null;
            }
            player.inventory.push(newItem);
        }
    }
    updateEquippedStats();
}
// MODIFIED: getVisionRange now accounts for weather
function getVisionRange() {
    const hour = currentTime.getHours();
    let baseVision = player.vision;
    if (character.traits.includes("ç›®ãŒæ‚ªã„") && player.equipment.some(e => e.name === 'ãƒ¡ã‚¬ãƒ')) baseVision++;
    
    const hasTorch = player.equipment.some(e => e.isTorch);
    
    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
    const isEvening = hour >= 18 && hour < 21;   // å¤•æ–¹ (18:00 - 20:59)
    const isDeepNight = hour >= 21 || hour < 6;  // å¤œ (21:00 - 5:59)

    if (isEvening) {
        baseVision = 1; // å¤•æ–¹ã®è¦–ç•Œã‚’1ã«å›ºå®š
    } else if (isDeepNight) {
        let nightVision = 0; // å¤œã®åŸºæœ¬è¦–ç•Œã‚’0ã«
        if (hasTorch) nightVision = 1;
        if (character.traits.includes("ç›®ãŒã„ã„")) nightVision = Math.max(nightVision, 1);
        baseVision = nightVision;
    } else if (hour < 8) { // æœ (6:00 - 7:59)
        baseVision = Math.max(hasTorch ? 1 : 0, baseVision - 1);
    }
    // (åˆå‰8æ™‚ï½åˆå¾Œ5æ™‚ã¯ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®åŸºæœ¬è¦–ç•ŒãŒãã®ã¾ã¾ä½¿ã‚ã‚Œã¾ã™)
    // â–²â–²â–² ã“ã“ã¾ã§ãŒä¿®æ­£ç®‡æ‰€ â–²â–²â–²

    // å¤©å€™ã«ã‚ˆã‚‹å½±éŸ¿
    if (currentWeather.name === 'é›¨') baseVision *= 0.75;
    if (currentWeather.name === 'åµ') baseVision *= 0.5;

    return Math.max(0, Math.round(baseVision));
}

// MODIFIED: getEntityVisionRange now accounts for weather
function getEntityVisionRange(entity) {
    let baseVision;
    const hour = currentTime.getHours();
    
    const isEvening = hour >= 18 && hour < 21;
    const isDeepNight = hour >= 21 || hour < 6;
    const isMorning = hour >= 6 && hour < 8;

    if (entity.isAnimal) {
        // --- é‡ç”Ÿå‹•ç‰©ã®è¦–ç•Œãƒ­ã‚¸ãƒƒã‚¯ (ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¦–ç•Œ+1) ---
        // ã¾ãšãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¤©å€™é©ç”¨å‰ã®è¦–ç•Œã‚’è¨ˆç®—
        let playerPreWeatherVision = player.vision;
        if (character.traits.includes("ç›®ãŒæ‚ªã„") && player.equipment.some(e => e.name === 'ãƒ¡ã‚¬ãƒ')) {
            playerPreWeatherVision++;
        }
        
        const hasTorch = player.equipment.some(e => e.isTorch);
        let playerCurrentVision;

        if (isEvening) {
            playerCurrentVision = 1;
        } else if (isDeepNight) {
            let nightVision = 0;
            if (hasTorch) nightVision = 1;
            if (character.traits.includes("ç›®ãŒã„ã„")) nightVision = Math.max(nightVision, 1);
            playerCurrentVision = nightVision;
        } else if (isMorning) {
            playerCurrentVision = Math.max(hasTorch ? 1 : 0, playerPreWeatherVision - 1);
        } else { // æ˜¼
            playerCurrentVision = playerPreWeatherVision;
        }
        
        baseVision = playerCurrentVision + 1;

    } else { // --- NPCã¨ã‚¾ãƒ³ãƒ“ã®è¦–ç•Œãƒ­ã‚¸ãƒƒã‚¯ (ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ•°å€¤ã«åˆã‚ã›ã‚‹) ---
        let playerBaseVision = player.vision;
        
        if (isEvening) {
            baseVision = 1;
        } else if (isDeepNight) {
            let nightVision = 0;
            const hasGoodEyesight = entity.traits && entity.traits.includes("ç›®ãŒã„ã„");
            if (hasGoodEyesight) { // NPCã®ã¿å½±éŸ¿
                nightVision = 1;
            }
            baseVision = nightVision;
        } else if (isMorning) {
            baseVision = playerBaseVision - 1; // é€šå¸¸ã¯ 2 - 1 = 1
        } else { // æ˜¼
            baseVision = playerBaseVision; // é€šå¸¸ã¯ 2
        }
    }
    
    // å…¨å“¡ã«å¤©å€™ã®å½±éŸ¿ã‚’é©ç”¨
    if (currentWeather.name === 'é›¨') baseVision *= 0.75;
    if (currentWeather.name === 'åµ') baseVision *= 0.5;

    return Math.max(0, Math.round(baseVision));
}


function updateExploration() {
    const visionRange = getVisionRange();
    for (let y = Math.max(0, player.y - visionRange); y <= Math.min(mapSize - 1, player.y + visionRange); y++) {
        for (let x = Math.max(0, player.x - visionRange); x <= Math.min(mapSize - 1, player.x + visionRange); x++) {
            const distance = Math.sqrt(Math.pow(player.x - x, 2) + Math.pow(player.y - y, 2));
            if (distance <= visionRange) {
                if (hasLineOfSight(player.x, player.y, x, y) && !map[y][x].explored) {
                    map[y][x].explored = true;
                    if(x === salvationCityCoords.x && y === salvationCityCoords.y && !salvationCityDiscovered) {
                        salvationCityDiscovered = true; playSound('victory'); log("ã‚µãƒ«ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ã‚·ãƒ†ã‚£ã‚’ç™ºè¦‹ã—ãŸï¼");
                    }
                }
            }
        }
    }
    if (isNight) {
        const campfire = placedObjects.find(obj => obj.type === 'campfire' && Math.abs(player.x - obj.x) <= 1 && Math.abs(player.y - obj.y) <= 1);
        if (campfire) {
            for (let y = Math.max(0, campfire.y - 1); y <= Math.min(mapSize - 1, campfire.y + 1); y++) {
                for (let x = Math.max(0, campfire.x - 1); x <= Math.min(mapSize - 1, campfire.x + 1); x++) {
                    map[y][x].explored = true;
                }
            }
        }
    }
}

function triggerRandomEvent() {
    const movementMode = player.movementMode;

    if (movementMode === 'run') {
        // èµ°è¡Œæ™‚: 25%ã®ç¢ºç‡ã§ã‚¤ãƒ™ãƒ³ãƒˆç™ºç”Ÿ
        if (Math.random() < 0.25) {
            // ã•ã‚‰ã«ã€ãã®ä¸­ã§25%ãŒã‚¢ã‚¤ãƒ†ãƒ ç´›å¤±ã€75%ãŒè£…å‚™ç ´æ
            if (Math.random() < 0.25) {
                event_loseItem(); // ã‚¢ã‚¤ãƒ†ãƒ ã‚’è½ã¨ã™ã‚¤ãƒ™ãƒ³ãƒˆ
            } else {
                event_damageEquipment(); // ã‚¢ã‚¤ãƒ†ãƒ ã®è€ä¹…å€¤ãŒä¸‹ãŒã‚‹ã‚¤ãƒ™ãƒ³ãƒˆ
            }
        }
    } else if (movementMode === 'walk') {
        // æ­©è¡Œæ™‚: 3%ã®ç¢ºç‡ã§è£…å‚™ç ´æã‚¤ãƒ™ãƒ³ãƒˆã®ã¿ç™ºç”Ÿ
        if (Math.random() < 0.03) {
            event_damageEquipment();
        }
    }
    // ãã®ä»–ã®ç§»å‹•ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã‚¤ãƒ™ãƒ³ãƒˆã¯ç™ºç”Ÿã—ãªã„
}

function event_loseItem() {
    // æ‰€æŒå“ãŒãªã„å ´åˆã¯ä½•ã‚‚ã—ãªã„
    if (player.inventory.length === 0) {
        return;
    }
    // æ‰€æŒå“ã®ä¸­ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ãªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’é¸ã¶
    const itemIndex = Math.floor(Math.random() * player.inventory.length);
    const lostItem = player.inventory[itemIndex];

    // é¸ã°ã‚ŒãŸã‚¢ã‚¤ãƒ†ãƒ ã‚’æ‰€æŒå“ã‹ã‚‰å‰Šé™¤
    player.inventory.splice(itemIndex, 1);

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é‡é‡ã¨å®¹é‡ã‚’æ›´æ–°
    player.weight -= lostItem.weight || 0;
    player.volume -= lostItem.volume || 0;

    const eventMessage = `ç§»å‹•ä¸­ã«ä½•ã‹ã‚’è½ã¨ã—ã¦ã—ã¾ã£ãŸã‚ˆã†ã ...ï¼<span style="color: indianred;">ï¼ˆ${getItemDisplayName(lostItem)}ã‚’ç´›å¤±ï¼‰</span>`;
    log(eventMessage, true);
    showModal(eventMessage); // Pop-up is displayed
    updateItemPanels();
    updateStatus();
}

function event_damageEquipment() {
    // è£…å‚™å“ã¨æ‰€æŒå“ã®ä¸­ã‹ã‚‰ã€è€ä¹…åº¦ã‚’æŒã¤ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã™ã¹ã¦ãƒªã‚¹ãƒˆã‚¢ãƒƒãƒ—
    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
    // æ­¦å™¨ (item.slot === 'weapon') ã‚’ãƒ€ãƒ¡ãƒ¼ã‚¸ã®å¯¾è±¡ã‹ã‚‰é™¤å¤–ã™ã‚‹
    const damageableItems = [...player.equipment, ...player.inventory].filter(item => 
        item.durability !== undefined && 
        (item.type === 'clothing' || item.type === 'equipment') &&
        item.slot !== 'weapon'
    );
    // â–²â–²â–² ã“ã“ã¾ã§ãŒä¿®æ­£ç®‡æ‰€ â–²â–²â–²
    
    // å¯¾è±¡ã‚¢ã‚¤ãƒ†ãƒ ãŒãªã„å ´åˆã¯ä½•ã‚‚ã—ãªã„
    if (damageableItems.length === 0) {
        return;
    }

    // å¯¾è±¡ã‚¢ã‚¤ãƒ†ãƒ ã®ä¸­ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«1ã¤é¸ã¶
    const targetItem = randChoice(damageableItems);
    const damageAmount = Math.floor(Math.random() * 30) + 20; // 20ã‹ã‚‰49ã®ãƒ€ãƒ¡ãƒ¼ã‚¸
    const originalDurability = targetItem.durability;
    
    targetItem.durability -= damageAmount;

    let eventMessage;
    if (targetItem.durability <= 0) {
        targetItem.durability = 0;
        eventMessage = `æã«è¡£æœãŒå¼•ã£ã‹ã‹ã£ãŸï¼<span style="color: red;">ï¼ˆ${getItemDisplayName(targetItem)}ãŒå®Œå…¨ã«å£Šã‚Œã¦ã—ã¾ã£ãŸï¼ï¼‰</span>`;
    } else {
        eventMessage = `æã«è¡£æœãŒå¼•ã£ã‹ã‹ã£ãŸï¼<span style="color: orange;">ï¼ˆ${getItemDisplayName(targetItem)}ã®è€ä¹…åº¦ãŒå¤§å¹…ã«æ¸›å°‘ï¼‰</span>`;
    }
    log(eventMessage, true);
    showModal(eventMessage); // Pop-up is displayed
    updateItemPanels();
    updateEquippedStats();
    updateStatus();
}

// MODIFIED: handleTileClick now manages movement modes
function handleTileClick(targetX, targetY) {
    if (isInteractionActive || targetingState.active) {
        if (targetingState.active) handleTargetingClick(targetX, targetY);
        return;
    }

    const barricade = placedObjects.find(o => o.x === targetX && o.y === targetY && o.type === 'barricade' && o.health > 0);
    if (barricade) {
        log("ãƒãƒªã‚±ãƒ¼ãƒ‰ãŒé“ã‚’å¡ã„ã§ã„ã‚‹ã€‚");
        return;
    }

    const dist = Math.max(Math.abs(player.x - targetX), Math.abs(player.y - targetY));

    if (dist === 0) {
        const placedObject = placedObjects.find(p => p.x === player.x && p.y === player.y);
        if (placedObject) {
            if (placedObject.type === 'wooden_box') openStoragePanel(placedObject);
            else showPlacedObjectDetail(placedObject);
        } else {
            speakAndConfirm("ä½•ã‚‚ã—ãªã„ã§éã”ã—ã¾ã™ã‹ï¼Ÿ", waitOneTurn);
        }
        return;
    }

    if (player.movementMode === 'run') {
        if (dist !== 2) {
            log("èµ°è¡Œãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€å¿…ãš2ãƒã‚¹å…ˆ(æ–œã‚å«ã‚€)ã®ã‚¿ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚");
            return;
        }
    } else {
        if (dist !== 1) {
            log("æ­©è¡Œãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€éš£æ¥ã™ã‚‹ãƒã‚¹(æ–œã‚å«ã‚€)ã®ã¿ç§»å‹•ã§ãã¾ã™ã€‚");
            return;
        }
    }

    snapshotStats();
    player.isInside = false;

    player.x = targetX;
    player.y = targetY;
    
    updateExploration();

    if (player.movementMode === 'run') {
        player.hunger -= 2;
        player.thirst -= 4;
        createSound(targetX, targetY, 8);
        log("2ãƒã‚¹èµ°ã£ã¦ç§»å‹•ã—ãŸã€‚");
    } else {
        createSound(targetX, targetY, 2);
    }
    
    if (player.x === salvationCityCoords.x && player.y === salvationCityCoords.y) {
        triggerGameClear();
        return;
    }
    
    exploreTile();
    triggerRandomEvent();

    // â–¼â–¼â–¼ å®Ÿè¡Œé †åºã‚’ã“ã“ã‹ã‚‰ä¿®æ­£ â–¼â–¼â–¼
    
    advanceTurn(); // å…ˆã«ã‚¿ãƒ¼ãƒ³ã‚’é€²ã‚ã‚‹å‡¦ç†ã‚’å‘¼ã³å‡ºã™
    
    // ãã®å¾Œã«UIï¼ˆç”»é¢ï¼‰ã‚’æ›´æ–°ã™ã‚‹
    updateTurnInfo();
    drawMap();
    drawMinimap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    
    checkGameOver();
    speakQueuedLogs();
    
    // â–²â–²â–² ã“ã“ã¾ã§ä¿®æ­£ â–²â–²â–²
}

function drawMap() {
    if (!map || map.length === 0 || !player) return; // â† ã“ã®ä¸€è¡Œã‚’è¿½åŠ 
    
    mapIconIntervals.forEach(clearInterval);
    mapIconIntervals = [];

    const mapDiv = document.getElementById("map");
    mapDiv.style.gridTemplateColumns = `repeat(${viewportSize}, 40px)`;
    mapDiv.innerHTML = "";
    const halfView = Math.floor(viewportSize / 2),
        startX = player.x - halfView,
        startY = player.y - halfView;
    for (let yOffset = 0; yOffset < viewportSize; yOffset++) {
        for (let xOffset = 0; xOffset < viewportSize; xOffset++) {
            const x = startX + xOffset,
                y = startY + yOffset;
            const div = document.createElement("div");
            div.className = "tile";
            if (x < 0 || y < 0 || x >= mapSize || y >= mapSize) {
                div.classList.add("unexplored");
                div.style.background = "#111";
                div.style.border = "none";
                mapDiv.appendChild(div);
                continue;
            }
            const tile = map[y][x];

            if (targetingState.active && getDistance(player.x, player.y, x, y) <= targetingState.range) {
                if (hasLineOfSight(player.x, player.y, x, y)) {
                    div.classList.add("targeting");
                }
            }

            if (tile.explored) {
                const isInSight = getDistance(player.x, player.y, x, y) <= getVisionRange() && hasLineOfSight(player.x, player.y, x, y);

                if (isInSight) {
                    div.classList.add("explored");
                    if (tile.biome === 'Road') div.classList.add('road-tile');
                    
                    const iconsToShow = [];
                    const showTileTooltip = (e) => {
                        const preview = document.getElementById("statusPreview");
                        let contentHtml = `<strong>${tile.loc.name}</strong>`;
                        if (tile.loc.blocksVision) {
                            contentHtml += `<div style="color: indianred; font-size: 0.9em;">(è¦–ç•Œã‚’é®ã‚‹)</div>`;
                        }
                        preview.innerHTML = contentHtml;
                        preview.style.display = 'block';
                        updatePreviewPosition(e);
                    };
                    iconsToShow.push({icon: tile.loc.icon, tooltip: showTileTooltip});

                    const entityOnTile = entities.find(e => e.x === x && e.y === y);
                    if (entityOnTile) {
                        iconsToShow.push({icon: entityOnTile.icon, tooltip: (e) => showEntityTooltip(entityOnTile, e)});
                    }

                    if (player.x === x && player.y === y) {
                        div.classList.add("player-tile");
                        const playerIconContent = (character.gender === "ç”·æ€§") ? "ğŸš¹" : "ğŸšº";
                        const showPlayerTooltip = (e) => {
                            const preview = document.getElementById("statusPreview");
                            let contentHtml = `<strong>${tile.loc.name}</strong>`;
                            if (tile.loc.blocksVision) {
                                contentHtml += `<div style="color: indianred; font-size: 0.9em;">(è¦–ç•Œã‚’é®ã‚‹)</div>`;
                            }
                            contentHtml += `<div style="border-top: 1px solid #555; margin-top:5px; padding-top:5px;"><strong>ã‚ãªãŸ</strong><br/>${character.fullName}</div>`;
                            preview.innerHTML = contentHtml;
                            preview.style.display = 'block';
                            updatePreviewPosition(e);
                        };
                        iconsToShow.push({icon: playerIconContent, tooltip: showPlayerTooltip});
                    }
                    
                    const placedObjectsOnTile = placedObjects.filter(c => c.x === x && c.y === y);
                    if (placedObjectsOnTile.length > 0) {
                        placedObjectsOnTile.forEach(pObj => {
                           iconsToShow.push({icon: pObj.graphic, tooltip: (e) => showPlacedObjectTooltip(pObj, e)});
                        });
                    }

                    if (iconsToShow.length <= 1) {
                        div.textContent = iconsToShow.length > 0 ? iconsToShow[0].icon : '?';
                        if (iconsToShow.length === 1 && iconsToShow[0].tooltip) {
                             div.addEventListener('mouseenter', iconsToShow[0].tooltip);
                             div.addEventListener('mouseleave', hideStatusPreview);
                             div.addEventListener('mousemove', (e) => updatePreviewPosition(e));
                        }
                    } else {
                        let currentIndex = 0;
                        const iconSpan = document.createElement('span');
                        div.appendChild(iconSpan);

                        const updateIcon = () => {
                            const current = iconsToShow[currentIndex];
                            iconSpan.textContent = current.icon;
                            div.onmouseenter = null; div.onmouseleave = null; div.onmousemove = null;
                            if (current.tooltip) {
                                div.addEventListener('mouseenter', current.tooltip);
                                div.addEventListener('mouseleave', hideStatusPreview);
                                div.addEventListener('mousemove', (e) => updatePreviewPosition(e));
                            } else {
                                div.addEventListener('mouseleave', hideStatusPreview);
                            }
                        };
                        updateIcon();
                        const intervalId = setInterval(() => {
                            currentIndex = (currentIndex + 1) % iconsToShow.length;
                            updateIcon();
                        }, 1000);
                        mapIconIntervals.push(intervalId);
                    }
                } else {
                    div.classList.add("memorized-tile");
                    div.textContent = tile.loc.icon;
                    div.title = tile.loc.name + " (è¨˜æ†¶)";
                }

            } else {
                div.classList.add("unexplored");
                div.textContent = "?";
                div.title = "æœªæ¢ç´¢";
            }
            
            div.addEventListener("click", () => handleTileClick(x, y));
            mapDiv.appendChild(div);
        }
    }
}
function updatePlayerSmell() {
    let totalSmell = 0;

    // 1. æ‰€æŒå“ã«ã‚ˆã‚‹è‡­ã„
    const smellyItems = [...player.inventory, ...player.equipment].filter(item => item.smell);
    if (smellyItems.length > 0) {
        totalSmell += smellyItems.reduce((sum, item) => sum + item.smell, 0);
    }

    // 2. çŠ¶æ…‹ã«ã‚ˆã‚‹è‡­ã„ï¼ˆä¾‹ï¼šå‡ºè¡€ï¼‰
    if (player.injuries.some(i => i.type === 'bleeding')) {
        totalSmell += 15;
    }

    // 3. ä½“è‡­ã«ã‚ˆã‚‹è‡­ã„
    totalSmell += Math.floor(player.bodyOdor / 5);

    currentPlayerSmell = totalSmell;
}

function advanceTurn() {
    if (isLoading) return; // â† ã“ã®è¡Œã‚’è¿½åŠ  (ãƒ­ãƒ¼ãƒ‰ä¸­ã¯ã“ã“ã§å‡¦ç†ã‚’ä¸­æ–­)
    turn++;
    previousSoundLevel = currentSoundLevel;
    previousPlayerSmell = currentPlayerSmell;
    currentSoundLevel = 0;
    
    currentTime.setHours(currentTime.getHours() + 1);
    const dayOfYear = Math.floor((turn / 24) % 360);
    const newSeason = seasons[Math.floor(dayOfYear / 90)];
    if (newSeason !== currentSeason) { currentSeason = newSeason; log(`å­£ç¯€ã¯${currentSeason}ã«ãªã£ãŸã€‚`); }
    isNight = (currentTime.getHours() >= 18 || currentTime.getHours() < 6);

    const isRaining = currentWeather.name === 'é›¨' || currentWeather.name === 'åµ';

    if (!player.isInside) {
        player.equipment.forEach(item => {
            if (item.type === 'clothing') {
                if (currentWeather.name === 'åµ') {
                    if (item.wetness !== 'soaking_wet') {
                        item.wetness = 'soaking_wet';
                        log(`åµã§${getItemDisplayName(item)}ãŒä¸€æ°—ã«ãšã¶æ¿¡ã‚Œã«ãªã£ãŸï¼`);
                    }
                } else if (currentWeather.name === 'é›¨') {
                    if (item.wetness === 'dry') {
                        item.wetness = 'wet';
                        log(`é›¨ã§${getItemDisplayName(item)}ãŒæ¿¡ã‚ŒãŸã€‚`);
                    } else if (item.wetness === 'wet') {
                        item.wetness = 'soaking_wet';
                        log(`${getItemDisplayName(item)}ãŒãšã¶æ¿¡ã‚Œã«ãªã£ãŸã€‚`);
                    }
                }
            }
        });
    }

    placedObjects = placedObjects.filter(obj => {
        if (obj.type === 'campfire' || obj.type === 'corpse') {
            if (obj.type === 'campfire' && isRaining) {
                if(Math.abs(player.x - obj.x) <= 1 && Math.abs(player.y - obj.y) <= 1) {
                    log("é›¨ã§ãŸãç«ãŒæ¶ˆãˆã¦ã—ã¾ã£ãŸ...");
                }
                return false;
            }
            obj.duration--;
            if (obj.duration <= 0) {
                 if(obj.type === 'campfire' && player.x === obj.x && player.y === obj.y) log("è¶³å…ƒã®ãŸãç«ãŒæ¶ˆãˆãŸã€‚");
                 return false;
            }
        }
        return true;
    });
    
    const torch = player.equipment.find(e => e.isTorch);
    if (torch) {
        torch.duration--;
        if (torch.duration <= 0) {
            log("æ¾æ˜ãŒç‡ƒãˆå°½ããŸã€‚");
            const torchIndex = player.equipment.findIndex(e => e.isTorch);
            if(torchIndex > -1) {
                const removedItem = player.equipment.splice(torchIndex, 1)[0];
                player.weight -= removedItem.weight || 0;
                player.volume -= removedItem.volume || 0;
            }
            updateEquippedStats();
            updateItemPanels();
        }
    }
    
    ensureKnowledgeableTrader();
    updateEntities(); 
    updateExploration(); 
    checkStats();
    updatePlayerSmell(); 
    updateBackgroundColor();
    drawMinimap();
}

// NEW: Major rewrite of entity AI
function updateEntities() {
    const activeEntities = [...entities];
    activeEntities.forEach(entity => {
        if (!entities.includes(entity) || isInteractionActive || entity.stunnedTurns > 0) {
            if (entity.stunnedTurns > 0) entity.stunnedTurns--;
            return;
        }

        // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰è¿½åŠ  â–¼â–¼â–¼
        // ã‚¾ãƒ³ãƒ“ã®ç§»å‹•ç¢ºç‡ã‚’å°å…¥
        if (entity.isZombie) {
            const moveChance = 0.8; // 80%ã®ç¢ºç‡ã§è¡Œå‹•ã™ã‚‹ (ã“ã®å€¤ã‚’å°ã•ãã™ã‚‹ã¨æ›´ã«é…ããªã‚‹)
            if (Math.random() > moveChance) {
                return; // ã“ã®ã‚¿ãƒ¼ãƒ³ã¯è¡Œå‹•ã‚’ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹
            }
        }
        // â–²â–²â–² ã“ã“ã¾ã§è¿½åŠ  â–²â–²â–²

        // 1. Vision Check (Highest Priority)
        let visualTarget = null;
//... (ä»¥é™ã®ã‚³ãƒ¼ãƒ‰ã¯å¤‰æ›´ãªã—)
        if (getDistance(entity.x, entity.y, player.x, player.y) <= getEntityVisionRange(entity)) {
            if (hasLineOfSight(entity.x, entity.y, player.x, player.y)) {
                visualTarget = player;
            }
        }
        // TODO: Add vision checks for other entities (e.g., zombie vs survivor)

        if (visualTarget) {
            entity.target = visualTarget;
            entity.investigationTarget = null; // Visual contact overrides sound investigation
            if (entity.isZombie || entity.type === 'Raider' || (entity.isAnimal && !entity.flees)) {
                entity.aiState = 'attacking';
            } else if (entity.flees) {
                entity.aiState = 'fleeing';
            } else { // Trader, Survivor
                entity.aiState = 'alert';
            }
        } else {
            entity.target = null;
            if (entity.aiState === 'attacking' || entity.aiState === 'fleeing') {
                entity.aiState = 'wandering'; // Lost sight
            }
            
            // â–¼â–¼â–¼ ä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
            // è¦–ç•Œå†…ã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã„ãªã„å ´åˆã€è‡­ã„ã§æ¢çŸ¥ã‚’è©¦ã¿ã‚‹
            if ((entity.isZombie || (entity.isAnimal && !entity.flees)) && currentPlayerSmell > 0) {
                const smellDetectionChance = currentPlayerSmell / 50; // è‡­ã„ãƒ¬ãƒ™ãƒ«ãŒé«˜ã„ã»ã©ç¢ºç‡UP
                const distanceToPlayer = getDistance(entity.x, entity.y, player.x, player.y);
                
                // è‡­ã„ã®æœ‰åŠ¹ç¯„å›²ï¼ˆä¾‹: 10ãƒã‚¹ï¼‰å†…ã§ã€ç¢ºç‡åˆ¤å®šã«æˆåŠŸã—ãŸå ´åˆ
                if (distanceToPlayer <= 10 && Math.random() < smellDetectionChance) {
                    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã„ã‚‹å ´æ‰€ã‚’èª¿æŸ»å¯¾è±¡ã«ã™ã‚‹
                    entity.investigationTarget = { x: player.x, y: player.y };
                    entity.aiState = 'investigating';
                    
                    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒè¦–ç•Œå†…ã«ã„ã‚Œã°ãƒ­ã‚°ã‚’è¡¨ç¤º
                    if (getDistance(player.x, player.y, entity.x, entity.y) <= getVisionRange()) {
                        log(`${entity.name}ãŒä½•ã‹ã®è‡­ã„ã‚’å—…ãã¤ã‘ãŸã‚ˆã†ã ...`);
                    }
                }
            }
            // â–²â–²â–² ä¿®æ­£ç®‡æ‰€ â–²â–²â–²
        }

        // 2. AI State Machine
        switch (entity.aiState) {
            case 'attacking':
                if (getDistance(entity.x, entity.y, entity.target.x, entity.target.y) <= 1) {
                    if (entity.target === player) {
                        isInteractionActive = true;
                        log(`${entity.name}ã«è¥²ã‚ã‚ŒãŸï¼`);
                        setTimeout(() => startCombat(entity), 500);
                    } else {
                        resolveEntityCombat(entity, entity.target);
                    }
                } else {
                    moveEntityTowards(entity, entity.target.x, entity.target.y);
                }
                break;

            case 'fleeing':
                moveEntityAwayFrom(entity, entity.target.x, entity.target.y);
                break;

            case 'investigating':
                if (entity.x === entity.investigationTarget.x && entity.y === entity.investigationTarget.y) {
                    entity.aiState = 'wandering';
                    entity.investigationTarget = null;
                } else {
                    moveEntityTowards(entity, entity.investigationTarget.x, entity.investigationTarget.y);
                }
                break;

            case 'wandering':
            case 'alert':
                if (Math.random() < 0.3) {
                    let newX = entity.x + randChoice([-1, 0, 1]);
                    let newY = entity.y + randChoice([-1, 0, 1]);
                    moveEntityTo(entity, newX, newY);
                }
                break;
        }

        entity.x = Math.max(0, Math.min(mapSize - 1, entity.x));
        entity.y = Math.max(0, Math.min(mapSize - 1, entity.y));
    });
}

function resolveEntityAttackOnObject(attacker, object) {
    if (object.type !== 'barricade') return;

    const damage = Math.max(1, (attacker.attack || attacker.baseAttack || 5) + (Math.floor(Math.random() * 3) - 1));
    object.health -= damage;

    const distanceToPlayer = Math.abs(attacker.x - player.x) + Math.abs(attacker.y - player.y);
    if (distanceToPlayer <= getVisionRange()) {
        log(`${attacker.name}ãŒãƒãƒªã‚±ãƒ¼ãƒ‰ã‚’æ”»æ’ƒã—ã¦ã„ã‚‹ï¼ (æ®‹ã‚Šä½“åŠ›: ${object.health.toFixed(0)})`);
    }

    if (object.health <= 0) {
        if (distanceToPlayer <= getVisionRange()) {
            log("ãƒãƒªã‚±ãƒ¼ãƒ‰ãŒç ´å£Šã•ã‚ŒãŸï¼");
        }
        const logItem = items.find(i => i.name === 'ä¸¸å¤ª');
        if (logItem) {
            const locationKey = `${object.x},${object.y}`;
            if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
            droppedItems[locationKey].push({ ...logItem });
        }
        const objectIndex = placedObjects.findIndex(o => o === object);
        if (objectIndex > -1) {
            placedObjects.splice(objectIndex, 1);
        }
    }
}


function resolveEntityCombat(attacker, defender) {
    if (defender === player) {
        if (Math.abs(attacker.x - player.x) + Math.abs(attacker.y - player.y) <= 1) {
            isInteractionActive = true;
            log(`${attacker.name}ã«è¥²ã‚ã‚ŒãŸï¼`);
            setTimeout(() => startCombat(attacker), 500);
        }
        return;
    }
    if(attacker === player) return;

    const attackerDamage = Math.max(1, (attacker.attack || attacker.baseAttack || 5) - (defender.defense || defender.baseDefense || 0) + (Math.floor(Math.random() * 5) - 2));
    defender.health -= attackerDamage;

    const distanceToPlayer = Math.abs(attacker.x - player.x) + Math.abs(attacker.y - player.y);
    if(distanceToPlayer <= getVisionRange()) {
         log(`${attacker.name}ãŒ${defender.name}ã‚’æ”»æ’ƒï¼`);
    }

    if (defender.health <= 0) {
        if(distanceToPlayer <= getVisionRange()) {
            log(`${defender.name}ã¯å€’ã•ã‚ŒãŸã€‚`);
        }
        const locationKey = `${defender.x},${defender.y}`;
        
        if (defender.isAnimal && defender.loot) {
            const corpse = { 
                x: defender.x, y: defender.y, type: 'corpse', name: `${defender.name}ã®æ­»ä½“`, graphic: 'ğŸ¦´', 
                duration: 48, isAnimalCorpse: true, unbutchered: true, potentialLoot: defender.loot
            };
            placedObjects.push(corpse);
        } else if (!defender.isZombie) {
            const lootItems = [...(defender.inventory || []), ...(defender.equipment || [])];
            const corpse = { 
                x: defender.x, y: defender.y, type: 'corpse', name: `${defender.name}ã®æ­»ä½“`, graphic: 'ğŸ¦´', 
                duration: 24, isHumanCorpse: true, unsearched: true, potentialLoot: lootItems
            };
            placedObjects.push(corpse);
        }

        const defenderIndex = entities.findIndex(e => e === defender);
        if (defenderIndex > -1) {
            entities.splice(defenderIndex, 1);
        }
    }
}


function generateWeatherAndTemperature() {
    const hour = currentTime.getHours();
    let seasonBaseTemp;
    switch(currentSeason) { case 'å¤': seasonBaseTemp = 28; break; case 'æ˜¥': seasonBaseTemp = 18; break; case 'ç§‹': seasonBaseTemp = 15; break; case 'å†¬': seasonBaseTemp = 5; break; default: seasonBaseTemp = 15; }
    const currentBiome = map[player.y][player.x].biome;
    let biomeModifier = (currentBiome === 'Forest') ? -3 : (currentBiome === 'Town') ? 2 : 0;
    const timeOfDayModifier = (hour >= 6 && hour < 18) ? 5 : -5;
    let baseTemp = seasonBaseTemp + biomeModifier + timeOfDayModifier;
    const weatherOptions = [ { name: "å¿«æ™´", icon: "â˜€ï¸", chance: 50, tempMod: 2 }, { name: "æ›‡ã‚Š", icon: "â˜ï¸", chance: 25, tempMod: 0 }, { name: "é›¨", icon: "ğŸŒ§ï¸", chance: 15, tempMod: -3 }, { name: "åµ", icon: "â›ˆï¸", chance: 10, tempMod: -5 } ];
    if (Math.random() < 0.2 || turn === 1) {
      let totalChance = weatherOptions.reduce((sum, w) => sum + w.chance, 0), randomValue = Math.random() * totalChance, accumulatedChance = 0;
      for (const weather of weatherOptions) {
        accumulatedChance += weather.chance;
        if (randomValue <= accumulatedChance) {
          if (turn > 1 && currentWeather.name !== weather.name) log(`å¤©å€™ãŒ${weather.name}ã«å¤‰ã‚ã£ãŸã€‚`);
          currentWeather = weather; break;
        }
      }
    }

    if (currentWeather.name === 'é›¨' || currentWeather.name === 'åµ') {
        stopClouds();
        startWeatherEffect(currentWeather.name);
    } else if (currentWeather.name === 'æ›‡ã‚Š') {
        stopWeatherEffect();
        startClouds();
    } else {
        stopWeatherEffect();
        stopClouds();
    }

    baseTemp += currentWeather.tempMod;
    currentTemperature = baseTemp + (Math.random() - 0.5) * 4;
}

function checkStats() {
    let totalTurnDamage = 0;
    if (player.feverImmunityTurns > 0) {
        player.feverImmunityTurns--;
    }

    // --- Injury processing ---
    const newInjuries = [];
    player.injuries.forEach(injury => {
        let stillInjured = true;
        switch (injury.type) {
            case 'bleeding':
                totalTurnDamage += 3;
                log("å‡ºè¡€ã«ã‚ˆã‚Šä½“åŠ›ãŒæ¶ˆè€—ã—ã¦ã„ã‚‹...", false);
                break;
            case 'bruise':
                totalTurnDamage += 1;
                injury.duration--;
                if (injury.duration <= 0) {
                    log("æ‰“æ’²ãŒæ²»ã£ãŸã€‚", true);
                    stillInjured = false;
                }
                break;
            case 'fracture':
                if (injury.splinted) {
                    totalTurnDamage += 2;
                } else {
                    totalTurnDamage += 5;
                }
                injury.duration--;
                if (injury.duration <= 0) {
                    log("éª¨æŠ˜ãŒã‚ˆã†ã‚„ãæ²»ã£ãŸã€‚", true);
                    stillInjured = false;
                }
                break;
        }
        if (stillInjured) {
            newInjuries.push(injury);
        }
    });
    player.injuries = newInjuries;

    // --- Sickness processing ---
    if (player.bodyTemp < 35.5) {
        player.hypothermiaTurns++;
    } else {
        player.hypothermiaTurns = 0;
    }
    if (player.hypothermiaTurns > 4 && !player.sicknesses.some(s => s.type === 'fever') && player.feverImmunityTurns <= 0) {
        if (Math.random() < 0.6) {
            log("æ‚ªå¯’ãŒã™ã‚‹...ä½“ãŒç†±ã£ã½ããªã£ã¦ããŸã€‚", true);
            player.sicknesses.push({ type: 'fever', duration: 48 });
            player.hypothermiaTurns = 0;
        }
    }
    const newSicknesses = [];
    player.sicknesses.forEach(sickness => {
        let stillSick = true;
        switch (sickness.type) {
            case 'food_poisoning':
                totalTurnDamage += 2;
                log("é£Ÿä¸­æ¯’ã§æ°—åˆ†ãŒæ‚ªã„...", false);
                break;
            case 'diarrhea':
                totalTurnDamage += 2;
                log("ä¸‹ç—¢ã§ä½“åŠ›ã‚’æ¶ˆè€—ã—ã¦ã„ã‚‹...", false);
                break;
            case 'fever':
                totalTurnDamage += 4;
                log("é«˜ç†±ã§æ„è­˜ãŒæœ¦æœ§ã¨ã™ã‚‹...", false);
                break;
        }

        if (sickness.medicated_duration) {
            sickness.medicated_duration--;
            if (sickness.medicated_duration <= 0) {
                log(`${getSicknessName(sickness.type)}ãŒè–¬ã§æ²»ã£ãŸã€‚`, true);
                if (sickness.type === 'fever') {
                    player.feverImmunityTurns = 48; // 2æ—¥é–“ (48ã‚¿ãƒ¼ãƒ³) ã®ç™ºç†±è€æ€§
                    log("ã—ã°ã‚‰ãã¯ç†±ã‚’å‡ºã•ãªã„ã ã‚ã†ã€‚");
                }
                stillSick = false;
            }
        } else {
            sickness.duration--;
            if (sickness.duration <= 0) { // Fever should not heal randomly
                 log(`${getSicknessName(sickness.type)}ãŒè‡ªç„¶ã«æ²»ã£ãŸã€‚`, true);
                 if (sickness.type === 'fever') {
                    player.feverImmunityTurns = 48; // 2æ—¥é–“ (48ã‚¿ãƒ¼ãƒ³) ã®ç™ºç†±è€æ€§
                    log("ã—ã°ã‚‰ãã¯ç†±ã‚’å‡ºã•ãªã„ã ã‚ã†ã€‚");
                 }
                 stillSick = false;
            }
        }

        if (stillSick) {
            newSicknesses.push(sickness);
        }
    });
    player.sicknesses = newSicknesses;
    
    // --- General Stats Processing ---
    let hungerLoss = 2, thirstLoss = 3, moraleLoss = 1, sleepLoss = 5;
    
    // â˜…â˜…â˜… ç§»å‹•ãƒ¢ãƒ¼ãƒ‰ã«ä¾å­˜ã™ã‚‹ä¸è¦ãªã‚³ã‚¹ãƒˆè¨ˆç®—ã‚’å‰Šé™¤ â˜…â˜…â˜…

    const campfireNearby = placedObjects.find(c => c.type === 'campfire' && Math.abs(c.x - player.x) <=1 && Math.abs(c.y - player.y) <= 1);
    const insideBonus = player.isInside ? 5 : 0;
    const effectiveTemperature = currentTemperature + (campfireNearby ? 15 : 0) + insideBonus;
    const totalInsulation = player.insulation;
    const insulationFactor = Math.max(0.1, 1 - (totalInsulation / 10));
    const tempDiff = effectiveTemperature - 25;
    player.bodyTemp += (tempDiff * 0.05) * insulationFactor;
    player.bodyTemp -= (player.bodyTemp - 36.5) * 0.08;

    // --- Wetness Penalty on Body Temp ---
    let wetItems = 0;
    let soakingWetItems = 0;
    player.equipment.forEach(item => {
        if (item.type === 'clothing') {
            if (item.wetness === 'wet') wetItems++;
            else if (item.wetness === 'soaking_wet') soakingWetItems++;
        }
    });
    if (wetItems > 0 || soakingWetItems > 0) {
        const wetnessPenalty = (wetItems * 0.1) + (soakingWetItems * 0.25);
        player.bodyTemp -= wetnessPenalty;
        if (soakingWetItems > 0) log("ãšã¶æ¿¡ã‚Œã®æœãŒä½“æ¸©ã‚’å¥ªã£ã¦ã„ã...", false);
        else if (wetItems > 0) log("æ¿¡ã‚ŒãŸæœã§ä½“ãŒå†·ãˆã‚‹...", false);
    }
    
    if (player.bodyTemp > 38.5 || player.bodyTemp < 34.5) { moraleLoss += 2; } 
    else if (player.bodyTemp > 37.5) { moraleLoss += 1; totalTurnDamage += 0.5; } 
    else if (player.bodyTemp < 35.5) { hungerLoss += 1; moraleLoss += 1; totalTurnDamage += 0.5; }
    if (currentWeather.name === "é›¨") { moraleLoss += 1; if (currentTemperature < 20 && !campfireNearby) player.bodyTemp -= 0.2 * insulationFactor; } 
    else if (currentWeather.name === "åµ") { moraleLoss += 3; totalTurnDamage += 1; if(!campfireNearby) player.bodyTemp -= 0.4 * insulationFactor; } 
    else if (currentWeather.name === "å¿«æ™´" && !isNight) { moraleLoss = Math.max(0, moraleLoss - 1); player.morale += 0.5; }
    player.hunger -= hungerLoss; player.thirst -= thirstLoss; player.sleep -= sleepLoss; player.morale -= moraleLoss;
    if (player.sleep <= 0) player.morale -= 2;
    if (player.morale <= 0) totalTurnDamage += 1;
    if (player.hunger <= 0) totalTurnDamage += 1.5;
    if (player.thirst <= 0) totalTurnDamage += 2;
    
    if(player.hunger >= maxStats.hunger) { player.health += 0.5; player.morale += 1; }
    if(player.thirst >= maxStats.thirst) { player.health += 0.5; player.morale += 1; }

    if (totalTurnDamage > 0) {
        player.health -= totalTurnDamage;
    }
    
    let bodyOdorIncrease = 1.5;
    if (player.bodyTemp > 37.5) bodyOdorIncrease += 0.5;
    if (player.equipment.some(e => e.type === 'clothing' && e.wetness === 'soaking_wet')) {
        bodyOdorIncrease += 0.5;
    }
    player.bodyOdor += bodyOdorIncrease;
    
    player.hunger = Math.max(0, player.hunger); player.thirst = Math.max(0, player.thirst); player.sleep = Math.max(0, player.sleep);
    player.morale = Math.max(0, Math.min(maxStats.morale, player.morale)); player.health = Math.min(maxStats.health, player.health);
    player.bodyOdor = Math.max(0, Math.min(maxStats.bodyOdor, player.bodyOdor));
    [...player.inventory, ...player.equipment].forEach(item => {
      if (item.type === "consumable" && item.freshness !== undefined) item.freshness = Math.max(0, item.freshness - 2);
      if ((item.type === "equipment" || item.type === "clothing") && item.durability !== undefined && (currentWeather.name === "é›¨" || currentWeather.name === "åµ")) item.durability = Math.max(0, item.durability - 0.5);
      if (item.type === 'container' && item.content && item.content.type === 'clean') {
          item.content.freshness = Math.max(0, item.content.freshness - 1);
          if (item.content.freshness === 0) { log(`${getItemDisplayName(item)}ã®ä¸­ã®æ°´ãŒæ±šã‚Œã¦ã—ã¾ã£ãŸã€‚`); item.content.type = 'dirty'; }
      }
    });
    updateEquippedStats(); updateItemPanels(); updateItemDetailPanel(); generateWeatherAndTemperature();
}

function updateItemDetailPanel() {
    if (currentItemDetail) {
        let updatedItem, itemIndex = currentItemDetail.index, itemSource = currentItemDetail.source;
        if (itemSource === 'inventory') updatedItem = player.inventory[itemIndex];
        else if (itemSource === 'equipment') updatedItem = player.equipment[itemIndex];
        else if (itemSource === 'dropped') updatedItem = (droppedItems[`${player.x},${player.y}`] || [])[itemIndex];
        else if (itemSource === 'placed') updatedItem = placedObjects.find(o => o.x === currentItemDetail.coords.x && o.y === currentItemDetail.coords.y);

        if (updatedItem) {
            if (itemSource === 'placed') showPlacedObjectDetail(updatedItem);
            else showItemDetail(updatedItem, itemIndex, itemSource);
        } else hideItemDetail();
    }
}

function generateNPC() {
    const template = JSON.parse(JSON.stringify(randChoice(npcTemplates)));
    const npc = { ...template, inventory: [], equipment: [], traits: [] }; // traitsãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¿½åŠ 
    const invItemCount = Math.floor(Math.random() * 3) + 1;
    for(let i=0; i<invItemCount; i++) {
        const itemTemplate = randChoice(items.filter(item => (!item.tags || !item.tags.includes(NO_LOOT_TAG))));
        let newItem = JSON.parse(JSON.stringify(itemTemplate));
        if (newItem.type === "consumable") newItem.freshness = Math.max(20, Math.floor(Math.random() * 80) + 20);
        else if (newItem.type === "equipment" || newItem.type === "clothing") newItem.durability = Math.max(20, Math.floor(Math.random() * 80) + 20);
        else if (newItem.type === 'container') {
             const waterType = randChoice(['clean', 'dirty', null]);
             if (waterType === 'clean') newItem.content = { type: 'clean', freshness: Math.floor(Math.random() * 50) + 50 };
             else if (waterType === 'dirty') newItem.content = { type: 'dirty' };
        }
        npc.inventory.push(newItem);
    }
    const equipItemCount = Math.floor(Math.random() * 3);
     for(let i=0; i<equipItemCount; i++) {
        const equipableItems = items.filter(item => (item.type === "equipment" || item.type === "clothing") && (!item.tags || !item.tags.includes(NO_LOOT_TAG)));
        if(equipableItems.length === 0) continue;
        const itemTemplate = randChoice(equipableItems);
        const newItem = JSON.parse(JSON.stringify(itemTemplate));
        newItem.durability = Math.max(20, Math.floor(Math.random() * 80) + 20);
        if (!npc.equipment.some(e => e.slot === newItem.slot)) npc.equipment.push(newItem);
    }

    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
    // 20%ã®ç¢ºç‡ã§è¦–ç•Œã«é–¢ã™ã‚‹ç‰¹æ€§ã‚’ä»˜ä¸
    if (Math.random() < 0.2) {
        if (Math.random() < 0.5) {
            npc.traits.push("ç›®ãŒã„ã„");
            npc.visionRange += 1; // åŸºæœ¬è¦–ç•Œ3+1 = 4
        } else {
            npc.traits.push("ç›®ãŒæ‚ªã„");
            npc.visionRange -= 1; // åŸºæœ¬è¦–ç•Œ3-1 = 2
        }
    }
    // â–²â–²â–² ã“ã“ã¾ã§ â–²â–²â–²

    npc.attack = npc.baseAttack; npc.defense = npc.baseDefense;
    npc.equipment.forEach(item => {
        const durabilityFactor = item.durability / 100;
        npc.attack += (item.attack || 0) * durabilityFactor;
        npc.defense += (item.defense || 0) * durabilityFactor;
    });
    npc.attack = Math.floor(npc.attack); npc.defense = Math.floor(npc.defense);
    return npc;
}

function exploreTile() {
    if (isInteractionActive || player.health <= 0) return;
    let tile = map[player.y][player.x];
    if(tile.loc.isShop){ startTraderShopEncounter(); return; }
    const entityOnTile = entities.find(e => e.x === player.x && e.y === player.y);
    if(entityOnTile) {
        if(entityOnTile.isZombie || entityOnTile.isAnimal) {
             log(`${entityOnTile.name}ã«é­é‡ã—ãŸï¼`, false); playSound('zombie');
             startCombat(entityOnTile); updateCurrentLocationPanel(true, entityOnTile); return;
        } else { currentNPC = entityOnTile; startNPCEncounter(); return; }
    }
    searchCurrentLocation();
}

function searchCurrentLocation() {
    let tile = map[player.y][player.x];

    if (tile.searched) {
        log(`ã“ã“ã¯${tile.loc.name}ã ã€‚æ—¢ã«æ¢ç´¢æ¸ˆã¿ã®ã‚ˆã†ã ã€‚`);
        updateCurrentLocationPanel(false);
        return;
    }

    log(`ã“ã“ã¯${tile.loc.name}ã ã€‚`);
    updateCurrentLocationPanel(false);
    let itemsFound = [];
    const locationKey = `${player.x},${player.y}`;
    if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
    const itemReference = {
        stone: items.find(i => i.name === 'çŸ³'), branch: items.find(i => i.name === 'æ'),
        water: items.find(i => i.name === 'æ±šã‚ŒãŸæ°´'), leaf: items.find(i => i.name === 'å¤§ããªè‘‰'),
        emptyCan: items.find(i => i.name === 'ç©ºãç¼¶'),
        plasticBottle: items.find(i => i.name === 'ãƒšãƒƒãƒˆãƒœãƒˆãƒ«'),
        lighter: items.find(i => i.name === 'ãƒ©ã‚¤ã‚¿ãƒ¼'),
        flint: items.find(i => i.name === 'ç«æ‰“çŸ³'),
        mushroom: items.find(i => i.name === 'ã‚­ãƒã‚³'),
        corn: items.find(i => i.name === 'ãƒˆã‚¦ãƒ¢ãƒ­ã‚³ã‚·'),
        potato: items.find(i => i.name === 'ã‚¸ãƒ£ã‚¬ã‚¤ãƒ¢'),
        carrot: items.find(i => i.name === 'ãƒ‹ãƒ³ã‚¸ãƒ³'),
    };

    if (tile.loc.name === 'å²©') {
        if (Math.random() < 0.25) itemsFound.push({ ...itemReference.flint });
        if (Math.random() < 0.8) itemsFound.push({ ...itemReference.stone });
    } else if (tile.biome === 'Forest') {
        if (Math.random() < 0.7) itemsFound.push({ ...itemReference.leaf });
        if (Math.random() < 0.6) itemsFound.push({ ...itemReference.branch });
        if (Math.random() < 0.4) itemsFound.push({ ...itemReference.stone });
        if (Math.random() < 0.2) itemsFound.push({ ...itemReference.mushroom });
    } else if (tile.biome === 'Plains') {
        if (Math.random() < 0.4) itemsFound.push({ ...itemReference.leaf });
        if (Math.random() < 0.3) itemsFound.push({ ...itemReference.branch });
        if (Math.random() < 0.2) itemsFound.push({ ...itemReference.stone });
    } else if (tile.loc.name === 'ç•‘') {
        if (Math.random() < 0.3) itemsFound.push({ ...itemReference.corn });
        if (Math.random() < 0.3) itemsFound.push({ ...itemReference.potato });
        if (Math.random() < 0.3) itemsFound.push({ ...itemReference.carrot });
    }
    
    if (tile.loc.name === 'æ± ' && !droppedItems[locationKey].some(item => item.type === 'water_source')) {
         itemsFound.push({ ...itemReference.water });
    }
    
    if (tile.biome === 'Town' || tile.loc.name === 'å°å±‹') {
        if (Math.random() < 0.05) { // 5% chance for a medicine
            const medicineTypes = items.filter(i => ['æ•´è…¸å‰¤', 'ä¸‹ç—¢æ­¢ã‚', 'è§£ç†±å‰¤'].includes(i.name));
            itemsFound.push({ ...randChoice(medicineTypes) });
        }
    }
    
    if (Math.random() * 100 < tile.loc.loot) {
        let lootableItems = items.filter(i => (!i.tags || !i.tags.includes(NO_LOOT_TAG)) && i.type !== 'ammo' && !['æ•´è…¸å‰¤', 'ä¸‹ç—¢æ­¢ã‚', 'è§£ç†±å‰¤'].includes(i.name));
        
        if (lootableItems.length > 0) {
            let newItem = {...randChoice(lootableItems)};
            if (newItem.type === 'container') {
                const waterType = randChoice(['clean', 'dirty', null]);
                if (waterType === 'clean') newItem.content = { type: 'clean', freshness: Math.floor(Math.random() * 50) + 50 };
                else if (waterType === 'dirty') newItem.content = { type: 'dirty' };
                else newItem.content = null;
            } else if (newItem.type === "consumable" && newItem.freshness !== undefined) {
                newItem.freshness = Math.max(10, Math.floor(Math.random() * 90) + 10);
                if(newItem.isSealed && Math.random() < 0.05) newItem.isSpoiled = true;
            } else if ((newItem.type === "equipment" || newItem.type === "clothing" || newItem.type === "tool") && newItem.durability !== undefined) {
                newItem.durability = Math.max(10, Math.floor(Math.random() * 90) + 10);
            }
            itemsFound.push(newItem);
        }
    }
    
    if (tile.loc.name === 'å°å±‹' || tile.biome === 'Town') {
        if (Math.random() < 0.08) { 
            const gunOrAmmo = randChoice(['gun', 'ammo']);
            if (gunOrAmmo === 'gun') {
                const gunTypes = items.filter(i => i.ammoType && i.type === 'equipment');
                const newGun = {...randChoice(gunTypes)};
                newGun.loadedAmmo = Math.floor(Math.random() * 3) + 1;
                newGun.durability = Math.max(20, Math.floor(Math.random() * 80) + 20);
                itemsFound.push(newGun);
                log("å¤ã„éŠƒã‚’è¦‹ã¤ã‘ãŸï¼", false);
            } else {
                const ammoTypes = items.filter(i => i.type === 'ammo');
                const newAmmo = {...randChoice(ammoTypes)};
                itemsFound.push(newAmmo);
                log("å¼¾è–¬ç®±ã‚’è¦‹ã¤ã‘ãŸã€‚", false);
            }
        }
    }

    if (itemsFound.length > 0) {
        itemsFound.forEach(item => droppedItems[locationKey].push(item));
        updateCurrentLocationPanel(false);
    } else {
        log("ç‰¹ã«è¦‹ã¤ã‹ã‚‹ã‚‚ã®ã¯ãªã‹ã£ãŸã€‚", false);
    }
    createSound(player.x, player.y, 3); // Sound of searching
    tile.searched = true;
}

function showConditionTooltip(event, conditionType) {
    const preview = document.getElementById("statusPreview");
    let title = '', description = '';

    switch (conditionType) {
        case 'critical_health':
            title = 'é‡å‚·';
            description = 'ä½“åŠ›ãŒè‡´å‘½çš„ã«ä½ä¸‹ã—ã¦ã„ã‚‹çŠ¶æ…‹ã€‚åŒ…å¸¯ãªã©ã§å›å¾©ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚';
            break;
        case 'hypothermia':
            title = 'ä½ä½“æ¸©';
            description = 'ä½“æ¸©ãŒä½ä¸‹ã—ã¦ã„ã‚‹ã€‚ç«ã®ãã°ã§æš–ã¾ã‚‹ã‹ã€æš–ã‹ã„è¡£æœã‚’ç€ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚æ”¾ç½®ã™ã‚‹ã¨ç™ºç†±ã®åŸå› ã«ãªã‚‹ã€‚';
            break;
        case 'severe_hypothermia':
            title = 'æ·±åˆ»ãªä½ä½“æ¸©';
            description = 'ä½“æ¸©ãŒå±é™ºãªãƒ¬ãƒ™ãƒ«ã¾ã§ä½ä¸‹ã—ã¦ã„ã‚‹ã€‚ç·Šæ€¥ã«æš–ã‚’å–ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚';
            break;
        case 'fever':
            title = 'ç™ºç†±';
            description = 'ç—…æ°—ã‚„ä½ä½“æ¸©ã«ã‚ˆã‚Šç™ºç†±ã—ã¦ã„ã‚‹ã€‚è§£ç†±å‰¤ã‚’ä½¿ã†ã¨æ²»ã‚‹ã€‚';
            break;
        case 'starving':
            title = 'é¤“æ­»å¯¸å‰';
            description = 'æ·±åˆ»ãªé£¢é¤“çŠ¶æ…‹ã€‚ã™ãã«ä½•ã‹é£Ÿã¹ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚';
            break;
        case 'dehydrated':
            title = 'è„±æ°´ç—‡çŠ¶';
            description = 'æ·±åˆ»ãªæ°´åˆ†ä¸è¶³ã€‚ã™ãã«æ°´ã‚’é£²ã‚€å¿…è¦ãŒã‚ã‚‹ã€‚';
            break;
        case 'bleeding':
            title = 'å‡ºè¡€';
            description = 'æ¯ã‚¿ãƒ¼ãƒ³ä½“åŠ›ãŒæ¸›å°‘ã—ç¶šã‘ã‚‹ã€‚åŒ…å¸¯ã‚’ä½¿ã†ã¨æ­¢è¡€ã§ãã‚‹ã€‚';
            break;
        case 'bruise':
            title = 'æ‰“æ’²';
            description = 'è»½åº¦ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ç¶šã‘ã‚‹ã€‚æ™‚é–“çµŒéã§è‡ªç„¶ã«æ²»ã‚‹ã€‚';
            break;
        case 'fracture':
            title = 'éª¨æŠ˜';
            description = 'æ·±åˆ»ãªãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ç¶šã‘ã‚‹ã€‚æ·»ãˆæœ¨ã§å›ºå®šã™ã‚‹ã¨ãƒ€ãƒ¡ãƒ¼ã‚¸ãŒè»½æ¸›ã•ã‚Œã€æ²»ç™’ãŒå§‹ã¾ã‚‹ã€‚';
            break;
        case 'splinted_fracture':
            title = 'éª¨æŠ˜(æ·»ãˆæœ¨å›ºå®š)';
            description = 'å›ºå®šæ¸ˆã¿ã€‚æ™‚é–“çµŒéã§æ²»ã‚‹ã€‚';
            break;
        case 'food_poisoning':
            title = 'é£Ÿä¸­æ¯’';
            description = 'è…ã£ãŸã‚‚ã®ã‚’é£Ÿã¹ãŸãŸã‚ä½“èª¿ãŒæ‚ªã„ã€‚æ•´è…¸å‰¤ã‚’æœç”¨ã™ã‚‹ã¨æ²»ã‚ŠãŒæ—©ã¾ã‚‹ã€‚';
            break;
        case 'diarrhea':
            title = 'ä¸‹ç—¢';
            description = 'æ±šã‚ŒãŸæ°´ã‚’é£²ã‚“ã ãŸã‚ä½“èª¿ãŒæ‚ªã„ã€‚ä¸‹ç—¢æ­¢ã‚ã‚’æœç”¨ã™ã‚‹ã¨æ²»ã‚ŠãŒæ—©ã¾ã‚‹ã€‚';
            break;
        default:
            return; 
    }

    preview.innerHTML = `<strong>${title}</strong><div style="margin-top: 5px;">${description}</div>`;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}

function updatePhysicalCondition() {
    const conditionDiv = document.getElementById("physicalCondition");
    let healthPercent = (player.health / maxStats.health) * 100, hungerPercent = (player.hunger / maxStats.hunger) * 100, thirstPercent = (player.thirst / maxStats.thirst) * 100, sleepPercent = (player.sleep / maxStats.sleep) * 100, moralePercent = (player.morale / maxStats.morale) * 100;
    let bodyTemp = player.bodyTemp, messageElements = [], messages = [], conditionLevel = "normal";

    const addCondition = (text, type, level) => {
        messageElements.push(`<span onmouseenter="showConditionTooltip(event, '${type}')" onmouseleave="hideStatusPreview()">${text}</span>`);
        if (level === 'critical') {
            conditionLevel = 'critical';
        } else if (level === 'warning' && conditionLevel === 'normal') {
            conditionLevel = 'warning';
        }
    };

    if (healthPercent < 20) { addCondition("é‡å‚·", 'critical_health', 'critical'); }
    if (bodyTemp < 34.5) { addCondition("æ·±åˆ»ãªä½ä½“æ¸©", 'severe_hypothermia', 'critical'); } else if (bodyTemp < 35.5) { addCondition("ä½ä½“æ¸©", 'hypothermia', 'warning'); }
    if (hungerPercent < 20) { addCondition("é¤“æ­»å¯¸å‰", 'starving', 'critical'); } else if (hungerPercent < 50) { messages.push("ç©ºè…¹"); if (conditionLevel === "normal") conditionLevel = "warning"; }
    if (thirstPercent < 20) { addCondition("è„±æ°´ç—‡çŠ¶", 'dehydrated', 'critical'); } else if (thirstPercent < 50) { messages.push("å–‰ã®æ¸‡ã"); if (conditionLevel === "normal") conditionLevel = "warning"; }
    if (sleepPercent < 20) { messages.push("æ¥µåº¦ã®çœ æ°—"); if (conditionLevel !== "critical") conditionLevel = "critical"; } else if (sleepPercent < 50) { messages.push("çœ æ°—"); if (conditionLevel === "normal") conditionLevel = "warning"; }
    if (moralePercent < 20) { messages.push("çµ¶æœ›"); if (conditionLevel !== "critical") conditionLevel = "critical"; }
    
    if (bodyTemp > 38.5) { messages.push("é«˜ç†±"); conditionLevel = "critical"; } else if (bodyTemp > 37.5) { messages.push("å¾®ç†±"); if (conditionLevel === "normal") conditionLevel = "warning"; }

    player.injuries.forEach(injury => {
        if (injury.type === 'bleeding') addCondition("å‡ºè¡€", 'bleeding', 'critical');
        else if (injury.type === 'bruise') addCondition("æ‰“æ’²", 'bruise', 'warning');
        else if (injury.type === 'fracture') {
            const text = injury.splinted ? "éª¨æŠ˜(æ·»ãˆæœ¨å›ºå®š)" : "éª¨æŠ˜";
            const type = injury.splinted ? "splinted_fracture" : "fracture";
            addCondition(text, type, 'critical');
        }
    });

    player.sicknesses.forEach(sickness => {
        const level = sickness.type === 'fever' ? 'critical' : 'warning';
        addCondition(getSicknessName(sickness.type), sickness.type, level);
    });

    const finalMessages = messageElements.concat(messages);

    if (finalMessages.length === 0) {
        conditionDiv.innerHTML = `<strong>èº«ä½“ã®çŠ¶æ…‹ï¼š</strong><span class="condition-normal">æ­£å¸¸</span>`;
    } else {
        conditionDiv.innerHTML = `<strong>èº«ä½“ã®çŠ¶æ…‹ï¼š</strong><span class="condition-${conditionLevel}">${finalMessages.join("ã€ ")}</span>`;
    }
}

function logStatChanges(before, after) {
    const statsToCheck = { health: "ä½“åŠ›", hunger: "ç©ºè…¹", thirst: "æ¸‡ã", morale: "æ°—åŠ›", sleep: "ç¡çœ ", bodyTemp: "ä½“æ¸©" };
    for (const stat in statsToCheck) {
        const beforeVal = Math.round(before[stat]);
        const afterVal = Math.round(after[stat]);
        const delta = afterVal - beforeVal;
        if (delta !== 0) {
            const changeType = delta > 0 ? "å¢—ãˆãŸ" : "æ¸›ã£ãŸ";
            log(`${statsToCheck[stat]}ãŒ${Math.abs(delta)}${changeType}ã€‚`);
        }
    }
}

function updateStatus() {
  function updateBar(idBar, idVal, val, maxVal, prevVal) {
    const displayVal = Math.max(0, val);
    const p = Math.min(1, displayVal / maxVal);
    document.getElementById(idBar).style.width = (p * 100) + "%";
    let deltaText = "";
    if (prevVal && prevVal[idVal.replace('Val','')] !== undefined) {
        const delta = Math.round(val - prevVal[idVal.replace('Val','')]);
        if (delta !== 0) deltaText = ` <span style="color:${delta > 0 ? 'limegreen' : 'indianred'}; font-weight:bold;">(${delta > 0 ? '+' : ''}${delta})</span>`;
    }
    document.getElementById(idVal).innerHTML = `${displayVal.toFixed(0)} / ${maxVal.toFixed(0)}${deltaText}`;
  }
  function updateValue(idVal, val, prevVal, suffix = '', precision = 0) {
    const valElem = document.getElementById(idVal);
    let deltaText = "";
    if (prevVal && prevVal[idVal.replace('Val','')] !== undefined) {
        const delta = parseFloat(val.toFixed(precision + 1)) - parseFloat(prevVal[idVal.replace('Val','')].toFixed(precision + 1));
        if (Math.abs(delta) > (precision === 0 ? 0.5 : 0)) deltaText = ` <span style="color:${delta > 0 ? 'limegreen' : 'indianred'}; font-weight:bold;">(${delta > 0 ? '+' : ''}${delta.toFixed(precision)})</span>`;
    }
    valElem.innerHTML = `${val.toFixed(precision)}${suffix}${deltaText}`;
  }
  updateBar("hungerBar", "hungerVal", player.hunger, maxStats.hunger, playerStatsBeforeAction);
  updateBar("thirstBar", "thirstVal", player.thirst, maxStats.thirst, playerStatsBeforeAction);
  updateBar("healthBar", "healthVal", player.health, maxStats.health, playerStatsBeforeAction);
  updateBar("moraleBar", "moraleVal", player.morale, maxStats.morale, playerStatsBeforeAction);
  updateBar("sleepBar", "sleepVal", player.sleep, maxStats.sleep, playerStatsBeforeAction);
  const sleepBtn = document.getElementById("sleepNowBtn");
  sleepBtn.style.display = (player.sleep >= maxStats.sleep || isInteractionActive) ? "none" : "block";
  const bodyTempBar = document.getElementById("bodyTempBar");
  const minTemp = 34.0, maxTemp = 41.0, normalRangeMin = 36.0, normalRangeMax = 37.5;
  const pTemp = (player.bodyTemp - minTemp) / (maxTemp - minTemp);
  bodyTempBar.style.width = (pTemp * 100) + "%";
  updateValue("bodyTempVal", player.bodyTemp, playerStatsBeforeAction, 'Â°C', 1);
  if (player.bodyTemp < normalRangeMin || player.bodyTemp > normalRangeMax) bodyTempBar.style.background = (player.bodyTemp < 35.0 || player.bodyTemp > 38.5) ? '#e74c3c' : '#f1c40f';
  else bodyTempBar.style.background = '#27ae60';
  
  let pWeight = Math.min(1, player.weight / player.maxWeight);
  document.getElementById("weightBar").style.width = (pWeight * 100) + "%";
  document.getElementById("weightBar").style.background = player.weight > player.maxWeight ? '#e74c3c' : '#7f8c8d';
  updateValue("weightVal", player.weight, playerStatsBeforeAction, ` / ${player.maxWeight.toFixed(1)}`, 1);
  
  let pVolume = Math.min(1, player.volume / player.maxVolume);
  document.getElementById("volumeBar").style.width = (pVolume * 100) + "%";
  document.getElementById("volumeBar").style.background = player.volume > player.maxVolume ? '#e74c3c' : '#9b59b6';
  updateValue("volumeVal", player.volume, playerStatsBeforeAction, ` / ${player.maxVolume.toFixed(1)}`, 1);

  document.getElementById("attackBar").style.width = Math.min(1, player.attack / 50) * 100 + "%";
  updateValue("attackVal", player.attack, playerStatsBeforeAction, '', 0);
  document.getElementById("defenseBar").style.width = Math.min(1, player.defense / 50) * 100 + "%";
  updateValue("defenseVal", player.defense, playerStatsBeforeAction, '', 0);
  
  updateBar("bodyOdorBar", "bodyOdorVal", player.bodyOdor, maxStats.bodyOdor, playerStatsBeforeAction);
  const bodyOdorBar = document.getElementById("bodyOdorBar");
  if (player.bodyOdor > 70) bodyOdorBar.style.background = '#e74c3c';
  else if (player.bodyOdor > 40) bodyOdorBar.style.background = '#f1c40f';
  else bodyOdorBar.style.background = '#8B4513';
  
  updatePhysicalCondition();
}


function sleepForOneHour() {
    if(isInteractionActive) return;
    const sleepingBag = placedObjects.find(o => o.type === 'sleeping_bag' && o.x === player.x && o.y === player.y);
    const sleepQuality = sleepingBag ? 2.0 : 0.5;
    const sleepAmount = 25 * sleepQuality;
    if (player.sleep >= maxStats.sleep) { log("ã“ã‚Œä»¥ä¸Šçœ ã‚‹å¿…è¦ã¯ãªã„ã€‚"); return; }
    snapshotStats();
    log(sleepingBag ? "å¯è¢‹ã«å…¥ã‚Šã€1æ™‚é–“ãã£ã™ã‚Šçœ ã£ãŸã€‚" : "ãã®å ´ã§1æ™‚é–“ä»®çœ ã‚’ã¨ã£ãŸã€‚");
    player.sleep = Math.min(maxStats.sleep, player.sleep + sleepAmount);
    player.hunger -= 1; player.thirst -= 1;
    logStatChanges(playerStatsBeforeAction, player);
    advanceTurn();
    drawMap(); updateStatus(); updateItemPanels(); updateCharacterBody(); updateCharacterInfo(); checkGameOver(); updateTurnInfo();
}


// ã€1. ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã®è¿½åŠ ã€‘
// placedObjects ã®å®šç¾©ã®ä¸‹ã‚ãŸã‚Šã«ã€ä»¥ä¸‹ã®1è¡Œã‚’è¿½åŠ ã—ã¾ã™ã€‚
let previousVisionLevel = 0; // â˜…è¿½åŠ : å‰ã®ã‚¿ãƒ¼ãƒ³ã®è¦–ç•Œãƒ¬ãƒ™ãƒ«ã‚’è¨˜éŒ²
let lastSoundCalculation = { base: 0, shoes: {name: 'ç´ è¶³', modifier: 1.2}, weather: {name: 'å¿«æ™´', modifier: 1.0}, total: 0, source: 'ãªã—' };
// ã€2. æ–°ã—ã„é–¢æ•°ã®è¿½åŠ ã€‘
// updateTurnInfo é–¢æ•°ã®ã™ãä¸Šã«ã€ä»¥ä¸‹ã®ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—è¡¨ç¤ºç”¨é–¢æ•°ã‚’æ–°ãŸã«è¿½åŠ ã—ã¾ã™ã€‚

/**
 * è¦–ç•Œãƒ¬ãƒ™ãƒ«ã«ã‚«ãƒ¼ã‚½ãƒ«ã‚’åˆã‚ã›ãŸéš›ã«ã€ãã®å†…è¨³ã‚’ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã§è¡¨ç¤ºã™ã‚‹é–¢æ•°
 * @param {MouseEvent} event - ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
 */
function showVisionTooltip(event) {
    const preview = document.getElementById("statusPreview");
    let contentHtml = `<strong>è¦–ç•Œãƒ¬ãƒ™ãƒ«ã®å†…è¨³</strong><br/>`;
    const hour = currentTime.getHours();
    
    // è¨ˆç®—éç¨‹ã‚’è¿½è·¡ã™ã‚‹ãŸã‚ã®å¤‰æ•°
    let visionCalc = player.vision;
    let calculationStepsHtml = "";

    // 1. åŸºæœ¬è¦–ç•Œ
    calculationStepsHtml += `<div>åŸºæœ¬è¦–ç•Œ: ${player.vision}</div>`;

    // 2. ç‰¹æ€§ã‚„è£…å‚™ã«ã‚ˆã‚‹åŠ ç®—ãƒ»æ¸›ç®—
    if (character.traits.includes("ç›®ãŒæ‚ªã„") && player.equipment.some(e => e.name === 'ãƒ¡ã‚¬ãƒ')) {
        calculationStepsHtml += `<div><span class="stat-positive">ãƒ¡ã‚¬ãƒ (ç›®ãŒæ‚ªã„è£œæ­£)</span>: +1</div>`;
        visionCalc++;
    }
    
    // 3. æ™‚é–“å¸¯ã«ã‚ˆã‚‹å½±éŸ¿
    const hasTorch = player.equipment.some(e => e.isTorch);
    if (isNight) {
        let nightVision = 0;
        let nightReason = "å¤œ";
        if (hasTorch) {
            nightVision = 1;
            nightReason += `+<span class="stat-positive">æ¾æ˜</span>`;
        }
        if (character.traits.includes("ç›®ãŒã„ã„")) {
             if(nightVision < 1) {
               nightReason += `+<span class="stat-positive">ç›®ãŒã„ã„</span>`;
            }
            nightVision = Math.max(nightVision, 1);
        }
        calculationStepsHtml += `<div>${nightReason}ã®ãŸã‚ <span class="stat-negative">${nightVision}</span> ã«è£œæ­£</div>`;
        visionCalc = nightVision;
    } else if (hour < 8 || hour > 17) {
        let originalVision = visionCalc;
        visionCalc = Math.max(hasTorch ? 1 : 0, visionCalc - 1);
        let duskReason = "å¤•æ–¹/æ—©æœ";
        if (hasTorch && originalVision - 1 < 1) {
             duskReason += ` (<span class="stat-positive">æ¾æ˜</span>ã§æœ€ä½1ç¶­æŒ)`;
        }
        calculationStepsHtml += `<div>${duskReason}ã«ã‚ˆã‚‹è£œæ­£: -1</div>`;
    }

    // 4. å¤©å€™ã«ã‚ˆã‚‹å½±éŸ¿
    let weatherMultiplier = 1.0;
    let weatherReason = "";
    if (currentWeather.name === 'é›¨') {
        weatherMultiplier = 0.75;
        weatherReason = "é›¨";
    }
    if (currentWeather.name === 'åµ') {
        weatherMultiplier = 0.5;
        weatherReason = "åµ";
    }

    if (weatherMultiplier !== 1.0) {
        calculationStepsHtml += `<div>${weatherReason}ã«ã‚ˆã‚‹æ‚ªåŒ–: Ã—${weatherMultiplier}</div>`;
        visionCalc *= weatherMultiplier;
    }

    // 5. æœ€çµ‚çµæœã®è¡¨ç¤º
    const finalVision = Math.max(0, Math.round(visionCalc));
    
    contentHtml += calculationStepsHtml;
    contentHtml += `<div style="border-bottom: 1px solid #555; margin: 4px 0;"></div>`;
    
    // å°æ•°ç‚¹ãŒç™ºç”Ÿã—ãŸå ´åˆã€å››æ¨äº”å…¥å‰ã®å€¤ã‚‚è¡¨ç¤º
    if (Math.round(visionCalc) !== visionCalc) {
         contentHtml += `<div>è¨ˆç®—çµæœ: ${visionCalc.toFixed(2)}</div>`;
    }
    
    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
    contentHtml += `<strong>æœ€çµ‚çš„ãªè¦–ç•Œãƒ¬ãƒ™ãƒ«: ${finalVision}</strong>`;
    // â–²â–²â–² ã“ã“ã¾ã§ãŒä¿®æ­£ç®‡æ‰€ â–²â–²â–²

    preview.innerHTML = contentHtml;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}
function showSmellTooltip(event) {
    const preview = document.getElementById("statusPreview");
    let contentHtml = `<strong>è‡­ã„ãƒ¬ãƒ™ãƒ«ã®å†…è¨³</strong><br/>`;
    let totalSmell = 0;
    let hasSource = false;

    // ã‚½ãƒ¼ã‚¹1: ã‚¢ã‚¤ãƒ†ãƒ 
    const smellyItems = [...player.inventory, ...player.equipment].filter(item => item.smell);
    if (smellyItems.length > 0) {
        smellyItems.forEach(item => {
            contentHtml += `<div>${getItemDisplayName(item)}: +${item.smell}</div>`;
            totalSmell += item.smell;
        });
        hasSource = true;
    }

    // ã‚½ãƒ¼ã‚¹2: å‡ºè¡€
    if (player.injuries.some(i => i.type === 'bleeding')) {
        contentHtml += `<div><span class="stat-negative">å‡ºè¡€</span>: +15</div>`;
        totalSmell += 15;
        hasSource = true;
    }

    // ã‚½ãƒ¼ã‚¹3: ä½“è‡­
    const bodyOdorSmell = Math.floor(player.bodyOdor / 5);
    if (bodyOdorSmell > 0) {
        contentHtml += `<div>ä½“è‡­: +${bodyOdorSmell}</div>`;
        totalSmell += bodyOdorSmell;
        hasSource = true;
    }

    if (!hasSource) {
        contentHtml += `<div>è‡­ã„ã®ç™ºç”ŸæºãŒã‚ã‚Šã¾ã›ã‚“ã€‚</div>`;
    }

    contentHtml += `<div style="border-bottom: 1px solid #555; margin: 2px 0;"></div>`;
    // ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—å†…ã§è¨ˆç®—ã—ãŸåˆè¨ˆå€¤ã‚’è¡¨ç¤ºã™ã‚‹
    contentHtml += `<strong>åˆè¨ˆ: ${totalSmell}</strong>`;

    preview.innerHTML = contentHtml;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}
function showSoundTooltip(event) {
    const preview = document.getElementById("statusPreview");
    const calc = lastSoundCalculation;
    let contentHtml = `<strong>ç‰©éŸ³ãƒ¬ãƒ™ãƒ«ã®å†…è¨³</strong><br/>`;

    if (calc.total === 0) {
        contentHtml += `<div>éŸ³ã‚’ç«‹ã¦ã‚‹è¡Œå‹•ã‚’ã—ã¦ã„ã¾ã›ã‚“ã€‚</div>`;
    } else {
        contentHtml += `<div>è¡Œå‹• (${calc.source}): ${calc.base.toFixed(1)}</div>`;
        contentHtml += `<div>è£…å‚™ (${calc.shoes.name}): Ã—${calc.shoes.modifier.toFixed(1)}</div>`;
        if (calc.weather.modifier !== 1.0) {
            contentHtml += `<div>å¤©å€™ (${calc.weather.name}): Ã—${calc.weather.modifier.toFixed(1)}</div>`;
        }
        contentHtml += `<div style="border-bottom: 1px solid #555; margin: 2px 0;"></div>`;
        contentHtml += `<strong>åˆè¨ˆ: ${calc.total.toFixed(1)}</strong>`;
    }

    preview.innerHTML = contentHtml;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}

// ã€3. æ—¢å­˜é–¢æ•°ã®ä¿®æ­£ã€‘
// æ—¢å­˜ã® updateTurnInfo é–¢æ•°ã‚’ã€ä»¥ä¸‹ã®å†…å®¹ã§ç½®ãæ›ãˆã¾ã™ã€‚

function updateTurnInfo() {
    const year = currentTime.getFullYear();
    const month = currentTime.getMonth() + 1;
    const day = currentTime.getDate();
    const currentHour = currentTime.getHours();
    const ampm = currentHour >= 12 ? "åˆå¾Œ" : "åˆå‰";
    let hours = currentHour % 12;
    hours = hours ? hours : 12; // 0æ™‚ã‚’12æ™‚ã«å¤‰æ›
    const minutes = currentTime.getMinutes().toString().padStart(2, '0');

    // ç‰©éŸ³ãƒ¬ãƒ™ãƒ«ã®è¡¨ç¤ºéƒ¨åˆ† (æ•°å€¤)
    const soundLevelHtml = `<span onmouseenter="showSoundTooltip(event)" onmouseleave="hideInfoTooltip()" onmousemove="updatePreviewPosition(event)">${currentSoundLevel}</span>`;

    // è‡­ã„ãƒ¬ãƒ™ãƒ«ã®è¡¨ç¤ºéƒ¨åˆ† (æ•°å€¤)
    const smellLevelHtml = `<span onmouseenter="showSmellTooltip(event)" onmouseleave="hideInfoTooltip()" onmousemove="updatePreviewPosition(event)">${currentPlayerSmell}</span>`;

    let turnInfoHtml = `ã‚¿ãƒ¼ãƒ³: ${turn}<br>${year}å¹´${month}æœˆ${day}æ—¥<br>${ampm} ${hours}æ™‚${minutes}åˆ†`;

    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
    // å„ãƒ©ãƒ™ãƒ«ã®ãƒ†ã‚­ã‚¹ãƒˆã‚‚spanã§å›²ã¿ã€ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—è¡¨ç¤ºã‚¤ãƒ™ãƒ³ãƒˆã‚’è¿½åŠ 
    turnInfoHtml += `<br><span onmouseenter="showSoundTooltip(event)" onmouseleave="hideInfoTooltip()" onmousemove="updatePreviewPosition(event)">ç‰©éŸ³ãƒ¬ãƒ™ãƒ«</span>: ${soundLevelHtml}`;
    turnInfoHtml += `<br><span onmouseenter="showSmellTooltip(event)" onmouseleave="hideInfoTooltip()" onmousemove="updatePreviewPosition(event)">è‡­ã„ãƒ¬ãƒ™ãƒ«</span>: ${smellLevelHtml}`;
    
    const currentVision = getVisionRange();
    const visionLevelHtml = `<span onmouseenter="showVisionTooltip(event)" onmouseleave="hideInfoTooltip()" onmousemove="updatePreviewPosition(event)">${currentVision}</span>`;
    turnInfoHtml += `<br><span onmouseenter="showVisionTooltip(event)" onmouseleave="hideInfoTooltip()" onmousemove="updatePreviewPosition(event)">è¦–ç•Œãƒ¬ãƒ™ãƒ«</span>: ${visionLevelHtml}`;
    previousVisionLevel = currentVision; // æ¬¡ã®ã‚¿ãƒ¼ãƒ³ã®ãŸã‚ã«ç¾åœ¨ã®è¦–ç•Œãƒ¬ãƒ™ãƒ«ã‚’ä¿å­˜
    // â–²â–²â–² ã“ã“ã¾ã§ãŒä¿®æ­£ç®‡æ‰€ â–²â–²â–²
    
    document.getElementById("turnInfoText").innerHTML = turnInfoHtml;
    
    updateMapHeaderInfo();
}

function showInfoTooltip(event, title, description) {
    const preview = document.getElementById("statusPreview");
    preview.innerHTML = `<strong>${title}</strong><div style="margin-top: 5px;">${description}</div>`;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}

function hideInfoTooltip() {
    hideStatusPreview();
}

function updateMapHeaderInfo() {
    let dayState, dayIcon, dayDesc;
    const hour = currentTime.getHours();
    if (hour >= 6 && hour < 12) { 
        dayState = "æœ"; 
        dayIcon = "ğŸŒ…";
        dayDesc = "ä¸€æ—¥ã®å§‹ã¾ã‚Šã€‚å¤œè¡Œæ€§ã®æ•µã¯å°‘ãªããªã‚‹ãŒã€æ´»å‹•ã‚’å§‹ã‚ã‚‹ç”Ÿå­˜è€…ã‚‚å¤šã„ã€‚";
    } else if (hour >= 12 && hour < 18) { 
        dayState = "æ˜¼"; 
        dayIcon = "â˜€ï¸";
        dayDesc = "æœ€ã‚‚è¦–ç•ŒãŒè‰¯ãã€æ´»å‹•ã—ã‚„ã™ã„æ™‚é–“å¸¯ã€‚ãŸã ã—ã€æ•µã«è¦‹ã¤ã‹ã‚Šã‚„ã™ã„ãƒªã‚¹ã‚¯ã‚‚ã‚ã‚‹ã€‚";
    } else if (hour >= 18 && hour < 21) { 
        dayState = "å¤•æ–¹"; 
        dayIcon = "ğŸŒ‡";
        dayDesc = "æ—¥ãŒæ²ˆã¿å§‹ã‚ã€è¦–ç•ŒãŒæ‚ªããªã£ã¦ãã‚‹ã€‚å¤œè¡Œæ€§ã®æ•µãŒæ´»å‹•ã‚’å§‹ã‚ã‚‹æ™‚é–“ã€‚";
    } else { 
        dayState = "å¤œ"; 
        dayIcon = "ğŸŒ™";
        dayDesc = "è¦–ç•ŒãŒè‘—ã—ãåˆ¶é™ã•ã‚Œã‚‹å±é™ºãªæ™‚é–“å¸¯ã€‚æ•µã®æ´»å‹•ãŒæ´»ç™ºã«ãªã‚‹ãŒã€æ¾æ˜ãŒã‚ã‚Œã°è¦–ç•Œã‚’ç¢ºä¿ã§ãã‚‹ã€‚";
    }

    const seasonInfo = {
        'æ˜¥': { icon: 'ğŸŒ¸', desc: 'éã”ã—ã‚„ã™ã„æ°—å€™ã ãŒã€å¤©å€™ãŒå¤‰ã‚ã‚Šã‚„ã™ã„ã€‚é£Ÿæ–™ãŒè¦‹ã¤ã‹ã‚Šã‚„ã™ã„æ™‚æœŸã€‚' },
        'å¤': { icon: 'ğŸŒ»', desc: 'æ°—æ¸©ãŒé«˜ãã€ç†±ä¸­ç—‡ã‚„è„±æ°´ç—‡çŠ¶ã«æ³¨æ„ãŒå¿…è¦ã€‚æ—¥ä¸­ã®æ´»å‹•ã¯ä½“åŠ›ã‚’æ¶ˆè€—ã—ã‚„ã™ã„ã€‚' },
        'ç§‹': { icon: 'ğŸ‚', desc: 'æ°—æ¸©ãŒä¸‹ãŒã‚Šå§‹ã‚ã€éã”ã—ã‚„ã™ããªã‚‹ã€‚å†¬ã«å‚™ãˆã¦é£Ÿæ–™ã‚„è³‡æºã‚’é›†ã‚ã‚‹é‡è¦ãªæ™‚æœŸã€‚' },
        'å†¬': { icon: 'â„ï¸', desc: 'å³ã—ã„å¯’ã•ãŒä½“æ¸©ã¨ä½“åŠ›ã‚’å¥ªã†ã€‚é£Ÿæ–™ãŒè¦‹ã¤ã‹ã‚Šã«ããã€ç”Ÿå­˜ãŒæœ€ã‚‚å›°é›£ãªå­£ç¯€ã€‚' }
    };

    const weatherInfo = {
        'å¿«æ™´': { icon: 'â˜€ï¸', desc: 'è¦–ç•ŒãŒè‰¯å¥½ã§ã€æ°—åŠ›ã‚‚å›å¾©ã—ã‚„ã™ã„ã€‚ãŸã ã—ã€å¤ã¯æ°—æ¸©ãŒéå¸¸ã«é«˜ããªã‚‹ã€‚' },
        'æ›‡ã‚Š': { icon: 'â˜ï¸', desc: 'éã”ã—ã‚„ã™ã„ãŒã€ã‚„ã‚„è–„æš—ã„ã€‚å¤©å€™ãŒæ‚ªåŒ–ã™ã‚‹å‰å…†ã‹ã‚‚ã—ã‚Œãªã„ã€‚' },
        'é›¨': { icon: 'ğŸŒ§ï¸', desc: 'è¡£æœãŒæ¿¡ã‚Œã¦ä½“æ¸©ãŒä¸‹ãŒã‚Šã‚„ã™ããªã‚‹ã€‚ç‰©éŸ³ãŒèã“ãˆã«ãããªã‚‹ãŸã‚ã€æ•µã«æ°—ã¥ã‹ã‚Œã«ãã„åˆ©ç‚¹ã‚‚ã‚ã‚‹ã€‚' },
        'åµ': { icon: 'â›ˆï¸', desc: 'æ¿€ã—ã„é›¨ã¨é¢¨ã€‚ãšã¶æ¿¡ã‚Œã«ãªã‚Šã€æ€¥æ¿€ã«ä½“æ¸©ãŒä½ä¸‹ã™ã‚‹ã€‚è¦–ç•Œã‚‚æ‚ªåŒ–ã—ã€ç§»å‹•ã¯å±é™ºã€‚' }
    };
    
    let tempClass = 'temp-normal';
    let tempDesc = 'éã”ã—ã‚„ã™ã„æ°—æ¸©ã€‚';
    if (currentTemperature > 28) {
        tempClass = 'temp-hot';
        tempDesc = 'æš‘ã„ã€‚æ°´åˆ†è£œçµ¦ã‚’æ€ ã‚‹ã¨å±é™ºã€‚';
    } else if (currentTemperature < 10) {
        tempClass = 'temp-cold';
        tempDesc = 'å¯’ã„ã€‚æš–ã‹ã„æœè£…ã‚’ã—ãªã„ã¨ä½“æ¸©ãŒä½ä¸‹ã™ã‚‹ã€‚';
    }

    const seasonHtml = `<span 
        onmouseenter="showInfoTooltip(event, '${currentSeason}', '${seasonInfo[currentSeason].desc}')" 
        onmouseleave="hideInfoTooltip()"
        onmousemove="updatePreviewPosition(event)">
        ${seasonInfo[currentSeason].icon} ${currentSeason}
    </span>`;

    const weatherHtml = `<span 
        onmouseenter="showInfoTooltip(event, '${currentWeather.name}', '${weatherInfo[currentWeather.name].desc}')" 
        onmouseleave="hideInfoTooltip()"
        onmousemove="updatePreviewPosition(event)">
        ${weatherInfo[currentWeather.name].icon} ${currentWeather.name}
    </span>`;

    const dayStateHtml = `<span 
        onmouseenter="showInfoTooltip(event, '${dayState}', '${dayDesc}')" 
        onmouseleave="hideInfoTooltip()"
        onmousemove="updatePreviewPosition(event)">
        ${dayIcon} ${dayState}
    </span>`;

    const tempHtml = `<span class="${tempClass}" 
        onmouseenter="showInfoTooltip(event, 'æ°—æ¸©', '${tempDesc}')" 
        onmouseleave="hideInfoTooltip()"
        onmousemove="updatePreviewPosition(event)">
        ${currentTemperature.toFixed(1)}Â°C
    </span>`;

    document.getElementById("mapHeaderInfo").innerHTML = `${seasonHtml}|${weatherHtml}|${dayStateHtml}|${tempHtml}`;
}

function logClear() { document.getElementById("log").innerHTML = ""; }

function log(text, doSpeak = true) {
    // 1. ç”»é¢ã®æ—¥è¨˜ãƒ‘ãƒãƒ«ã«æ–‡ç« ã‚’æ›¸ãè¾¼ã‚€å‡¦ç†
    const logDiv = document.getElementById("log");
    Array.from(logDiv.children).forEach(div => {
        div.style.color = "#666";
        div.style.fontWeight = "normal";
    });
    let div = document.createElement("div");
    div.innerHTML = text;
    div.classList.add("new");
    logDiv.appendChild(div);
    logDiv.scrollTop = logDiv.scrollHeight;

    // 2. èª­ã¿ä¸Šã’ã‚’ã‚­ãƒ¥ãƒ¼ã«å…¥ã‚Œãšã€å³åº§ã«å®Ÿè¡Œã™ã‚‹å‡¦ç†ã«å¤‰æ›´
    if (doSpeak) {
        const tempDiv = document.createElement("div");
        tempDiv.innerHTML = text;
        const plainText = tempDiv.textContent || tempDiv.innerText || "";
        speak(plainText); // ã“ã“ã‚’å¤‰æ›´ï¼šã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã›ãšã€ç›´æ¥ speak é–¢æ•°ã‚’å‘¼ã³å‡ºã™
    }
}

function getItemDisplayName(item) {
    if (!item) return "";
    let baseName = item.name;
    let prefix = '';
    let color = '#eee';

    if (item.durability !== undefined) {
        const durabilityPercent = item.durability;
        if (durabilityPercent === 100) {
            prefix = 'æ–°å“ã®';
            color = '#2ecc71';
        } else if (durabilityPercent >= 70) {
            prefix = 'æ–°å“åŒæ§˜ã®';
            color = '#eee';
        } else if (durabilityPercent >= 30) {
            prefix = 'ä½¿ã„å¤ã•ã‚ŒãŸ';
            color = '#FFD700';
        } else if (durabilityPercent > 0) {
            prefix = 'ãƒœãƒ­ãƒœãƒ­ã®';
            color = '#FFA500';
        } else {
            prefix = 'å£Šã‚ŒãŸ';
            color = '#FF4444';
        }
    }
    
    let durabilityPrefix = prefix ? `<span style="color: ${color};">${prefix}</span> ` : '';

    // â–¼â–¼â–¼ ã“ã®ä¸€è¡Œã‚’ä¿®æ­£ â–¼â–¼â–¼
    let wetnessPrefix = ''; // â†ã“ã®ã‚ˆã†ã«ç©ºã®æ–‡å­—åˆ—ã§åˆæœŸåŒ–ã—ã¾ã™
    // â–²â–²â–² ä¿®æ­£ç®‡æ‰€ â–²â–²â–²
    if (item.wetness === 'wet') {
        wetnessPrefix = '<span style="color: lightblue;">(æ¿¡ã‚ŒãŸ) </span>';
    } else if (item.wetness === 'soaking_wet') {
        wetnessPrefix = '<span style="color: blue;">(ãšã¶æ¿¡ã‚Œ) </span>';
    }

    let name = wetnessPrefix + durabilityPrefix + baseName;


    if (item.openedName) name = item.openedName;

    if (item.ammoType && item.ammoCapacity) {
        name += ` (${item.loadedAmmo}/${item.ammoCapacity})`;
        if (item.name === 'ãƒ©ã‚¤ãƒ•ãƒ«' && item.bayonetAttached) {
            name += ' éŠƒå‰£ä»˜';
        }
    } else if (item.type === 'container') {
        if (!item.content) return `${name} (ç©º)`;
        if (item.content.type === 'clean') return `${name} (ç¶ºéº—ãªæ°´)`;
        return `${name} (æ±šã‚ŒãŸæ°´)`;
    }
    return name;
}

function updateItemPanels() {
Â  const invDiv = document.getElementById("inventory"), equipDiv = document.getElementById("equipment");
Â  invDiv.innerHTML = ""; equipDiv.innerHTML = "";
Â  if (player.inventory.length === 0) invDiv.textContent = "ãªã—";
Â  player.inventory.forEach((item, idx) => {
Â  Â  let div = document.createElement("div"); div.className = "item";
Â  Â  let descText = "";
Â  Â  if (item.type === "consumable" && item.freshness !== undefined) descText = item.freshness > 0 ? `æ–°é®®åº¦: ${item.freshness.toFixed(0)}%` : `è…ã£ã¦ã„ã‚‹`;
Â  Â  else if ((item.type === "equipment" || item.type === "clothing" || item.type === "tool") && item.durability !== undefined) descText = `è€ä¹…åº¦: ${item.durability.toFixed(0)}%`;
Â  Â  else if (item.type === "ammo") descText = 'å¼¾è–¬';
Â  Â  div.innerHTML = `<span style="margin-right: 5px;">${item.graphic}</span>${getItemDisplayName(item)}${descText ? ` <span style="font-size: smaller; color: #888;">(${descText})</span>` : ''}`;
Â  Â  div.onclick = () => showItemDetail(item, idx, 'inventory');
Â  Â  invDiv.appendChild(div);
Â  });
Â  if (player.equipment.length === 0) equipDiv.textContent = "ãªã—";
Â  player.equipment.forEach((item, idx) => {
Â  Â  let div = document.createElement("div"); div.className = "item";
Â  Â  let descText = `è€ä¹…åº¦: ${item.durability !== undefined ? item.durability.toFixed(0) : 'N/A'}%`;
Â  Â  if (item.isTorch && item.duration) descText += `, æ®‹ã‚Š: ${item.duration}ã‚¿ãƒ¼ãƒ³`;
Â  Â  let slotPrefix = item.slot ? `[${getSlotName(item.slot)}] ` : '';
Â  Â  div.innerHTML = `<span style="margin-right: 5px;">${item.graphic}</span>${slotPrefix}${getItemDisplayName(item)}<span style="font-size: smaller; color: #888;"> (${descText})</span>`;
Â  Â  div.onclick = () => showItemDetail(item, idx, 'equipment');
Â  Â  equipDiv.appendChild(div);
Â  });
Â  updateCraftingPanel();
}

function updateCraftingPanel() {
Â  Â  const craftListDiv = document.getElementById("craftingList");
Â  Â  craftListDiv.innerHTML = "";

Â  Â  const categories = {
Â  Â  Â  Â  'ä»Šä½œã‚Œã‚‹ã‚¢ã‚¤ãƒ†ãƒ ': [],
Â  Â  Â  Â  'æ­¦å™¨': [],
Â  Â  Â  Â  'é˜²å…·ãƒ»è¡£é¡': [],
Â  Â  Â  Â  'é“å…·': [],
Â  Â  Â  Â  'ãã®ä»–': []
Â  Â  };

Â  Â  recipes.forEach(recipe => {
Â  Â  Â  Â  const resultItem = items.find(i => i.name === recipe.result);
Â  Â  Â  Â  if (!resultItem) return;

Â  Â  Â  Â  const isCraftable = canCraftItem(recipe);
Â  Â  Â  Â  const recipeData = { ...recipe, canCraft: isCraftable };

Â  Â  Â  Â  if (isCraftable) {
Â  Â  Â  Â  Â  Â  categories['ä»Šä½œã‚Œã‚‹ã‚¢ã‚¤ãƒ†ãƒ '].push(recipeData);
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  if (resultItem.name === 'ãƒãƒªã‚±ãƒ¼ãƒ‰') {
Â  Â  Â  Â  Â  Â  categories['ãã®ä»–'].push(recipeData);
Â  Â  Â  Â  } else if (resultItem.type === 'equipment' && resultItem.slot === 'weapon') {
Â  Â  Â  Â  Â  Â  categories['æ­¦å™¨'].push(recipeData);
Â  Â  Â  Â  } else if (resultItem.type === 'equipment' || resultItem.type === 'clothing') {
Â  Â  Â  Â  Â  Â  categories['é˜²å…·ãƒ»è¡£é¡'].push(recipeData);
Â  Â  Â  Â  } else if (resultItem.type === 'tool' || resultItem.type === 'container') {
Â  Â  Â  Â  Â  Â  categories['é“å…·'].push(recipeData);
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  categories['ãã®ä»–'].push(recipeData);
Â  Â  Â  Â  }
Â  Â  });

Â  Â  for (const categoryName in categories) {
Â  Â  Â  Â  const recipeList = categories[categoryName];
Â  Â  Â  Â  if (recipeList.length === 0) continue;

Â  Â  Â  Â  const header = document.createElement("div");
Â  Â  Â  Â  header.className = "crafting-category-header";
Â  Â  Â  Â  header.innerHTML = `<span>${categoryName}</span><span class="toggle-arrow">â–¼</span>`;
Â  Â  Â  Â  craftListDiv.appendChild(header);

Â  Â  Â  Â  const recipeContainer = document.createElement("div");
Â  Â  Â  Â  recipeContainer.className = "recipe-container";
Â  Â  Â  Â  craftListDiv.appendChild(recipeContainer);

Â  Â  Â  Â  header.addEventListener('click', () => {
Â  Â  Â  Â  Â  Â  recipeContainer.classList.toggle('collapsed');
Â  Â  Â  Â  Â  Â  const arrow = header.querySelector('.toggle-arrow');
Â  Â  Â  Â  Â  Â  arrow.textContent = recipeContainer.classList.contains('collapsed') ? 'â–¶' : 'â–¼';
Â  Â  Â  Â  });

Â  Â  Â  Â  recipeList.sort((a, b) => {
Â  Â  Â  Â  Â  Â  if (categoryName === 'ä»Šä½œã‚Œã‚‹ã‚¢ã‚¤ãƒ†ãƒ ') {
Â  Â  Â  Â  Â  Â  Â  Â  return a.result.localeCompare(b.result);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if (a.canCraft && !b.canCraft) return -1;
Â  Â  Â  Â  Â  Â  if (!a.canCraft && b.canCraft) return 1;
Â  Â  Â  Â  Â  Â  return a.result.localeCompare(b.result);
Â  Â  Â  Â  });

Â  Â  Â  Â  recipeList.forEach(recipe => {
Â  Â  Â  Â  Â  Â  const resultItem = items.find(i => i.name === recipe.result);
Â  Â  Â  Â  Â  Â  const div = document.createElement("div");
Â  Â  Â  Â  Â  Â  div.className = "item";
Â  Â  Â  Â  Â  Â  div.addEventListener('mouseenter', (e) => showRecipeTooltip(resultItem, e));
Â  Â  Â  Â  Â  Â  div.addEventListener('mouseleave', hideStatusPreview);
Â  Â  Â  Â  Â  Â  div.addEventListener('mousemove', (e) => updatePreviewPosition(e));
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  if (!recipe.canCraft) {
Â  Â  Â  Â  Â  Â  Â  Â  div.classList.add("un-craftable");
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  let ingredientsHtml = recipe.ingredients.map(ing => `${ing.name} x${ing.count}`).join(', ');
Â  Â  Â  Â  Â  Â  div.innerHTML = `<button>ä½œæˆ</button><span style="margin-right: 5px;">${resultItem.graphic || 'ğŸš§'}</span>${resultItem.name}<div class="recipe-ingredients">${ingredientsHtml}</div>`;
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  if (recipe.canCraft) {
Â  Â  Â  Â  Â  Â  Â  Â  div.querySelector("button").onclick = () => craftItem(recipe);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  recipeContainer.appendChild(div);
Â  Â  Â  Â  });
Â  Â  }
}

function canCraftItem(recipe) {
Â  Â  const availableMaterials = {};
Â  Â  player.inventory.forEach(item => { 
Â  Â  Â  Â  availableMaterials[item.name] = (availableMaterials[item.name] || 0) + 1; 
Â  Â  });
Â  Â  const locationKey = `${player.x},${player.y}`;
Â  Â  const itemsOnGround = droppedItems[locationKey] || [];
Â  Â  itemsOnGround.forEach(item => {
Â  Â  Â  Â  availableMaterials[item.name] = (availableMaterials[item.name] || 0) + 1;
Â  Â  });

Â  Â  return recipe.ingredients.every(ingredient => (availableMaterials[ingredient.name] || 0) >= ingredient.count);
}

function craftItem(recipe) {
    if (!canCraftItem(recipe)) { log("ææ–™ãŒè¶³ã‚Šã¾ã›ã‚“ã€‚"); return; }

    snapshotStats();
    
    recipe.ingredients.forEach(ingredient => {
        for (let i = 0; i < ingredient.count; i++) {
            const invIndex = player.inventory.findIndex(invItem => invItem.name === ingredient.name);
            if (invIndex > -1) {
                const removedItem = player.inventory.splice(invIndex, 1)[0];
                player.weight -= removedItem.weight || 0;
                player.volume -= removedItem.volume || 0;
                continue;
            }

            const locationKey = `${player.x},${player.y}`;
            const groundItems = droppedItems[locationKey] || [];
            const groundIndex = groundItems.findIndex(groundItem => groundItem.name === ingredient.name);
            if (groundIndex > -1) {
                groundItems.splice(groundIndex, 1);
            }
        }
    });

    const resultItemTemplate = items.find(item => item.name === recipe.result);
    if (resultItemTemplate) {
        const newItem = { ...resultItemTemplate };
        
        if (player.weight + newItem.weight > player.maxWeight || player.volume + (newItem.volume || 0) > player.maxVolume) {
            const msg = `é‡ã•ã‹å®¹é‡ãŒè¶³ã‚Šãªãã¦${newItem.name}ã‚’æŒã¦ãªã„ãŸã‚ã€åœ°é¢ã«ç½®ã„ãŸã€‚`;
            log(msg, false); // èª­ã¿ä¸Šã’ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã—ãªã„
            speak(msg);      // å³åº§ã«èª­ã¿ä¸Šã’
            const locationKey = `${player.x},${player.y}`;
            if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
            droppedItems[locationKey].push(newItem);
        } else {
            player.inventory.push(newItem);
            player.weight += newItem.weight || 0;
            player.volume += newItem.volume || 0;
        }
        const successMessage = `${newItem.name}ã‚’ã‚¯ãƒ©ãƒ•ãƒˆã—ãŸï¼`;
        log(successMessage, false); // èª­ã¿ä¸Šã’ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã—ãªã„
        speak(successMessage);      // å³åº§ã«èª­ã¿ä¸Šã’
        createSound(player.x, player.y, 3);
    }
    advanceTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    updateTurnInfo();
    checkGameOver();
    updateCurrentLocationPanel(false);
}

function dropItem(index) {
    snapshotStats();
    const droppedItem = player.inventory.splice(index, 1)[0];
    player.weight -= droppedItem.weight || 0;
    player.volume -= droppedItem.volume || 0;
    log(`${getItemDisplayName(droppedItem)}ã‚’è½ã¨ã—ãŸã€‚`);
    const locationKey = `${player.x},${player.y}`;
    if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
    droppedItems[locationKey].push(droppedItem);
    updateItemPanels(); updateCurrentLocationPanel(false); updateStatus(); updateCharacterBody();
    speakQueuedLogs(); // ã€è¿½åŠ ã€‘
}

function pickUpItemFromGround(index) {
  const locationKey = `${player.x},${player.y}`;
  const itemToPickUp = droppedItems[locationKey][index];
  if (itemToPickUp.type === 'water_source') { log("æ°´ãã®ã‚‚ã®ã‚’æ‹¾ã†ã“ã¨ã¯ã§ããªã„ã€‚"); hideItemDetail(); return; }
  
  if (player.weight + itemToPickUp.weight > player.maxWeight) { 
      speakAndAlert(`é‡ã™ãã¦${itemToPickUp.name}ã‚’æ‹¾ãˆãªã„...ã€‚`); 
      return; 
  }
  if (player.volume + (itemToPickUp.volume || 0) > player.maxVolume) { 
      speakAndAlert(`å®¹é‡ãŒè¶³ã‚Šãªãã¦${itemToPickUp.name}ã‚’æ‹¾ãˆãªã„...ã€‚`); 
      return; 
  }

  snapshotStats();
  const pickedUpItem = droppedItems[locationKey].splice(index, 1)[0];
  player.inventory.push(pickedUpItem); 
  player.weight += pickedUpItem.weight || 0;
  player.volume += pickedUpItem.volume || 0;
  log(`${getItemDisplayName(pickedUpItem)}ã‚’æ‹¾ã£ãŸã€‚`);
  updateCurrentLocationPanel(false); updateItemPanels(); updateStatus(); updateCharacterBody(); hideItemDetail();
  speakQueuedLogs(); // ã€è¿½åŠ ã€‘
}

function triggerCombatTurnForAction(logMessage) {
    log(logMessage);
    hideItemDetail();

    // â–¼â–¼â–¼ ä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
    // ã‚¢ã‚¤ãƒ†ãƒ æ“ä½œã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§åæ˜ ã•ã›ã‚‹ãŸã‚ã«ãƒ‘ãƒãƒ«ã®è¡¨ç¤ºã‚’æ›´æ–°ã™ã‚‹
    updateItemPanels(); 
    updateStatus();
    // â–²â–²â–² ä¿®æ­£ç®‡æ‰€ â–²â–²â–²

    // æ•µã®ã‚¿ãƒ¼ãƒ³ã‚’å®Ÿè¡Œ
    enemyTurn(); 
}

function unequipItem(index, showLog = true) {
    const itemToUnequip = player.equipment[index];

    let futureMaxVolume = maxStats.maxVolume;
    player.equipment.forEach((item, i) => {
        if (i !== index && item.effects && item.effects.maxVolume) {
        futureMaxVolume += item.effects.maxVolume;
        }
    });

    const futurePlayerVolume = player.volume + (itemToUnequip.volume || 0);

    if (futurePlayerVolume > futureMaxVolume) {
        speakAndAlert(`ã“ã‚Œã‚’å¤–ã™ã¨å®¹é‡ã‚ªãƒ¼ãƒãƒ¼ã«ãªã‚Šã¾ã™ã€‚å…ˆã«æ‰€æŒå“ã‚’æ¸›ã‚‰ã—ã¦ãã ã•ã„ã€‚<br>(ç§»å‹•å¾Œ: ${futurePlayerVolume.toFixed(1)} > æ–°æœ€å¤§å€¤: ${futureMaxVolume.toFixed(1)})`);
        hideItemDetail();
        return;
    }

    snapshotStats();
    const unequippedItem = player.equipment.splice(index, 1)[0];
    unequippedItem.slot = (unequippedItem.handedness) ? 'weapon' : unequippedItem.slot;
    player.inventory.push(unequippedItem);
    
    updateEquippedStats(); 

    if (currentEnemy) {
        // æˆ¦é—˜ä¸­ã®å ´åˆ
        triggerCombatTurnForAction(`${getItemDisplayName(unequippedItem)}ã‚’å¤–ã—ã¦ã„ã‚‹éš™ã«æ”»æ’ƒã‚’å—ã‘ãŸï¼`);
    } else {
        // å¹³å¸¸æ™‚ã®å ´åˆ
        if (showLog) log(`${getItemDisplayName(unequippedItem)}ã‚’å¤–ã—ãŸã€‚`);
        if (showLog) {
            updateItemPanels(); 
            updateStatus(); 
            updateCharacterBody();
            speakQueuedLogs(); // ã€è¿½åŠ ã€‘
        }
    }
}

function updateEquippedStats() {
    player.attack = player.baseAttack;
    player.defense = player.baseDefense;
    player.maxWeight = maxStats.maxWeight;
    player.maxVolume = maxStats.maxVolume;
    player.insulation = 0;

    player.equipment.forEach(item => {
        const durabilityFactor = (item.durability === undefined ? 100 : item.durability) / 100;
        let itemAttack = item.attack || 0;
        
        if (item.ammoType) {
            if (item.loadedAmmo === 0) {
                if (item.name === 'ãƒ©ã‚¤ãƒ•ãƒ«' && item.bayonetAttached) {
                    const knife = items.find(i => i.name === 'ãƒŠã‚¤ãƒ•');
                    itemAttack = knife ? knife.attack : item.attack;
                }
            } else {
                itemAttack = item.attack;
            }
        }
        
        player.attack += itemAttack * durabilityFactor;
        player.defense += (item.defense || 0) * durabilityFactor;
        player.insulation += (item.insulation || 0) * durabilityFactor;
        
        // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
        if(item.effects) {
            // ã‚¢ã‚¤ãƒ†ãƒ ãŒå£Šã‚Œã¦ã„ãªã„ã‹ï¼ˆè€ä¹…åŠ›ãŒ0ã‚ˆã‚Šå¤§ãã„ã‹ï¼‰ã‚’ãƒã‚§ãƒƒã‚¯
            const isBroken = item.durability !== undefined && item.durability <= 0;
            if (!isBroken) { // å£Šã‚Œã¦ã„ãªã„å ´åˆã®ã¿åŠ¹æœã‚’é©ç”¨ã™ã‚‹
                if(item.effects.maxWeight) player.maxWeight += item.effects.maxWeight;
                if(item.effects.maxVolume) player.maxVolume += item.effects.maxVolume;
            }
        }
        // â–²â–²â–² ã“ã“ã¾ã§ â–²â–²â–²
    });
    
    player.attack = Math.floor(player.attack);
    player.defense = Math.floor(player.defense);
    
    player.weight = [...player.inventory, ...player.equipment].reduce((sum, item) => sum + (item.weight || 0), 0);
    player.volume = player.inventory.reduce((sum, item) => sum + (item.volume || 0), 0);
}

function equipItem(idx) {
    // ã€ä¿®æ­£â‘ ã€‘æœ€åˆã«ã€ã“ã‚Œã‹ã‚‰è£…å‚™ã™ã‚‹ã‚¢ã‚¤ãƒ†ãƒ è‡ªä½“ã‚’å¤‰æ•°ã«ä¿å­˜ã—ã¦ãŠã
    const itemToEquip = player.inventory[idx];
    if (!itemToEquip) { // å®‰å…¨ç¢ºèª
        console.error("equipItem: ç„¡åŠ¹ãªã‚¢ã‚¤ãƒ†ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒæŒ‡å®šã•ã‚Œã¾ã—ãŸã€‚", idx);
        return;
    }

    // æ­¦å™¨ä»¥å¤–ã®è£…å‚™å“ï¼ˆé˜²å…·ãªã©ï¼‰ã®å ´åˆ
    if (itemToEquip.slot !== 'weapon' || !itemToEquip.handedness) {
        let slot = itemToEquip.slot;
        if (!slot) { speakAndAlert("è£…å‚™ã§ãã¾ã›ã‚“ã€‚"); return; }
        const doEquip = () => {
            snapshotStats();
            let replacedItem = player.equipment.find(e => e.slot === slot);
            if(replacedItem) {
                const replacedItemIndex = player.equipment.findIndex(e => e.slot === slot);
                if (replacedItemIndex > -1) {
                    const itemToUnequip = player.equipment.splice(replacedItemIndex, 1)[0];
                    player.inventory.push(itemToUnequip); // ã“ã“ã§ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªãŒå¤‰æ›´ã•ã‚Œã‚‹
                }
            }
            
            // ã€ä¿®æ­£â‘¡ã€‘ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªãŒå¤‰æ›´ã•ã‚ŒãŸå¾Œã€è£…å‚™ã—ãŸã„ã‚¢ã‚¤ãƒ†ãƒ ã®ã€Œç¾åœ¨ã®ä½ç½®ã€ã‚’æ¢ã—ç›´ã™
            const newEquipIndex = player.inventory.findIndex(i => i === itemToEquip);
            if (newEquipIndex === -1) {
                console.error("å¤ã„è£…å‚™ã‚’å¤–ã—ãŸå¾Œã€è£…å‚™ã™ã‚‹ã‚¢ã‚¤ãƒ†ãƒ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚");
                hideItemDetail();
                return;
            }
            // ã€ä¿®æ­£â‘¢ã€‘æ¢ã—ç›´ã—ãŸæ­£ã—ã„ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½¿ã£ã¦ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã‹ã‚‰å–ã‚Šé™¤ã
            let newEquip = player.inventory.splice(newEquipIndex, 1)[0];
            player.equipment.push(newEquip);

            const logMessage = replacedItem ? `${getItemDisplayName(replacedItem)}ã‚’å¤–ã—ã€${getItemDisplayName(newEquip)}ã‚’è£…å‚™ã—ãŸã€‚` : `${getItemDisplayName(newEquip)}ã‚’è£…å‚™ã—ãŸã€‚`;

            updateEquippedStats();
            hideItemDetail();

            if (currentEnemy) {
                triggerCombatTurnForAction(logMessage + "éš™ã«æ”»æ’ƒã‚’å—ã‘ãŸï¼");
            } else {
                log(logMessage);
                updateItemPanels();
                updateStatus();
                updateCharacterBody();
                speakQueuedLogs(); // ã€ä¿®æ­£ã€‘èª­ã¿ä¸Šã’ã‚’å®Ÿè¡Œ
            }
        };
        let replacedItem = player.equipment.find(e => e.slot === slot);
        if (replacedItem) showItemComparisonModal(itemToEquip, replacedItem, doEquip, () => log("è£…å‚™ã®å…¥ã‚Œæ›¿ãˆã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸã€‚"));
        else doEquip();
        return;
    }

    const mainHandWeapon = player.equipment.find(e => e.slot === 'main_hand' || e.handedness === 'two');
    const offHandWeapon = player.equipment.find(e => e.slot === 'off_hand');

    // ä¸¡æ‰‹æ­¦å™¨ã®å ´åˆ
    if (itemToEquip.handedness === 'two') {
        speakAndConfirm(`${getItemDisplayName(itemToEquip)}ã‚’è£…å‚™ã—ã¾ã™ã‹ï¼Ÿç¾åœ¨ä¸¡æ‰‹ã«æŒã£ã¦ã„ã‚‹æ­¦å™¨ã¯å¤–ã•ã‚Œã¾ã™ã€‚`, () => {
            snapshotStats();
            // å…ˆã«ã™ã¹ã¦ã®è£…å‚™è§£é™¤ã‚’è¡Œã†
            if (mainHandWeapon) {
                const mainHandIndex = player.equipment.findIndex(e => e === mainHandWeapon);
                if(mainHandIndex > -1) unequipItem(mainHandIndex, false);
            }
            if (offHandWeapon) {
                 const offHandIndex = player.equipment.findIndex(e => e === offHandWeapon);
                 if(offHandIndex > -1) unequipItem(offHandIndex, false);
            }

            // ã€æ­¦å™¨ã®ä¿®æ­£ç®‡æ‰€ã€‘ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªãŒå¤‰æ›´ã•ã‚ŒãŸå¾Œã€ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ¢ã—ç›´ã—ã¦è£…å‚™ã™ã‚‹
            const newWeaponIndex = player.inventory.findIndex(i => i === itemToEquip);
            if (newWeaponIndex === -1) {
                console.error("è£…å‚™è§£é™¤å¾Œã€ä¸¡æ‰‹æ­¦å™¨ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚");
                hideItemDetail();
                return;
            }
            const newWeapon = player.inventory.splice(newWeaponIndex, 1)[0];

            newWeapon.slot = 'main_hand';
            player.equipment.push(newWeapon);
            const logMessage = `${getItemDisplayName(itemToEquip)}ã‚’ä¸¡æ‰‹ã§æ§‹ãˆãŸã€‚`;

            updateEquippedStats();
            hideItemDetail();

            if(currentEnemy){
                triggerCombatTurnForAction(logMessage + "éš™ã«æ”»æ’ƒã‚’å—ã‘ãŸï¼");
            } else {
                log(logMessage);
                updateItemPanels();
                updateStatus();
                updateCharacterBody();
                speakQueuedLogs(); // ã€ä¿®æ­£ã€‘èª­ã¿ä¸Šã’ã‚’å®Ÿè¡Œ
            }
        });
    } 
    // ç‰‡æ‰‹æ­¦å™¨ã®å ´åˆ
    else if (itemToEquip.handedness === 'one') {
        const equipToOneHand = (targetSlot) => {
            const currentWeapon = player.equipment.find(e => e.slot === targetSlot);
            const doEquipAction = () => {
                snapshotStats();
                // å…ˆã«ã™ã¹ã¦ã®è£…å‚™è§£é™¤ã‚’è¡Œã†
                if (mainHandWeapon && mainHandWeapon.handedness === 'two') {
                     const twoHandedIndex = player.equipment.findIndex(e => e === mainHandWeapon);
                     if(twoHandedIndex > -1) unequipItem(twoHandedIndex, false);
                }
                if (currentWeapon) {
                    const currentWeaponIndex = player.equipment.findIndex(e => e === currentWeapon);
                    if(currentWeaponIndex > -1) unequipItem(currentWeaponIndex, false);
                }

                // ã€æ­¦å™¨ã®ä¿®æ­£ç®‡æ‰€ã€‘ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªãŒå¤‰æ›´ã•ã‚ŒãŸå¾Œã€ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ¢ã—ç›´ã—ã¦è£…å‚™ã™ã‚‹
                const newWeaponIndex = player.inventory.findIndex(i => i === itemToEquip);
                if (newWeaponIndex === -1) {
                    console.error("è£…å‚™è§£é™¤å¾Œã€ç‰‡æ‰‹æ­¦å™¨ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚");
                    hideItemDetail();
                    return;
                }
                const newWeapon = player.inventory.splice(newWeaponIndex, 1)[0];
                newWeapon.slot = targetSlot;
                player.equipment.push(newWeapon);
                const logMessage = `${getSlotName(targetSlot)}ã«${getItemDisplayName(newWeapon)}ã‚’è£…å‚™ã—ãŸã€‚`;

                updateEquippedStats();
                hideItemDetail();

                if(currentEnemy){
                    triggerCombatTurnForAction(logMessage + "éš™ã«æ”»æ’ƒã‚’å—ã‘ãŸï¼");
                } else {
                    log(logMessage);
                    updateItemPanels();
                    updateStatus(); 
                    updateCharacterBody();
                    speakQueuedLogs(); // ã€ä¿®æ­£ã€‘èª­ã¿ä¸Šã’ã‚’å®Ÿè¡Œ
                }
            };

            if (currentWeapon) {
                showItemComparisonModal(itemToEquip, currentWeapon, doEquipAction, () => log("è£…å‚™ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸã€‚"));
            } else {
                doEquipAction();
            }
        };

        if (!mainHandWeapon || (mainHandWeapon && mainHandWeapon.handedness === 'two')) {
            equipToOneHand('main_hand');
        } else if (!offHandWeapon) {
            equipToOneHand('off_hand');
        } else {
             equipToOneHand('main_hand');
        }
    }
}
function useItem(idx, source = 'inventory') {
  let item = (source === 'inventory') ? player.inventory[idx] : player.equipment[idx];
  if(item.useAction) {
      window[item.useAction](item, idx, source);
      return;
  }
  if (item.type === "consumable") {
    snapshotStats();
    if(item.isSealed) { log(`${item.name}ã¯å¯†é–‰ã•ã‚Œã¦ã„ã‚‹ã€‚é–‹ã‘ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚`); hideItemDetail(); return; }
    
    if (item.name.includes("åŒ…å¸¯") || item.name.includes("ã‚­ãƒƒãƒˆ") || item.name.includes("ã‚»ãƒƒãƒˆ")) {
        const bleedingIndex = player.injuries.findIndex(i => i.type === 'bleeding');
        if (bleedingIndex > -1) {
            player.injuries.splice(bleedingIndex, 1);
            log("åŒ…å¸¯ã§æ­¢è¡€ã—ãŸï¼");
        }
    }

    if (item.freshness !== undefined) {
        let foodPoisoningChance = 0;
        if (item.freshness <= 0) {
            foodPoisoningChance = 0.8; 
        } else if (item.freshness < 40) {
            foodPoisoningChance = 0.1;
        }

        if (Math.random() < foodPoisoningChance && !player.sicknesses.some(s => s.type === 'food_poisoning')) {
            log("é£Ÿã¹ãŸã‚‚ã®ãŒæ‚ªã‹ã£ãŸã‚ˆã†ã ...æ°—åˆ†ãŒæ‚ªã„ã€‚", true);
            player.sicknesses.push({ type: 'food_poisoning', duration: 36 });
        }
    }

    if (item.effects) {
        for (const stat in item.effects) {
            if (player[stat] !== undefined) {
              let effect = item.effects[stat];
              if (maxStats[stat]) player[stat] = Math.min(maxStats[stat], player[stat] + effect); else player[stat] += effect;
            }
        }
    }
    log(`${getItemDisplayName(item)}ã‚’ä½¿ã£ãŸã€‚`);
    
    const removedItem = player.inventory.splice(idx, 1)[0];
    player.weight -= removedItem.weight || 0;
    player.volume -= removedItem.volume || 0;
    logStatChanges(playerStatsBeforeAction, player);
    updateItemPanels(); updateStatus(); updateCharacterBody(); hideItemDetail();
    speakQueuedLogs(); // ã€è¿½åŠ ã€‘
  }
}

// --- Sound Effects ---
function playSound(type) {
    try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        if(!ctx) return;
        const o = ctx.createOscillator(), g = ctx.createGain();
        o.connect(g); g.connect(ctx.destination);
        let duration = 0.2;
        switch(type) {
            case 'start': o.type = 'sine'; o.frequency.setValueAtTime(440, ctx.currentTime); g.gain.setValueAtTime(0.2, ctx.currentTime); o.frequency.exponentialRampToValueAtTime(880, ctx.currentTime + 0.2); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.2); duration = 0.2; break;
case 'attack': o.type = 'triangle'; g.gain.setValueAtTime(0.2, ctx.currentTime); o.frequency.setValueAtTime(880, ctx.currentTime); o.frequency.exponentialRampToValueAtTime(220, ctx.currentTime + 0.15); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.15); duration = 0.2; break;
            case 'gunshot': o.type = 'sawtooth'; o.frequency.setValueAtTime(2000, ctx.currentTime); o.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.1); g.gain.setValueAtTime(0.4, ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.2); duration = 0.3; break;
            case 'damage': o.type = 'square'; o.frequency.setValueAtTime(110, ctx.currentTime); g.gain.setValueAtTime(0.3, ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.2); duration = 0.25; break;
            case 'victory': o.type = 'sine'; g.gain.setValueAtTime(0.2, ctx.currentTime); o.frequency.setValueAtTime(523.25, ctx.currentTime); o.frequency.linearRampToValueAtTime(659.26, ctx.currentTime + 0.1); o.frequency.linearRampToValueAtTime(783.99, ctx.currentTime + 0.2); o.frequency.linearRampToValueAtTime(1046.50, ctx.currentTime + 0.4); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.5); duration = 0.6; break;
            case 'defeat': o.type = 'sawtooth'; g.gain.setValueAtTime(0.3, ctx.currentTime); o.frequency.setValueAtTime(220, ctx.currentTime); o.frequency.exponentialRampToValueAtTime(55, ctx.currentTime + 1.0); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 1.0); duration = 1.1; break;
            case 'zombie': o.frequency.value = 400; o.type = "square"; g.gain.setValueAtTime(0.1, ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.00001, ctx.currentTime + 0.4); duration = 0.5; break;
        }
        o.start(); o.stop(ctx.currentTime + duration);
    } catch (e) { console.error("Web Audio API not supported or failed.", e); }
}


// --- Combat System ---
function startCombat(enemy) {
    isInteractionActive = true; currentEnemy = enemy;
    const panelsToHide = document.querySelectorAll('.panel:not(#combatPanel):not(#statusPanel):not(#inventoryPanel):not(#equipmentPanel):not(#itemDetailPanel)');
    panelsToHide.forEach(p => {
        if (!p.classList.contains('minimized')) {
            p.style.display = 'none';
        }
    });

    document.getElementById('sleepNowBtn').style.display = 'none';
    const combatPanel = document.getElementById('combatPanel'); combatPanel.style.display = 'block'; bringToFront(combatPanel);
    
    // æˆ¦é—˜ä¸­ã‚‚è¡¨ç¤ºã™ã‚‹ãƒ‘ãƒãƒ«
    document.getElementById('statusPanel').style.display = 'block'; bringToFront(document.getElementById('statusPanel'));
    document.getElementById('inventoryPanel').style.display = 'flex'; bringToFront(document.getElementById('inventoryPanel'));
    document.getElementById('equipmentPanel').style.display = 'flex'; bringToFront(document.getElementById('equipmentPanel'));

    document.getElementById('combatPlayerAscii').className = 'ascii-art-container';
    document.getElementById('combatEnemyAscii').className = 'ascii-art-container';
    
    document.getElementById('combatEnemyName').textContent = enemy.name;
    
    updateCombatUI();
    document.getElementById('combatLog').innerHTML = '';
    document.getElementById('attackMainBtn').disabled = true; document.getElementById('attackOffBtn').disabled = true; document.getElementById('fireBtn').disabled = true; document.getElementById('runBtn').disabled = true;
    const startMessage = (enemy.isZombie || enemy.isAnimal) ? `${enemy.name}ãŒç¾ã‚ŒãŸï¼` : `${enemy.name}ã¨æˆ¦é—˜ã«ãªã£ãŸï¼`;
    combatLogMessage(startMessage, 'normal', () => { 
        document.getElementById('attackMainBtn').disabled = false; 
        document.getElementById('attackOffBtn').disabled = false; 
        document.getElementById('fireBtn').disabled = false; // ç™ºç ²ãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹ã«ã™ã‚‹å‘½ä»¤ã‚’è¿½åŠ 
        document.getElementById('runBtn').disabled = false; 
        updateCombatUI(); 
    });
    document.getElementById('attackMainBtn').onclick = () => handleAttack('main');
    document.getElementById('attackOffBtn').onclick = () => handleAttack('off');
    document.getElementById('fireBtn').onclick = handleFire;
    document.getElementById('runBtn').onclick = handleRun;
}

function updateCombatUI() {
    const getAsciiForHealth = (entity, maxHealth, asciiStates) => {
        const healthPercent = (entity.health / maxHealth) * 100;
        if (healthPercent > 70) return { ascii: asciiStates.high, colorClass: 'hp-high' };
        if (healthPercent > 40) return { ascii: asciiStates.medium, colorClass: 'hp-medium' };
        if (healthPercent > 10) return { ascii: asciiStates.low, colorClass: 'hp-low' };
        return { ascii: asciiStates.critical, colorClass: 'hp-critical' };
    };

    const playerAsciiPre = document.getElementById('combatPlayerAscii');
    const playerState = getAsciiForHealth(player, maxStats.health, playerAsciiStates);
    playerAsciiPre.textContent = playerState.ascii;
    playerAsciiPre.className = `ascii-art-container ${playerState.colorClass}`;

    if (currentEnemy) {
        const enemyAsciiPre = document.getElementById('combatEnemyAscii');
        let enemyMaxHealth = 100;
        let enemyAsciiStates = zombieAscii;
        
    if (currentEnemy.isAnimal) {
        const template = wildlifeTemplates.find(t => t.type === currentEnemy.type);
        if (template) {
            enemyMaxHealth = template.health;
            enemyAsciiStates = template.ascii;
        } else {
            enemyMaxHealth = 100; 
            enemyAsciiStates = zombieAscii; 
            console.error("Could not find wildlife template for type:", currentEnemy.type);
        }
    } else if (!currentEnemy.isZombie) {
            const template = npcTemplates.find(t => t.type === currentEnemy.type);
            enemyMaxHealth = template.health;
            enemyAsciiStates = template.ascii;
        }
        
        const enemyState = getAsciiForHealth(currentEnemy, enemyMaxHealth, enemyAsciiStates);
        enemyAsciiPre.textContent = enemyState.ascii;
        enemyAsciiPre.className = `ascii-art-container ${enemyState.colorClass}`;
        document.getElementById('combatEnemyHealth').textContent = Math.max(0, currentEnemy.health).toFixed(0);
    }

    document.getElementById('combatPlayerHealth').textContent = `${Math.max(0, player.health).toFixed(0)} / ${maxStats.health}`;
    document.getElementById('combatPlayerAttack').textContent = player.attack;
    document.getElementById('combatPlayerDefense').textContent = player.defense;
    const playerEquipDiv = document.getElementById('combatEquipmentList');
    playerEquipDiv.innerHTML = player.equipment.length > 0 ? player.equipment.map(item => `<div>${item.graphic} ${getSlotName(item.slot)}: ${getItemDisplayName(item)}</div>`).join('') : 'ãªã—';
    
    const playerInjuriesDiv = document.getElementById('combatPlayerInjuries');
    if (player.injuries.length > 0) {
        playerInjuriesDiv.style.display = 'block';
        playerInjuriesDiv.innerHTML = player.injuries.map(i => {
            if (i.type === 'fracture') return i.splinted ? 'éª¨æŠ˜(å›ºå®š)' : 'éª¨æŠ˜';
            if (i.type === 'bleeding') return 'å‡ºè¡€';
            if (i.type === 'bruise') return 'æ‰“æ’²';
        }).join(', ');
    } else {
        playerInjuriesDiv.style.display = 'none';
    }

    const enemyEquipPanel = document.getElementById('combatEnemyEquipment');
    const enemyEquipListDiv = document.getElementById('combatEnemyEquipmentList');
     if (currentEnemy && (currentEnemy.isZombie || currentEnemy.isAnimal || !currentEnemy.equipment || currentEnemy.equipment.length === 0)) {
        enemyEquipPanel.style.display = 'none';
    } else if (currentEnemy) {
        enemyEquipPanel.style.display = 'block';
        enemyEquipListDiv.innerHTML = currentEnemy.equipment.map(item => `<div>${item.graphic} ${item.name}</div>`).join('');
    }

    const attackContainer = document.getElementById('combatAttackContainer'), defenseContainer = document.getElementById('combatDefenseContainer');
    attackContainer.onmouseenter = (e) => showCombatStatTooltip('attack', e);
    attackContainer.onmouseleave = hideCombatStatTooltip;
    attackContainer.onmousemove = (e) => updatePreviewPosition(e);
    defenseContainer.onmouseenter = (e) => showCombatStatTooltip('defense', e);
    defenseContainer.onmouseleave = hideCombatStatTooltip;
    defenseContainer.onmousemove = (e) => updatePreviewPosition(e);
    
    const mainHandWeapon = player.equipment.find(e => e.slot === 'main_hand' || e.handedness === 'two');
    const offHandWeapon = player.equipment.find(e => e.slot === 'off_hand');
    const attackMainBtn = document.getElementById('attackMainBtn');
    const attackOffBtn = document.getElementById('attackOffBtn');
    const fireBtn = document.getElementById('fireBtn');
    
    const loadedGun = player.equipment.find(e => e.ammoType && e.loadedAmmo > 0);

    attackMainBtn.style.display = 'none';
    attackOffBtn.style.display = 'none';
    fireBtn.style.display = 'none';
    attackMainBtn.style.gridColumn = 'auto';
    attackOffBtn.style.gridColumn = 'auto';

    if (mainHandWeapon) {
        attackMainBtn.textContent = `æ”»æ’ƒ (${mainHandWeapon.name})`;
        attackMainBtn.style.display = 'block';
        if (mainHandWeapon.handedness === 'two') {
            attackMainBtn.style.gridColumn = 'span 2';
        }
    } else {
        attackMainBtn.textContent = 'æ”»æ’ƒ (ç´ æ‰‹)';
        attackMainBtn.style.display = 'block';
    }

    if (offHandWeapon) {
        attackOffBtn.textContent = `æ”»æ’ƒ (${offHandWeapon.name})`;
        attackOffBtn.style.display = 'block';
        if (!mainHandWeapon) {
             attackMainBtn.style.display = 'none';
             attackOffBtn.style.gridColumn = 'span 2';
        }
    }
    
    if (loadedGun) {
        fireBtn.style.display = 'block';
        if (attackMainBtn.style.display === 'block' && attackOffBtn.style.display === 'block') {
            attackOffBtn.style.display = 'none';
            attackMainBtn.style.gridColumn = '1 / 2';
            fireBtn.style.gridColumn = '2 / 3';
        } 
        else if (attackMainBtn.style.display === 'block') {
            attackMainBtn.style.gridColumn = '1 / 2';
            fireBtn.style.gridColumn = '2 / 3';
        }
        else if (attackOffBtn.style.display === 'block') {
            attackOffBtn.style.gridColumn = '1 / 2';
            fireBtn.style.gridColumn = '2 / 3';
        }
    }
}

function showCombatStatTooltip(stat, event) {
    const preview = document.getElementById("statusPreview");
    let contentHtml = `<strong>${stat === 'attack' ? 'æ”»æ’ƒåŠ›' : 'é˜²å¾¡åŠ›'}ã®å†…è¨³</strong><br/>`;
    let total = 0, baseStat = 0;
    if (stat === 'attack') { baseStat = player.baseAttack; total = player.attack; } else { baseStat = player.baseDefense; total = player.defense; }
contentHtml += `<div>åŸºæœ¬å€¤: ${baseStat}</div><div style="border-bottom: 1px solid #555; margin: 2px 0;"></div>`;
    player.equipment.forEach(item => {
        const durabilityFactor = (item.durability === undefined ? 100 : item.durability) / 100;
        let bonus = 0;
        if (stat === 'attack') {
             let itemAttack = item.attack || 0;
            if (item.ammoType && item.loadedAmmo === 0 && item.name === 'ãƒ©ã‚¤ãƒ•ãƒ«' && item.bayonetAttached) {
                const knife = items.find(i => i.name === 'ãƒŠã‚¤ãƒ•');
                itemAttack = knife ? knife.attack : item.attack;
            }
            bonus = itemAttack * durabilityFactor;
        } else {
            bonus = (item.defense || 0) * durabilityFactor;
        }

        if (bonus > 0) contentHtml += `<div>${item.name}: +${Math.floor(bonus)}</div>`;
    });
    contentHtml += `<div style="border-bottom: 1px solid #555; margin: 2px 0;"></div><div><strong>åˆè¨ˆ: ${total}</strong></div>`;
    preview.innerHTML = contentHtml; preview.style.display = 'block'; updatePreviewPosition(event);
}


function hideCombatStatTooltip() { document.getElementById("statusPreview").style.display = "none"; }


function combatLogMessage(msg, type = 'normal', onEndCallback) {
    const combatLog = document.getElementById('combatLog'), msgDiv = document.createElement('div');
    msgDiv.textContent = msg;
    if (type === 'playerAttack') msgDiv.style.color = 'lightblue'; else if (type === 'enemyAttack') msgDiv.style.color = 'indianred';
    else if (type === 'playerFire') msgDiv.style.color = '#e67e22';
    else if (type === 'victory') msgDiv.style.color = 'lightgreen'; else if (type === 'defeat') msgDiv.style.color = 'red';
    else if (type === 'run') msgDiv.style.color = 'yellow';
    combatLog.appendChild(msgDiv); combatLog.scrollTop = combatLog.scrollHeight;
    speak(msg, onEndCallback);
}

function showDealtDamage(dmg) {
    const damageText = document.createElement('div'); damageText.textContent = `-${dmg}`;
    damageText.style.cssText = "position: absolute; left: 50%; top: 40%; transform: translate(-50%, -50%) scale(1); font-size: 4em; font-weight: bold; color: #3498db; text-shadow: 0 0 8px #000; opacity: 0; pointer-events: none; transition: opacity 0.5s ease-out, transform 0.5s ease-out; z-index: 100;";
    const enemyPanel = document.getElementById('combatEnemy');
    enemyPanel.appendChild(damageText);
    setTimeout(() => { damageText.style.opacity = '1'; damageText.style.transform = 'translate(-50%, -50%) scale(1.5)'; }, 10);
    setTimeout(() => { damageText.style.opacity = '0'; damageText.style.transform = 'translate(-50%, -50%) scale(3)'; setTimeout(() => { if(damageText.parentNode) enemyPanel.removeChild(damageText); }, 500); }, 600);
}

function handleAttack(hand) {
    snapshotStats();
    document.getElementById('attackMainBtn').disabled = true;
    document.getElementById('attackOffBtn').disabled = true;
    document.getElementById('fireBtn').disabled = true; 
    document.getElementById('runBtn').disabled = true;
    
    playSound('attack');
    createSound(player.x, player.y, 4);
    
    let weapon, weaponName = "ç´ æ‰‹", baseDamage = player.baseAttack;
    const targetSlot = (hand === 'off') ? 'off_hand' : 'main_hand';
    weapon = player.equipment.find(e => e.slot === targetSlot);

    if (!weapon && hand === 'main') {
        weapon = player.equipment.find(e => e.handedness === 'two');
    }

    if (weapon) {
        const durabilityFactor = (weapon.durability === undefined ? 100 : weapon.durability) / 100;
        let itemAttack = weapon.attack || 0;
        
        if (weapon.ammoType && weapon.loadedAmmo === 0 && weapon.name === 'ãƒ©ã‚¤ãƒ•ãƒ«' && weapon.bayonetAttached) {
            const knife = items.find(i => i.name === 'ãƒŠã‚¤ãƒ•');
            itemAttack = knife ? knife.attack : weapon.attack;
            weaponName = "éŠƒå‰£";
        } else {
             weaponName = weapon.name;
        }
        baseDamage = Math.floor(itemAttack * durabilityFactor);
    }
    
    const playerDamage = Math.max(1, baseDamage - (currentEnemy.defense || 0) + (Math.floor(Math.random() * 5) - 2));
    currentEnemy.health -= playerDamage;
    showDealtDamage(playerDamage.toFixed(0));
    
    if (weapon && weapon.durability !== undefined) {
        weapon.durability -= 1; 
        if (weapon.durability <= 0) {
            weapon.durability = 0;
            combatLogMessage(`${weapon.name}ã¯å£Šã‚Œã¦ã—ã¾ã£ãŸï¼`, 'enemyAttack');
        }
    }
    
    combatLogMessage(`${weaponName}ã§æ”»æ’ƒï¼ ${currentEnemy.name}ã«${playerDamage.toFixed(0)}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆãŸã€‚`, 'playerAttack', () => {
        updateEquippedStats(); 
        updateCombatUI();
        // â–¼â–¼â–¼ ä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
        // ãƒ¡ã‚¤ãƒ³ã®è£…å‚™å“ãƒ»æ‰€æŒå“ãƒ‘ãƒãƒ«ã‚‚ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§æ›´æ–°ã™ã‚‹
        updateItemPanels();
        // â–²â–²â–² ä¿®æ­£ç®‡æ‰€ â–²â–²â–²
        if (currentEnemy.health <= 0) {
            endCombat(true);
        } else if (currentEnemy.flees && Math.random() < 0.5) {
            combatLogMessage(`${currentEnemy.name}ã¯é€ƒã’å‡ºã—ãŸï¼`, 'run', () => endCombat('escaped'));
        }
        else {
            enemyTurn();
        }
    });
}

function handleFire() {
    snapshotStats();
    document.getElementById('attackMainBtn').disabled = true;
    document.getElementById('attackOffBtn').disabled = true;
    document.getElementById('fireBtn').disabled = true;
    document.getElementById('runBtn').disabled = true;
    
    const gun = player.equipment.find(e => e.ammoType && e.loadedAmmo > 0);
    if (!gun) {
        document.getElementById('runBtn').disabled = false;
        return;
    }

    playSound('gunshot');
    createSound(player.x, player.y, 25); // Gunshot sound
    gun.loadedAmmo--;
    
    const playerDamage = Math.max(1, gun.fireDamage - (currentEnemy.defense || 0) + (Math.floor(Math.random() * 10) - 5));
    currentEnemy.health -= playerDamage;
    showDealtDamage(playerDamage.toFixed(0));

    combatLogMessage(`${gun.name}ã‚’ç™ºç ²ï¼ ${currentEnemy.name}ã«${playerDamage.toFixed(0)}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆãŸã€‚`, 'playerFire', () => {
        updateCombatUI();
        if (currentEnemy.health <= 0) endCombat(true);
        else enemyTurn();
    });
}


function enemyTurn() {
    playSound('damage');
    const enemyDamage = Math.max(1, currentEnemy.attack - player.defense + (Math.floor(Math.random() * 5) - 2));
    player.health -= enemyDamage; showDamage(enemyDamage.toFixed(0));
    
    const injuryChance = enemyDamage / 50;
    if (Math.random() < injuryChance) {
        const hasBleeding = player.injuries.some(i => i.type === 'bleeding');
        const hasFracture = player.injuries.some(i => i.type === 'fracture');
        
        if (enemyDamage > 15 && Math.random() < 0.3 && !hasFracture) {
            player.injuries.push({ type: 'fracture', duration: 48, splinted: false });
            log("å¼·æ‰“ã‚’å—ã‘ã€éª¨ãŒæŠ˜ã‚ŒãŸï¼", true);
        } else if (enemyDamage > 8 && Math.random() < 0.5 && !hasBleeding) {
            player.injuries.push({ type: 'bleeding' });
            log("æ·±ã„å‚·ã‚’è² ã„ã€å‡ºè¡€ãŒå§‹ã¾ã£ãŸï¼", true);
        } else {
            if (!player.injuries.some(i => i.type === 'bruise')) {
                 player.injuries.push({ type: 'bruise', duration: 24 });
                 log("æ‰“æ’²ã‚’è² ã£ãŸã€‚", true);
            }
        }
    }

    combatLogMessage(`${currentEnemy.name}ã®æ”»æ’ƒï¼ ${enemyDamage.toFixed(0)}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸã€‚`, 'enemyAttack', () => {
        updateCombatUI(); updateStatus(); updateCharacterBody();
        if (player.health <= 0) {
            endCombat(false);
        } else { 
            document.getElementById('attackMainBtn').disabled = false;
            document.getElementById('attackOffBtn').disabled = false;
            document.getElementById('fireBtn').disabled = false;
            document.getElementById('runBtn').disabled = false;
            updateCombatUI(); 
        }
    });
}


function handleRun() {
    snapshotStats();
    document.getElementById('attackMainBtn').disabled = true;
    document.getElementById('attackOffBtn').disabled = true;
    document.getElementById('fireBtn').disabled = true;
    document.getElementById('runBtn').disabled = true;
    player.thirst -= 5; player.morale -= 8;
    const escapeChance = currentEnemy.isAnimal ? 0.6 : 0.3;
    if (Math.random() < escapeChance) {
        const enemyInList = entities.find(e => e.x === currentEnemy.x && e.y === currentEnemy.y);
        if (enemyInList) enemyInList.stunnedTurns = 1;
        combatLogMessage("ãªã‚“ã¨ã‹é€ƒã’åˆ‡ã‚‹ã“ã¨ãŒã§ããŸï¼", "run", () => { updateStatus(); endCombat('escaped'); });
    } else {
        combatLogMessage("é€ƒã’ã‚‰ã‚Œãªã„ï¼", "run", () => { updateStatus(); enemyTurn(); });
    }
}

function endCombat(result) {
    const wasVictory = result === true, wasEscaped = result === 'escaped';
    const originalEnemy = { ...currentEnemy };
    const enemyIndex = entities.findIndex(e => e && currentEnemy && e.x === currentEnemy.x && e.y === currentEnemy.y);
    const cleanupAndExit = () => {
        setTimeout(() => {
            const allPanels = document.querySelectorAll('.panel');
            allPanels.forEach(panel => {
                 if (['combatPanel', 'dialoguePanel', 'tradePanel', 'storagePanel'].includes(panel.id)) {
                    panel.style.display = 'none';
                 } else if(!panel.classList.contains('minimized')) {
                    panel.style.display = 'block';
                    if (['mapPanel', 'inventoryPanel', 'equipmentPanel', 'minimapPanel', 'craftingPanel', 'currentLocationPanel'].includes(panel.id)) {
                       panel.style.display = 'flex';
                    }
                 }
            });
            isInteractionActive = false;
            
            // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
            // æˆ¦é—˜ã«å‹åˆ©ã—ãŸå ´åˆã«ã®ã¿ã€æ•µã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’ã‚²ãƒ¼ãƒ ã‹ã‚‰å‰Šé™¤ã™ã‚‹
            if (wasVictory) {
                // æ­»ä½“ã‚„æˆ¦åˆ©å“ã‚’ç”Ÿæˆã™ã‚‹
                if (originalEnemy.isAnimal && originalEnemy.loot) {
                    const corpse = { 
                        x: originalEnemy.x, 
                        y: originalEnemy.y, 
                        type: 'corpse', 
                        name: `${originalEnemy.name}ã®æ­»ä½“`, 
                        graphic: 'ğŸ¦´', 
                        duration: 48,
                        isAnimalCorpse: true,
                        unbutchered: true,
                        potentialLoot: originalEnemy.loot
                    };
                    placedObjects.push(corpse);
                } else if (!originalEnemy.isZombie) {
                    const lootItems = [...(originalEnemy.inventory || []), ...(originalEnemy.equipment || [])];
                    const corpse = { 
                        x: originalEnemy.x, 
                        y: originalEnemy.y, 
                        type: 'corpse', 
                        name: `${originalEnemy.name}ã®æ­»ä½“`, 
                        graphic: 'ğŸ¦´', 
                        duration: 24, 
                        isHumanCorpse: true, 
                        unsearched: true, 
                        potentialLoot: lootItems
                    };
                    placedObjects.push(corpse);
                }

                // å‹åˆ©ã—ãŸå ´åˆã®ã¿ã€entitiesé…åˆ—ã‹ã‚‰æ•µã‚’å‰Šé™¤ã™ã‚‹
                if (enemyIndex > -1) {
                    entities.splice(enemyIndex, 1);
                }
            }
            // é€ƒèµ°ã—ãŸå ´åˆ(wasVictoryãŒfalseã®æ™‚)ã¯ã€æ•µã¯å‰Šé™¤ã•ã‚Œãšã«ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«æ®‹ã‚‹
            // â–²â–²â–² ã“ã“ã¾ã§ãŒä¿®æ­£ç®‡æ‰€ â–²â–²â–²

            currentEnemy = null; currentNPC = null;
            drawMap(); updateStatus(); updateCharacterBody(); updateCurrentLocationPanel(false);
        }, wasEscaped ? 100 : 1500); 
    };

    if (wasVictory) { playSound('victory'); combatLogMessage(`${originalEnemy.name}ã‚’å€’ã—ãŸï¼`, 'victory', cleanupAndExit); } 
    else if (wasEscaped) {
        // é€ƒã’ãŸå ´åˆã¯å˜ç´”ã«ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å‡¦ç†ã‚’å‘¼ã¶
        cleanupAndExit();
    } 
    else { 
        playSound('defeat');
        combatLogMessage(`${originalEnemy.name}ã«å€’ã•ã‚Œã¦ã—ã¾ã£ãŸ...`, 'defeat', () => {
            setTimeout(() => {
                const gameOverMessage = `æˆ¦é—˜ã«æ•—åŒ—ã—ã€ã‚ãªãŸã¯åŠ›å°½ããŸã€‚`;
                speak(gameOverMessage + " ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼"); handleGameOver(gameOverMessage);
                document.getElementById('combatPanel').style.display = 'none';
                isInteractionActive = false; currentEnemy = null; currentNPC = null;
            }, 1500);
        });
    }
}

// --- Game Over System ---
function initGame() {
    playSound('start');
    stopWeatherEffect();
    stopClouds();
    document.getElementById('startScreen').style.display = 'none';
    document.getElementById('gameClearScreen').style.display = 'none';
    document.querySelectorAll('.panel').forEach(p => p.style.display = 'none');
    restartGame();
}

function restartGame() {
      const panels = ["mapPanel", "statusPanel", "turnPanel", "logPanel", "inventoryPanel", "equipmentPanel", "craftingPanel", "characterPanel", "currentLocationPanel", "minimapPanel"];
      panels.forEach(id => {
      const panel = document.getElementById(id);
      if (panel) {
          panel.style.display = 'block';
           if (['mapPanel', 'inventoryPanel', 'equipmentPanel', 'minimapPanel', 'craftingPanel', 'currentLocationPanel'].includes(id)) {
              panel.style.display = 'flex';
          }
      }
  });
    document.getElementById('itemDetailPanel').style.display = 'none';
    document.getElementById('gameClearScreen').style.display = 'none';
    genMap(); generateWeatherAndTemperature(); snapshotStats();
    drawMap(); updateStatus(); updateItemPanels(); logClear();
    updateCurrentLocationPanel(false); updateCharacterBody(); updateCharacterInfo(); updateTurnInfo();
    log(generateBackstory());
    speakQueuedLogs(); // Add this line right here
    updateBackgroundColor();
    isInteractionActive = false;
    drawMinimap();
    updateMovementButtons();
}

function showRetryModal(message) {
    if (document.getElementById("retryModal")) return;
    const modalDiv = document.createElement("div"); modalDiv.id = "retryModal";
    modalDiv.style.cssText = `position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #222; color: white; padding: 30px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.6); z-index: 9999; text-align: center; font-family: sans-serif;`;
    modalDiv.innerHTML = `<p style="font-size: 1.2em; margin-bottom: 20px;">${message}<br>ã‚‚ã†ä¸€åº¦æŒ‘æˆ¦ã—ã¾ã™ã‹ï¼Ÿ</p><button id="retryYesBtn" style="background: #4CAF50; color: white; border: none; padding: 10px 20px; margin-right: 10px; border-radius: 5px; cursor: pointer;">ã¯ã„</button><button id="retryNoBtn" style="background: #f44336; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">ã„ã„ãˆ</button>`;
    document.body.appendChild(modalDiv);
    document.getElementById("retryYesBtn").onclick = () => { modalDiv.remove(); restartGame(); };
    document.getElementById("retryNoBtn").onclick = () => { modalDiv.innerHTML = '<p style="font-size: 1.2em;">ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</p>'; };
}

function handleGameOver(message) {
    isInteractionActive = true;
    stopWeatherEffect();
    stopClouds();
    document.querySelectorAll('.panel').forEach(p => p.style.display = 'none');
    showRetryModal(message);
}
// â–¼â–¼â–¼ ã“ã®é–¢æ•°ã‚’ã¾ã‚‹ã”ã¨ã‚³ãƒ”ãƒ¼ã—ã¦è¿½åŠ  â–¼â–¼â–¼
function waitOneTurn() {
    if(isInteractionActive) return; // ä»–ã®æ“ä½œä¸­ã¯å®Ÿè¡Œã—ãªã„
    snapshotStats();
    log("ä½•ã‚‚ã—ãªã„ã§1ã‚¿ãƒ¼ãƒ³éã”ã—ãŸã€‚");
    advanceTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    checkGameOver();
    updateTurnInfo();
    speakQueuedLogs();
}
// â–²â–²â–² ã“ã“ã¾ã§ â–²â–²â–²
function triggerGameClear() {
    isInteractionActive = true; log("ã‚µãƒ«ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ã‚·ãƒ†ã‚£ã«åˆ°ç€ã—ãŸ"); playSound('victory');
    document.querySelectorAll('.panel').forEach(p => p.style.display = 'none');
    const clearScreen = document.getElementById('gameClearScreen'), gateArt = document.getElementById('gateArt'), clearHeader = document.getElementById('clearHeader'), clearMessage = document.getElementById('clearMessage');
    const art1 = `
      ||||||||
    ||||||||||||
   | o ______ o |
   | o|      |o |
   | o|______|o |
    ||||||||||||
      ||||||||`, msg1 = `é•·ã„æ—…è·¯ã®æœ«ã€ã‚ãªãŸã¯æœ€å¾Œã®æ¥½åœ’ã€Œã‚µãƒ«ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ã‚·ãƒ†ã‚£ã€ã«ãŸã©ã‚Šç€ã„ãŸ...`;
    gateArt.textContent = art1; clearMessage.textContent = msg1;
    clearScreen.style.display = 'flex'; speak(clearHeader.textContent); speak(msg1);
    setTimeout(() => {
        const art2 = `
      |||    |||
    |||||    |||||
   | o |    | o |
   | o |    | o |
   | o |____| o |
    |||||    |||||
      |||    |||`, msg2 = `ã‚²ãƒ¼ãƒˆãŒé–‹ãã€ä¸­ã‹ã‚‰æ¸©ã‹ã„å…‰ãŒå·®ã—è¾¼ã‚€ã€‚ã‚ˆãã‚„ã£ãŸã€ç”Ÿå­˜è€…ã€‚ã‚ãªãŸã®æˆ¦ã„ã¯ã€ä»Šçµ‚ã‚ã£ãŸã€‚`;
        gateArt.textContent = art2; clearMessage.textContent = msg2; speak(msg2);
    }, 3000);
}

function checkGameOver() {
    if (player.health <= 0 && !isInteractionActive) {
        let causeMessage = "";
        if (player.bodyTemp >= 41) causeMessage = `è‡´å‘½çš„ãªé«˜ä½“æ¸©(${player.bodyTemp.toFixed(1)}â„ƒ)ã«ã‚ˆã‚‹ç†±ä¸­ç—‡ã§ã™ã€‚`;
        else if (player.bodyTemp <= 34) causeMessage = `è‡´å‘½çš„ãªä½ä½“æ¸©(${player.bodyTemp.toFixed(1)}â„ƒ)ã«ã‚ˆã‚‹ä½ä½“æ¸©ç—‡ã§ã™ã€‚`;
        else if (player.thirst <= 0 && player.hunger <= 0) causeMessage = "é£¢ãˆã¨æ¸‡ããŒé™ç•Œã«é”ã—ã¾ã—ãŸã€‚";
        else if (player.thirst <= 0) causeMessage = "æ·±åˆ»ãªè„±æ°´ç—‡çŠ¶ã«é™¥ã‚Šã¾ã—ãŸã€‚";
        else if (player.hunger <= 0) causeMessage = "æ¥µåº¦ã®é£¢é¤“çŠ¶æ…‹ã§ã—ãŸã€‚";
        else if (player.morale <= 0) causeMessage = "çµ¶æœ›ã«æ‰“ã¡ã®ã‚ã•ã‚Œã¾ã—ãŸã€‚";
        else causeMessage = "èº«ä½“ãŒè¡°å¼±ã—ãã£ã¦ã—ã¾ã„ã¾ã—ãŸã€‚";
        const gameOverMessage = `ã‚ãªãŸã¯åŠ›å°½ãã¾ã—ãŸã€‚æ­»å› : ${causeMessage}`;
        speak(gameOverMessage + " ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼");
        handleGameOver(gameOverMessage);
    }
}

function playZombieSound() { playSound('zombie'); }

function updateCurrentLocationPanel(isEncounter, entity = null) {
  const locationName = document.getElementById("locationName"),
      locationAscii = document.getElementById("locationAscii"),
      droppedItemsList = document.getElementById("droppedItemsList"),
      locationActions = document.getElementById("locationActions");
      
  locationActions.innerHTML = ''; 
  let tile = map[player.y][player.x];
  
  if (isEncounter && entity) {
      locationName.textContent = entity.name;
      locationAscii.textContent = entity.ascii.high || entity.ascii;
  } else {
      if (player.isInside) {
          locationName.textContent = "å°å±‹ã®ä¸­";
      } else {
          locationName.textContent = tile.loc.name;
      }
      locationAscii.textContent = tile.loc.ascii;

      if (tile.loc.name === 'å°å±‹') {
          const cabinBtn = document.createElement('button');
          if (player.isInside) {
              cabinBtn.textContent = 'å°å±‹ã‹ã‚‰å‡ºã‚‹';
              cabinBtn.onclick = exitCabin;
          } else {
              cabinBtn.textContent = 'å°å±‹ã«å…¥ã‚‹';
              cabinBtn.onclick = enterCabinWithEncounter;
          }
          locationActions.appendChild(cabinBtn);
      }

      if (tile.loc.name === 'æ± ') {
          const washBtn = document.createElement('button');
          washBtn.textContent = 'ä½“ã‚’æ´—ã†';
          washBtn.onclick = washBody;
          if (player.bodyOdor < 10) washBtn.disabled = true;
          locationActions.appendChild(washBtn);
      }

      if (tile.loc.name === 'æ£®æ—') {
          const gatherBtn = document.createElement('button');
          gatherBtn.id = 'gatherLogBtn';
          gatherBtn.textContent = `ä¸¸å¤ªã‚’åé›†ã™ã‚‹ (${tile.logSupply || 0}æœ¬)`;
          const hasAxe = player.inventory.some(i => i.isAxe) || player.equipment.some(i => i.isAxe);
          if (!hasAxe || !tile.logSupply || tile.logSupply <= 0) {
              gatherBtn.disabled = true;
          }
          gatherBtn.onclick = gatherLog;
          locationActions.appendChild(gatherBtn);
      }
  }

  droppedItemsList.innerHTML = "";
  const locationKey = `${player.x},${player.y}`,
      itemsHere = droppedItems[locationKey] || [];
  if (itemsHere.length === 0) {
      droppedItemsList.textContent = "ãªã—";
      return;
  }
  itemsHere.forEach((item, idx) => {
      let div = document.createElement("div");
      div.className = "item";
      let descText = "";
      if (item.type === "consumable" && item.freshness !== undefined) descText = item.freshness > 0 ? `æ–°é®®åº¦: ${item.freshness.toFixed(0)}%` : `è…ã£ã¦ã„ã‚‹`;
      else if ((item.type === "equipment" || item.type === "clothing" || item.type === "tool") && item.durability !== undefined) descText = `è€ä¹…åº¦: ${item.durability.toFixed(0)}%`;
      div.innerHTML = `<span style="margin-right: 5px;">${item.graphic}</span>${getItemDisplayName(item)}${descText ? ` <span style="font-size: smaller; color: #888;">(${descText})</span>` : ''}`;
      div.onclick = () => showItemDetail(item, idx, 'dropped');
      droppedItemsList.appendChild(div);
  });
}
function enterCabinWithEncounter() {
    if (Math.random() < 0.05) {
        log("å°å±‹ã®ãƒ‰ã‚¢ã‚’ã‚†ã£ãã‚Šã¨é–‹ã‘ã‚‹ã¨...ä¸­ã«èª°ã‹ã„ã‚‹ï¼");
        
        // å‡ºç¾ã™ã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®ãƒªã‚¹ãƒˆ
        const possibleEncounters = [
            { type: 'Zombie', chance: 35 },
            { type: 'Bear', chance: 10 },
            { type: 'Wolf', chance: 15 },
            { type: 'Survivor', chance: 20 },
            { type: 'Trader', chance: 5 },
            { type: 'Raider', chance: 15 }
        ];

        let totalChance = possibleEncounters.reduce((sum, e) => sum + e.chance, 0);
        let randomValue = Math.random() * totalChance;
        let selectedType;

        for (const encounter of possibleEncounters) {
            randomValue -= encounter.chance;
            if (randomValue <= 0) {
                selectedType = encounter.type;
                break;
            }
        }

        let newEntity;
        if (selectedType === 'Zombie') {
            newEntity = { type: 'Zombie', name: 'æ½œã‚“ã§ã„ãŸã‚¾ãƒ³ãƒ“', icon: 'ğŸ’€', x: player.x, y: player.y, health: 60, attack: 10, defense: 2, visionRange: 3, isZombie: true, stunnedTurns: 0, aiState: 'wandering', target: null, investigationTarget: null };
        } else if (selectedType === 'Bear' || selectedType === 'Wolf') {
            const template = wildlifeTemplates.find(t => t.type === selectedType);
            newEntity = { ...JSON.parse(JSON.stringify(template)), x: player.x, y: player.y, stunnedTurns: 0, aiState: 'attacking', target: player };
        } else {
            newEntity = generateNPC();
            newEntity.type = selectedType;
            const template = npcTemplates.find(t => t.type === selectedType);
            newEntity.name = template.name;
            newEntity.icon = template.icon;
            newEntity.x = player.x;
            newEntity.y = player.y;
        }
        
        player.isInside = true;
        updateCurrentLocationPanel(false);
        
        // æ•µå¯¾çš„ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãªã‚‰æˆ¦é—˜é–‹å§‹
        if (newEntity.isZombie || newEntity.type === 'Bear' || newEntity.type === 'Wolf' || newEntity.type === 'Raider') {
            setTimeout(() => startCombat(newEntity), 500);
        } else {
            // å‹å¥½çš„ãªã‚‰ä¼šè©±ã‚¤ãƒ™ãƒ³ãƒˆé–‹å§‹
            currentNPC = newEntity;
            setTimeout(() => startNPCEncounter(), 500);
        }

    } else {
        // é€šå¸¸é€šã‚Šã€èª°ã‚‚ã„ãªã„å ´åˆ
        player.isInside = true;
        log("å°å±‹ã«å…¥ã£ãŸã€‚é›¨é¢¨ã‚’ã—ã®ã’ã‚‹ã ã‚ã†ã€‚");
        updateCurrentLocationPanel(false);
    }
}

function exitCabin() {
    player.isInside = false;
    log("å°å±‹ã‹ã‚‰å‡ºãŸã€‚");
    updateCurrentLocationPanel(false);
    drawMap(); // â† ã“ã®è¡Œã‚’è¿½åŠ ã—ã¦ãƒãƒƒãƒ—ã‚’å†æç”»
}
function updateCharacterBody() {
  const pre = document.getElementById("charBody");
  if (player.health <= 0) {
      pre.textContent = charBodyDead;
      return;
  }
  let healthPercent = (player.health / maxStats.health) * 100;
  if(healthPercent > 70) pre.textContent = playerAsciiStates.high;
  else if(healthPercent > 40) pre.textContent = playerAsciiStates.medium;
  else if(healthPercent > 10) pre.textContent = playerAsciiStates.low;
  else pre.textContent = playerAsciiStates.critical;
}

function updateCharacterInfo() {
  document.getElementById("charName").textContent = character.fullName;
  document.getElementById("charAge").textContent = character.age;
  document.getElementById("charGender").textContent = character.gender;
  document.getElementById("charJob").textContent = character.job;
  document.getElementById("charRace").textContent = character.race;
  const traitsContainer = document.getElementById("charTraits");
  traitsContainer.innerHTML = "";
  character.traits.forEach(traitName => {
      const trait = characterTraits.find(t => t.name === traitName);
      if (trait) {
          const pill = document.createElement("span");
          pill.className = "trait-pill";
          pill.textContent = trait.name;
          pill.addEventListener("mouseenter", (e) => showTraitDetail(e, trait));
          pill.addEventListener("mouseleave", hideTraitDetail);
          traitsContainer.appendChild(pill);
      }
  });
  const memoryContainer = document.getElementById("memoryContainer");
  memoryContainer.innerHTML = "";
  if (character.salvationCityHint) {
      const memoryDiv = document.createElement("div");
      memoryDiv.style.cssText = "color: #f1c40f; font-size: 12px;";
      memoryDiv.innerHTML = `<strong>è¨˜æ†¶:</strong><br>${character.salvationCityHint}`;
      memoryContainer.appendChild(memoryDiv);
  }
}

function showTraitDetail(event, trait) {
  const preview = document.getElementById("statusPreview");
  preview.style.display = "block";
  preview.style.pointerEvents = "none";
  let contentHtml = `<strong>${trait.name}</strong><br><div style="margin-top: 5px; margin-bottom: 5px;">${trait.desc}</div>`;
  if (trait.effects) {
      contentHtml += `<div style="margin-top: 5px;"><strong>åŠ¹æœ:</strong></div>${Object.keys(trait.effects).map(stat => {
        const change = trait.effects[stat], sign = change > 0 ? "+" : "", className = change > 0 ? "positive" : "negative";
        return `<div class="preview-stat"><span class="preview-stat-name">${getStatName(stat)}:</span><span class="preview-change ${className}">${sign}${change}</span></div>`;
    }).join('')}`;
  }
  preview.innerHTML = contentHtml;
  updatePreviewPosition(event);
}

function showEntityTooltip(entity, event) {
    const preview = document.getElementById("statusPreview");
    
    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
    const tile = map[entity.y][entity.x];
    let contentHtml = `<strong>${tile.loc.name}</strong>`;
    if (tile.loc.blocksVision) {
        contentHtml += `<div style="color: indianred; font-size: 0.9em;">(è¦–ç•Œã‚’é®ã‚‹)</div>`;
    }
    contentHtml += `<div style="border-top: 1px solid #555; margin-top:5px; padding-top:5px;"><strong>${entity.name}</strong><br/>`;
    // â–²â–²â–² ã“ã“ã¾ã§ â–²â–²â–²

    contentHtml += `<div>ä½“åŠ›: ${entity.health.toFixed(0)}</div>`;
    if (entity.equipment && entity.equipment.length > 0) {
        contentHtml += `<div style="margin-top: 5px; border-top: 1px solid #555; padding-top: 5px;"><strong>è£…å‚™:</strong></div>`;
        entity.equipment.forEach(item => {
            contentHtml += `<div>${item.graphic} ${item.name}</div>`;
        });
    } else if (!entity.isZombie) contentHtml += `<div style="margin-top: 5px; border-top: 1px solid #555; padding-top: 5px;"><strong>è£…å‚™:</strong> ãªã—</div>`;
    
    // â–¼â–¼â–¼ é–‰ã˜ã‚¿ã‚°ã‚’è¿½åŠ  â–¼â–¼â–¼
    contentHtml += `</div>`; 

    preview.innerHTML = contentHtml;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}

function hideTraitDetail() { document.getElementById("statusPreview").style.display = "none"; }

function drawMinimap() {
  const canvas = document.getElementById('minimapCanvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  
  canvas.width = canvas.offsetWidth;
  canvas.height = canvas.offsetHeight;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  const tileSize = minimapZoomLevel;

  const halfTilesX = canvas.width / (2 * tileSize);
  const halfTilesY = canvas.height / (2 * tileSize);
  
  const startMapX = Math.floor(player.x - halfTilesX);
  const endMapX = Math.ceil(player.x + halfTilesX);
  const startMapY = Math.floor(player.y - halfTilesY);
  const endMapY = Math.ceil(player.y + halfTilesY);

  for (let mapY = startMapY; mapY < endMapY; mapY++) {
    for (let mapX = startMapX; mapX < endMapX; mapX++) {
      if (mapX < 0 || mapY < 0 || mapX >= mapSize || mapY >= mapSize) {
        continue;
      }
      
      const tile = map[mapY][mapX];
      if (!tile.explored) {
        continue; 
      }
      
      let color = '#333'; 
      switch (tile.biome) {
        case 'Plains': color = '#5a6349'; break;
        case 'Forest': color = '#2d572c'; break;
        case 'Town':   color = '#666666'; break;
        case 'Road':   color = '#444444'; break;
      }
      
      const placedObject = placedObjects.find(obj => obj.x === mapX && obj.y === mapY);
      if (placedObject && placedObject.type === 'sleeping_bag') {
          color = '#9b59b6'; // å¯è¢‹ç”¨ã®ç‰¹åˆ¥ãªè‰²ï¼ˆç´«ï¼‰
      }

      const drawX = (canvas.width / 2) + (mapX - player.x - 0.5) * tileSize;
      const drawY = (canvas.height / 2) + (mapY - player.y - 0.5) * tileSize;

      ctx.fillStyle = color;
      ctx.fillRect(drawX, drawY, tileSize, tileSize);
    }
  }

  // â–¼â–¼â–¼ ä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
  // ã‚‚ã—ã‚µãƒ«ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ã‚·ãƒ†ã‚£ãŒã€Œç™ºè¦‹æ¸ˆã¿ã€ã®å ´åˆã®ã¿ãƒŸãƒ‹ãƒãƒƒãƒ—ã«è¡¨ç¤ºã™ã‚‹
  if (salvationCityDiscovered) {
      const cityDrawX = (canvas.width / 2) + (salvationCityCoords.x - player.x - 0.5) * tileSize;
      const cityDrawY = (canvas.height / 2) + (salvationCityCoords.y - player.y - 0.5) * tileSize;
      ctx.fillStyle = '#ffd700'; 
      ctx.fillRect(cityDrawX, cityDrawY, tileSize, tileSize);
  }
  // â–²â–²â–² ä¿®æ­£ç®‡æ‰€ â–²â–²â–²

  ctx.fillStyle = '#ff0000'; 
  ctx.fillRect((canvas.width / 2) - (tileSize / 2), (canvas.height / 2) - (tileSize / 2), tileSize, tileSize);
}

function showDamage(dmg) {
  const dp = document.getElementById("damagePop");
  const popContainer = currentEnemy ? document.getElementById('combatPlayer') : document.body;
  if (currentEnemy) popContainer.style.position = 'relative';
  popContainer.appendChild(dp);
  dp.textContent = `-${dmg}`;
  dp.style.opacity = "1";
  dp.style.transform = "translate(-50%, -50%) scale(1.5)";
  setTimeout(() => {
      dp.style.opacity = "0";
      dp.style.transform = "translate(-50%, -50%) scale(3)";
  }, 100);
}

function showItemDetail(item, index, source) {
  const panel = document.getElementById("itemDetailPanel"),
      header = document.getElementById("itemDetailHeader"),
      graphic = document.getElementById("itemDetailGraphic"),
      content = document.getElementById("itemDetailContent");
  currentItemDetail = { item, index, source };
  header.innerHTML = `${getItemDisplayName(item)}`;
  graphic.textContent = item.graphic;
  let details = `<div class="item-description">${item.desc}</div>`;
  if (item.type === "consumable") {
      details += `<strong>ã‚¿ã‚¤ãƒ—</strong> æ¶ˆè²»å“<br>`;
if (item.freshness !== undefined) details += item.freshness > 0 ? `<strong>æ–°é®®åº¦</strong> ${item.freshness.toFixed(0)}%<br>` : `<strong>çŠ¶æ…‹</strong> <span style="color:indianred;">è…ã£ã¦ã„ã‚‹</span><br>`;
  } else if (item.type === "container") {
      details += `<strong>ã‚¿ã‚¤ãƒ—</strong> å®¹å™¨<br>`;
      if (item.content) details += (item.content.type === 'clean') ? `<strong>ä¸­èº«</strong> ç¶ºéº—ãªæ°´ (æ–°é®®åº¦: ${item.content.freshness.toFixed(0)}%)<br>` : `<strong>ä¸­èº«</strong> <span style="color:indianred;">æ±šã‚ŒãŸæ°´</span><br>`;
      else details += `<strong>ä¸­èº«</strong> ç©º<br>`;
  } else if (item.type === "equipment" || item.type === "clothing" || item.type === "tool") {
      details += `<strong>ã‚¿ã‚¤ãƒ—</strong> ${item.type}<br>`;
      if(item.handedness) details += `<strong>ç¨®é¡</strong> ${item.handedness === 'one' ? 'ç‰‡æ‰‹' : 'ä¸¡æ‰‹'}<br>`;
      if (item.slot) details += `<strong>ã‚¹ãƒ­ãƒƒãƒˆ</strong> ${getSlotName(item.slot)}<br>`;
      if (item.durability !== undefined) details += `<strong>è€ä¹…åº¦</strong> ${item.durability.toFixed(0)}%<br>`;
      
      const durabilityFactor = (item.durability === undefined ? 100 : item.durability) / 100;
      
      if (item.attack) {
          const effectiveAttack = Math.floor(item.attack * durabilityFactor);
          details += `<strong>æ”»æ’ƒåŠ›(è¿‘æ¥)</strong> <span class="item-effect-positive">+${effectiveAttack}</span> (åŸºæœ¬å€¤: ${item.attack})<br>`;
      }
      if (item.fireDamage) {
          details += `<strong>æ”»æ’ƒåŠ›(å°„æ’ƒ)</strong> <span class="item-effect-positive">${item.fireDamage}</span><br>`;
      }
      if (item.defense) {
          const effectiveDefense = Math.floor(item.defense * durabilityFactor);
          details += `<strong>é˜²å¾¡åŠ›</strong> <span class="item-effect-positive">+${effectiveDefense}</span> (åŸºæœ¬å€¤: ${item.defense})<br>`;
      }
      if (item.insulation) {
          const effectiveInsulation = (item.insulation * durabilityFactor).toFixed(1);
          details += `<strong>ä¿æ¸©æ€§</strong> <span class="item-effect-positive">+${effectiveInsulation}</span> (åŸºæœ¬å€¤: ${item.insulation.toFixed(1)})<br>`;
      }

      if (item.effects && item.effects.maxWeight) details += `<strong>æœ€å¤§é‡é‡</strong> <span class="item-effect-positive">+${item.effects.maxWeight}</span><br>`;
      if (item.effects && item.effects.maxVolume) details += `<strong>æœ€å¤§å®¹é‡</strong> <span class="item-effect-positive">+${item.effects.maxVolume}</span><br>`;
      if (item.volumePenalty) details += `<strong>è£…å‚™æ™‚å®¹é‡</strong> <span class="item-effect-negative">-${item.volumePenalty.toFixed(1)}</span><br>`;
      if (item.isTorch) details += `<strong>æŒç¶š</strong> ${item.duration}ã‚¿ãƒ¼ãƒ³<br>`;
  } else if (item.type === 'material') { details += `<strong>ã‚¿ã‚¤ãƒ—</strong> ç´ æ<br>`; } else if (item.type === 'water_source') { details += `<strong>ã‚¿ã‚¤ãƒ—</strong> æ°´æº<br>`; } else if (item.type === 'ammo') { details += `<strong>ã‚¿ã‚¤ãƒ—</strong> å¼¾è–¬<br>`; }
  details += `<strong>é‡ã•</strong> ${item.weight || 0}<br><strong>å®¹é‡</strong> ${item.volume || 0}<br><strong>ä¾¡å€¤</strong> ${item.value || 0}<br>`;
  content.innerHTML = details;
  document.getElementById("itemDetailActions").querySelectorAll('button').forEach(btn => btn.style.display = 'none');
  document.getElementById("closeItemDetailBtn").style.display = 'inline-block';

  const unlitCampfireNearby = placedObjects.some(c => c.type === 'unlit_campfire' && c.x === player.x && c.y === player.y);
  const isOnCampfire = placedObjects.some(c => c.type === 'campfire' && c.x === player.x && c.y === player.y);
  const hasBlade = player.inventory.some(i => i.isBlade) || player.equipment.some(i => i.isBlade);
  const hasCanOpener = player.inventory.some(i => i.name === 'ç¼¶åˆ‡ã‚Š');
  const hasLighter = player.inventory.some(i => i.name === 'ãƒ©ã‚¤ã‚¿ãƒ¼');

  if (item.throwable && source === 'inventory') {
      document.getElementById("throwItemBtn").style.display = 'inline-block';
      document.getElementById("throwItemBtn").onclick = () => startTargeting(item, index, source);
  }

  const wipeClothBtn = document.getElementById("wipeClothBtn");
  const wringClothBtn = document.getElementById("wringClothBtn");

  if ((item.name === 'ã‚¿ã‚ªãƒ«' || item.name === 'å¸ƒåˆ‡ã‚Œ') && source === 'inventory') {
      const hasSoakingWetClothes = player.equipment.some(e => e.type === 'clothing' && e.wetness === 'soaking_wet');
      if (hasSoakingWetClothes) {
          wipeClothBtn.style.display = 'inline-block';
          wipeClothBtn.onclick = () => wipeClothes(item, index, source);
      }
  }

  if (item.type === 'clothing' && item.wetness === 'soaking_wet' && source === 'equipment') {
      wringClothBtn.style.display = 'inline-block';
      wringClothBtn.onclick = () => wringCloth(item, index, source);
  }

  if (source === 'inventory' || source === 'equipment') {
      if (dismantleRecipes[item.name]) {
          document.getElementById("dismantleBtn").style.display = 'inline-block';
          document.getElementById("dismantleBtn").onclick = () => dismantleItem(index, source);
      }
  }

  if (source === 'inventory') {
      document.getElementById("dropItemBtn").style.display = 'inline-block';
      document.getElementById("dropItemBtn").onclick = () => { dropItem(index); hideItemDetail(); };
      if (item.type === "consumable") {
          if (item.name === "ãƒ€ã‚¯ãƒˆãƒ†ãƒ¼ãƒ—") {
              document.getElementById("repairItemBtn").style.display = 'inline-block';
              document.getElementById("repairItemBtn").onclick = () => repairItemWithTape(index);
          } else if (item.isSealed) {
              if (hasCanOpener || hasBlade) {
                  document.getElementById("openItemBtn").style.display = 'inline-block';
                  document.getElementById("openItemBtn").onclick = () => openCan(index);
              }
              document.getElementById("forceOpenItemBtn").style.display = 'inline-block';
              document.getElementById("forceOpenItemBtn").onclick = () => forceOpenCan(index);
          } else {
              document.getElementById("useItemBtn").style.display = 'inline-block';
              document.getElementById("useItemBtn").onclick = () => useItem(index, 'inventory');
          }
          if (cookingMap[item.name] && isOnCampfire) {
              document.getElementById("cookItemBtn").style.display = 'inline-block';
              document.getElementById("cookItemBtn").onclick = () => cookFood(index);
          }
      } else if (item.type === 'container') {
          if (item.content) {
              document.getElementById("drinkItemBtn").style.display = 'inline-block';
              document.getElementById("drinkItemBtn").onclick = () => drinkFromContainer(index);
              document.getElementById("emptyItemBtn").style.display = 'inline-block';
              document.getElementById("emptyItemBtn").onclick = () => emptyContainer(index);
              if (item.content.type === 'dirty' && isOnCampfire) {
                  document.getElementById("boilItemBtn").style.display = 'inline-block';
                  document.getElementById("boilItemBtn").onclick = () => boilWater(index);
              }
          }
      } else if (item.type === "equipment" || item.type === "clothing") {
          document.getElementById("equipItemBtn").style.display = 'inline-block';
          document.getElementById("equipItemBtn").onclick = () => equipItem(index);
      } else if (item.type === 'tool') {
          if (item.useAction && !['startFire', 'wipeClothes'].includes(item.useAction)) {
              document.getElementById("useItemBtn").style.display = 'inline-block';
              document.getElementById("useItemBtn").onclick = () => useItem(index, 'inventory');
          }
          if (item.useAction === 'startFire' && unlitCampfireNearby) {
              document.getElementById("startFireBtn").style.display = 'inline-block';
              document.getElementById("startFireBtn").onclick = () => startFire(item, index, 'inventory');
          }
      } else if (item.name === 'æ') {
          if (isOnCampfire) {
              document.getElementById("addFuelBtn").style.display = 'inline-block';
              document.getElementById("addFuelBtn").onclick = () => addFuelToCampfire(index);
          }
          if (hasLighter) {
              document.getElementById("craftTorchBtn").style.display = 'inline-block';
              document.getElementById("craftTorchBtn").onclick = () => craftTorchWithLighter(index);
          }
      } else if (item.type === 'ammo') {
          const gunToReload = player.equipment.find(e => e.ammoType === item.ammoType && e.loadedAmmo < e.ammoCapacity);
          if (gunToReload) {
              document.getElementById("reloadGunBtn").style.display = 'inline-block';
              document.getElementById("reloadGunBtn").onclick = () => reloadWeapon();
          }
      }
  } else if (source === 'equipment') {
      document.getElementById("unequipItemBtn").style.display = 'inline-block';
      document.getElementById("unequipItemBtn").onclick = () => { unequipItem(index); hideItemDetail(); };
      if (item.useAction === 'startFire' && unlitCampfireNearby) {
          document.getElementById("startFireBtn").style.display = 'inline-block';
          document.getElementById("startFireBtn").onclick = () => startFire(item, index, 'equipment');
      }
      if (item.ammoType && item.loadedAmmo < item.ammoCapacity && player.inventory.some(i => i.ammoType === item.ammoType)) {
          document.getElementById("reloadGunBtn").style.display = 'inline-block';
          document.getElementById("reloadGunBtn").onclick = () => reloadWeapon(index);
      }
      // â˜…ã“ã“ã‹ã‚‰è¿½åŠ 
      if (item.ammoType && item.loadedAmmo > 0) {
          document.getElementById("unloadGunBtn").style.display = 'inline-block';
          document.getElementById("unloadGunBtn").onclick = () => unloadWeapon(index);
      }
      // â˜…ã“ã“ã¾ã§è¿½åŠ 
      if (item.name === 'ãƒ©ã‚¤ãƒ•ãƒ«' && !item.bayonetAttached && player.inventory.some(i => i.name === 'ãƒŠã‚¤ãƒ•')) {
          document.getElementById("attachBayonetBtn").style.display = 'inline-block';
          document.getElementById("attachBayonetBtn").onclick = () => attachBayonet(index);
      }
  } else if (source === 'dropped') {
      if (item.type === 'water_source') {
          document.getElementById("drinkItemBtn").style.display = 'inline-block';
          document.getElementById("drinkItemBtn").onclick = drinkFromSource;
          document.getElementById("fillItemBtn").style.display = 'inline-block';
          document.getElementById("fillItemBtn").onclick = fillContainerFromSource;
      } else {
          document.getElementById("pickupItemBtn").style.display = 'inline-block';
          document.getElementById("pickupItemBtn").onclick = () => pickUpItemFromGround(index);
      }
  }
  panel.style.display = 'block';
  panel.style.top = "100px";
  panel.style.left = "100px";
  panel.style.transform = "none";
  bringToFront(panel);
}

function getStatName(stat) { switch (stat) { case 'health': return 'ä½“åŠ›'; case 'hunger': return 'ç©ºè…¹'; case 'thirst': return 'æ¸‡ã'; case 'morale': return 'æ°—åŠ›'; case 'sleep': return 'ç¡çœ '; case 'bodyTemp': return 'ä½“æ¸©'; case 'attack': return 'æ”»æ’ƒåŠ›'; case 'defense': return 'é˜²å¾¡åŠ›'; case 'insulation': return 'ä¿æ¸©æ€§'; case 'weight': return 'é‡ã•'; case 'volume': return 'å®¹é‡'; case 'volumePenalty': return 'è£…å‚™å®¹é‡'; case 'maxWeight': return 'æœ€å¤§é‡é‡'; case 'maxVolume': return 'æœ€å¤§å®¹é‡'; case 'vision': return 'è¦–ç•Œ'; default: return stat; } }
function getSicknessName(type) { switch (type) { case 'food_poisoning': return 'é£Ÿä¸­æ¯’'; case 'diarrhea': return 'ä¸‹ç—¢'; case 'fever': return 'ç™ºç†±'; default: return 'ä¸æ˜ãªç—…æ°—'; } }
function getSlotName(slot) { switch (slot) { case 'main_hand': return 'å³æ‰‹'; case 'off_hand': return 'å·¦æ‰‹'; case 'weapon': return 'æ­¦å™¨'; case 'head': return 'é ­'; case 'body_inner': return 'ã‚¤ãƒ³ãƒŠãƒ¼'; case 'body_outer': return 'ã‚¢ã‚¦ã‚¿ãƒ¼'; case 'legs': return 'è„š'; case 'hands': return 'æ‰‹'; case 'feet': return 'è¶³'; case 'back': return 'èƒŒä¸­'; case 'pochette': return 'è…°'; case 'eyes': return 'ç›®'; default: return 'ãã®ä»–';  } }
function hideItemDetail() { 
    if (targetingState.active) {
        cancelTargeting();
    }
    document.getElementById("itemDetailPanel").style.display = 'none';
    currentItemDetail = null; 
}

document.getElementById("closeItemDetailBtn").onclick = hideItemDetail;

function updatePreviewPosition(event) {
  const preview = document.getElementById("statusPreview");
  const rect = preview.getBoundingClientRect();
  let left = event.clientX + 10,
      top = event.clientY - 10;
  if (left + rect.width > window.innerWidth) left = event.clientX - rect.width - 10;
  if (top + rect.height > window.innerHeight) top = event.clientY - rect.height - 10;
  if (top < 0) top = 10;
  if (left < 0) left = 10;
  preview.style.left = left + "px";
  preview.style.top = top + "px";
}

function hideStatusPreview() { document.getElementById("statusPreview").style.display = "none"; }

function showBodyTempTooltip(event) {
    const preview = document.getElementById("statusPreview");
    const campfireNearby = placedObjects.find(c => c.type === 'campfire' && Math.abs(c.x - player.x) <= 1 && Math.abs(c.y - player.y) <= 1);
    const insideBonus = player.isInside ? 5 : 0;
    const effectiveTemperature = currentTemperature + (campfireNearby ? 15 : 0) + insideBonus;
    let contentHtml = `<strong>ä½“æ¸©æƒ…å ±</strong><div>å¤–æ°—æ¸©: ${currentTemperature.toFixed(1)}Â°C</div>`;
    if (player.isInside) contentHtml += `<div>å°å±‹ã®ä¸­: <span class="stat-positive">+${insideBonus}Â°C</span></div>`;
    if (campfireNearby) contentHtml += `<div>ãŸãç«: <span class="stat-positive">+15Â°C</span></div>`;
    contentHtml += `<div>è£…å‚™ä¿æ¸©æ€§: <span class="stat-positive">${player.insulation.toFixed(1)}</span></div><div style="border-bottom: 1px solid #555; margin: 2px 0;"></div><strong>å®ŸåŠ¹æ¸©åº¦: ${effectiveTemperature.toFixed(1)}Â°C</strong>`;
    preview.innerHTML = contentHtml;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}

function showMovementTooltip(event, mode) {
    const preview = document.getElementById("statusPreview");
    let title = '';
    let description = '';

    if (mode === 'walk') {
        title = 'æ­©è¡Œ';
        description = 'æ¨™æº–çš„ãªç§»å‹•æ–¹æ³•ã€‚1ã‚¿ãƒ¼ãƒ³ã«1ãƒã‚¹ç§»å‹•ã—ã¾ã™ã€‚ç«‹ã¦ã‚‹éŸ³ã¯æ¯”è¼ƒçš„å°ã•ã„ã§ã™ã€‚';
    } else if (mode === 'run') {
        title = 'èµ°è¡Œ';
        description = 'é«˜é€Ÿç§»å‹•ã€‚1ã‚¿ãƒ¼ãƒ³ã«å¿…ãš2ãƒã‚¹ç§»å‹•ã—ã¾ã™ã€‚å¤§ããªéŸ³ã‚’ç«‹ã¦ã€è¿½åŠ ã§ç©ºè…¹ã¨æ¸‡ãã‚’æ¶ˆè²»ã—ã¾ã™ã€‚';
    } else {
        return;
    }

    preview.innerHTML = `<strong>${title}</strong><div style="margin-top: 5px;">${description}</div>`;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}
function getDirectionHint(fromX, fromY, toX, toY) {
    const deltaX = toX - fromX,
        deltaY = toY - fromY;
    let vertical = "",
        horizontal = "";
    if (Math.abs(deltaY) > 2) vertical = (deltaY < 0) ? "åŒ—" : "å—";
    if (Math.abs(deltaX) > 2) horizontal = (deltaX > 0) ? "æ±" : "è¥¿";
    if (vertical && horizontal) return `ã“ã“ã‹ã‚‰${vertical}${horizontal}ã®æ–¹è§’ã«ã€ç”Ÿå­˜è€…ã®æœ€å¾Œã®æ¥½åœ’ãŒã‚ã‚‹ã¨ã„ã†å™‚ã ã€‚`;
    if (vertical) return `ã“ã“ã‹ã‚‰${vertical}ã®æ–¹è§’ã«ã€ç”Ÿå­˜è€…ã®æœ€å¾Œã®æ¥½åœ’ãŒã‚ã‚‹ã¨ã„ã†å™‚ã ã€‚`;
    if (horizontal) return `ã“ã“ã‹ã‚‰${horizontal}ã®æ–¹è§’ã«ã€ç”Ÿå­˜è€…ã®æœ€å¾Œã®æ¥½åœ’ãŒã‚ã‚‹ã¨ã„ã†å™‚ã ã€‚`;
    return "ã“ã®è¾ºã‚Šã«ã‚ã‚‹ã¨èããŒ...è©³ã—ã„å ´æ‰€ã¾ã§ã¯ã‚ã‹ã‚‰ãªã„ãªã€‚";
}


// --- NPC and Trade System ---
function startTraderShopEncounter() {
    isInteractionActive = true;
    const shopKeeper = generateNPC();
    shopKeeper.type = 'Trader';
    shopKeeper.name = 'åº—ã®å•†äºº';
    currentNPC = shopKeeper;
    startNPCEncounter();
}

function startNPCEncounter() {
    isInteractionActive = true;
    if (currentNPC.type === 'Raider') {
        log(`${currentNPC.name}ãŒè¥²ã„ã‹ã‹ã£ã¦ããŸï¼`, false);
        startCombat(currentNPC);
        return;
    }
    const dialoguePanel = document.getElementById('dialoguePanel');
    document.querySelectorAll('.panel:not(#dialoguePanel)').forEach(p => p.style.display = 'none');
    document.getElementById('dialogueNpcName').textContent = currentNPC.name;
    document.getElementById('dialogueNpcAscii').textContent = currentNPC.ascii.high;
    document.getElementById('dialogueText').innerHTML = `<p><i>ã€Œ${currentNPC.dialogue.greeting}ã€</i></p>`;
    const infoBtn = document.getElementById('dialogueInfoBtn');
    if (currentNPC.knowsSalvationCity) {
        infoBtn.style.display = 'block';
        infoBtn.disabled = false;
        infoBtn.onclick = () => {
            const hint = getDirectionHint(player.x, player.y, salvationCityCoords.x, salvationCityCoords.y);
            document.getElementById('dialogueText').innerHTML += `<p style="color: yellow;"><i>ã€Œ${hint}ã€</i></p>`;
            document.getElementById('dialogueText').scrollTop = document.getElementById('dialogueText').scrollHeight;
            character.salvationCityHint = hint;
            updateCharacterInfo();
            infoBtn.disabled = true;
        };
    } else { infoBtn.style.display = 'none'; }
    document.getElementById('dialogueTradeBtn').onclick = openTradeWindow;
    document.getElementById('dialogueFightBtn').onclick = () => {
        dialoguePanel.style.display = 'none';
        log(`ã‚ãªãŸã¯${currentNPC.name}ã«è¥²ã„ã‹ã‹ã£ãŸï¼`, false);
        startCombat(currentNPC);
    };
    document.getElementById('dialogueLeaveBtn').onclick = () => {
        log(`ã‚ãªãŸã¯${currentNPC.name}ã¨åˆ¥ã‚ŒãŸã€‚`);
        endNPCEncounter();
    };
    dialoguePanel.style.display = 'block';
    bringToFront(dialoguePanel);
}

function endNPCEncounter() {
    isInteractionActive = false;
    currentNPC = null;
    currentEnemy = null;

    document.getElementById('dialoguePanel').style.display = 'none';
    document.getElementById('tradePanel').style.display = 'none';

    document.querySelectorAll('.panel:not(#dialoguePanel):not(#tradePanel):not(#combatPanel):not(#storagePanel)').forEach(panel => {
        if (!panel.classList.contains('minimized')) {
            if (['mapPanel', 'inventoryPanel', 'equipmentPanel', 'craftingPanel', 'currentLocationPanel', 'minimapPanel'].includes(panel.id)) {
                panel.style.display = 'flex';
            } else if (panel.id !== 'itemDetailPanel') {
                panel.style.display = 'block';
            }
        }
    });

    drawMap();
    updateStatus();
    updateTurnInfo();
}

let playerOffer = [],
    npcOffer = [],
    tradePlayerInv = [],
    tradePlayerEquip = [],
    tradeNpcInv = [],
    tradeNpcEquip = [];

function openTradeWindow() {
    tradePlayerInv = JSON.parse(JSON.stringify(player.inventory));
    tradePlayerEquip = JSON.parse(JSON.stringify(player.equipment));
    tradeNpcInv = JSON.parse(JSON.stringify(currentNPC.inventory));
    tradeNpcEquip = JSON.parse(JSON.stringify(currentNPC.equipment));
    playerOffer = [];
    npcOffer = [];
    document.getElementById('dialoguePanel').style.display = 'none';
    const tradePanel = document.getElementById('tradePanel');
    tradePanel.style.display = 'flex';
    bringToFront(tradePanel);
    renderTradeUI();
    document.getElementById('executeTradeBtn').onclick = executeTrade;
    document.getElementById('cancelTradeBtn').onclick = () => {
        tradePanel.style.display = 'none';
        document.getElementById('dialoguePanel').style.display = 'block';
    };
}

function renderTradeUI() {
    const playerInvDiv = document.getElementById('playerTradeInventory'),
        playerEquipDiv = document.getElementById('playerTradeEquipment'),
        npcInvDiv = document.getElementById('npcTradeInventory'),
        npcEquipDiv = document.getElementById('npcTradeEquipment'),
        playerOfferDiv = document.getElementById('playerOfferArea'),
        npcOfferDiv = document.getElementById('npcOfferArea');
    playerInvDiv.innerHTML = '';
    playerEquipDiv.innerHTML = '';
    npcInvDiv.innerHTML = '';
    npcEquipDiv.innerHTML = '';
    playerOfferDiv.innerHTML = '';
    npcOfferDiv.innerHTML = '';
    const createItemDiv = (item, source, index) => {
        const div = document.createElement('div');
        div.className = 'item';
        div.innerHTML = `${item.graphic} ${getItemDisplayName(item)} (ä¾¡å€¤: ${item.value || 0})`;
        div.onclick = () => moveTradeItem(source, index);
        return div;
    };
    tradePlayerInv.forEach((item, i) => playerInvDiv.appendChild(createItemDiv(item, 'playerInv', i)));
    tradePlayerEquip.forEach((item, i) => playerEquipDiv.appendChild(createItemDiv(item, 'playerEquip', i)));
    tradeNpcInv.forEach((item, i) => npcInvDiv.appendChild(createItemDiv(item, 'npcInv', i)));
    tradeNpcEquip.forEach((item, i) => npcEquipDiv.appendChild(createItemDiv(item, 'npcEquip', i)));
    playerOffer.forEach((item, i) => playerOfferDiv.appendChild(createItemDiv(item, 'playerOffer', i)));
    npcOffer.forEach((item, i) => npcOfferDiv.appendChild(createItemDiv(item, 'npcOffer', i)));
    updateTradeValues();
}

function moveTradeItem(source, index) {
    const move = (from, to, idx) => { to.push(from.splice(idx, 1)[0]); };
    if (source === 'playerInv') move(tradePlayerInv, playerOffer, index);
    else if (source === 'playerEquip') move(tradePlayerEquip, playerOffer, index);
    else if (source === 'npcInv') move(tradeNpcInv, npcOffer, index);
    else if (source === 'npcEquip') move(tradeNpcEquip, npcOffer, index);
    else if (source === 'playerOffer') {
        const itemToMove = playerOffer.splice(index, 1)[0];
        const wasEquipped = player.equipment.some(e => e.name === itemToMove.name && e.graphic === itemToMove.graphic);
        if (wasEquipped && !tradePlayerEquip.some(e => e.slot === itemToMove.slot)) tradePlayerEquip.push(itemToMove);
        else tradePlayerInv.push(itemToMove);
    } else if (source === 'npcOffer') {
        const itemToMove = npcOffer.splice(index, 1)[0];
        const wasEquipped = currentNPC.equipment.some(e => e.name === itemToMove.name && e.graphic === itemToMove.graphic);
        if (wasEquipped && !tradeNpcEquip.some(e => e.slot === itemToMove.slot)) tradeNpcEquip.push(itemToMove);
        else tradeNpcInv.push(itemToMove);
    }
    renderTradeUI();
}

function updateTradeValues() {
    const playerValue = playerOffer.reduce((sum, item) => sum + (item.value || 0), 0);
    const npcValue = npcOffer.reduce((sum, item) => sum + (item.value || 0), 0);
    document.getElementById('playerTradeValue').textContent = playerValue;
    document.getElementById('npcTradeValue').textContent = npcValue;
    const tradeBtn = document.getElementById('executeTradeBtn');
    if (playerValue >= npcValue * 0.9 && (playerValue > 0 || npcValue > 0)) {
        tradeBtn.disabled = false;
        tradeBtn.style.background = '#4CAF50';
    } else {
        tradeBtn.disabled = true;
        tradeBtn.style.background = '#333';
    }
}

function executeTrade() {
    snapshotStats();

    const finalInventory = [...tradePlayerInv, ...npcOffer];
    const finalEquipment = [...tradePlayerEquip];
    const finalItems = [...finalInventory, ...finalEquipment];

    let newWeight = finalItems.reduce((sum, item) => sum + (item.weight || 0), 0);
    let newVolume = finalInventory.reduce((sum, item) => sum + (item.volume || 0), 0);
    
    let newMaxWeight = maxStats.maxWeight;
    let newMaxVolume = maxStats.maxVolume;
    finalEquipment.forEach(item => {
        if(item.effects) {
            if(item.effects.maxWeight) newMaxWeight += item.effects.maxWeight;
            if(item.effects.maxVolume) newMaxVolume += item.effects.maxVolume;
        }
    });

    if (newWeight > newMaxWeight) {
        speakAndAlert("äº¤æ¸‰å¾Œã®ã‚¢ã‚¤ãƒ†ãƒ ãŒé‡ã™ãã¦æŒã¦ã¾ã›ã‚“ã€‚å–å¼•ã¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸã€‚");
        return;
    }
    if (newVolume > newMaxVolume) {
        speakAndAlert("äº¤æ¸‰å¾Œã®ã‚¢ã‚¤ãƒ†ãƒ ãŒã‹ã•ã°ã‚Šã™ãã¦æŒã¦ã¾ã›ã‚“ã€‚å–å¼•ã¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸã€‚");
        return;
    }

    log("äº¤æ¸‰ãŒæˆç«‹ã—ãŸã€‚");
    player.inventory = finalInventory;
    player.equipment = finalEquipment;
    currentNPC.inventory = [...tradeNpcInv, ...playerOffer];
    currentNPC.equipment = [...tradeNpcEquip];
    updateEquippedStats();
    document.getElementById('tradePanel').style.display = 'none';
    document.getElementById('dialoguePanel').style.display = 'block';
    const dialogueText = document.getElementById('dialogueText');
    dialogueText.innerHTML += `<p style="color: lightgreen;"><i>äº¤æ¸‰ãŒæˆç«‹ã—ãŸã€‚</i></p>`;
    dialogueText.scrollTop = dialogueText.scrollHeight;
    updateItemPanels();
    updateStatus();
}

// --- Rain Animation Functions ---
function triggerLightning() {
    const flash = document.getElementById('lightning-flash');
    if (flash && currentWeather.name === 'åµ') {
        flash.classList.add('active');
        setTimeout(() => {
            flash.classList.remove('active');
        }, 300);

        if (lightningTimeout) clearTimeout(lightningTimeout);
        lightningTimeout = setTimeout(triggerLightning, Math.random() * 8000 + 4000);
    }
}

function startWeatherEffect(weatherType) {
    const weatherContainer = document.getElementById('weather-container');
    if (!weatherContainer) return;

    weatherContainer.innerHTML = '';
    weatherContainer.style.display = 'block';
    weatherContainer.className = '';

    let dropCount = 100;
    if (weatherType === 'åµ') {
        dropCount = 150;
        weatherContainer.classList.add('storm');
        if (lightningTimeout) clearTimeout(lightningTimeout);
        lightningTimeout = setTimeout(triggerLightning, Math.random() * 5000 + 2000);
    }

    for (let i = 0; i < dropCount; i++) {
        const drop = document.createElement('div');
        drop.className = 'drop';
        drop.style.left = Math.random() * 120 - 10 + 'vw';

        let duration = (Math.random() * 0.5 + 0.5);
        if (weatherType === 'åµ') {
            duration = (Math.random() * 0.3 + 0.3);
        }

        drop.style.animationDuration = duration + 's';
        drop.style.animationDelay = Math.random() * 5 + 's';
        weatherContainer.appendChild(drop);
    }
}

function stopWeatherEffect() {
    const weatherContainer = document.getElementById('weather-container');
    if (weatherContainer) {
        weatherContainer.style.display = 'none';
        weatherContainer.innerHTML = '';
    }
    if (lightningTimeout) {
        clearTimeout(lightningTimeout);
        lightningTimeout = null;
    }
    const flash = document.getElementById('lightning-flash');
    if (flash) flash.classList.remove('active');
}

function startClouds() {
    const cloudContainer = document.getElementById('cloud-container');
    if (!cloudContainer || cloudContainer.style.display === 'block') return;

    cloudContainer.innerHTML = '';
    cloudContainer.style.display = 'block';

    const cloudCount = 5;
    for (let i = 0; i < cloudCount; i++) {
        const cloud = document.createElement('div');
        cloud.className = 'cloud';

        const size = Math.random() * 0.5 + 0.75;
        cloud.style.transform = `scale(${size})`;
        cloud.style.top = `${Math.random() * 80}%`;

        const duration = Math.random() * 30 + 40;
        cloud.style.animationDuration = `${duration}s`;
        cloud.style.animationDelay = `-${Math.random() * duration}s`;

        cloudContainer.appendChild(cloud);
    }
}

function stopClouds() {
    const cloudContainer = document.getElementById('cloud-container');
    if (cloudContainer) {
        cloudContainer.style.display = 'none';
        cloudContainer.innerHTML = '';
    }
}
function placeUnlitCampfire(item, itemIndex, source) {
    if (placedObjects.find(o => o.x === player.x && o.y === player.y && (o.type === 'unlit_campfire' || o.type === 'campfire'))) { 
        log(`ã“ã“ã«ã¯æ—¢ã«ãŸãç«ãŒã‚ã‚‹ã€‚`);
        return; 
    }
    snapshotStats();
    const removedItem = player.inventory.splice(itemIndex, 1)[0];
    player.weight -= removedItem.weight;
    player.volume -= removedItem.volume;
    log("ãŸãç«ã‚­ãƒƒãƒˆã‚’è¨­ç½®ã—ãŸã€‚ç«ã‚’ã¤ã‘ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚");
    placedObjects.push({ x: player.x, y: player.y, type: 'unlit_campfire', name: 'ã¾ã ç«ã®ã¤ã„ã¦ã„ãªã„ãŸãç«', graphic: 'ğŸ”¥' });
    drawMap();
    updateItemPanels();
    updateStatus();
    hideItemDetail();
}

function startFire(fireStarter, itemIndex, source) {
    const unlitCampfire = placedObjects.find(c => c.type === 'unlit_campfire' && c.x === player.x && c.y === player.y);
    if (!unlitCampfire) { log("ç«ã‚’ã¤ã‘ã‚‹å¯¾è±¡ãŒãªã„ã€‚"); hideItemDetail(); return; }

    snapshotStats();
    log(`${fireStarter.name}ã‚’ä½¿ã£ã¦ç«ã‚’ãŠã“ã—ãŸã€‚`);
    unlitCampfire.type = 'campfire';
    unlitCampfire.name = 'ãŸãç«';
    unlitCampfire.duration = 2;

    const itemContainer = (source === 'inventory') ? player.inventory : player.equipment;

    if (fireStarter.isTorch) {
        fireStarter.duration -= 1;
        if (fireStarter.duration <= 0) {
            log(`${fireStarter.name}ã¯ç‡ƒãˆå°½ãã¦ã—ã¾ã£ãŸã€‚`);
            const removedItem = itemContainer.splice(itemIndex, 1)[0];
            player.weight -= removedItem.weight;
            player.volume -= removedItem.volume;
        }
    } else if (fireStarter.durability) {
        fireStarter.durability -= 20;
        if (fireStarter.durability <= 0) {
            log(`${fireStarter.name}ã¯å£Šã‚Œã¦ã—ã¾ã£ãŸã€‚`);
            const removedItem = itemContainer.splice(itemIndex, 1)[0];
            player.weight -= removedItem.weight;
            player.volume -= removedItem.volume;
        }
    } else if (fireStarter.name !== 'ç«æ‰“çŸ³') {
        const removedItem = itemContainer.splice(itemIndex, 1)[0];
        player.weight -= removedItem.weight;
        player.volume -= removedItem.volume;
    }

    drawMap();
    updateItemPanels();
    updateStatus();
    hideItemDetail();
}

function addFuelToCampfire(itemIndex) {
    const campfire = placedObjects.find(c => c.type === 'campfire' && c.x === player.x && c.y === player.y);
    if (!campfire) return;
    snapshotStats();
    const removedItem = player.inventory.splice(itemIndex, 1)[0];
    player.weight -= removedItem.weight;
    player.volume -= removedItem.volume;
    campfire.duration += 2;
    log(`ãŸãç«ã«æã‚’ãã¹ãŸã€‚ç«ã®å‹¢ã„ãŒå¼·ã¾ã£ãŸã€‚(æ®‹ã‚Š${campfire.duration}ã‚¿ãƒ¼ãƒ³)`);
    updateItemPanels();
    updateStatus();
    hideItemDetail();
    drawMap();
}

function craftTorchWithLighter(branchIndex) {
    snapshotStats();
    const lighterIndex = player.inventory.findIndex(i => i.name === 'ãƒ©ã‚¤ã‚¿ãƒ¼');
    if (lighterIndex === -1) return;

    const lighter = player.inventory[lighterIndex];
    lighter.durability -= 10;

    const removedBranch = player.inventory.splice(branchIndex, 1)[0];
    player.weight -= removedBranch.weight;
    player.volume -= removedBranch.volume;

    const torchTemplate = items.find(i => i.name === 'æ¾æ˜');
    const newTorch = { ...torchTemplate, duration: torchTemplate.duration, durability: 100 };
    player.inventory.push(newTorch);
    player.weight += newTorch.weight;
    player.volume += newTorch.volume;

    log("ãƒ©ã‚¤ã‚¿ãƒ¼ã‚’ä½¿ã„ã€æã§æ¾æ˜ã‚’ä½œã£ãŸã€‚");

    if (lighter.durability <= 0) {
        log("ãƒ©ã‚¤ã‚¿ãƒ¼ã®ç‡ƒæ–™ãŒå°½ãã¦ã—ã¾ã£ãŸã€‚");
        const removedLighter = player.inventory.splice(lighterIndex, 1)[0];
        player.weight -= removedLighter.weight;
        player.volume -= removedLighter.volume;
    }

    updateItemPanels();
    updateStatus();
    hideItemDetail();
}

function placeSleepingBag(item, itemIndex, source) {
    // â˜…ä¿®æ­£: å¯è¢‹ã ã‘ã§ãªãã€ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä½•ã‚‚ãªã„ã“ã¨ã‚’ç¢ºèªã™ã‚‹
    if (placedObjects.find(o => o.x === player.x && o.y === player.y)) { 
        log(`ã“ã“ã«ã¯æ—¢ã«ä½•ã‹ãŒè¨­ç½®ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€å¯è¢‹ã‚’åºƒã’ã‚‰ã‚Œãªã„ã€‚`);
        return; 
    }
    snapshotStats();
    const removedItem = player.inventory.splice(itemIndex, 1)[0];
    player.weight -= removedItem.weight;
    player.volume -= removedItem.volume;
    log("å¯è¢‹ã‚’åœ°é¢ã«åºƒã’ãŸã€‚ã“ã“ã§ãªã‚‰å¿«é©ã«çœ ã‚Œãã†ã ã€‚");
    placedObjects.push({ x: player.x, y: player.y, type: 'sleeping_bag', name: 'å¯è¢‹', graphic: 'ğŸ›Œ' });
    drawMap();
    updateItemPanels();
    updateStatus();
    hideItemDetail();
}

function placeWoodenBox(item, itemIndex, source) {
    if (placedObjects.find(o => o.x === player.x && o.y === player.y)) { log(`ã“ã“ã«ã¯æ—¢ã«ä½•ã‹ãŒè¨­ç½®ã•ã‚Œã¦ã„ã‚‹ã€‚`); return; }
    snapshotStats();
    const removedItem = player.inventory.splice(itemIndex, 1)[0];
    player.weight -= removedItem.weight;
    player.volume -= removedItem.volume;
    log("æœ¨ç®±ã‚’è¨­ç½®ã—ãŸã€‚ã‚¢ã‚¤ãƒ†ãƒ ã‚’ä¿ç®¡ã§ãã‚‹ã€‚");
    placedObjects.push({ x: player.x, y: player.y, type: 'wooden_box', name: 'æœ¨ç®±', graphic: 'ğŸ“¦', content: [], capacity: 10 });
    drawMap();
    updateItemPanels();
    updateStatus();
    hideItemDetail();
}

function cookFood(itemIndex) {
    const rawItem = player.inventory[itemIndex];
    const cookedItemName = cookingMap[rawItem.name];
    if (!cookedItemName) return;

    snapshotStats();
    const removedItem = player.inventory.splice(itemIndex, 1)[0];
    player.weight -= removedItem.weight;
    player.volume -= removedItem.volume;
    const cookedItemTemplate = items.find(i => i.name === cookedItemName);
    const newItem = { ...cookedItemTemplate };
    player.inventory.push(newItem);
    player.weight += newItem.weight;
    player.volume += newItem.volume;
    log(`${rawItem.name}ã‚’ç„¼ãã€${newItem.name}ãŒã§ããŸã€‚`);
    updateItemPanels();
    updateStatus();
    hideItemDetail();
}

function boilWater(itemIndex) {
    snapshotStats();
    player.inventory[itemIndex].content = { type: 'clean', freshness: 100 };
    log(`${getItemDisplayName(player.inventory[itemIndex])}ã®æ°´ã‚’æ²¸é¨°ã•ã›ã€ç¶ºéº—ãªæ°´ã«ã—ãŸã€‚`);
    updateItemPanels();
    updateStatus();
    hideItemDetail();
}

function drinkFromContainer(itemIndex) {
    snapshotStats();
    const container = player.inventory[itemIndex];
    if (container.content.type === 'clean') {
        player.thirst = Math.min(maxStats.thirst, player.thirst + 40);
        log("ç¶ºéº—ãªæ°´ã‚’é£²ã‚“ã§å–‰ã®æ¸‡ãã‚’ç™’ã—ãŸã€‚");
    } else {
        player.thirst = Math.min(maxStats.thirst, player.thirst + 20);
        if (Math.random() < 0.8 && !player.sicknesses.some(s => s.type === 'diarrhea')) {
            log("æ±šã‚ŒãŸæ°´ã‚’é£²ã‚“ã ...è…¹ã®å…·åˆãŒæ€¥ã«æ‚ªããªã£ãŸï¼", true);
            player.sicknesses.push({ type: 'diarrhea', duration: 36 });
        } else {
            log("æ±šã‚ŒãŸæ°´ã‚’é£²ã‚“ã ã€‚å–‰ã¯æ½¤ã£ãŸãŒã€ä½“èª¿ãŒå„ªã‚Œãªã„...");
        }
    }
    container.content = null;
    logStatChanges(playerStatsBeforeAction, player);
    updateItemPanels();
    updateStatus();
    hideItemDetail();
}

function drinkFromSource() {
    snapshotStats();
    player.thirst = Math.min(maxStats.thirst, player.thirst + 20);
    if (Math.random() < 0.9 && !player.sicknesses.some(s => s.type === 'diarrhea')) {
        log("åœ°é¢ã®æ°´ã‚’ç›´æ¥é£²ã‚“ã ...ã™ãã«å¾Œæ‚”ã™ã‚‹ã“ã¨ã«ãªã£ãŸï¼", true);
        player.sicknesses.push({ type: 'diarrhea', duration: 36 });
    } else {
        log("åœ°é¢ã®æ°´ã‚’ç›´æ¥é£²ã‚“ã ã€‚å–‰ã¯æ½¤ã£ãŸãŒã€è…¹ã®èª¿å­ãŒæ‚ªã„...");
    }
    logStatChanges(playerStatsBeforeAction, player);
    updateStatus();
    hideItemDetail();
}

function fillContainerFromSource() {
    const emptyContainerIndex = player.inventory.findIndex(i => i.type === 'container' && !i.content);
    if (emptyContainerIndex === -1) { log("æ°´ã‚’æ±²ã‚€ãŸã‚ã®ç©ºã®å®¹å™¨ãŒãªã„ã€‚"); hideItemDetail(); return; }
    snapshotStats();
    player.inventory[emptyContainerIndex].content = { type: 'dirty' };
    log(`ç©ºã®${getItemDisplayName(player.inventory[emptyContainerIndex])}ã«æ±šã‚ŒãŸæ°´ã‚’æ±²ã‚“ã ã€‚`);
    updateItemPanels();
    updateStatus();
    hideItemDetail();
}

function emptyContainer(itemIndex) {
    snapshotStats();
    const container = player.inventory[itemIndex];
    log(`${getItemDisplayName(container)}ã®ä¸­èº«ã‚’åœ°é¢ã«æ¨ã¦ãŸã€‚`);
    const water = { ...items.find(i => i.name === 'æ±šã‚ŒãŸæ°´') };
    const locationKey = `${player.x},${player.y}`;
    if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
    droppedItems[locationKey].push(water);
    container.content = null;
    updateItemPanels();
    updateCurrentLocationPanel();
    updateStatus();
    hideItemDetail();
}

function openCan(itemIndex) {
    snapshotStats();
    const can = player.inventory[itemIndex];
    can.isSealed = false;
    can.openedName = can.name.replace('ç¼¶è©°', 'é–‹ã‘ãŸç¼¶');
    can.effects = can.sealedEffects;
    can.smell = 3; // é–‹ã‘ãŸç¬é–“ã«è‡­ã„ã‚’è¿½åŠ 
    log(`${can.name}ã‚’é“å…·ã‚’ä½¿ã£ã¦ãã‚Œã„ã«é–‹ã‘ãŸã€‚`);
    updateItemPanels();
    updateStatus();
    hideItemDetail();
}

function forceOpenCan(itemIndex) {
    snapshotStats();
    const can = player.inventory[itemIndex];
    const emptyCanTemplate = items.find(i => i.name === 'ç©ºãç¼¶');
    if (Math.random() < 0.6) {
        log(`${can.name}ã‚’ç„¡ç†ã‚„ã‚Šé–‹ã‘ã‚ˆã†ã¨ã—ãŸãŒã€å¤±æ•—ã—ã¦ä¸­èº«ã‚’ã¶ã¡ã¾ã‘ã¦ã—ã¾ã£ãŸï¼`);
        const removedCan = player.inventory.splice(itemIndex, 1)[0];
        player.inventory.push({ ...emptyCanTemplate });
        player.weight -= (removedCan.weight - emptyCanTemplate.weight);
        player.volume -= (removedCan.volume - emptyCanTemplate.volume);
    } else {
        can.isSealed = false;
        can.openedName = can.name.replace('ç¼¶è©°', 'é–‹ã‘ãŸç¼¶');
        can.effects = can.sealedEffects;
        can.smell = 3; // é–‹ã‘ãŸç¬é–“ã«è‡­ã„ã‚’è¿½åŠ 
        log(`${can.name}ã‚’ãªã‚“ã¨ã‹ã“ã˜é–‹ã‘ã‚‹ã“ã¨ãŒã§ããŸã€‚`);
    }
    updateItemPanels();
    updateStatus();
    hideItemDetail();
}

function showPlacedObjectTooltip(object, event) {
    const preview = document.getElementById("statusPreview");

    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
    const tile = map[object.y][object.x];
    let contentHtml = `<strong>${tile.loc.name}</strong>`;
    if (tile.loc.blocksVision) {
        contentHtml += `<div style="color: indianred; font-size: 0.9em;">(è¦–ç•Œã‚’é®ã‚‹)</div>`;
    }
    contentHtml += `<div style="border-top: 1px solid #555; margin-top:5px; padding-top:5px;"><strong>${object.name}</strong><br/>`;
    // â–²â–²â–² ã“ã“ã¾ã§ â–²â–²â–²

    if (object.type === 'campfire') contentHtml += `<div>æ®‹ã‚Š: ${object.duration} ã‚¿ãƒ¼ãƒ³</div><div>æã‚’ãã¹ã‚‹ã¨é•·æŒã¡ã™ã‚‹ã€‚</div>`;
    else if (object.type === 'unlit_campfire') contentHtml += `<div>ç«ãŒã¤ã„ã¦ã„ãªã„ã€‚</div><div>ãƒ©ã‚¤ã‚¿ãƒ¼ãªã©ã§ç«ã‚’ã¤ã‘ã‚‰ã‚Œã‚‹ã€‚</div>`;
    else if (object.type === 'wooden_box') contentHtml += `<div>ä¸­èº«: ${object.content.length} / ${object.capacity}</div><div>ã‚¯ãƒªãƒƒã‚¯ã—ã¦é–‹ã</div>`;
    else if (object.type === 'sleeping_bag') contentHtml += `<div>ã‚¯ãƒªãƒƒã‚¯ã—ã¦æ“ä½œã™ã‚‹</div>`;
    else if (object.type === 'barricade') contentHtml += `<div>ä½“åŠ›: ${object.health.toFixed(0)} / ${object.maxHealth.toFixed(0)}</div>`;
    else if (object.isAnimalCorpse) {
        contentHtml += object.unbutchered ? "<div>è§£ä½“ã§ãã‚‹</div>" : "<div>è§£ä½“æ¸ˆã¿</div>";
    } else if (object.isHumanCorpse) {
        contentHtml += object.unsearched ? "<div>æ¼ã‚‹ã“ã¨ãŒã§ãã‚‹</div>" : "<div>æ¼ã‚‰ã‚ŒãŸå¾Œã </div>";
    }
    
    // â–¼â–¼â–¼ é–‰ã˜ã‚¿ã‚°ã‚’è¿½åŠ  â–¼â–¼â–¼
    contentHtml += `</div>`;

    preview.innerHTML = contentHtml;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}

function showPlacedObjectDetail(object) {
  const panel = document.getElementById("itemDetailPanel");
  const header = document.getElementById("itemDetailHeader");
  const graphic = document.getElementById("itemDetailGraphic");
  const content = document.getElementById("itemDetailContent");

  currentItemDetail = { item: object, source: 'placed', coords: { x: object.x, y: object.y } };
  header.textContent = object.name;
  graphic.textContent = object.graphic;

  let description = "ç‰¹ã«å¤‰ã‚ã£ãŸã¨ã“ã‚ã¯ãªã„ã€‚";
  let weight = 0;
  let volume = 0;
  
  if(object.type === 'barricade') {
        description = "ä¸¸å¤ªã‚’çµ„ã‚“ã§ä½œã‚‰ã‚ŒãŸç²—é›‘ãªéšœå®³ç‰©ã€‚";
        content.innerHTML = `<div class="item-description">${description}</div><strong>ã‚¿ã‚¤ãƒ—</strong> è¨­ç½®ç‰©<br><strong>ä½“åŠ›</strong> ${object.health.toFixed(0)} / ${object.maxHealth.toFixed(0)}`;
  } else {
    const itemTemplate = items.find(i => object.name.includes(i.name));
    if (itemTemplate) {
        description = itemTemplate.desc;
        weight = itemTemplate.weight || 0;
        volume = itemTemplate.volume || 0;
    }

    if (object.isAnimalCorpse) {
        description = object.unbutchered ? "åˆƒç‰©ã§è§£ä½“ã™ã‚Œã°ã€é£Ÿæ–™ãªã©ãŒæ‰‹ã«å…¥ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚" : "æ—¢ã«è§£ä½“ã•ã‚Œã¦ãŠã‚Šã€ã‚ã¼ã—ã„ã‚‚ã®ã¯æ®‹ã£ã¦ã„ãªã„ã‚ˆã†ã ã€‚";
    } else if (object.isHumanCorpse) {
        description = object.unsearched ? "ä½•ã‹æŒã£ã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚æ¼ã£ã¦ã¿ã‚‹ä¾¡å€¤ã¯ã‚ã‚Šãã†ã ã€‚" : "æ—¢ã«æ¼ã‚‰ã‚Œã¦ãŠã‚Šã€ã‚ã¼ã—ã„ã‚‚ã®ã¯æ®‹ã£ã¦ã„ãªã„ã‚ˆã†ã ã€‚";
    }
    content.innerHTML = `<div class="item-description">${description}</div><strong>ã‚¿ã‚¤ãƒ—</strong> è¨­ç½®ç‰©<br><strong>é‡ã•</strong> ${weight}<br><strong>å®¹é‡</strong> ${volume}`;
  }


  document.getElementById("itemDetailActions").querySelectorAll('button').forEach(btn => btn.style.display = 'none');
  document.getElementById("closeItemDetailBtn").style.display = 'inline-block';
  
  const hasAxe = player.inventory.some(i => i.isAxe) || player.equipment.some(i => i.isAxe);
  
  if (object.type === 'barricade' && hasAxe) {
      document.getElementById("dismantleBtn").style.display = 'inline-block';
      document.getElementById("dismantleBtn").onclick = dismantleBarricade;
  } else if (object.isAnimalCorpse && object.unbutchered) {
    const hasBlade = player.inventory.some(i => i.isBlade) || player.equipment.some(i => i.isBlade);
    if (hasBlade) {
        document.getElementById("butcherItemBtn").style.display = 'inline-block';
        document.getElementById("butcherItemBtn").onclick = butcherAnimalCorpse;
    }
  } else if (object.isHumanCorpse && object.unsearched) {
      document.getElementById("searchCorpseBtn").style.display = 'inline-block';
      document.getElementById("searchCorpseBtn").onclick = searchHumanCorpse;
  } else if (object.type === 'sleeping_bag' || object.type === 'unlit_campfire' || (object.type === 'wooden_box' && (!object.content || object.content.length === 0))) {
      const pickupBtn = document.getElementById("pickupItemBtn");
      pickupBtn.style.display = 'inline-block';
      pickupBtn.onclick = () => pickupPlacedObject(object);
  }

  panel.style.display = 'block';
  bringToFront(panel);
}

function pickupPlacedObject(object) {
    let itemTemplate;
    if (object.type === 'sleeping_bag') {
        itemTemplate = items.find(i => i.name === 'å¯è¢‹');
    } else if (object.type === 'wooden_box') {
        itemTemplate = items.find(i => i.name === 'æœ¨ç®±');
    } else if (object.type === 'unlit_campfire') {
        itemTemplate = items.find(i => i.name === 'ãŸãç«ã‚­ãƒƒãƒˆ');
    } else {
        log("ãã‚Œã‚’æ‹¾ã†ã“ã¨ã¯ã§ããªã„ã€‚");
        return;
    }
    
    if (!itemTemplate) return;

    if (player.weight + itemTemplate.weight > player.maxWeight) {
        log(`é‡ã™ãã¦${itemTemplate.name}ã‚’æ‹¾ãˆãªã„ã€‚`);
        return;
    }
    if (player.volume + (itemTemplate.volume || 0) > player.maxVolume) {
        log(`å®¹é‡ãŒè¶³ã‚Šãªãã¦${itemTemplate.name}ã‚’æ‹¾ãˆãªã„ã€‚`);
        return;
    }

    const objectIndex = placedObjects.findIndex(o => o.x === object.x && o.y === object.y);
    if (objectIndex > -1) {
        placedObjects.splice(objectIndex, 1);
        const newItem = { ...itemTemplate };
        player.inventory.push(newItem);
        player.weight += newItem.weight;
        player.volume += newItem.volume;
        log(`${itemTemplate.name}ã‚’ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã«æˆ»ã—ãŸã€‚`);
        hideItemDetail();
        drawMap();
        updateItemPanels();
        updateStatus();
    }
}


function showRecipeTooltip(item, event) {
    const preview = document.getElementById("statusPreview");
    let details = `<strong>${item ? item.name : 'ãƒãƒªã‚±ãƒ¼ãƒ‰'}</strong><br><div class="item-description">${item ? item.desc : 'ä¸¸å¤ª3æœ¬ã§ä½œã‚‹éšœå®³ç‰©ã€‚'}</div>`;
    if (item && item.attack) details += `<strong>æ”»æ’ƒåŠ›</strong> <span class="item-effect-positive">+${item.attack}</span><br>`;
    if (item && item.defense) details += `<strong>é˜²å¾¡åŠ›</strong> <span class="item-effect-positive">+${item.defense}</span><br>`;
    if (item && item.insulation) details += `<strong>ä¿æ¸©æ€§</strong> <span class="item-effect-positive">+${item.insulation.toFixed(1)}</span><br>`;
    if (item && item.effects && item.effects.maxWeight) details += `<strong>æœ€å¤§é‡é‡</strong> <span class="item-effect-positive">+${item.effects.maxWeight}</span><br>`;
    if (item && item.effects && item.effects.maxVolume) details += `<strong>æœ€å¤§å®¹é‡</strong> <span class="item-effect-positive">+${item.effects.maxVolume}</span><br>`;
    if (item) details += `<strong>é‡ã•</strong> ${item.weight || 0}<br><strong>å®¹é‡</strong> ${item.volume || 0}<br>`;
    preview.innerHTML = details; preview.style.display = 'block'; updatePreviewPosition(event);
}

let currentStorageBox = null;
function openStoragePanel(boxObject) {
    isInteractionActive = true; currentStorageBox = boxObject;
    const storagePanel = document.getElementById('storagePanel');
    document.getElementById('storagePanelHeader').textContent = `${boxObject.name}ã®ä¸­èº«`;
    renderStorageUI();
    storagePanel.style.display = 'flex'; bringToFront(storagePanel);
}

function renderStorageUI() {
    if(!currentStorageBox) return;
    const boxArea = document.getElementById('storageBoxArea'), playerArea = document.getElementById('storagePlayerInventory');
    boxArea.innerHTML = ''; playerArea.innerHTML = '';
    document.getElementById('storageBoxTitle').textContent = `æœ¨ç®±ã®ä¸­èº« (${currentStorageBox.content.length}/${currentStorageBox.capacity})`;
    const createItemDiv = (item, source, index) => {
        const div = document.createElement('div'); div.className = 'item';
        div.innerHTML = `${item.graphic} ${getItemDisplayName(item)}`;
        div.onclick = () => moveStorageItem(source, index); return div;
    };
    currentStorageBox.content.forEach((item, i) => boxArea.appendChild(createItemDiv(item, 'box', i)));
    player.inventory.forEach((item, i) => playerArea.appendChild(createItemDiv(item, 'player', i)));
    const pickupBtn = document.getElementById('pickupStorageBtn');
    pickupBtn.disabled = currentStorageBox.content.length > 0;
}

function moveStorageItem(source, index) {
    if(source === 'player') {
        if(currentStorageBox.content.length < currentStorageBox.capacity) {
            const itemToStore = player.inventory.splice(index, 1)[0];
            currentStorageBox.content.push(itemToStore);
        } else { log("æœ¨ç®±ã¯ã‚‚ã†æº€æ¯ã ã€‚"); }
    } else {
        const itemToTake = currentStorageBox.content[index];
        if(player.weight + itemToTake.weight > player.maxWeight) { log("ã“ã‚Œä»¥ä¸ŠæŒã¦ãªã„ã€‚"); } 
        else if(player.volume + (itemToTake.volume || 0) > player.maxVolume) { log("å®¹é‡ãŒè¶³ã‚Šãªã„ã€‚"); } 
        else { 
            player.inventory.push(currentStorageBox.content.splice(index, 1)[0]); 
        }
    }
    updateEquippedStats(); updateStatus(); renderStorageUI();
}

function pickupStorageBox() {
    if (currentStorageBox && currentStorageBox.content.length === 0) {
        const boxItem = items.find(i => i.name === 'æœ¨ç®±');
        if (player.weight + boxItem.weight > player.maxWeight) {
            log("é‡ã™ãã¦æœ¨ç®±ã‚’æ‹¾ãˆãªã„ã€‚"); return;
        }
        if (player.volume + (boxItem.volume || 0) > player.maxVolume) {
            log("å®¹é‡ãŒè¶³ã‚Šãªãã¦æœ¨ç®±ã‚’æ‹¾ãˆãªã„ã€‚"); return;
        }
        const boxIndex = placedObjects.findIndex(o => o.x === currentStorageBox.x && o.y === currentStorageBox.y);
        if (boxIndex > -1) {
            placedObjects.splice(boxIndex, 1);
            player.inventory.push({...boxItem});
            log("ç©ºã®æœ¨ç®±ã‚’æ‹¾ã„ä¸Šã’ãŸã€‚");
            closeStoragePanel();
            drawMap(); 
            updateEquippedStats(); 
            updateStatus();
            updateItemPanels();
        }
    }
}

function closeStoragePanel() {
    document.getElementById('storagePanel').style.display = 'none';
    currentStorageBox = null; isInteractionActive = false;
    updateItemPanels();
}

function reloadWeapon(gunIndexInEquipment) {
    const gun = player.equipment[gunIndexInEquipment];
    if (!gun || !gun.ammoType) return;

    let reloadedCount = 0;
    while (gun.loadedAmmo < gun.ammoCapacity) {
        const ammoIndex = player.inventory.findIndex(i => i.ammoType === gun.ammoType);
        if (ammoIndex > -1) {
            const ammo = player.inventory.splice(ammoIndex, 1)[0];
            player.weight -= ammo.weight;
            player.volume -= ammo.volume;
            gun.loadedAmmo++;
            reloadedCount++;
        } else {
            break;
        }
    }

    if (reloadedCount > 0) {
        log(`${gun.name}ã«å¼¾ã‚’${reloadedCount}ç™ºè£…å¡«ã—ãŸã€‚`);
        updateItemPanels();
        updateEquippedStats();
        updateStatus();
        hideItemDetail();
    } else {
        log("é©åˆã™ã‚‹å¼¾è–¬ã‚’æŒã£ã¦ã„ãªã„ã€‚");
    }
}

function attachBayonet(rifleIndexInEquipment) {
    const rifle = player.equipment[rifleIndexInEquipment];
    const knifeIndex = player.inventory.findIndex(i => i.name === 'ãƒŠã‚¤ãƒ•');

    if (rifle && rifle.name === 'ãƒ©ã‚¤ãƒ•ãƒ«' && knifeIndex > -1) {
        const knife = player.inventory.splice(knifeIndex, 1)[0];
        player.weight -= knife.weight;
        player.volume -= knife.volume;
        rifle.bayonetAttached = true;
        log(`${rifle.name}ã«${knife.name}ã‚’è£…ç€ã—ãŸã€‚è¿‘æ¥æ”»æ’ƒãŒå¼·åŒ–ã•ã‚Œã‚‹ã€‚`);
        updateEquippedStats();
        updateItemPanels();
        updateStatus();
        hideItemDetail();
    }
}

function ensureKnowledgeableTrader() {
    const knowledgeableTraderExists = entities.some(e => e.type === 'Trader' && e.knowsSalvationCity);
    if (!knowledgeableTraderExists) {
        const anyTrader = entities.find(e => e.type === 'Trader');
        if (anyTrader) {
            anyTrader.knowsSalvationCity = true;
        } else {
            let x, y;
            do {
                x = Math.floor(Math.random() * mapSize);
                y = Math.floor(Math.random() * mapSize);
            } while (entities.some(e => e.x === x && e.y === y) || (player.x === x && player.y === y));
            
            const newTrader = generateNPC();
            newTrader.type = 'Trader';
            newTrader.x = x;
            newTrader.y = y;
            newTrader.stunnedTurns = 0;
            newTrader.knowsSalvationCity = true;
            entities.push(newTrader);
        }
    }
}

function updateBackgroundColor() {
    const hour = currentTime.getHours();
    let color;

    if (hour >= 5 && hour <= 8) {
        color = '#87CEEB';
    } else if (hour >= 9 && hour <= 16) {
        color = '#FFF8DC';
    } else if (hour >= 17 && hour <= 19) {
        color = '#E9967A';
    } else {
        color = '#0F192D';
    }
    document.body.style.backgroundColor = color;
}

function butcherAnimalCorpse() {
    const corpse = currentItemDetail.item;
    if (!corpse || !corpse.unbutchered) return;

    const blade = player.inventory.find(i => i.isBlade) || player.equipment.find(i => i.isBlade);
    if (!blade) {
        // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
        const msg = "è§£ä½“ã™ã‚‹ã«ã¯ãƒŠã‚¤ãƒ•ã‚„æ–§ã®ã‚ˆã†ãªåˆƒç‰©ãŒå¿…è¦ã ã€‚";
        log(msg, false);
        speak(msg);
        // â–²â–²â–² ã“ã“ã¾ã§ãŒä¿®æ­£ç®‡æ‰€ â–²â–²â–²
        return;
    }
    
    snapshotStats();
    
    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
    // å„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ãƒ­ã‚°ã«è¡¨ç¤ºã—ã€å³åº§ã«èª­ã¿ä¸Šã’ã‚‹
    const msg1 = `${blade.name}ã‚’ä½¿ã£ã¦${corpse.name}ã‚’è§£ä½“ã—ãŸã€‚`;
    log(msg1, false);
    speak(msg1);
    
    let itemsFound = [];
    const meatTemplate = items.find(i => i.name === 'ç”Ÿè‚‰');
    const furTemplate = items.find(i => i.name === 'æ¯›çš®');
    
    if (meatTemplate && corpse.potentialLoot.meat > 0) {
        for (let i = 0; i < corpse.potentialLoot.meat; i++) {
            itemsFound.push({...meatTemplate});
        }
        const msg2 = `ç”Ÿè‚‰ã‚’${corpse.potentialLoot.meat}ã¤æ‰‹ã«å…¥ã‚ŒãŸã€‚`;
        log(msg2, false);
        speak(msg2);
    }
    if (furTemplate && corpse.potentialLoot.fur > 0) {
        for (let i = 0; i < corpse.potentialLoot.fur; i++) {
            itemsFound.push({...furTemplate});
        }
        const msg3 = `æ¯›çš®ã‚’${corpse.potentialLoot.fur}ã¤æ‰‹ã«å…¥ã‚ŒãŸã€‚`;
        log(msg3, false);
        speak(msg3);
    }
    // â–²â–²â–² ã“ã“ã¾ã§ãŒä¿®æ­£ç®‡æ‰€ â–²â–²â–²

    const locationKey = `${player.x},${player.y}`;
    if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
    itemsFound.forEach(item => droppedItems[locationKey].push(item));
    
    corpse.unbutchered = false;
    corpse.name = corpse.name.replace('ã®æ­»ä½“', 'ã®æ­»éª¸');

    hideItemDetail();
    advanceTurn();
    updateCurrentLocationPanel(false);
    updateStatus();
    updateCharacterBody();
    updateTurnInfo();
}

function searchHumanCorpse() {
    const corpse = currentItemDetail.item;
    if (!corpse || !corpse.unsearched) return;

    snapshotStats();
    
    // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ â–¼â–¼â–¼
    const msg1 = `${corpse.name}ã‚’æ¼ã‚Šã€ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ¢ã—ãŸã€‚`;
    log(msg1, false); // ãƒ­ã‚°ãƒ‘ãƒãƒ«ã«ã¯è¡¨ç¤ºã™ã‚‹ãŒã€èª­ã¿ä¸Šã’ã‚­ãƒ¥ãƒ¼ã«ã¯å…¥ã‚Œãªã„
    speak(msg1);      // å³åº§ã«èª­ã¿ä¸Šã’ã‚‹

    const locationKey = `${player.x},${player.y}`;
    if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
    
    let msg2 = '';
    if (corpse.potentialLoot && corpse.potentialLoot.length > 0) {
        corpse.potentialLoot.forEach(item => {
            droppedItems[locationKey].push(item);
        });
        msg2 = `ã„ãã¤ã‹ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¦‹ã¤ã‘ã€åœ°é¢ã«ç½®ã„ãŸã€‚`;
    } else {
        msg2 = `ã—ã‹ã—ã€ä½•ã‚‚è¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã€‚`;
    }

    // 2ã¤ç›®ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚‚åŒæ§˜ã«ã€ãƒ­ã‚°ã«è¡¨ç¤ºã—ã¦å³åº§ã«èª­ã¿ä¸Šã’ã‚‹
    // (ãƒ–ãƒ©ã‚¦ã‚¶ã®èª­ã¿ä¸Šã’æ©Ÿèƒ½ãŒè‡ªå‹•çš„ã«ç™ºè¨€ã‚’ã‚­ãƒ¥ãƒ¼ã«å…¥ã‚Œã‚‹ãŸã‚ã€é †ç•ªã«å†ç”Ÿã•ã‚Œã¾ã™)
    log(msg2, false);
    speak(msg2);
    // â–²â–²â–² ã“ã“ã¾ã§ãŒä¿®æ­£ç®‡æ‰€ â–²â–²â–²

    corpse.unsearched = false;
    corpse.name = corpse.name.replace('æ­»ä½“', 'æ¼ã‚‰ã‚ŒãŸæ­»ä½“');

    hideItemDetail();
    advanceTurn();
    updateCurrentLocationPanel(false);
    updateStatus();
    updateCharacterBody();
    updateTurnInfo();
}

function applySplint(item, itemIndex, source) {
    const fracture = player.injuries.find(i => i.type === 'fracture' && !i.splinted);
    if (fracture) {
        fracture.splinted = true;
        log("æ·»ãˆæœ¨ã§éª¨æŠ˜ç®‡æ‰€ã‚’å›ºå®šã—ãŸã€‚ç—›ã¿ãŒå°‘ã—å’Œã‚‰ã„ã ã€‚", true);
        const removedItem = player.inventory.splice(itemIndex, 1)[0];
        player.weight -= removedItem.weight;
        player.volume -= removedItem.volume;
        updateItemPanels();
        updateStatus();
        hideItemDetail();
        speakQueuedLogs(); // ã€è¿½åŠ ã€‘
    } else {
        log("æ·»ãˆæœ¨ã‚’ä½¿ã†å¿…è¦ã¯ãªã„ã‚ˆã†ã ã€‚");
        speakQueuedLogs(); // ã€è¿½åŠ ã€‘
    }
}

function cureSickness(sicknessType, medicineName, itemIndex) {
    const sickness = player.sicknesses.find(s => s.type === sicknessType);
    if (sickness) {
        log(`${medicineName}ã‚’æœç”¨ã—ãŸã€‚å°‘ã—æ¥½ã«ãªã£ãŸã‚ˆã†ã ã€‚`, true);
        sickness.medicated_duration = 6; 
        const removedItem = player.inventory.splice(itemIndex, 1)[0];
        player.weight -= removedItem.weight;
        player.volume -= removedItem.volume;
        updateItemPanels();
        updateStatus();
        hideItemDetail();
        speakQueuedLogs(); // ã€è¿½åŠ ã€‘
    } else {
        log(`${medicineName}ã‚’é£²ã‚€å¿…è¦ã¯ãªã„ã‚ˆã†ã ã€‚`);
        speakQueuedLogs(); // ã€è¿½åŠ ã€‘
    }
}

function repairItemWithTape(tapeIndex) {
    const repairableItems = [...player.equipment, ...player.inventory].filter(i =>
        (i.type === 'equipment' || i.type === 'clothing' || i.type === 'tool') &&
        i.durability !== undefined && i.durability < 100
    );

    if (repairableItems.length === 0) {
        log("ä¿®ç†ã™ã‚‹ã‚‚ã®ãŒä½•ã‚‚ãªã„ã€‚");
        return;
    }

    hideItemDetail(); // æœ€åˆã«ã‚¢ã‚¤ãƒ†ãƒ è©³ç´°ãƒ‘ãƒãƒ«ã‚’é–‰ã˜ã¾ã™

    // ä¿®ç†ã‚¢ã‚¤ãƒ†ãƒ é¸æŠç”¨ã®ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’ä½œæˆ
    const modalDiv = document.createElement("div");
    modalDiv.id = "repairModal";
    modalDiv.style.cssText = `position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #222; color: white; padding: 20px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.6); z-index: 1001; max-height: 80vh; display: flex; flex-direction: column;`;
    
    modalDiv.innerHTML = `<h3 style="margin-top:0; padding-bottom:10px; border-bottom:1px solid #555;">ä¿®ç†ã™ã‚‹ã‚¢ã‚¤ãƒ†ãƒ ã‚’é¸æŠ</h3>`;

    const itemListDiv = document.createElement("div");
    itemListDiv.className = "item-list";
    itemListDiv.style.maxHeight = "60vh";

    // ä¿®ç†å¯èƒ½ãªã‚¢ã‚¤ãƒ†ãƒ ã®ãƒªã‚¹ãƒˆã‚’ç”Ÿæˆ
    repairableItems.forEach(itemToRepair => {
        const itemDiv = document.createElement("div");
        itemDiv.className = "item";
        itemDiv.innerHTML = `${itemToRepair.graphic} ${getItemDisplayName(itemToRepair)} (è€ä¹…åº¦: ${itemToRepair.durability.toFixed(0)}%)`;
        itemDiv.onclick = () => {
            executeRepair(itemToRepair, tapeIndex);
            document.body.removeChild(modalDiv);
        };
        itemListDiv.appendChild(itemDiv);
    });
    
    modalDiv.appendChild(itemListDiv);

    // ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãƒœã‚¿ãƒ³ã‚’è¿½åŠ 
    const cancelBtn = document.createElement("button");
    cancelBtn.textContent = "ã‚­ãƒ£ãƒ³ã‚»ãƒ«";
    cancelBtn.style.cssText = `margin-top: 15px; padding: 8px 15px; background: #444; color: #eee; border: none; border-radius: 5px; cursor: pointer;`;
    cancelBtn.onclick = () => document.body.removeChild(modalDiv);
    
    modalDiv.appendChild(cancelBtn);
    document.body.appendChild(modalDiv);
}

function executeRepair(itemToRepair, tapeIndex) {
    const repairAmount = 50;
    const originalDurability = itemToRepair.durability;
    itemToRepair.durability = Math.min(100, itemToRepair.durability + repairAmount);

    log(`ãƒ€ã‚¯ãƒˆãƒ†ãƒ¼ãƒ—ã‚’ä½¿ã£ã¦${getItemDisplayName(itemToRepair)}ã‚’ä¿®ç†ã—ãŸã€‚(è€ä¹…åº¦: ${originalDurability.toFixed(0)}% -> ${itemToRepair.durability.toFixed(0)}%)`);

    // ãƒ€ã‚¯ãƒˆãƒ†ãƒ¼ãƒ—ã‚’æ¶ˆè²»
    const removedTape = player.inventory.splice(tapeIndex, 1)[0];
    player.weight -= removedTape.weight;
    player.volume -= removedTape.volume;

    updateItemPanels();
    updateStatus();
    speakQueuedLogs(); // ã€è¿½åŠ ã€‘
}


function cureFoodPoisoning(item, itemIndex) {
    cureSickness('food_poisoning', 'èƒƒè…¸è–¬', itemIndex);
}

function cureDiarrhea(item, itemIndex) {
    cureSickness('diarrhea', 'ä¸‹ç—¢æ­¢ã‚', itemIndex);
}

function cureFever(item, itemIndex) {
    cureSickness('fever', 'è§£ç†±å‰¤', itemIndex);
}

function gatherLog() {
    snapshotStats();
    let tile = map[player.y][player.x];
    if (Math.random() < 0.5) {
        log("ä¸¸å¤ªã®åé›†ã«å¤±æ•—ã—ãŸ...");
    } else {
        const logItemTemplate = items.find(i => i.name === 'ä¸¸å¤ª');
        const newItem = { ...logItemTemplate };
        
        if (player.weight + newItem.weight > player.maxWeight || player.volume + newItem.volume > player.maxVolume) {
            log("ä¸¸å¤ªã‚’æ‰‹ã«å…¥ã‚ŒãŸãŒã€é‡ãã¦æŒã¦ãªã„ã®ã§åœ°é¢ã«ç½®ã„ãŸã€‚");
            const locationKey = `${player.x},${player.y}`;
            if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
            droppedItems[locationKey].push(newItem);
        } else {
            log("ä¸¸å¤ªã‚’1æœ¬æ‰‹ã«å…¥ã‚ŒãŸï¼");
            player.inventory.push(newItem);
            player.weight += newItem.weight;
            player.volume += newItem.volume;
        }
        tile.logSupply--;
    }
    
    advanceTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    updateTurnInfo();
    checkGameOver();
    updateCurrentLocationPanel(false);
}

function placeBarricade(recipe) {
    if (placedObjects.some(o => o.x === player.x && o.y === player.y)) {
        log("ã“ã“ã«ã¯æ—¢ã«ä½•ã‹è¨­ç½®ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€ãƒãƒªã‚±ãƒ¼ãƒ‰ã‚’è¨­ç½®ã§ããªã„ã€‚");
        return;
    }
    snapshotStats();
    log("ä¸¸å¤ªã‚’æ¶ˆè²»ã—ã¦ãƒãƒªã‚±ãƒ¼ãƒ‰ã‚’è¨­ç½®ã—ãŸã€‚");
    createSound(player.x, player.y, 6);
    
    for (let i = 0; i < recipe.ingredients[0].count; i++) {
        const logIndex = player.inventory.findIndex(item => item.name === 'ä¸¸å¤ª');
        if (logIndex > -1) {
            const removedLog = player.inventory.splice(logIndex, 1)[0];
            player.weight -= removedLog.weight;
            player.volume -= removedLog.volume;
        }
    }

    placedObjects.push({ 
        x: player.x, 
        y: player.y, 
        type: 'barricade', 
        name: 'ãƒãƒªã‚±ãƒ¼ãƒ‰', 
        graphic: 'ğŸš§', 
        health: 100,
        maxHealth: 100 
    });

    advanceTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    updateTurnInfo();
    checkGameOver();
    updateCurrentLocationPanel(false);
}

function placeBarricadeItem(item, itemIndex, source) {
    if (placedObjects.find(o => o.x === player.x && o.y === player.y)) { 
        log(`ã“ã“ã«ã¯æ—¢ã«ä½•ã‹ãŒè¨­ç½®ã•ã‚Œã¦ã„ã‚‹ã€‚`); 
        return; 
    }
    
    snapshotStats();
    
    const removedItem = player.inventory.splice(itemIndex, 1)[0];
    player.weight -= removedItem.weight;
    player.volume -= removedItem.volume;
    
    log("ãƒãƒªã‚±ãƒ¼ãƒ‰ã‚’è¨­ç½®ã—ãŸã€‚");
    createSound(player.x, player.y, 6);
    
    placedObjects.push({ 
        x: player.x, 
        y: player.y, 
        type: 'barricade', 
        name: 'ãƒãƒªã‚±ãƒ¼ãƒ‰', 
        graphic: 'ğŸš§', 
        health: 100,
        maxHealth: 100 
    });
    
    drawMap();
    updateItemPanels();
    updateStatus();
    hideItemDetail();
}

function dismantleBarricade() {
    const barricadeObject = currentItemDetail.item;
    if (!barricadeObject || barricadeObject.type !== 'barricade') return;
    
    log("æ–§ã‚’ä½¿ã„ã€ãƒãƒªã‚±ãƒ¼ãƒ‰ã‚’è§£ä½“ã—ã¦ã‚¢ã‚¤ãƒ†ãƒ ã«æˆ»ã—ãŸã€‚");

    const barricadeItem = items.find(i => i.name === 'ãƒãƒªã‚±ãƒ¼ãƒ‰');
    if (barricadeItem) {
        const newItem = { ...barricadeItem };

        if (player.weight + newItem.weight > player.maxWeight || player.volume + newItem.volume > player.maxVolume) {
            log("é‡ã•ã‹å®¹é‡ãŒè¶³ã‚Šãªãã¦æŒã¦ãªã„ãŸã‚ã€åœ°é¢ã«ç½®ã„ãŸã€‚");
            const locationKey = `${barricadeObject.x},${barricadeObject.y}`;
            if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
            droppedItems[locationKey].push(newItem);
        } else {
            log("ãƒãƒªã‚±ãƒ¼ãƒ‰ã‚’æ‰€æŒå“ã«åŠ ãˆãŸã€‚");
            player.inventory.push(newItem);
            player.weight += newItem.weight;
            player.volume += newItem.volume;
        }
    }

    const objectIndex = placedObjects.findIndex(o => o === barricadeObject);
    if (objectIndex > -1) {
        placedObjects.splice(objectIndex, 1);
    }
    
    hideItemDetail();
    advanceTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCurrentLocationPanel(false);
}

function dismantleItem(itemIndex, source) {
    const sourceArray = source === 'inventory' ? player.inventory : player.equipment;
    const itemToDismantle = sourceArray[itemIndex];
    
    if (!itemToDismantle) return;

    const recipe = dismantleRecipes[itemToDismantle.name];
    if (!recipe) {
        log("ã“ã‚Œã¯è§£ä½“ã§ããªã„ã€‚");
        return;
    }

    log(`${itemToDismantle.name}ã‚’è§£ä½“ã—ãŸã€‚`);

    const removedItem = sourceArray.splice(itemIndex, 1)[0];
    player.weight -= removedItem.weight || 0;
    if (source === 'inventory') {
        player.volume -= removedItem.volume || 0;
    }

    recipe.forEach(result => {
        const materialTemplate = items.find(i => i.name === result.name);
        if (materialTemplate) {
            for (let i = 0; i < result.count; i++) {
                const newItem = { ...materialTemplate };
                if (player.weight + newItem.weight <= player.maxWeight && player.volume + newItem.volume <= player.maxVolume) {
                    player.inventory.push(newItem);
                    player.weight += newItem.weight || 0;
                    player.volume += newItem.volume || 0;
                    log(`${newItem.name}ã‚’æ‰‹ã«å…¥ã‚ŒãŸã€‚`);
                } else {
                    const locationKey = `${player.x},${player.y}`;
                    if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
                    droppedItems[locationKey].push(newItem);
                    log(`${newItem.name}ã‚’æ‰‹ã«å…¥ã‚ŒãŸãŒã€æŒã¦ãªã„ã®ã§åœ°é¢ã«ç½®ã„ãŸã€‚`);
                }
            }
        }
    });

    hideItemDetail();
    updateEquippedStats();
    updateItemPanels();
    updateStatus();
    updateCurrentLocationPanel(false);
    speakQueuedLogs(); // ã€è¿½åŠ ã€‘
}

function wipeClothes(item, itemIndex, source) {
    const soakingWetClothes = player.equipment.filter(e => e.type === 'clothing' && e.wetness === 'soaking_wet');
    if (soakingWetClothes.length === 0) {
        log("æ‹­ãå¿…è¦ã®ã‚ã‚‹ã€ãšã¶æ¿¡ã‚Œã®æœãŒãªã„ã€‚");
        hideItemDetail();
        return;
    }

    log(`${item.name}ã‚’ä½¿ã£ã¦ã€ãšã¶æ¿¡ã‚Œã®æœã‚’æ‹­ã„ãŸã€‚`);
    soakingWetClothes.forEach(cloth => {
        cloth.wetness = 'wet';
    });

    updateItemPanels();
    updateStatus();
    hideItemDetail();
}

function wringCloth(item, itemIndex, source) {
    if (item.wetness !== 'soaking_wet') {
        log("ã“ã®æœã¯çµã‚‹å¿…è¦ãŒãªã„ã€‚");
        hideItemDetail();
        return;
    }

    snapshotStats();
    log(`${getItemDisplayName(item)}ã‚’çµã‚Šã€æ°´æ°—ã‚’åˆ‡ã£ãŸã€‚`);
    item.wetness = 'wet';

    hideItemDetail();
    advanceTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    updateTurnInfo();
    checkGameOver();
}

// --- NEW Vision and Sound Functions ---
function getDistance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

// â–¼â–¼â–¼ hasLineOfSighté–¢æ•°ã‚’ã¾ã‚‹ã”ã¨ã“ã‚Œã§ç½®ãæ›ãˆ â–¼â–¼â–¼
function hasLineOfSight(x1, y1, x2, y2) {
    let dx = Math.abs(x2 - x1);
    let dy = -Math.abs(y2 - y1);
    let sx = x1 < x2 ? 1 : -1;
    let sy = y1 < y2 ? 1 : -1;
    let err = dx + dy;

    // ãƒ«ãƒ¼ãƒ—ã®çµ‚ç‚¹ï¼ˆå¯¾è±¡ã®ãƒã‚¹ï¼‰è‡ªä½“ã¯é®è”½ç‰©åˆ¤å®šã‹ã‚‰é™¤å¤–ã™ã‚‹
    const endX = x2;
    const endY = y2;

    while (true) {
        // ç¾åœ¨ã®ãƒã‚¹ãŒçµ‚ç‚¹ï¼ˆå¯¾è±¡ã®ãƒã‚¹ï¼‰ã§ãªã‘ã‚Œã°ã€é®è”½ç‰©ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯
        if (x1 !== endX || y1 !== endY) {
            if (map[y1][x1].loc.blocksVision) {
                return false;
            }
        }
        
        if (x1 === endX && y1 === endY) break;
        
        let e2 = 2 * err;
        if (e2 >= dy) {
            err += dy;
            x1 += sx;
        }
        if (e2 <= dx) {
            err += dx;
            y1 += sy;
        }
    }
    return true;
}

function createSound(x, y, radius, sourceAction = 'ä¸æ„ã®ç‰©éŸ³') {
    const shoes = player.equipment.find(e => e.slot === 'feet');
    const soundModifier = shoes ? (shoes.soundModifier || 1.0) : 1.2; 
    let weatherModifier = 1.0;
    if (currentWeather.name === 'é›¨') weatherModifier = 0.7;
    if (currentWeather.name === 'åµ') weatherModifier = 0.4;

    let soundRadius = radius * soundModifier * weatherModifier;
    
    currentSoundLevel = parseFloat(soundRadius.toFixed(1));

    lastSoundCalculation = {
        base: radius,
        shoes: shoes ? { name: shoes.name, modifier: soundModifier } : { name: 'ç´ è¶³', modifier: soundModifier },
        weather: { name: currentWeather.name, modifier: weatherModifier },
        total: currentSoundLevel,
        source: sourceAction
    };

    entities.forEach(entity => {
        if (getDistance(x, y, entity.x, entity.y) <= soundRadius) {
            if (entity.isZombie || (entity.isAnimal && !entity.flees)) {
                entity.investigationTarget = { x, y };
                entity.aiState = 'investigating';
            } else if (radius > 5 && (entity.flees || entity.type === 'Survivor' || entity.type === 'Trader')) {
                entity.target = {x, y}; 
                entity.aiState = 'fleeing';
            }
        }
    });
}

function moveEntityTowards(entity, targetX, targetY) {
    let dx = targetX - entity.x;
    let dy = targetY - entity.y;
    let newX = entity.x;
    let newY = entity.y;

    if (Math.abs(dx) > Math.abs(dy)) {
        newX += Math.sign(dx);
    } else if (Math.abs(dy) > 0) {
        newY += Math.sign(dy);
    }
    moveEntityTo(entity, newX, newY);
}

function moveEntityAwayFrom(entity, targetX, targetY) {
    let dx = entity.x - targetX;
    let dy = entity.y - targetY;
    let newX = entity.x;
    let newY = entity.y;

    if (Math.abs(dx) > Math.abs(dy)) {
        newX += Math.sign(dx);
    } else {
        newY += Math.sign(dy);
    }
    moveEntityTo(entity, newX, newY);
}

function moveEntityTo(entity, newX, newY) {
    if (newX < 0 || newY < 0 || newX >= mapSize || newY >= mapSize) return;

    const barricade = placedObjects.find(o => o.x === newX && o.y === newY && o.type === 'barricade' && o.health > 0);
    if (barricade) {
        resolveEntityAttackOnObject(entity, barricade);
    } else if (!entities.some(e => e.x === newX && e.y === newY) && !(player.x === newX && player.y === newY)) {
        entity.x = newX;
        entity.y = newY;
    }
}

// --- NEW Targeting Functions ---
function startTargeting(item, index, source) {
    targetingState.active = true;
    targetingState.item = item;
    targetingState.itemIndex = index;
    targetingState.source = source;
    targetingState.range = item.throwRange || 5;

    log(`${item.name}ã‚’æŠ•ã’ã‚‹å ´æ‰€ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚(ã‚¯ãƒªãƒƒã‚¯ã§æ±ºå®šã€å³ã‚¯ãƒªãƒƒã‚¯ã§ã‚­ãƒ£ãƒ³ã‚»ãƒ«)`);
    hideItemDetail();
    drawMap();
}

function cancelTargeting() {
    targetingState.active = false;
    log("æŠ•ã’ã‚‹ã®ã‚’ã‚„ã‚ãŸã€‚");
    drawMap();
}

function handleTargetingClick(targetX, targetY) {
    if (Math.abs(targetX - player.x) > targetingState.range || Math.abs(targetY - player.y) > targetingState.range) {
        log("ãã“ã¾ã§ã¯å±Šã‹ãªã„ã€‚");
        cancelTargeting();
        return;
    }

    const item = targetingState.item;
    const itemIndex = targetingState.itemIndex;

    log(`${item.name}ã‚’ (${targetX}, ${targetY}) ã«æŠ•ã’ãŸã€‚`);
    
    // Create sound at the target location
    createSound(targetX, targetY, item.throwSoundRadius || 5);
    
    // Remove item from inventory
    const removedItem = player.inventory.splice(itemIndex, 1)[0];
    player.weight -= removedItem.weight;
    player.volume -= removedItem.volume;
    
    // Drop the item at the target location
    const locationKey = `${targetX},${targetY}`;
    if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
    droppedItems[locationKey].push(removedItem);

    cancelTargeting();
    advanceTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    updateTurnInfo();
    checkGameOver();
}

function setMovementMode(mode) {
    player.movementMode = mode;
    const message = `ç§»å‹•æ–¹æ³•ã‚’ã€Œ${{sneak: 'éš å¯†', walk: 'æ­©è¡Œ', run: 'èµ°è¡Œ'}[mode]}ã€ã«å¤‰æ›´ã—ãŸã€‚`;

    // 1. æ—¥è¨˜ãƒ‘ãƒãƒ«ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã™ã‚‹
    // log()é–¢æ•°ã‹ã‚‰ç”»é¢è¡¨ç¤ºéƒ¨åˆ†ã ã‘ã‚’æŠœãå‡ºã—ã¦å®Ÿè¡Œ
    const logDiv = document.getElementById("log");
    Array.from(logDiv.children).forEach(div => {
        div.style.color = "#666";
        div.style.fontWeight = "normal";
    });
    let div = document.createElement("div");
    div.innerHTML = message;
    div.classList.add("new");
    logDiv.appendChild(div);
    logDiv.scrollTop = logDiv.scrollHeight;

    // 2. ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚­ãƒ¥ãƒ¼ã«å…¥ã‚Œãšã€å³åº§ã«èª­ã¿ä¸Šã’ã‚‹
    // HTMLã‚¿ã‚°ã‚’å–ã‚Šé™¤ã„ã¦ã‹ã‚‰speaké–¢æ•°ã«æ¸¡ã™
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = message;
    const plainText = tempDiv.textContent || tempDiv.innerText || "";
    speak(plainText);

    // 3. ãƒœã‚¿ãƒ³ã®è¡¨ç¤ºã‚’æ›´æ–°ã™ã‚‹
    updateMovementButtons();
}

function showBodyOdorTooltip(event) {
    const preview = document.getElementById("statusPreview");
    let description = 'æ™‚é–“ã®çµŒéã‚„ä½“æ¸©ã®ä¸Šæ˜‡ã§å¢—åŠ ã—ã¾ã™ã€‚è‡­ã„ãƒ¬ãƒ™ãƒ«ã«å½±éŸ¿ã—ã€æ•µã«ç™ºè¦‹ã•ã‚Œã‚„ã™ããªã‚Šã¾ã™ã€‚æ°´å ´ã§ä½“ã‚’æ´—ã†ã¨ãƒªã‚»ãƒƒãƒˆã§ãã¾ã™ã€‚';
    let contentHtml = `<strong>ä½“è‡­</strong><div style="margin-top: 5px;">${description}</div>`;
    preview.innerHTML = contentHtml;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}
function updateMovementButtons() {
    document.querySelectorAll('#movementControls button').forEach(btn => btn.classList.remove('active'));
    if (player.movementMode === 'walk') document.getElementById('moveWalkBtn').classList.add('active');
    else if (player.movementMode === 'run') document.getElementById('moveRunBtn').classList.add('active');
}

function washBody() {
    if (player.bodyOdor <= 0) {
        log("ã“ã‚Œä»¥ä¸Šä½“ã‚’æ´—ã†å¿…è¦ã¯ãªã„ã€‚");
        return;
    }

    const performWash = () => {
        snapshotStats();
        log("æ± ã®æ°´ã§ä½“ã‚’æ´—ã„ã€ã•ã£ã±ã‚Šã—ãŸã€‚");
        createSound(player.x, player.y, 3, 'æ°´æµ´ã³'); // ä½“ã‚’æ´—ã†éŸ³ã‚’ç™ºç”Ÿã•ã›ã‚‹
        player.bodyOdor = 0;
        
        updatePlayerSmell(); // â˜…ã“ã®ä¸€è¡Œã‚’è¿½åŠ ã—ã¦è‡­ã„ãƒ¬ãƒ™ãƒ«ã‚’å³æ™‚å†è¨ˆç®—

        player.equipment.forEach(item => {
            if (item.type === 'clothing') {
                if (item.wetness === 'dry') item.wetness = 'wet';
                else if (item.wetness === 'wet') item.wetness = 'soaking_wet';
            }
        });
        log("ç€ã¦ã„ãŸæœãŒæ¿¡ã‚Œã¦ã—ã¾ã£ãŸã€‚");

        // ä»–ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¨å‡¦ç†é †ã‚’çµ±ä¸€ã—ã€UIæ›´æ–°å¾Œã«ã‚¿ãƒ¼ãƒ³ã‚’é€²è¡Œã•ã›ã‚‹
        updateTurnInfo();
        drawMap();
        updateStatus();
        updateItemPanels();
        updateCharacterBody();
        updateCharacterInfo();
        advanceTurn(); // UIæ›´æ–°ã®å¾Œã«ã‚¿ãƒ¼ãƒ³ã‚’é€²è¡Œã•ã›ã‚‹
        checkGameOver();
    };

    // ç¾åœ¨ã®æ™‚åˆ»ãŒ17æ™‚å°ã®å ´åˆã€å¤œã«ãªã‚‹ã“ã¨ã‚’è­¦å‘Šã™ã‚‹
    if (currentTime.getHours() === 17) {
        speakAndConfirm("ã“ã“ã§1æ™‚é–“éã”ã™ã¨è¾ºã‚ŠãŒæš—ããªã£ã¦ã—ã¾ã„ã¾ã™ã€‚ä½“ã‚’æ´—ã„ã¾ã™ã‹ï¼Ÿ", performWash, () => {
            log("ä½“ã‚’æ´—ã†ã®ã‚’ã‚„ã‚ãŸã€‚");
        });
    } else {
        performWash();
    }
}

// Initial setup
document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.panel').forEach(panel => {
        panel.style.display = 'none';
        const header = panel.querySelector(".panel-header");
        if (header) {
            panel.addEventListener("mousedown", () => bringToFront(panel));
            header.addEventListener("click", () => { if (panel.classList.contains("minimized")) togglePanelSize(panel); });
            header.addEventListener("dblclick", () => { if (!panel.classList.contains("minimized")) togglePanelSize(panel); });
        }
        makeDraggable(panel); makeResizable(panel);
    });

    document.getElementById('map').addEventListener('contextmenu', e => {
        e.preventDefault();
        if (targetingState.active) {
            cancelTargeting();
        }
    });

    // â–¼â–¼â–¼ ã“ã“ã«ã€Œã‚²ãƒ¼ãƒ é–‹å§‹ã€ãƒœã‚¿ãƒ³ã®å‡¦ç†ãŒå¾©æ´»ã—ã¦ã„ã¾ã™ â–¼â–¼â–¼
    document.getElementById('startGameBtn').addEventListener('click', initGame);
    
    document.getElementById('enableSpeechToggle').addEventListener('change', (event) => {
        isSpeechEnabled = event.target.checked;
        if (isSpeechEnabled) {
            speak("éŸ³å£°èª­ã¿ä¸Šã’ãŒæœ‰åŠ¹ã«ãªã‚Šã¾ã—ãŸã€‚");
        }
    });
    document.getElementById('quitGameBtn').addEventListener('click', () => window.close());
    document.getElementById('playAgainBtn').addEventListener('click', initGame);
    document.getElementById('closeStorageBtn').addEventListener('click', closeStoragePanel);
    document.getElementById('pickupStorageBtn').addEventListener('click', pickupStorageBox);
    document.getElementById('sleepNowBtn').addEventListener('click', sleepForOneHour);
    document.getElementById('suicideBtn').addEventListener('click', () => speakAndConfirm("æœ¬å½“ã«è‡ªã‚‰å‘½ã‚’çµ¶ã¡ã¾ã™ã‹ï¼Ÿ", () => handleGameOver("è‡ªã‚‰å‘½ã‚’çµ¶ã£ãŸã€‚"), () => log("æ€ã„ã¨ã©ã¾ã£ãŸã€‚")));
    document.getElementById('waitTurnBtn').addEventListener('click', waitOneTurn);    
    const bodyTempLine = document.getElementById('bodyTempStatusLine');
    bodyTempLine.addEventListener('mouseenter', showBodyTempTooltip);
    bodyTempLine.addEventListener('mouseleave', hideStatusPreview);
    bodyTempLine.addEventListener('mousemove', (e) => updatePreviewPosition(e));

    const bodyOdorLine = document.getElementById('bodyOdorStatusLine');
    bodyOdorLine.addEventListener('mouseenter', showBodyOdorTooltip);
    bodyOdorLine.addEventListener('mouseleave', hideStatusPreview);
    bodyOdorLine.addEventListener('mousemove', (e) => updatePreviewPosition(e));

    const walkBtn = document.getElementById('moveWalkBtn');
    const runBtn = document.getElementById('moveRunBtn');

    walkBtn.onclick = () => setMovementMode('walk');
    walkBtn.addEventListener('mouseenter', (e) => showMovementTooltip(e, 'walk'));
    walkBtn.addEventListener('mouseleave', hideStatusPreview);
    walkBtn.addEventListener('mousemove', updatePreviewPosition);

    runBtn.onclick = () => setMovementMode('run');
    runBtn.addEventListener('mouseenter', (e) => showMovementTooltip(e, 'run'));
    runBtn.addEventListener('mouseleave', hideStatusPreview);
    runBtn.addEventListener('mousemove', updatePreviewPosition);

    // â˜…â˜…â˜… ã‚»ãƒ¼ãƒ–ãƒ»ãƒ­ãƒ¼ãƒ‰é–¢é€£ã®å‡¦ç† â˜…â˜…â˜…
    document.getElementById('saveGameBtn').addEventListener('click', saveGame);
    document.getElementById('loadGameBtn').addEventListener('click', loadGame);

    ipcRenderer.invoke('has-save-file').then(hasSave => {
        if (hasSave) {
            document.getElementById('loadGameBtn').style.display = 'inline-block';
        }
    });
    // â˜…â˜…â˜… ã“ã“ã¾ã§ â˜…â˜…â˜…

    window.addEventListener('resize', drawMap);
});
</script>

</body>
</html>