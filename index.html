<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>絶望サバイバル</title>
<meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline'">
<style>
body {
  background: #111;
  color: #eee;
  font-family: monospace, monospace;
  margin: 0;
  user-select: none;
  height: 100vh;
  overflow: hidden;
  position: relative;
  transition: background-color 2s linear;
}
#startScreen, #gameClearScreen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #111;
  color: #eee;
  z-index: 10000;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
  font-family: sans-serif;
}
#startScreen h1 {
  font-size: 3em;
  color: #e74c3c;
  text-shadow: 0 0 10px #c0392b;
}
#startScreen button, #gameClearScreen button {
  padding: 15px 30px;
  font-size: 1.5em;
  background: #333;
  color: #eee;
  border: 1px solid #555;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.3s ease;
  margin-top: 20px;
}
#startScreen button:hover, #gameClearScreen button:hover {
  background: #555;
  border-color: #777;
  transform: scale(1.05);
}
#quitGameBtn {
    background: #a04040 !important;
    border-color: #c06060 !important;
}
#quitGameBtn:hover {
    background: #c0392b !important;
}
/* ▼▼▼ このブロックを<style>タグ内に追加 ▼▼▼ */
#languageSwitcher button {
    padding: 8px 15px;
    margin: 0 5px;
    background-color: #333;
    border: 1px solid #555;
    color: #eee;
    cursor: pointer;
    transition: background-color 0.2s;
}
#languageSwitcher button:hover {
    background-color: #555;
}
#languageSwitcher button.active {
    background-color: #2ecc71;
    color: #111;
    border-color: #27ae60;
    font-weight: bold;
}
/* ▲▲▲ 追加ここまで ▲▲▲ */
#gameClearScreen .gate-art {
  font-size: 1.5em;
  line-height: 1.2;
  white-space: pre;
  color: #f1c40f;
  margin-bottom: 20px;
}
#gameClearScreen h2 {
    font-size: 2.5em;
    margin-bottom: 20px;
}
#gameClearScreen p {
    font-size: 1.2em;
    margin-bottom: 30px;
}

.panel {
  position: absolute;
  background: #222;
  border-radius: 6px;
  border: 1px solid #444;
  padding: 10px;
  box-sizing: border-box;
  cursor: grab;
  user-select: none;
  z-index: 10;
  box-shadow: 0 0 15px #000a inset;
  overflow: hidden;
}
.panel .resize-handle {
  position: absolute;
  width: 16px;
  height: 16px;
  right: 2px;
  bottom: 2px;
  background: #888;
  border-radius: 4px;
  cursor: nwse-resize;
  z-index: 1000;
}
.panel .resize-handle:hover {
  background: #aaa;
}
#mapPanel .resize-handle {
  display: none;
}
/* ▼▼▼ このブロックをCSS内に追加 ▼▼▼ */
#characterPanel .resize-handle,
#statusPanel .resize-handle,
#turnPanel .resize-handle {
  display: none;
}
/* ▲▲▲ 追加ここまで ▲▲▲ */
.panel-header {
  font-weight: bold;
  margin-bottom: 6px;
  cursor: grab;
  user-select: none;
  padding-bottom: 4px;
  border-bottom: 1px solid #555;
  user-select:none;
  -webkit-user-select:none;
  -moz-user-select:none;
  -ms-user-select:none;
  display: flex;
  justify-content: space-between;
  align-items: center;
}
#mapHeaderInfo {
    font-size: 14px;
    font-weight: normal;
    color: #ccc;
    /* pointer-events: none; の行を削除 */
}
#mapHeaderInfo .temp-hot { color: #e74c3c; }
#mapHeaderInfo .temp-normal { color: #2ecc71; }
#mapHeaderInfo .temp-cold { color: #3498db; }
#mapHeaderInfo span { margin: 0 5px; }

#map {
  display: grid;
  grid-gap: 0px;
  width: 100%;
  height: 100%;
  overflow: visible;
  font-size: 12px;
  position: relative;
  justify-content: center; /* ← 横方向の中央揃えを追加 */
  align-content: center;   /* ← 縦方向の中央揃えを追加 */
}
/* ▼▼▼ 既存の .tile の定義を、このブロックで丸ごと置き換えてください ▼▼▼ */
.tile {
  width: 40px;
  height: 40px;
  cursor: pointer;
  background: #555;
  user-select: none;
  position: relative; /* ← 画像を重ねるための基準点にする */
  transition: background-color 0.3s;
}

/* 画像を重ねるための新しいスタイルを追加 */
.tile-img {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  image-rendering: pixelated;
}

/* ▼▼▼ このブロックで置き換えてください ▼▼▼ */
.tile .tile-terrain {
  z-index: 1 !important; /* 地形 */
}
.tile .tile-object {
  z-index: 2 !important; /* 死体などの設置物 */
}
.tile .tile-player {
  z-index: 3 !important; /* プレイヤー */
}
.tile .tile-entity {
  z-index: 4 !important; /* 敵やNPCなどの動く存在 */
}
/* ▲▲▲ 置き換えここまで ▲▲▲ */
.tile.targeting {
    background-color: #8E44AD;
    box-shadow: 0 0 10px #8E44AD;
}
.tile.targeting:hover {
    background-color: #9B59B6;
}
.unexplored {
  background: #555;
  color: #555;
}
.explored {
  background: #777;
}
.memorized-tile {
  background: #5a3d24; /* 記憶を表す茶色 */
  color: #aaa; /* 記憶内のアイコンを少し暗くする */
}
.road-tile {
  background: #4a4a4a;
}
.memorized-tile img {
  opacity: 0.5; /* 画像を半透明にする */
}
.player-tile {
  background: #2c3e50; /* Changed background for player tile */
  position: relative;
}
.map-overlay-icon {
    position: absolute;
    font-size: 32px;
    z-index: 60;
    text-shadow: 0 0 8px #000;
    pointer-events: all;
    cursor: help;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    height: 100%;
}
.map-overlay-icon.campfire {
    animation: flicker 1.5s infinite alternate;
}
.map-overlay-icon.unlit-campfire {
    filter: grayscale(100%) brightness(0.7);
}
@keyframes flicker {
  0%, 18%, 22%, 25%, 53%, 57%, 100% {
    text-shadow:
      0 0 4px #fff,
      0 0 11px #fff,
      0 0 19px #fff,
      0 0 40px #f09,
      0 0 80px #f09,
      0 0 90px #f09,
      0 0 100px #f09,
      0 0 150px #f09;
  }
  20%, 24%, 55% { text-shadow: none; }
}

.entity-icon {
    position: absolute;
    font-size: 24px;
    z-index: 40;
    text-shadow: 0 0 5px #000;
    pointer-events: all; /* Make icon hoverable */
    cursor: help;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    height: 100%;
}
.player-icon {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 24px;
  z-index: 50;
  text-shadow: 0 0 5px #000;
  pointer-events: none;
}
.player-icon.race-white { color: #f5f5dc; }
.player-icon.race-asian { color: #f7e7c6; }
.player-icon.race-black { color: #2e2621; }
.player-icon.race-middle-eastern { color: #8b5a2b; }

#playerDirectionArrow {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  border-left: 10px solid transparent;
  border-right: 10px solid transparent;
  border-bottom: 20px solid red;
  transform-origin: 50% 100%;
  z-index: 50;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s ease, transform 0.2s ease;
}
/* ▼▼▼ この2つのブロックを置き換えてください ▼▼▼ */
.status-line {
  margin-bottom: 6px;
  font-family: sans-serif;
  cursor: default;
  display: flex; /* ← Flexboxを有効化 */
  align-items: center; /* ←要素を縦方向中央に揃える */
}
.status-label {
  flex-basis: 90px; /* ← ラベルの基本幅を90pxに確保 */
  flex-shrink: 0; /* ← ラベルが縮まないようにする */
  font-weight: bold;
  color: #ccc;
}
/* ▲▲▲ 置き換えここまで ▲▲▲ */
.bar {
  display: inline-block;
  width: 150px;
  height: 10px;
  background: #333;
  margin-right: 6px;
  border-radius: 5px;
  vertical-align: middle;
  overflow: hidden;
}
.fill {
  height: 100%;
  background: lime;
  transition: width 0.3s ease;
}
.fill.hunger { background: #d35400; }
.fill.thirst { background: #2980b9; }
.fill.health { background: #27ae60; }
.fill.morale { background: #f1c40f; }
.fill.sleep { background: #8e44ad; }
.fill.weight { background: #7f8c8d; }
.fill.volume { background: #9b59b6; }
.fill.attack { background: #e67e22; }
.fill.defense { background: #2980b9; }
.fill.bodyTemp { background: #7f8c8d; }
#log {
  background: #000;
  height: 100%; /* ← 高さをパネル全体に広げる */
  overflow-y: auto;
  font-size: 12px;
  padding: 5px;
  margin: 0; /* ← 上部の余白を削除 */
  line-height: 1.3em;
  font-weight: normal;
  color: #888;
  box-sizing: border-box; /* ← パディングを高さに含める */
}
#log div.new {
  color: #eee;
  font-weight: bold;
}
.item-list {
  background: #111;
  padding: 5px;
  height: calc(100% - 25px);
  overflow-y: auto;
  margin-top: 6px;
  font-family: sans-serif;
  color: #eee;
}
.item {
  background: #333;
  padding: 5px;
  margin: 3px 0;
  cursor: pointer;
  font-size: 12px;
  border-radius: 4px;
}
.item:hover {
  background: #555;
}
.item button {
  background: #444;
  color: #eee;
  border: none;
  padding: 2px 5px;
  border-radius: 3px;
  cursor: pointer;
  opacity: 0.7;
 }
 .item button:hover {
  opacity: 1.0;
  background: #666;
 }

#currentLocationPanel .location-name {
  font-family: sans-serif;
  font-size: 1.2em;
  margin-bottom: 5px;
}

#itemDetailPanel {
  position: absolute;
  background: #222;
  border-radius: 6px;
  border: 1px solid #444;
  padding: 15px;
  box-shadow: 0 0 20px rgba(0,0,0,0.8);
  z-index: 1000;
  width: 300px;
  max-width: 90vw;
  font-family: sans-serif;
  display: none;
}
#itemDetailPanel .panel-header {
  font-size: 1.2em;
  border-bottom: 1px solid #555;
  padding-bottom: 8px;
  margin-bottom: 10px;
  cursor: grab;
}
#itemDetailPanel .item-detail-info {
  line-height: 1.6em;
  font-size: 14px;
}
#itemDetailPanel .item-detail-info strong {
  display: inline-block;
  width: 80px;
}
#itemDetailPanel .item-detail-actions {
  margin-top: 15px;
  text-align: right;
}
#itemDetailPanel button {
  background: #444;
  color: #eee;
  border: none;
  padding: 8px 15px;
  border-radius: 5px;
  cursor: pointer;
  margin-left: 5px;
}
#itemDetailPanel button:hover {
  background: #666;
}
.item-graphic-container {
  text-align: center;
  margin: 10px 0;
}
.item-graphic {
  font-size: 48px;
  line-height: 1;
}
.item-description {
  margin-bottom: 10px;
  border-bottom: 1px solid #555;
  padding-bottom: 10px;
}
.item-effect-positive { color: limegreen; }
.item-effect-negative { color: indianred; }
#statusPreview {
  position: fixed;
  background: rgba(34, 34, 34, 0.95);
  border: 1px solid #666;
  border-radius: 4px;
  padding: 8px;
  font-size: 12px;
  color: #eee;
  pointer-events: none;
  z-index: 9999;
  display: none;
  box-shadow: 0 2px 8px rgba(0,0,0,0.5);
  line-height: 1.5;
}
.preview-stat {
  margin: 2px 0;
  display: flex;
  align-items: center;
}
.preview-stat-name {
  width: 50px;
  display: inline-block;
}
.preview-change {
  margin-left: 5px;
  font-weight: bold;
}
.preview-change.positive { color: #27ae60; }
.preview-change.negative { color: #e74c3c; }
.preview-change.neutral { color: #95a5a6; }
.trait-pill {
    background: #444;
    color: #fff;
    padding: 3px 8px;
    margin-right: 4px;
    border-radius: 12px;
    font-size: 12px;
    display: inline-block;
    white-space: nowrap;
    cursor: help;
}
#physicalCondition {
  margin-top: 10px;
  font-family: sans-serif;
  font-size: 14px;
  line-height: 1.4;
  padding: 5px;
  border-top: 1px solid #555;
}
#physicalCondition span[onmouseenter] {
    cursor: help;
    text-decoration: underline dotted;
}
.condition-normal { color: #3498db; }
.condition-warning { color: #f1c40f; }
.condition-critical { color: #e74c3c; }

#physicalCondition strong {
  display: block;
  margin-bottom: 5px;
}
.panel.minimized {
  position: fixed !important;
  right: 10px;
  bottom: 10px;
  width: auto !important;
  height: auto !important;
  padding: 0;
  border: 1px solid #444;
  overflow: visible;
  z-index: 999 !important;
  min-width: 0 !important;
  max-width: none !important;
  max-height: none !important;
  transition: all 0.3s ease;
}
.panel.minimized .panel-header {
  border-bottom: none;
  padding: 5px 10px;
  margin: 0;
}
.panel.minimized .resize-handle {
  display: none;
}
.panel.minimized .panel-content,
.panel.minimized #map,
.panel.minimized #status,
.panel.minimized #turnInfoText,
.panel.minimized #log,
.panel.minimized .item-list,
.panel.minimized #craftingPanel .panel-content,
.panel.minimized #characterBasic,
.panel.minimized #charBody,
.panel.minimized #currentLocationBody {
  display: none;
}
.panel.minimized#itemDetailPanel {
  display: none !important;
}
#turnInfoText {
  line-height: 1.6;
}
#craftingList .item button {
    float: right;
}
#craftingList .item.un-craftable {
    background: #2a2a2a;
    color: #777;
    cursor: not-allowed;
}
#craftingList .item.un-craftable button {
    display: none;
}
.recipe-ingredients {
    font-size: 10px;
    color: #aaa;
    margin-left: 15px;
}
.crafting-category-header {
    font-weight: bold;
    color: #f1c40f;
    margin-top: 10px;
    padding-bottom: 3px;
    border-bottom: 1px solid #555;
    cursor: pointer;
    user-select: none;
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.recipe-container.collapsed {
    display: none;
}

#damagePop {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(1);
  font-size: 6em;
  font-weight: bold;
  color: #e74c3c;
  text-shadow: 0 0 10px #000;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.5s ease-out, transform 0.5s ease-out;
  z-index: 9999;
}
#combatPanel {
    box-sizing: border-box;
    font-family: sans-serif;
}
#combatContent {
    display: flex;
    height: calc(100% - 30px);
    padding-top: 10px;
}
#combatPlayer, #combatEnemy {
    flex: 1;
    padding: 10px;
    text-align: center;
    position: relative;
}
#combatLogContainer {
    flex: 2;
    display: flex;
    flex-direction: column;
    padding: 0 10px;
}
#combatLog {
    flex-grow: 1;
    background: #000;
    color: #eee;
    font-size: 12px;
    padding: 10px;
    overflow-y: auto;
    margin-bottom: 10px;
    border: 1px solid #444;
    border-radius: 4px;
}
#combatActions {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
}
#combatActions button {
    width: 100%;
    padding: 10px;
    background: #444;
    color: #eee;
    border: none;
    cursor: pointer;
    border-radius: 4px;
    font-size: 14px;
    transition: background 0.2s;
}
#combatActions button:hover:not(:disabled) {
    background: #666;
}
#combatActions button:disabled {
    background: #333;
    color: #777;
    cursor: not-allowed;
}
#combatActions button.fire-btn {
    background: #c0392b;
}
#combatActions button.fire-btn:hover:not(:disabled) {
    background: #e74c3c;
}

#combatPlayerEquipment, #combatEnemyEquipment {
    margin-top: 15px;
    text-align: left;
    font-size: 12px;
    border-top: 1px solid #555;
    padding-top: 10px;
}
#combatPlayerInjuries {
    margin-top: 10px;
    text-align: left;
    font-size: 12px;
    color: indianred;
    border-top: 1px solid #555;
    padding-top: 10px;
}
#combatEquipmentList, #combatEnemyEquipmentList {
    margin-top: 5px;
    line-height: 1.5;
}
#combatPlayerStats div {
    cursor: help;
}
/* ▼▼▼ 既存のASCIIアート関連のスタイルを、このブロックで丸ごと置き換えてください ▼▼▼ */
#charBody, #locationAscii, #dialogueNpcAscii, .ascii-art-container {
  min-height: 100px;
  display: flex;
  justify-content: center;
  align-items: center;
}
#dialogueNpcAscii {
    min-height: 120px;
}
.ascii-art-container {
  font-size: 1em;
}

/* 体力に応じて枠線の色が変わる画像のためのスタイルを追加 */
#charBody img, #combatPlayerAscii img, #combatEnemyAscii img {
  border: 3px solid transparent; /* 初期状態では透明な枠線 */
  box-sizing: border-box;        /* 枠線が画像のサイズ内に収まるように */
  border-radius: 5px;            /* 枠線の角を少し丸める */
  transition: border-color 0.5s ease; /* 色の変化を滑らかにするアニメーション */
}
/* ▲▲▲ 置き換えここまで ▲▲▲ */
.hp-high { color: #eee; }
.hp-medium { color: #f1c40f; }
.hp-low { color: #e67e22; }
.hp-critical { color: #e74c3c; }


#comparisonModal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #333;
    color: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.6);
    z-index: 2001;
    font-family: sans-serif;
    width: 450px;
}
#comparisonModal h3 {
    text-align: center;
    margin-top: 0;
    margin-bottom: 15px;
    border-bottom: 1px solid #555;
    padding-bottom: 10px;
}
.comparison-container {
    display: flex;
    justify-content: space-between;
    margin-bottom: 20px;
}
.comparison-item {
    width: 48%;
    padding: 10px;
    box-sizing: border-box;
    background: #222;
    border-radius: 5px;
    text-align: center;
}
.comparison-item h4 {
    margin: 0 0 10px 0;
    font-size: 1em;
}
.comparison-item-graphic {
    font-size: 2.5em;
    margin-bottom: 10px;
}
.comparison-item-name {
    font-weight: bold;
    margin-bottom: 10px;
}
.comparison-stats {
    text-align: left;
    font-size: 0.9em;
}
.comparison-stats div {
    margin-bottom: 5px;
}
.stat-positive { color: limegreen; }
.stat-negative { color: indianred; }
.stat-neutral { color: #ccc; }
.comparison-actions {
    text-align: right;
}
.comparison-actions button {
    background: #444;
    color: #eee;
    border: none;
    padding: 8px 15px;
    border-radius: 5px;
    cursor: pointer;
    margin-left: 10px;
}
.comparison-actions button:hover {
    background: #666;
}
#dialoguePanel {
    width: 500px;
    height: 350px;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 1001;
}
#dialogueContent {
    display: flex;
    height: calc(100% - 30px);
    padding-top: 10px;
}
#dialogueNPC {
    flex: 1;
    text-align: center;
}
#dialogueNPC pre {
    font-size: 2.5em;
}
#dialogueTextContainer {
    flex: 2;
    display: flex;
    flex-direction: column;
    padding: 0 10px;
}
#dialogueText {
    flex-grow: 1;
    background: #111;
    padding: 10px;
    border: 1px solid #444;
    border-radius: 4px;
    margin-bottom: 10px;
    overflow-y: auto;
}
#dialogueActions {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
}
#dialogueActions button {
    padding: 10px;
    background-color: #444;
    color: #eee;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}
#dialogueActions button:hover {
    background: #666;
}
#tradePanel, #storagePanel {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 70vw;
    max-width: 750px;
    height: 90vh;
    max-height: 750px;
    z-index: 1002;
    display: flex;
    flex-direction: column;
}
.trade-main, .storage-main {
    display: flex;
    flex-grow: 1;
    gap: 10px;
    overflow: hidden;
}
.trade-column, .storage-column {
    flex: 1;
    display: flex;
    flex-direction: column;
    background: #333;
    padding: 10px;
    border-radius: 5px;
}
.trade-area {
    border: 2px dashed #555;
    min-height: 120px;
    flex-shrink: 0;
    padding: 5px;
    border-radius: 4px;
    overflow-y: auto;
}
.storage-area {
    flex-grow: 1;
    overflow-y: auto;
    border: 1px solid #555;
    padding: 5px;
    border-radius: 4px;
}
.trade-inventory, .storage-inventory {
    flex-grow: 1;
    overflow-y: auto;
    border-top: 1px solid #555;
    margin-top: 10px;
    padding-top: 10px;
}
.trade-footer, .storage-footer {
    padding-top: 10px;
    text-align: center;
}
.trade-footer button, .storage-footer button {
    padding: 10px 20px;
    margin: 0 5px;
}
.trade-value {
    font-weight: bold;
    margin: 5px 0;
}
#suicideBtn {
    width: 100%;
    padding: 8px;
    margin-top: 10px;
    background-color: #a04040;
    color: #eee;
    border: 1px solid #c06060;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
}
#suicideBtn:hover {
    background-color: #c0392b;
}
/* ▼▼▼ このブロックをコピーして追加 ▼▼▼ */
#waitTurnBtn {
    width: 100%;
    padding: 8px;
    margin-top: 5px; /* 上のボタンとの間隔を調整 */
    background-color: #4a4a52;
    color: #eee;
    border: 1px solid #666;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
}
/* ▼▼▼ このブロックをコピーしてCSS内に追加 ▼▼▼ */
#sleepNowBtn {
    width: 100%;
    padding: 8px;
    margin-top: 5px;
    background-color: #4a4a52;
    color: #eee;
    border: 1px solid #666;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
}
#sleepNowBtn:hover {
    background-color: #6c6c74;
}
/* ▲▲▲ ここまで ▲▲▲ */
#waitTurnBtn:hover {
    background-color: #6c6c74;
}
/* ▲▲▲ ここまで ▲▲▲ */
#locationActions {
    margin-top: 10px;
    border-top: 1px solid #555;
    padding-top: 5px;
}
#locationActions button {
    width: 100%;
    padding: 6px;
    margin-top: 5px;
    background: #4a4a52;
    color: #eee;
    border: 1px solid #666;
    border-radius: 3px;
    cursor: pointer;
}
#locationActions button:hover:not(:disabled) {
    background: #6c6c74;
}
#locationActions button:disabled {
    background: #333;
    color: #777;
    cursor: not-allowed;
}
#movementControls {
    margin-top: 5px;
    display: flex;
    justify-content: space-between;
}
#movementControls button {
    flex-grow: 1;
    font-size: 10px;
    padding: 3px;
    margin: 0 1px;
    border: 1px solid #666;
    background: #4a4a52;
    color: #eee;
    cursor: pointer;
}
#movementControls button.active {
    background: #2ecc71;
    border-color: #27ae60;
    color: #111;
}

/* --- Weather Animation --- */
#weather-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 9998;
  overflow: hidden;
  display: none;
}

.drop {
  position: absolute;
  bottom: 100%;
  width: 2px;
  height: 80px;
  background: linear-gradient(to bottom, rgba(255, 255, 255, 0), rgba(170, 180, 200, 0.4));
  animation: fall linear infinite;
}

#weather-container.storm .drop {
    width: 3px;
    height: 120px;
    animation-name: fall-storm;
}

#lightning-flash {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: #fff;
    opacity: 0;
    z-index: 9999;
    pointer-events: none;
}

#lightning-flash.active {
    animation: lightning-strike 0.3s ease-out;
}

@keyframes fall {
  to {
    transform: translateY(120vh);
  }
}

@keyframes fall-storm {
  to {
    transform: translate(-30vw, 120vh); /* 斜めに移動 */
  }
}

@keyframes lightning-strike {
  0% { opacity: 0; }
  10% { opacity: 0.8; }
  15% { opacity: 0.2; }
  20% { opacity: 0.9; }
  100% { opacity: 0; }
}
/* --- Cloud Animation --- */
#cloud-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 9997; /* 雨より下、背景より上 */
  overflow: hidden;
  display: none; /* デフォルトは非表示 */
}

.cloud {
  position: absolute;
  background: #d4d9de;
  border-radius: 100px;
  opacity: 0.25; /* うっすらとした雲 */
  animation: move-cloud linear infinite;
  width: 200px;
  height: 60px;
}

/* 雲のふわふわした形を疑似要素で作成 */
.cloud:before, .cloud:after {
  content: '';
  position: absolute;
  background: #d4d9de;
  width: 100px;
  height: 80px;
  top: -40px;
  left: 25px;
  border-radius: 100px;
  transform: rotate(30deg);
}

.cloud:after {
  width: 120px;
  height: 120px;
  top: -65px;
  left: auto;
  right: 15px;
}

@keyframes move-cloud {
  0% {
    transform: translateX(-300px); /* 画面左外からスタート */
  }
  100% {
    transform: translateX(110vw); /* 画面右外へ移動 */
  }
}
</style>
</head>
<body>

<div id="weather-container"></div>
<div id="lightning-flash"></div>
<div id="cloud-container"></div>

<div id="startScreen">
    <pre style="color: #555; font-family: monospace; line-height: 0.9; margin-bottom: 20px; text-shadow: 1px 1px #000;">
   Z
  /|\
  / \
  vVw          _______________________
         /|      "                |`.
 wW     | |         _______       |  `.
vV____,-| |________/_______\,____ |    \
 / O "  | | `-              `| O  |\    \
 \______|_|__________________|_,-'/     |
wW `-----(_)`----------'-(_)`' vV      |
 vVwW                          vV       /
                (@)           wV       /
      vV       /`|`\                  /
              |  |  |      vV        /
     wW vV    `--'--'               /
-------------------------------------------
- - - - - - - - - - - - - - - - - - - - - -
</pre>
    <h1 data-translate-key="app_title">絶望サバイバル</h1>
    <p data-translate-key="app_subtitle">ハードコアサバイバルシミュレーション</p>
    
    <button id="startGameBtn" data-translate-key="start_game">ゲーム開始</button>
    <button id="loadGameBtn" data-translate-key="load_game" style="display: none;">続きから</button>
    <button id="optionsBtn" data-translate-key="options">オプション</button>
    <button id="quitGameBtn" data-translate-key="quit_game">ゲームをやめる</button>
    <p id="version-display" style="position: absolute; bottom: 10px; right: 15px; font-size: 1em; color: #444;"></p>
</div>

<div id="optionsScreen" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #111; color: #eee; z-index: 10000; flex-direction: column; justify-content: center; align-items: center; text-align: center; font-family: sans-serif;">
    <h1 data-translate-key="options_title">オプション</h1>
<div style="margin-top: 25px; font-size: 1.2em; border-top: 1px solid #444; padding-top: 15px; width: 80%; max-width: 400px;">
    <label for="volumeSlider" data-translate-key="volume_control">環境音の音量</label>
    <div style="display: flex; align-items: center; justify-content: center; margin-top: 10px;">
        <span>🔇</span>
        <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="0.4" style="width: 80%; margin: 0 10px;">
        <span>🔊</span>
    </div>
</div>
<div style="margin-top: 25px; font-size: 1.2em; border-top: 1px solid #444; padding-top: 15px; width: 80%; max-width: 400px;">
    <label for="voiceVolumeSlider" data-translate-key="voice_volume_control">プレイヤーの声の音量</label>
    <div style="display: flex; align-items: center; justify-content: center; margin-top: 10px;">
        <span>🔇</span>
        <input type="range" id="voiceVolumeSlider" min="0" max="1" step="0.01" value="0.7" style="width: 80%; margin: 0 10px;">
        <span>🔊</span>
    </div>
</div>
    <div style="margin-top: 30px; font-size: 1.2em;">
      <label for="enableSpeechToggle" data-translate-key="enable_speech">音声読み上げを有効にする</label>
      <input type="checkbox" id="enableSpeechToggle" checked style="width: 18px; height: 18px; vertical-align: middle; margin-left: 10px;">
    </div>

<div id="languageSwitcher" style="margin-top: 25px; border-top: 1px solid #444; padding-top: 15px;">
        <button id="langBtnJa">日本語</button>
        <button id="langBtnEn">English</button>
        <button id="langBtnZh">简体中文</button>
    </div>

    <button id="backToMenuBtn" data-translate-key="back_to_menu" style="padding: 15px 30px; font-size: 1.5em; background: #333; color: #eee; border: 1px solid #555; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; margin-top: 40px;">戻る</button>
</div>
<div id="gameClearScreen" style="display: none;">
    <pre id="gateArt" class="gate-art"></pre>
    <h2 id="clearHeader" data-translate-key="game_clear_header">GAME CLEAR</h2>
    <p id="clearMessage"></p>
    <button id="playAgainBtn" data-translate-key="btn_play_again">もう一度プレイ</button>
</div>


<div id="mapPanel" class="panel" style="top:10px; left:10px; width:542px; height:572px; display:flex; flex-direction: column;">
  <div class="panel-header">
    <span data-translate-key="map_panel_title">マップ</span>
    <span id="mapHeaderInfo"></span>
  </div>
  <div id="map" style="flex:1;"></div>
  <div id="playerDirectionArrow"></div>
  <div class="resize-handle"></div>
</div>

<div id="statusPanel" class="panel" style="top:10px; left:460px; width:400px; height:auto; position:relative;">
  <div class="panel-header" data-translate-key="status_panel_title">ステータス</div>
  <div id="status">
    <div class="status-line">
      <span class="status-label" data-translate-key="status_hunger">空腹</span>
      <div class="bar"><div id="hungerBar" class="fill hunger"></div></div>
      <span id="hungerVal" class="status-value"></span>
    </div>
    <div class="status-line">
      <span class="status-label" data-translate-key="status_thirst">渇き</span>
      <div class="bar"><div id="thirstBar" class="fill thirst"></div></div>
      <span id="thirstVal" class="status-value"></span>
    </div>
    <div class="status-line">
      <span class="status-label" data-translate-key="status_health">体力</span>
      <div class="bar"><div id="healthBar" class="fill health"></div></div>
      <span id="healthVal" class="status-value"></span>
    </div>
    <div class="status-line">
      <span class="status-label" data-translate-key="status_morale">気力</span>
      <div class="bar"><div id="moraleBar" class="fill morale"></div></div>
      <span id="moraleVal" class="status-value"></span>
    </div>
    <div class="status-line">
      <span class="status-label" data-translate-key="status_sleep">睡眠</span>
      <div class="bar"><div id="sleepBar" class="fill sleep"></div></div>
      <span id="sleepVal" class="status-value"></span>
    </div>
    <div id="bodyTempStatusLine" class="status-line" style="cursor: help;">
      <span class="status-label" data-translate-key="status_body_temp">体温</span>
      <div class="bar"><div id="bodyTempBar" class="fill bodyTemp"></div></div>
      <span id="bodyTempVal" class="status-value"></span>
    </div>
    <div class="status-line">
      <span class="status-label" data-translate-key="status_weight">重さ</span>
      <div class="bar"><div id="weightBar" class="fill weight"></div></div>
      <span id="weightVal" class="status-value"></span>
    </div>
    <div class="status-line">
        <span class="status-label" data-translate-key="status_volume">容量</span>
        <div class="bar"><div id="volumeBar" class="fill volume"></div></div>
        <span id="volumeVal" class="status-value"></span>
    </div>
    <div class="status-line">
      <span class="status-label" data-translate-key="status_attack">攻撃力</span>
      <div class="bar"><div id="attackBar" class="fill attack"></div></div>
      <span id="attackVal" class="status-value"></span>
    </div>
    <div class="status-line">
      <span class="status-label" data-translate-key="status_defense">防御力</span>
      <div class="bar"><div id="defenseBar" class="fill defense"></div></div>
      <span id="defenseVal" class="status-value"></span>
    </div>
    <div id="bodyOdorStatusLine" class="status-line" style="cursor: help;">
      <span class="status-label" data-translate-key="status_body_odor">体臭</span>
      <div class="bar"><div id="bodyOdorBar" class="fill"></div></div>
      <span id="bodyOdorVal" class="status-value"></span>
    </div>
  </div>
  <div id="physicalCondition"></div>
  <div class="resize-handle"></div>
</div>

<div id="turnPanel" class="panel" style="top:435px; left:460px; width:160px; height:auto;">
  <div class="panel-header" data-translate-key="turn_panel_title">時間</div>
  <div id="turnInfoText"></div>
  <pre id="compass" style="text-align: center; margin-top: 5px; color: #aaa; font-size: 14px; line-height: 1.1;">   N
   |
 W-+-E
   |
   S</pre>
<div id="movementControls">
      <button id="moveWalkBtn" class="active" data-translate-key="move_walk">歩行</button>
      <button id="moveRunBtn" data-translate-key="move_run">走行</button>
  </div>
  <div class="resize-handle"></div>
</div>

<div id="logPanel" class="panel" style="top:300px; left:460px; width:360px; height:125px; overflow-y:auto;">
  <div class="panel-header" data-translate-key="log_panel_title">日記</div>
  <div id="log"></div>
  <div class="resize-handle"></div>
</div>

<div id="inventoryPanel" class="panel" style="top:480px; left:10px; width:245px; height:250px; display:flex; flex-direction: column;">
  <div class="panel-header" data-translate-key="inventory_panel_title">所持品</div>
  <div class="panel-content" style="height: calc(100% - 22px);">
      <div id="inventory" class="item-list" style="max-height: 100%;"></div>
  </div>
  <div class="resize-handle"></div>
</div>

<div id="equipmentPanel" class="panel" style="top:480px; left:265px; width:245px; height:250px; display:flex; flex-direction: column;">
  <div class="panel-header" data-translate-key="equipment_panel_title">装備品</div>
  <div class="panel-content" style="height: calc(100% - 22px);">
      <div id="equipment" class="item-list" style="max-height: 100%;"></div>
  </div>
  <div class="resize-handle"></div>
</div>
<div id="craftingPanel" class="panel" style="top:480px; left: 520px; width: 300px; height: 250px; display:flex; flex-direction: column;">
    <div class="panel-header" data-translate-key="crafting_panel_title">クラフト</div>
    <div class="panel-content" style="height: calc(100% - 22px);">
        <div id="craftingList" style="max-height: 100%;" class="item-list"></div>
    </div>
    <div class="resize-handle"></div>
</div>


<div id="characterPanel" class="panel" style="top:10px; left:830px; width:220px; height:auto;">
  <div class="panel-header" data-translate-key="character_panel_title">キャラクター情報</div>
  <div id="characterBasic">
    <div><strong data-translate-key="char_info_name">名前</strong>: <span id="charName"></span></div>
    <div><strong data-translate-key="char_info_age">年齢</strong>: <span id="charAge"></span> <span data-translate-key="char_info_age_suffix">歳</span></div>
    <div><strong data-translate-key="char_info_gender">性別</strong>: <span id="charGender"></span></div>
    <div><strong data-translate-key="char_info_job">職業</strong>: <span id="charJob"></span></div>
    <div style="margin-top: 5px;"><strong data-translate-key="char_info_race">人種</strong>: <span id="charRace"></span></div>
    <div style="margin-top: 5px;"><strong data-translate-key="char_info_traits">特性</strong>: <span id="charTraits"></span></div>
    <div id="memoryContainer" style="margin-top: 10px; border-top: 1px solid #555; padding-top: 5px;"></div>
  </div>
  <pre id="charBody" class="asciiBody"></pre>
  <button id="suicideBtn" data-translate-key="char_info_suicide_button">自ら命を絶つ</button>
  <button id="waitTurnBtn" data-translate-key="char_info_wait_button">1ターン待機</button>
  <button id="sleepNowBtn" data-translate-key="char_info_sleep_button">眠る</button>
<button id="saveGameBtn" data-translate-key="char_info_save_button" style="width:100%; padding: 8px; margin-top: 5px; background-color: #4a524b; color: #eee; border: 1px solid #666; border-radius: 4px; cursor: pointer; font-weight: bold;">セーブ</button>
  <button id="ingameOptionsBtn" data-translate-key="options" style="width:100%; padding: 8px; margin-top: 5px; background-color: #4a524b; color: #eee; border: 1px solid #666; border-radius: 4px; cursor: pointer; font-weight: bold;">オプション</button>

 <div class="resize-handle"></div>
</div>

<div id="currentLocationPanel" class="panel" style="top:360px; left:830px; width:200px; height:400px; overflow: hidden; display:flex; flex-direction: column;">
  <div class="panel-header" data-translate-key="current_location_panel_title">現在の場所</div>
  <div id="currentLocationBody" class="panel-content">
    <div id="locationName" class="location-name"></div>
    <pre id="locationAscii" class="ascii-art"></pre>
    <div id="locationActions"></div>
  </div>
  <div style="font-family: sans-serif; font-size: 14px; margin-top: 10px; border-top: 1px solid #555; padding-top: 5px; flex-grow: 1; display: flex; flex-direction: column;">
    <strong data-translate-key="location_info_dropped_items">落ちているアイテム:</strong>
    <div id="droppedItemsList" class="item-list"></div>
  </div>
  <div class="resize-handle"></div>
</div>

<div id="damagePop"></div>
<div id="statusPreview"></div>

<div id="minimapPanel" class="panel" style="top:10px; left:1060px; width:220px; height:240px; display:flex; flex-direction: column;">
  <div class="panel-header" style="display: flex; justify-content: space-between; align-items: center;">
    <span data-translate-key="minimap_panel_title">ミニマップ</span>
  </div>
  <div class="panel-content" style="padding: 5px; flex-grow: 1;">
    <canvas id="minimapCanvas" style="width: 100%; height: 100%; background: #000;"></canvas>
  </div>
</div>

<div id="itemDetailPanel" class="panel" style="top:50%; left:50%; transform: translate(-50%, -50%); width:300px; height:auto; display:none;">
  <div id="itemDetailHeader" class="panel-header"></div>
  <div class="item-graphic-container">
    <span id="itemDetailGraphic" class="item-graphic"></span>
  </div>
  <div id="itemDetailContent" class="item-detail-info"></div>
  <div id="itemDetailActions" class="item-detail-actions">
    <button id="useItemBtn" data-translate-key="btn_use" style="display:none;">使う</button>
    <button id="throwItemBtn" data-translate-key="btn_throw" style="display:none;">投げる</button>
    <button id="repairItemBtn" data-translate-key="btn_repair" style="display:none;">修理する</button>
    <button id="startFireBtn" data-translate-key="btn_start_fire" style="display:none;">火をおこす</button>
    <button id="openItemBtn" data-translate-key="btn_open" style="display:none;">開ける</button>
    <button id="forceOpenItemBtn" data-translate-key="btn_force_open" style="display:none;">無理やり開ける</button>
    <button id="emptyItemBtn" data-translate-key="btn_empty" style="display:none;">空にする</button>
    <button id="drinkItemBtn" data-translate-key="btn_drink" style="display:none;">飲む</button>
    <button id="fillItemBtn" data-translate-key="btn_fill" style="display:none;">汲む</button>
    <button id="cookItemBtn" data-translate-key="btn_cook" style="display:none;">焼く</button>
    <button id="boilItemBtn" data-translate-key="btn_boil" style="display:none;">沸かす</button>
    <button id="addFuelBtn" data-translate-key="btn_add_fuel" style="display:none;">くべる</button>
    <button id="craftTorchBtn" data-translate-key="btn_craft_torch" style="display:none;">松明を作る</button>
    <button id="wipeClothBtn" data-translate-key="btn_wipe_clothes" style="display:none;">服を拭く</button>
    <button id="wringClothBtn" data-translate-key="btn_wring" style="display:none;">絞る</button>
    <button id="equipItemBtn" data-translate-key="btn_equip" style="display:none;">装備する</button>
    <button id="unequipItemBtn" data-translate-key="btn_unequip" style="display:none;">外す</button>
    <button id="reloadGunBtn" data-translate-key="btn_reload" style="display:none;">装填する</button>
    <button id="unloadGunBtn" data-translate-key="btn_unload" style="display:none;">装填解除</button>
    <button id="attachBayonetBtn" data-translate-key="btn_attach_bayonet" style="display:none;">ナイフを装着</button>
    <button id="dropItemBtn" data-translate-key="btn_drop" style="display:none;">落とす</button>
    <button id="pickupItemBtn" data-translate-key="btn_pickup" style="display:none;">拾う</button>
    <button id="butcherItemBtn" data-translate-key="btn_butcher" style="display:none;">解体する</button>
    <button id="searchCorpseBtn" data-translate-key="btn_search" style="display:none;">漁る</button>
    <button id="dismantleBtn" data-translate-key="btn_dismantle" style="display:none;">解体する</button>
    <button id="closeItemDetailBtn" data-translate-key="btn_close">閉じる</button>
  </div>
  <div class="resize-handle"></div>
</div>

<div id="combatPanel" class="panel" style="display: none; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 700px; height: 450px; z-index: 1001;">
  <div class="panel-header" data-translate-key="combat_panel_title">戦闘</div>
  <div id="combatContent">
    <div id="combatPlayer">
      <h3 data-translate-key="combat_player_title">あなた</h3>
      <pre id="combatPlayerAscii" class="ascii-art-container"></pre>
      <div id="combatPlayerStats" style="text-align: left; margin-left: 20px;">
          <div id="combatHealthContainer"><span data-translate-key="combat_health">体力</span>: <span id="combatPlayerHealth"></span></div>
          <div id="combatAttackContainer" style="cursor: help;"><span data-translate-key="combat_attack">攻撃力</span>: <span id="combatPlayerAttack"></span></div>
          <div id="combatDefenseContainer" style="cursor: help;"><span data-translate-key="combat_defense">防御力</span>: <span id="combatPlayerDefense"></span></div>
      </div>
      <div id="combatPlayerEquipment">
        <strong data-translate-key="combat_equipment">装備:</strong>
        <div id="combatEquipmentList"></div>
      </div>
      <div id="combatPlayerInjuries"></div>
    </div>
    <div id="combatLogContainer">
        <div id="combatLog"></div>
        <div id="combatActions">
          <button id="attackMainBtn"></button>
          <button id="attackOffBtn"></button>
          <button id="fireBtn" class="fire-btn" data-translate-key="combat_fire">発砲</button>
          <button id="runBtn" data-translate-key="combat_run">逃げる</button>
        </div>
    </div>
    <div id="combatEnemy">
      <h3 id="combatEnemyName">ゾンビ</h3>
      <pre id="combatEnemyAscii" class="ascii-art-container"></pre>
      <div><span data-translate-key="combat_health">体力</span>: <span id="combatEnemyHealth"></span></div>
      <div id="combatEnemyEquipment" style="display: none;">
        <strong data-translate-key="combat_equipment">装備:</strong>
        <div id="combatEnemyEquipmentList"></div>
      </div>
    </div>
  </div>
  <div class="resize-handle"></div>
</div>

<div id="dialoguePanel" class="panel" style="display: none;">
    <div class="panel-header" id="dialoguePanelHeader" data-translate-key="dialogue_panel_title">生存者との遭遇</div>
    <div id="dialogueContent">
        <div id="dialogueNPC">
            <h3 id="dialogueNpcName"></h3>
            <pre id="dialogueNpcAscii"></pre>
        </div>
        <div id="dialogueTextContainer">
            <div id="dialogueText"></div>
            <div id="dialogueActions">
                <button id="dialogueTradeBtn" data-translate-key="btn_trade">交渉する</button>
                <button id="dialogueFightBtn" data-translate-key="btn_fight">戦闘する</button>
                <button id="dialogueLeaveBtn" data-translate-key="btn_leave">立ち去る</button>
                <button id="dialogueInfoBtn" data-translate-key="btn_ask_info" style="display:none;">情報を聞く</button>
            </div>
        </div>
    </div>
</div>

<div id="tradePanel" class="panel" style="display: none;">
    <div class="panel-header" data-translate-key="trade_panel_title">交渉</div>
    <div class="trade-main">
        <div class="trade-column">
            <h4 data-translate-key="trade_your_offer">あなたの提供アイテム</h4> (<span id="playerTradeValue">0</span>)
            <div id="playerOfferArea" class="trade-area"></div>
            <h5 data-translate-key="trade_your_inventory">あなたの所持品</h5>
            <div id="playerTradeInventory" class="trade-inventory"></div>
            <h5 data-translate-key="trade_your_equipment">あなたの装備品</h5>
            <div id="playerTradeEquipment" class="trade-inventory"></div>
        </div>
        <div class="trade-column">
            <h4 data-translate-key="trade_npc_offer">相手の提供アイテム</h4> (<span id="npcTradeValue">0</span>)
            <div id="npcOfferArea" class="trade-area"></div>
            <h5 data-translate-key="trade_npc_inventory">相手の所持品</h5>
            <div id="npcTradeInventory" class="trade-inventory"></div>
            <h5 data-translate-key="trade_npc_equipment">相手の装備品</h5>
            <div id="npcTradeEquipment" class="trade-inventory"></div>
        </div>
    </div>
    <div class="trade-footer">
        <button id="executeTradeBtn" data-translate-key="trade_execute" disabled>交渉成立</button>
        <button id="cancelTradeBtn" data-translate-key="trade_cancel">キャンセル</button>
    </div>
</div>

<div id="storagePanel" class="panel" style="display: none;">
    <div class="panel-header" id="storagePanelHeader" data-translate-key="storage_panel_title">木箱</div>
    <div class="storage-main">
        <div class="storage-column">
            <h4 id="storageBoxTitle">木箱の中身 (0/10)</h4>
            <div id="storageBoxArea" class="storage-area"></div>
        </div>
        <div class="storage-column">
            <h4>あなたの所持品</h4>
            <div id="storagePlayerInventory" class="storage-area"></div>
        </div>
    </div>
    <div class="storage-footer">
        <button id="pickupStorageBtn">拾う</button>
        <button id="closeStorageBtn">閉じる</button>
    </div>
</div>

<div id="workbenchPanel" class="panel" style="display: none; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 320px; height: 400px; z-index: 1003; display:flex; flex-direction: column;">
    <div class="panel-header" data-translate-key="workbench_panel_title">ワークベンチ</div>
    <div class="panel-content" style="height: calc(100% - 22px);">
        <div id="workbenchCraftingList" class="item-list" style="max-height: 100%;"></div>
    </div>
    <div class="resize-handle"></div>
</div>

<script>

const { ipcRenderer } = require('electron');

const CURRENT_GAME_VERSION = "1.1.8"; // 現在のゲームバージョンを定数として定義

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let soundBuffers = {}; // 読み込み済みのサウンドをキャッシュ（保存）しておく場所
// ▼▼▼ Web Audio APIで管理するための変数に変更 ▼▼▼
let rainSourceNodes = [];
let stormSourceNodes = [];
let birdsSourceNodes = []; // ← この行を追加
let windSourceNodes = [];  // ← この行を追加
// ▲▲▲ 変更ここまで ▲▲▲
let bgm;
/**
 * サウンドファイルを読み込み、キャッシュする関数
 * @param {string} filePath - sounds/からのパス
 */
async function loadSound(filePath) {
    // すでにキャッシュにあれば、それを使用
    if (soundBuffers[filePath]) return soundBuffers[filePath];
    try {
        const response = await fetch(filePath);
        const arrayBuffer = await response.arrayBuffer();
        const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
        soundBuffers[filePath] = audioBuffer; // 読み込んだ音をキャッシュに保存
        return audioBuffer;
    } catch(e) { 
        console.error(`サウンドファイルの読み込みエラー: ${filePath}`, e);
    }
}

/**
 * 効果音を再生する関数
 * @param {string} filePath - sounds/からのパス
 * @param {number} [volume=1.0] - 音量 (0.0 to 1.0)
 */
function playSoundFile(filePath, volume = 1.0) {
    // 最初のユーザー操作があるまで音声再生を試みないようにする
    if (audioCtx.state === 'suspended') {
        audioCtx.resume();
    }

    const sound = soundBuffers[filePath];
    if (sound) {
        const source = audioCtx.createBufferSource();
        source.buffer = sound;
        const gainNode = audioCtx.createGain();
        gainNode.gain.value = volume;
        source.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        source.start(0);
    } else {
        // 初めて再生する音の場合は、読み込んでから再生
        loadSound(filePath).then(buffer => {
            if(buffer) playSoundFile(filePath, volume);
        });
    }
}

/**
 * プレイヤーの声に関する効果音を、クールダウンと音量設定を考慮して再生する
 * @param {string} soundPath - sounds/からのパス
 * @param {number} volume - この音声の相対的な音量
 */
function playPlayerVoice(soundPath, volume) {
    const now = Date.now();
    // 現在時刻が、前回の再生時刻 + クールダウン時間よりも後であれば再生する
    if (now - lastPlayerVoiceTime > PLAYER_VOICE_COOLDOWN) {
        // ▼▼▼ ここからが変更箇所です ▼▼▼

        // 1. オプション画面の「プレイヤーの声」スライダーを取得
        const voiceVolumeSlider = document.getElementById('voiceVolumeSlider');
        // 2. スライダーの値を取得（見つからない場合はデフォルト値0.7を使用）
        const masterVoiceVolume = voiceVolumeSlider ? parseFloat(voiceVolumeSlider.value) : 0.7;

        // 3. スライダーの音量と、各音声固有の音量を掛け合わせて最終的な音量を決定
        playSoundFile(soundPath, volume * masterVoiceVolume);
        
        // ▲▲▲ 変更ここまで ▲▲▲

        lastPlayerVoiceTime = now; // 再生時刻を更新
    }
}
// ▼▼▼ この関数を新しく追加してください ▼▼▼
/**
 * 現在の天候に合わせて環境音を再生・停止する関数
 */
async function updateWeatherAudio() {
    stopWeatherAudio();
    const volumeSlider = document.getElementById('volumeSlider');
    const volume = volumeSlider ? parseFloat(volumeSlider.value) : 0.4;
    
    let soundPath = null;
    let sourceNodesArray = null;
    let weatherName = currentWeather.name;

    if (weatherName === '快晴') {
        soundPath = 'sounds/birds_loop.wav';
        sourceNodesArray = birdsSourceNodes;
    } else if (weatherName === '曇り') {
        soundPath = 'sounds/wind_loop.wav';
        sourceNodesArray = windSourceNodes;
    } else if (weatherName === '雨') {
        soundPath = 'sounds/rain_loop.wav';
        sourceNodesArray = rainSourceNodes;
    } else if (weatherName === '嵐') {
        soundPath = 'sounds/storm_loop.wav';
        sourceNodesArray = stormSourceNodes;
    }

    if (!soundPath) return;

    const audioBuffer = await loadSound(soundPath);
    if (!audioBuffer) return;

    const gainNode = audioCtx.createGain();
    gainNode.gain.value = volume;
    gainNode.connect(audioCtx.destination);
    
    playSeamlessLoop(audioBuffer, gainNode, sourceNodesArray, weatherName);

    setTimeout(() => {
        if (currentWeather.name === weatherName) {
            playSeamlessLoop(audioBuffer, gainNode, sourceNodesArray, weatherName);
        }
    }, audioBuffer.duration / 2 * 1000);
}


/**
 * アイコンのパスや絵文字から、表示用のHTMLを生成する関数
 * @param {string} iconSource - 画像パスまたは絵文字
 * @param {number} [size=16] - 表示サイズ（ピクセル）
 * @returns {string} - <img>タグまたは<span>タグのHTML文字列
 */
function getIconHTML(iconSource, size = 16) {
  if (!iconSource) return '';

  // 画像パスの場合
  if (iconSource.startsWith('images/')) {
    return `<img src="${iconSource}" alt="" style="width: ${size}px; height: ${size}px; image-rendering: pixelated; vertical-align: middle;">`;
  }
  
  // 絵文字やその他の文字の場合（移行中のフォールバック用）
  return `<span style="font-size: ${size}px; vertical-align: middle;">${iconSource}</span>`;
}
// ▲▲▲ ここまで ▲▲▲
// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function getGameState() {
  // セーブ用のデータを作成し、循環参照を解消する
  const entitiesForSave = entities.map((entity, index) => {
    const newEntity = { ...entity };
    // ターゲット情報を一時的な形式に変換
    if (newEntity.target) {
      if (newEntity.target === player) {
        newEntity.target = { isPlayer: true }; // プレイヤーがターゲットの場合
      } else {
        const targetIndex = entities.findIndex(e => e === newEntity.target);
        if (targetIndex !== -1) {
          newEntity.target = { isEntity: true, index: targetIndex }; // 他のエンティティがターゲットの場合
        } else {
          newEntity.target = null;
        }
      }
    }
    return newEntity;
  });

  return {
    saveVersion: CURRENT_GAME_VERSION,
    player: player,
    map: map,
    entities: entitiesForSave, // 循環参照を解消したエンティティリストを使用
    placedObjects: placedObjects,
    droppedItems: droppedItems,
    turn: turn,
    currentTime: currentTime,
    character: character,
    salvationCityCoords: salvationCityCoords,
    salvationCityDiscovered: salvationCityDiscovered,
    currentWeather: currentWeather,
    currentTemperature: currentTemperature,
    currentSeason: currentSeason,
  };
}
// ▼▼▼ この関数を getIconHTML の下に追加してください ▼▼▼
/**
 * 体力の割合に応じて、緑 -> 黄 -> 赤のグラデーション色を計算して返す
 * @param {number} currentHealth - 現在の体力
 * @param {number} maxHealth - 最大体力
 * @returns {string} - 'rgb(r,g,b)' 形式のCSSカラー文字列
 */
function getHealthColor(currentHealth, maxHealth) {
  if (maxHealth <= 0) return '#e74c3c'; // ゼロ除算を避ける
  const percent = Math.max(0, Math.min(1, currentHealth / maxHealth));

  let r, g, b;

  if (percent >= 0.5) {
    // 100% (緑) から 50% (黄) へのグラデーション
    const scale = (percent - 0.5) * 2; // この範囲での割合を0.0-1.0に変換
    const startR = 241, startG = 196, startB = 15;   // 黄色 (#f1c40f)
    const endR = 39,   endG = 174,  endB = 96;    // 緑 (#27ae60)
    r = Math.round(startR + (endR - startR) * scale);
    g = Math.round(startG + (endG - startG) * scale);
    b = Math.round(startB + (endB - startB) * scale);
  } else {
    // 50% (黄) から 0% (赤) へのグラデーション
    const scale = percent * 2; // この範囲での割合を0.0-1.0に変換
    const startR = 231, startG = 76,  startB = 60;    // 赤 (#e74c3c)
    const endR = 241,   endG = 196,  endB = 15;    // 黄色 (#f1c40f)
    r = Math.round(startR + (endR - startR) * scale);
    g = Math.round(startG + (endG - startG) * scale);
    b = Math.round(startB + (endB - startB) * scale);
  }
  return `rgb(${r},${g},${b})`;
}
// ▲▲▲ 追加ここまで ▲▲▲
function applyGameState(state) {
  if (!state) return;
  const loadedVersion = state.saveVersion || "1.0.0"; 
  if (loadedVersion < "1.1.9" && state.player.bodyOdor !== undefined) {
      console.log(`v${loadedVersion}からv1.1.9へのセーブデータ移行処理を実行...`);
      state.player.smellLevel = state.player.bodyOdor;
      delete state.player.bodyOdor;
  }
  if (loadedVersion < "1.2.0" && state.player.stamina === undefined) {
      console.log(`v${loadedVersion}からv1.2.0へのセーブデータ移行処理を実行...`);
      state.player.stamina = 100;
  }
  player = state.player; map = state.map; entities = state.entities; placedObjects = state.placedObjects; droppedItems = state.droppedItems; turn = state.turn; currentTime = new Date(state.currentTime); character = state.character; salvationCityCoords = state.salvationCityCoords; salvationCityDiscovered = state.salvationCityDiscovered; currentWeather = state.currentWeather; currentTemperature = state.currentTemperature; currentSeason = state.currentSeason;
  calculateMaxStats();
  updateTurnInfo(); drawMap(); drawMinimap(); updateStatus(); updateItemPanels(); updateCharacterBody(); updateCharacterInfo(); updateCurrentLocationPanel(false); updateBackgroundColor();
  log(getString("log_data_loaded"));
}

async function saveGame() {
  const gameState = getGameState();
  await ipcRenderer.invoke('save-game', gameState);
  log(getString("log_game_saved"), true);
}
async function loadGame() {
  isLoading = true;
  try {
    const gameState = await ipcRenderer.invoke('load-game');
    if (gameState) {
      applyGameState(gameState);
      document.getElementById('startScreen').style.display = 'none';
      const panels = ["mapPanel", "statusPanel", "turnPanel", "logPanel", "inventoryPanel", "equipmentPanel", "craftingPanel", "characterPanel", "currentLocationPanel", "minimapPanel"];
      panels.forEach(id => {
          const panel = document.getElementById(id);
          if (panel) {
              panel.style.display = 'block';
               if (['mapPanel', 'inventoryPanel', 'equipmentPanel', 'minimapPanel', 'craftingPanel', 'currentLocationPanel'].includes(id)) {
                  panel.style.display = 'flex';
              }
          }
      });
      isGameRunning = true; // ← この行を追加
    } else {
      log(getString("log_save_not_found"));
    }
  } finally {
    isLoading = false;
  }
}

// ここから下が元々のゲームコードです
let availableVoices = []; // ← この行を追加
let targetingState = {
    active: false,
    item: null,
    itemIndex: -1,
    source: '',
    range: 0,
    callback: null
};

let mapIconIntervals = []; 
let isLoading = false; // ← この行を追加
let currentLanguage = 'en'; // 現在選択されている言語コードを保持 (初期値: 英語)
let stringTable = {};     // 読み込んだ翻訳テキストを保持するオブジェクト
let maxZIndex = 10;
let minimapZoomLevel = 2;
let isSpeechEnabled = true; 
const minimizedPanels = [];
let logSpeechQueue = []; 
let currentItemDetail = null;
let lightningTimeout = null;
let currentWeather = { icon: "☀️", name: "快晴", chance: 50 };
let currentTemperature = 25;
let isInteractionActive = false;
let currentEnemy = null;
let currentNPC = null;
let playerStatsBeforeAction = {};
let salvationCityCoords = { x: -1, y: -1 };
let salvationCityDiscovered = false;
let entities = [];
let currentSoundLevel = 0;
let currentPlayerSmell = 0;
let previousPlayerSmell = 0;
let previousSoundLevel = 0;
let placedObjects = []; 

const salvationCityLocation = {
    nameKey: "location_salvation_city",
    icon: "🌟",
    loot: 0,
    zombie: 0,
    ascii: `
  /\\||/\\
 | (++) |
  \\||||/
   ||||
   ||||`
};

function bringToFront(elm) {
  maxZIndex++;
  elm.style.zIndex = maxZIndex;
}

function togglePanelSize(elm) {
  const header = elm.querySelector(".panel-header");
  const headerHeight = header.offsetHeight + 10;
  const margin = 10;

  if (elm.classList.contains("minimized")) {
    elm.classList.remove("minimized");
    elm.style.removeProperty("right");
    elm.style.removeProperty("bottom");
    elm.style.width = elm.dataset.originalWidth;
    elm.style.height = elm.dataset.originalHeight;
    elm.style.left = elm.dataset.originalLeft;
    elm.style.top = elm.dataset.originalTop;
    elm.querySelector(".resize-handle").style.display = "block";
    elm.style.overflow = "";
    const index = minimizedPanels.indexOf(elm);
    if (index > -1) {
      minimizedPanels.splice(index, 1);
    }
    restackMinimizedPanels();
    bringToFront(elm);
  } else {
    elm.dataset.originalWidth = elm.style.width;
    elm.dataset.originalHeight = elm.style.height;
    elm.dataset.originalLeft = elm.style.left;
    elm.dataset.originalTop = elm.style.top;
    elm.classList.add("minimized");
    elm.style.width = `${elm.offsetWidth}px`;
    elm.style.height = `${headerHeight}px`;
    elm.style.left = '';
    elm.style.top = '';
    elm.querySelector(".resize-handle").style.display = "none";
    elm.style.overflow = "hidden";
    minimizedPanels.push(elm);
    restackMinimizedPanels();
    bringToFront(elm);
  }
}

function restackMinimizedPanels() {
  const margin = 10;
  let totalWidth = 0;
  for (let i = minimizedPanels.length - 1; i >= 0; i--) {
    const panel = minimizedPanels[i];
    panel.style.right = `${margin + totalWidth}px`;
    panel.style.bottom = `${margin}px`;
    totalWidth += panel.offsetWidth + margin;
  }
}

function makeDraggable(elm) {
  const header = elm.querySelector(".panel-header");
  if (!header) return;
  header.style.cursor = "grab";
  let startX, startY, initialLeft, initialTop;
  const dragMouseDown = (e) => {
    e.preventDefault();
    if(elm.classList.contains("minimized")) return;
    bringToFront(elm);
    startX = e.clientX;
    startY = e.clientY;
    initialLeft = parseFloat(getComputedStyle(elm).left);
    initialTop = parseFloat(getComputedStyle(elm).top);
    header.style.cursor = "grabbing";
    window.addEventListener("mousemove", elementDrag);
    window.addEventListener("mouseup", closeDragElement);
  };
  const elementDrag = (e) => {
    e.preventDefault();
    let deltaX = e.clientX - startX;
    let deltaY = e.clientY - startY;
    let newLeft = initialLeft + deltaX;
    let newTop = initialTop + deltaY;
    newTop = Math.max(0, newTop);
    newLeft = Math.max(0, newLeft);
    newTop = Math.min(window.innerHeight - elm.offsetHeight, newTop);
    newLeft = Math.min(window.innerWidth - elm.offsetWidth, newLeft);
    elm.style.left = newLeft + "px";
    elm.style.top = newTop + "px";
  };
  const closeDragElement = () => {
    header.style.cursor = "grab";
    window.removeEventListener("mousemove", elementDrag);
    window.removeEventListener("mouseup", closeDragElement);
  };
  header.addEventListener("mousedown", dragMouseDown);
}

function makeResizable(elm) {
  const handle = elm.querySelector(".resize-handle");
  if (!handle) return;
  let pos = {x:0, y:0, w:0, h:0};
  const resizeMouseDown = (e) => {
    e.preventDefault();
    if(elm.classList.contains("minimized")) return;
    bringToFront(elm);
    pos.x = e.clientX;
    pos.y = e.clientY;
    pos.w = elm.offsetWidth;
    pos.h = elm.offsetHeight;
    window.addEventListener("mousemove", elementResize);
    window.addEventListener("mouseup", closeResizeElement);
  };
  const elementResize = (e) => {
    e.preventDefault();
    let dx = e.clientX - pos.x;
    let dy = e.clientY - pos.y;
    let newW = pos.w + dx;
    let newH = pos.h + dy;
    if (newW < 100) newW = 100;
    if (newH < 80) newH = 80;
    elm.style.width = newW + "px";
    elm.style.height = newH + "px";
    if (elm.id === "mapPanel") {
      drawMap();
    }
    if (elm.id === "minimapPanel") {
        drawMinimap();
    }
  };
  const closeResizeElement = () => {
    window.removeEventListener("mousemove", elementResize);
    window.removeEventListener("mouseup", closeResizeElement);
  };
  handle.addEventListener("mousedown", resizeMouseDown);
}

// ▼▼▼ この配列を丸ごと置き換えてください ▼▼▼

// index.html内
// index.html内

// index.html内

const characterTraits = [
  { id: "tough_body", effects: { health: 20, maxWeight: 5 } },
  { id: "frail", effects: { health: -20, maxWeight: -5, morale: -15 } },
  { id: "strong_willed", effects: { morale: 30, sleep: -10 } },
  { id: "insomniac", effects: { sleep: 40, morale: -20 } },
  { id: "good_eyesight", effects: { vision: 1 } },
  { id: "bad_eyesight", effects: { vision: -1 } },
  { id: "fast_learner", effects: { morale: 20 } },
  { id: "big_eater", effects: { hunger: -20 } },
  { id: "optimist", effects: { morale: 15 } },
  { id: "pessimist", effects: { morale: -15 } },
  { id: "deft_hands", effects: {} },
  { id: "clumsy_hands", effects: {} },
  { id: "cowardly", effects: { morale: -20 } }
];

let character = {
  fullNameKey: "",
  age: 0,
  gender: "",
  job: "",
  race: "",
  traits: [],
  salvationCityHint: ""
};

// index.html 内

const characterProfiles = [
    // Asian
    { nameKey: "char_name_akira_nakayama", genderKey: "gender_male", raceKey: "race_asian" },
    { nameKey: "char_name_ryoko_tanaka", genderKey: "gender_female", raceKey: "race_asian" },
    { nameKey: "char_name_kenji_sato", genderKey: "gender_male", raceKey: "race_asian" },
    { nameKey: "char_name_masashi_ishida", genderKey: "gender_male", raceKey: "race_asian" },
    { nameKey: "char_name_miki_suzuki", genderKey: "gender_female", raceKey: "race_asian" },
    // White
    { nameKey: "char_name_john_smith", genderKey: "gender_male", raceKey: "race_white" },
    { nameKey: "char_name_emily_jones", genderKey: "gender_female", raceKey: "race_white" },
    { nameKey: "char_name_michael_brown", genderKey: "gender_male", raceKey: "race_white" },
    { nameKey: "char_name_sarah_davis", genderKey: "gender_female", raceKey: "race_white" },
    { nameKey: "char_name_chris_wilson", genderKey: "gender_male", raceKey: "race_white" },
    // Middle-Eastern
    { nameKey: "char_name_ahmad_hassan", genderKey: "gender_male", raceKey: "race_middle_eastern" },
    { nameKey: "char_name_fatima_khan", genderKey: "gender_female", raceKey: "race_middle_eastern" },
    { nameKey: "char_name_yusuf_ali", genderKey: "gender_male", raceKey: "race_middle_eastern" },
    { nameKey: "char_name_zainab_abbas", genderKey: "gender_female", raceKey: "race_middle_eastern" },
    { nameKey: "char_name_rashid_saeed", genderKey: "gender_male", raceKey: "race_middle_eastern" },
    // Black
    { nameKey: "char_name_jamal_williams", genderKey: "gender_male", raceKey: "race_black" },
    { nameKey: "char_name_aliya_jackson", genderKey: "gender_female", raceKey: "race_black" },
    { nameKey: "char_name_caleb_johnson", genderKey: "gender_male", raceKey: "race_black" },
    { nameKey: "char_name_iman_adebayo", genderKey: "gender_female", raceKey: "race_black" }
];

const jobs = [
  "job_エンジニア", "job_医師", "job_軍人", "job_教師", "job_アスリート",
  "job_警察官", "job_看護師", "job_シェフ", "job_学生", "job_会社員"
];
// ▼▼▼ ここに貼り付け ▼▼▼
const seasonInfo = {
    '春': { icon: '🌸' },
    '夏': { icon: '☀️' },
    '秋': { icon: '🍂' },
    '冬': { icon: '❄️' }
};

const weatherInfo = {
    '快晴': { icon: '☀️' },
    '曇り': { icon: '☁️' },
    '雨': { icon: '🌧️' },
    '嵐': { icon: '⛈️' }
};
// index.html内

function generateRandomCharacter() {
  const profile = randChoice(characterProfiles);
  character.fullNameKey = profile.nameKey;
  character.gender = profile.genderKey;
  character.race = profile.raceKey;
  character.age = Math.floor(Math.random() * 43) + 18;
  character.job = randChoice(jobs);
  
  const opposites = {
    "tough_body": "frail", "frail": "tough_body",
    "good_eyesight": "bad_eyesight", "bad_eyesight": "good_eyesight",
    "strong_willed": "cowardly", "cowardly": "strong_willed",
    "optimist": "pessimist", "pessimist": "optimist",
    "deft_hands": "clumsy_hands", "clumsy_hands": "deft_hands"
  };

  let traitPool = [...characterTraits];
  const selectedTraits = [];
  const numberOfTraits = Math.random() < 0.5 ? 1 : 2;
  
  for (let i = 0; i < numberOfTraits; i++) {
    if (traitPool.length === 0) break;
    
    const traitIndex = Math.floor(Math.random() * traitPool.length);
    const selected = traitPool.splice(traitIndex, 1)[0];
    selectedTraits.push(selected.id); // 'name' ではなく 'id' を保存

    const oppositeTrait = opposites[selected.id];
    if (oppositeTrait) {
      traitPool = traitPool.filter(t => t.id !== oppositeTrait);
    }
  }
  
  character.traits = selectedTraits;
  character.salvationCityHint = "";
}

const mapSize = 200;
const viewportSize = 13;
let maxStats = {};
const baseMaxStat = 100;

// index.html内

function calculateMaxStats() {
  // ▼▼▼ 修正箇所：characterオブジェクトが存在しない、またはtraitsがない場合は処理を中断 ▼▼▼
  if (!character || !character.traits) {
    // 安全のため、基本的なmaxStatsのみ初期化して処理を終了
    maxStats = {
      hunger: baseMaxStat, thirst: baseMaxStat, health: baseMaxStat, morale: baseMaxStat, sleep: baseMaxStat,
      bodyTemp: 41, maxWeight: 10, maxVolume: 10, vision: 5, bodyOdor: 100
    };
    return;
  }
  // ▲▲▲ 修正ここまで ▲▲▲

  const age = character.age;
  const gender = character.gender;
  const job = character.job;
  const race = character.race;
  const traits = character.traits;
  
  maxStats = {
    hunger: baseMaxStat,
    thirst: baseMaxStat,
    health: baseMaxStat,
    morale: baseMaxStat,
    sleep: baseMaxStat,
    bodyTemp: 41,
    maxWeight: 10,
    maxVolume: 10,
    vision: 5,
    bodyOdor: 100
  };
  
  if (job === '軍人' || job === 'アスリート') maxStats.maxWeight += 8;
  if (job === 'エンジニア' || job === 'シェフ') maxStats.maxWeight += 3;
  if (job === '学生' || job === '教師') maxStats.maxWeight -= 2;

  if (gender === "男性") maxStats.maxWeight += 4;

  if (age < 20) {
    maxStats.health += 20; maxStats.sleep += 15; maxStats.morale -= 10;
  } else if (age >= 20 && age < 40) {
    maxStats.health += 10;
  } else if (age >= 40 && age < 60) {
    maxStats.health -= 15; maxStats.morale += 15;
  } else {
    maxStats.health -= 30; maxStats.sleep -= 20; maxStats.morale += 10;
  }
  
  if (gender === "男性") {
    maxStats.health += 10; maxStats.hunger += 10;
  } else if (gender === "女性") {
    maxStats.morale += 10; maxStats.sleep += 5;
  }
  
  traits.forEach(traitId => {
      const trait = characterTraits.find(t => t.id === traitId);
      if (trait && trait.effects) {
        for(const stat in trait.effects){
            if(stat === 'maxWeight' || stat === 'vision') {
                 maxStats[stat] = (maxStats[stat] || 0) + trait.effects[stat];
            } else {
                 maxStats[stat] = (maxStats[stat] || baseMaxStat) + trait.effects[stat];
            }
        }
      }
  });

  Object.keys(maxStats).forEach(stat => {
    if (stat !== 'bodyTemp' && stat !== 'maxWeight' && stat !== 'vision' && stat !== 'maxVolume' && stat !== 'bodyOdor') {
      maxStats[stat] = Math.max(50, Math.min(200, maxStats[stat]));
    }
  });
}

// ▼▼▼ この行を丸ごと置き換えてください ▼▼▼
const fieldLocation = { nameKey: "location_field", icon: "images/field.png", loot: 40, zombie: 2, ascii: `~~~~~~\n #####\n~# * #~\n #####\n~~~~~~` };
// ▼▼▼ このブロックを丸ごと置き換えてください ▼▼▼
const biomeLocations = {
    Plains: [
        { nameKey: "location_plains", icon: "images/plains.png", loot: 5, zombie: 8, ascii: `  ~~~~~\n ~     ~\n~   "   ~\n ~     ~\n  ~~~~~`, blocksVision: false },
        { nameKey: "location_plains", icon: "images/plains.png", loot: 5, zombie: 8, ascii: `  ~~~~~\n ~     ~\n~   "   ~\n ~     ~\n  ~~~~~`, blocksVision: false },
        { nameKey: "location_plains", icon: "images/plains.png", loot: 5, zombie: 8, ascii: `  ~~~~~\n ~     ~\n~   "   ~\n ~     ~\n  ~~~~~`, blocksVision: false },
        { nameKey: "location_plains", icon: "images/plains.png", loot: 5, zombie: 8, ascii: `  ~~~~~\n ~     ~\n~   "   ~\n ~     ~\n  ~~~~~`, blocksVision: false },
        { nameKey: "location_plains", icon: "images/plains.png", loot: 5, zombie: 8, ascii: `  ~~~~~\n ~     ~\n~   "   ~\n ~     ~\n  ~~~~~`, blocksVision: false },
        { nameKey: "location_plains", icon: "images/plains.png", loot: 5, zombie: 8, ascii: `  ~~~~~\n ~     ~\n~   "   ~\n ~     ~\n  ~~~~~`, blocksVision: false },
        { nameKey: "location_plains", icon: "images/plains.png", loot: 5, zombie: 8, ascii: `  ~~~~~\n ~     ~\n~   "   ~\n ~     ~\n  ~~~~~`, blocksVision: false },
        { nameKey: "location_pond", icon: "images/pond.png", loot: 2, zombie: 2, ascii: `  ~~~~~\n /     \\\n|  ~ ~  |\n \\_____/`, blocksVision: false },
        { nameKey: "location_rock", icon: "images/rock_terrain.png", loot: 3, zombie: 3, ascii: `   /\\ \n  /  \\ \n /____\\`, blocksVision: false },
        { ...fieldLocation, icon: "images/field.png", blocksVision: false }
    ],
    Forest: [
        { nameKey: "location_forest", icon: "images/forest.png", loot: 15, zombie: 15, ascii: `   TT\n  T  T\n TTT\n   | |`, blocksVision: true },
        { nameKey: "location_cabin", icon: "images/cabin.png", loot: 40, zombie: 5, ascii: `   /\\\n  /  \\\n |----|\n |[]_ |\n |____|`, blocksVision: false },
        { nameKey: "location_rock", icon: "images/rock_terrain.png", loot: 3, zombie: 3, ascii: `   /\\ \n  /  \\ \n /____\\`, blocksVision: false },
        { ...fieldLocation, icon: "images/field.png", blocksVision: false }
    ],
    Town: [
        { nameKey: "location_house", icon: "images/house.png", loot: 30, zombie: 25, ascii: `  /\\\n /__\\\n|'--'|\n| [] |\n|____|`, blocksVision: false },
        { nameKey: "location_store", icon: "images/store.png", loot: 60, zombie: 35, ascii: ` _______\n|       |\n| SALE  |\n|_______|\n|  [] ||`, blocksVision: false },
        { nameKey: "location_hospital", icon: "images/hospital.png", loot: 70, zombie: 40, ascii: `  _____\n |+ + +|\n |+_+_+|\n |     |\n |_____|`, blocksVision: false },
        { nameKey: "location_park", icon: "images/park.png", loot: 10, zombie: 10, ascii: `  T T T\n   ____\n  /    \\\n |  ^   |\n  \\____/`, blocksVision: false },
        { nameKey: "location_empty_lot", icon: "images/empty_lot.png", loot: 5, zombie: 5, ascii: `  ______\n |      |\n |      |\n |______|`, blocksVision: false }
    ],
    Road: [ { nameKey: "location_road", icon: "images/road.png", loot: 15, zombie: 3, ascii: `|       |\n|-------|\n|   |   |\n|-------|\n|       |`, blocksVision: false} ],
    TraderShop: { nameKey: "location_trader_shop", icon: "images/store.png", loot: 0, zombie: 0, ascii: ` _______\n| TRADE |\n|  $$$  |\n|_______|\n|  [] ||`, isShop: true, blocksVision: false }
};


const playerAsciiStates = {
    high: `  O\n /|\\\n / \\`,
    medium: `  o\n /|\\\n / >`,
    low: `  o\n /|~\n / \\`,
    critical: `  x\n _|_ \n / \\ `
}, charBodyDead = `   \n   X\n <--- \n / \\ `;

// ▼▼▼ このブロックを丸ごと置き換えてください ▼▼▼
const zombieAscii = {
    high: `  _._\n /| |\\\n /  |`,
    medium: `  ~.~\n /| |~\n /  |`,
    low: `  >_<\n /|_ | \n /  `,
    critical: `  x_x\n  |   \n  /  `
};
// ▲▲▲ 置き換えここまで ▲▲▲

const HANDMADE_TAG = "handmade";
const NO_LOOT_TAG = "no_loot";
// ▼▼▼ この const items = [ ... ]; の配列を丸ごと置き換えてください ▼▼▼
const items = [
    // === NEW ITEMS (ENGINEER) ===
    { name: "作業着", desc: "厚手の生地で作られた丈夫な服。多少の危険から身を守る。", type: "clothing", slot: "body_outer", defense: 4, insulation: 2.5, durability: 100, weight: 2.0, volume: 5.0, graphic: "images/work_clothes.png", value: 50, wetness: 'dry' },
    { name: "安全ヘルメット", desc: "頭部を保護する工業用のヘルメット。", type: "equipment", slot: "head", defense: 8, insulation: 0.5, durability: 100, weight: 1.5, volume: 4.0, graphic: "images/safety_helmet.png", value: 30 },
    { name: "ツールベルト", desc: "工具を携帯するためのベルト。最大重量と容量が少し増える。", type: "equipment", slot: "pochette", durability: 80, weight: 0.8, volume: 1.5, graphic: "images/tool_belt.png", value: 45, effects: { maxWeight: 5, maxVolume: 5 } },
    { name: "ダクトテープ", desc: "非常に強力な粘着テープ。装備品の応急修理に使える。", type: "consumable", useAction: 'repairItem', weight: 0.3, volume: 0.8, graphic: "images/duct_tape.png", value: 25 },

    // === NEW ITEMS (DOCTOR / NURSE) ===
    { name: "メス", desc: "医療用の小刀。切れ味は鋭いが、武器としてはもろい。", type: "equipment", slot: "weapon", handedness: "one", attack: 12, defense: 0, durability: 40, weight: 0.1, volume: 0.2, graphic: "images/scalpel.png", value: 20, isBlade: true },
    { name: "白衣", desc: "医師や看護師が着る白いコート。動きやすいが、防寒性は低い。", type: "clothing", slot: "body_outer", defense: 1, insulation: 1.0, durability: 80, weight: 0.8, volume: 3.0, graphic: "images/lab_coat.png", value: 20, wetness: 'dry' },
    { name: "マスク", desc: "医療用マスク。気休め程度の保温性がある。", type: "clothing", slot: "head", defense: 0, insulation: 0.2, durability: 100, weight: 0.05, volume: 0.1, graphic: "images/mask.png", value: 5, wetness: 'dry' },
    { name: "救急キット", desc: "様々な応急処置ができる医療品セット。体力を大きく回復する。", type: "consumable", effects: { health: 50 }, weight: 0.8, volume: 2.0, graphic: "images/first_aid_kit.png", value: 80 },
    { name: "胃腸薬", desc: "食中毒や腹痛を和らげる薬。", type: "consumable", useAction: 'cureFoodPoisoning', weight: 0.1, volume: 0.2, graphic: "images/medicine.png", value: 50 },
    { name: "ハサミ", desc: "医療用のはさみ。護身用としては心もとない。", type: "equipment", slot: "weapon", handedness: "one", attack: 6, defense: 0, durability: 60, weight: 0.2, volume: 0.4, graphic: "images/scissors.png", value: 10, isBlade: true },

    // === NEW ITEMS (SOLDIER) ===
    { name: "コンバットナイフ", desc: "軍用の頑丈なナイフ。戦闘に特化している。", type: "equipment", slot: "weapon", handedness: "one", attack: 18, defense: 0, durability: 100, weight: 0.6, volume: 1.0, graphic: "images/combat_knife.png", value: 60, isBlade: true },

    // === NEW ITEMS (TEACHER / STUDENT) ===
    { name: "モップ", desc: "床掃除に使う道具。長い柄はゾンビとの距離を保つのに役立つ。", type: "equipment", slot: "weapon", handedness: "two", attack: 6, defense: 0, durability: 50, weight: 1.2, volume: 5.0, graphic: "images/mop.png", value: 10 },
    { name: "ジャージ", desc: "動きやすいスポーツウェア。実用性は高い。", type: "clothing", slot: "body_outer", defense: 2, insulation: 1.8, durability: 90, weight: 1.0, volume: 3.5, graphic: "images/tracksuit.png", value: 25, wetness: 'dry' },
    { name: "バックパック", desc: "一般的なバックパック。多くの荷物を運べる。", type: "equipment", slot: "back", durability: 100, weight: 1.5, volume: 2.0, graphic: "images/backpack.png", value: 60, effects: { maxWeight: 15, maxVolume: 20 } },

    // === NEW ITEMS (ATHLETE) ===
    { name: "テニスラケット", desc: "軽量で振りやすいが、武器としての耐久性は低い。", type: "equipment", slot: "weapon", handedness: "one", attack: 8, defense: 0, durability: 25, weight: 0.4, volume: 3.0, graphic: "images/tennis_racket.png", value: 15 },
    { name: "野球のバット", desc: "強力な鈍器。扱いやすく、威力も高い。", type: "equipment", slot: "weapon", handedness: "two", attack: 15, defense: 0, durability: 80, weight: 1.5, volume: 4.0, graphic: "images/baseball_bat.png", value: 40 },
    { name: "エナジードリンク", desc: "疲労を吹き飛ばす炭酸飲料。空腹と渇きを少し癒す。", type: "consumable", effects: { hunger: 5, thirst: 20, sleep: 5 }, weight: 0.4, volume: 0.8, graphic: "images/energy_drink.png", value: 18 },
    { name: "プロテインバー", desc: "手軽に栄養補給ができる食品。空腹をしっかり満たす。", type: "consumable", effects: { hunger: 30 }, weight: 0.1, volume: 0.3, graphic: "images/protein_bar.png", value: 22 },

    // === NEW ITEMS (POLICE OFFICER) ===
    { name: "警棒", desc: "警察官が使う頑丈な棍棒。優れた近接武器。", type: "equipment", slot: "weapon", handedness: "one", attack: 14, defense: 0, durability: 100, weight: 0.9, volume: 1.5, graphic: "images/baton.png", value: 45 },

    // === NEW ITEMS (CHEF) ===
    { name: "包丁", desc: "鋭い切れ味の料理用刃物。武器としても非常に有効。", type: "equipment", slot: "weapon", handedness: "one", attack: 15, defense: 0, durability: 80, weight: 0.4, volume: 0.7, graphic: "images/kitchen_knife.png", value: 40, isBlade: true },
    { name: "コックコート", desc: "厚手の調理服。保温性は低いが丈夫。", type: "clothing", slot: "body_outer", defense: 2, insulation: 1.2, durability: 100, weight: 1.2, volume: 4.0, graphic: "images/chef_coat.png", value: 28, wetness: 'dry' },

    // === NEW ITEMS (OFFICE WORKER) ===
    { name: "スーツのジャケット", desc: "オフィスワーカーの服装。保温性はそこそこある。", type: "clothing", slot: "body_outer", defense: 1, insulation: 1.5, durability: 70, weight: 1.1, volume: 3.5, graphic: "images/suit_jacket.png", value: 20, wetness: 'dry' },

    // === EXISTING ITEMS ===
    { name: "包帯", desc: "傷を治す", type: "consumable", effects: { health: 20 }, weight: 0.2, volume: 0.5, graphic: "images/bandage.png", value: 20 },
    { name: "簡単な包帯", desc: "傷を少しだけ治す応急処置品。", type: "consumable", effects: { health: 10 }, weight: 0.1, volume: 0.2, graphic: "images/bandage.png", value: 8, tags: [HANDMADE_TAG, NO_LOOT_TAG] },
    { name: "パン", desc: "空腹を満たす", type: "consumable", effects: { hunger: 25 }, freshness: 100, weight: 0.5, volume: 1.5, graphic: "images/bread.png", value: 15, smell: 2 },
    { name: "生肉", desc: "焼けば食べられる新鮮な肉。生で食べると危険。", type: "consumable", effects: { hunger: 10, health: -15 }, freshness: 100, weight: 0.8, volume: 1.0, graphic: "images/raw_meat.png", value: 8, tags: [NO_LOOT_TAG], smell: 10 },
    { name: "焼いた肉", desc: "栄養価の高い安全な食料。", type: "consumable", effects: { hunger: 40, morale: 5 }, freshness: 100, weight: 0.7, volume: 1.0, graphic: "images/cooked_meat.png", value: 25, tags: [NO_LOOT_TAG], smell: 5 },
    { name: "缶詰(豆)", desc: "豆の缶詰。開ける必要がある。", type: "consumable", isSealed: true, sealedEffects: { hunger: 30 }, freshness: 1000, weight: 0.5, volume: 1.0, graphic: "images/canned_beans.png", value: 20 },
    
    { name: "整腸剤", desc: "食中毒を和らげる薬。", type: "consumable", useAction: 'cureFoodPoisoning', weight: 0.1, volume: 0.2, graphic: "images/medicine.png", value: 50 },
    { name: "下痢止め", desc: "下痢を抑える薬。", type: "consumable", useAction: 'cureDiarrhea', weight: 0.1, volume: 0.2, graphic: "images/medicine.png", value: 50 },
    { name: "解熱剤", desc: "熱を下げるための薬。", type: "consumable", useAction: 'cureFever', weight: 0.1, volume: 0.2, graphic: "images/medicine.png", value: 60 },

    { name: "キノコ", desc: "食べられるキノコ。生で食べると毒にあたるかもしれない。", type: "consumable", effects: { hunger: 8 }, riskOfSickness: 0.3, weight: 0.1, volume: 0.5, graphic: "images/mushroom.png", value: 6, tags: [NO_LOOT_TAG], smell: 1 },
    { name: "焼いたキノコ", desc: "香ばしく焼かれたキノコ。安全で美味しい。", type: "consumable", effects: { hunger: 15, morale: 3 }, weight: 0.1, volume: 0.5, graphic: "images/mushroom.png", value: 12, tags: [NO_LOOT_TAG], smell: 3 },
    { name: "トウモロコシ", desc: "甘いトウモロコシ。生で食べるとお腹を壊すかも。", type: "consumable", effects: { hunger: 10 }, riskOfSickness: 0.2, weight: 0.4, volume: 1.2, graphic: "images/corn.png", value: 8, tags: [NO_LOOT_TAG], smell: 1 },
    { name: "焼いたトウモロコシ", desc: "甘く焼かれたトウモロコシ。とても美味しい。", type: "consumable", effects: { hunger: 25, morale: 5 }, weight: 0.4, volume: 1.2, graphic: "images/corn.png", value: 16, tags: [NO_LOOT_TAG], smell: 4 },
    { name: "ジャガイモ", desc: "生のジャガイモ。調理したほうが良さそうだ。", type: "consumable", effects: { hunger: 8 }, riskOfSickness: 0.25, weight: 0.3, volume: 0.8, graphic: "images/potato.png", value: 5, tags: [NO_LOOT_TAG], smell: 1 },
    { name: "焼いたジャガイモ", desc: "ホクホクのベイクドポテト。体が温まる。", type: "consumable", effects: { hunger: 20, morale: 4 }, weight: 0.3, volume: 0.8, graphic: "images/potato.png", value: 10, tags: [NO_LOOT_TAG], smell: 3 },
    { name: "ニンジン", desc: "新鮮なニンジン。泥を落とせば食べられそう。", type: "consumable", effects: { hunger: 6 }, riskOfSickness: 0.1, weight: 0.2, volume: 0.6, graphic: "images/carrot.png", value: 5, tags: [NO_LOOT_TAG], smell: 1 },
    { name: "焼いたニンジン", desc: "甘みが増した焼きニンジン。", type: "consumable", effects: { hunger: 12, morale: 2 }, weight: 0.2, volume: 0.6, graphic: "images/carrot.png", value: 10, tags: [NO_LOOT_TAG], smell: 3 },
    { name: "キャベツ", desc: "栄養のある葉物野菜。調理せずに食べられる。", type: "consumable", effects: { hunger: 10 }, weight: 0.5, volume: 1.5, graphic: "images/cabbage.png", value: 10, tags: [NO_LOOT_TAG], smell: 1 },

    { name: "たき火キット", desc: "たき火の土台を設置する。火をつけるには別の道具が必要。", type: "tool", useAction: 'placeUnlitCampfire', weight: 1.5, volume: 5.0, graphic: "images/campfire_kit.png", value: 30, tags: [HANDMADE_TAG, NO_LOOT_TAG] },
    { name: "寝袋", desc: "地面に設置して眠ることができる。睡眠の回復効率が高い。", type: "tool", useAction: 'placeSleepingBag', weight: 1, volume: 4.0, graphic: "images/sleeping_bag.png", value: 40, tags: [HANDMADE_TAG] },
    { name: "缶切り", desc: "缶詰を安全に開けるための道具。", type: "tool", durability: 100, weight: 0.3, volume: 0.5, graphic: "images/can_opener.png", value: 15 },
    { name: "ライター", desc: "火をおこすための道具。燃料には限りがある。", type: "tool", useAction: 'startFire', weight: 0.1, volume: 0.2, graphic: "images/lighter.png", value: 40, durability: 100 },
    { name: "火打石", desc: "火花を散らして火をおこす石。使うたびに少しずつ削れていく。", type: "tool", useAction: 'startFire', durability: 100, weight: 0.4, volume: 0.5, graphic: "images/flint.png", value: 25 },
    { name: "火起こし器", desc: "木の摩擦で火をおこす原始的な道具。", type: "tool", useAction: 'startFire', weight: 0.8, volume: 3.0, graphic: "images/fire_starter.png", value: 15, durability: 100, tags: [HANDMADE_TAG, NO_LOOT_TAG] },
    { name: "添え木", desc: "骨折を固定するための応急処置具。", type: "consumable", useAction: 'applySplint', weight: 0.5, volume: 1.5, graphic: "images/splint.png", value: 15, tags: [HANDMADE_TAG, NO_LOOT_TAG] },
    { name: "タオル", desc: "濡れた体や衣服を拭くための布。", type: "tool", useAction: 'wipeClothes', weight: 0.4, volume: 1.5, graphic: "images/towel.png", value: 18 },
    { name: "手作りの鍬", desc: "畑を耕すための簡単な道具。種を植えるのに使う。", type: "tool", useAction: 'tillSoil', durability: 60, weight: 1.8, volume: 4.0, graphic: "images/hoe.png", value: 20, tags: [HANDMADE_TAG, NO_LOOT_TAG] },

    { name: "水筒", desc: "水を持ち運ぶための容器。", type: "container", capacity: 2, durability: 100, weight: 0.5, volume: 2.0, graphic: "images/canteen.png", value: 15, content: null },
    { name: "手作り水筒", desc: "毛皮で作った水筒。少し水漏れするかもしれない。", type: "container", capacity: 2, durability: 70, weight: 0.4, volume: 2.0, graphic: "images/waterskin.png", value: 12, tags: [HANDMADE_TAG, NO_LOOT_TAG], content: null },
    { name: "ペットボトル", desc: "水を持ち運べる便利な容器。", type: "container", capacity: 1, durability: 50, weight: 0.1, volume: 1.5, graphic: "images/plastic_bottle.png", value: 5, content: null },
    { name: "空き缶", desc: "水を持ち運べるが量は少ない。", type: "container", capacity: 1, durability: 30, weight: 0.1, volume: 1.0, graphic: "images/empty_can.png", value: 2, content: null },
    { name: "汚れた水", desc: "水源。そのまま飲むか、容器に汲める。", type: "water_source", weight: 0, volume: 0, graphic: "images/pond.png", value: 0, tags: [NO_LOOT_TAG]},

    { name: "ナイフ", desc: "戦闘や調理に使える万能な刃物。", type: "equipment", slot: "weapon", handedness: "one", attack: 15, defense: 0, durability: 100, weight: 0.5, volume: 0.8, graphic: "images/kitchen_knife.png", value: 40, isBlade: true },
    { name: "石斧", desc: "原始的な斧。攻撃力が少し上がる。", type: "equipment", slot: "weapon", handedness: "one", attack: 12, defense: 0, durability: 50, weight: 1.5, volume: 3.0, graphic: "images/stone_axe.png", value: 25, tags: [HANDMADE_TAG, NO_LOOT_TAG], isBlade: true, isAxe: true },
    { name: "手作り石ナイフ", desc: "石を砕いて作ったナイフ。もろいが無いよりはまし。", type: "equipment", slot: "weapon", handedness: "one", attack: 8, defense: 0, durability: 30, weight: 0.3, volume: 0.6, graphic: "images/stone_knife.png", value: 10, tags: [HANDMADE_TAG, NO_LOOT_TAG], isBlade: true },
    { name: "手作りスピア", desc: "枝の先端を尖らせただけの簡単な槍。リーチが少し長い。", type: "equipment", slot: "weapon", handedness: "two", attack: 10, defense: 0, durability: 40, weight: 1.0, volume: 4.0, graphic: "images/spear.png", value: 12, tags: [HANDMADE_TAG, NO_LOOT_TAG] },
    { name: "松明", desc: "周囲を照らす明かり。6ターンで燃え尽きる。", type: "equipment", slot: "weapon", handedness: "one", attack: 2, defense: 0, durability: 100, weight: 0.6, volume: 2.5, graphic: "images/torch.png", value: 10, tags: [HANDMADE_TAG, NO_LOOT_TAG], duration: 6, isTorch: true, useAction: 'startFire' },
    
    { name: "ピストル", desc: "小型の拳銃。近距離での戦闘に適している。", type: "equipment", slot: "weapon", handedness: "one", attack: 4, fireDamage: 40, durability: 100, weight: 1.2, volume: 2.0, graphic: "images/pistol.png", value: 150, ammoType: 'pistol', ammoCapacity: 7, loadedAmmo: 0 },
    { name: "ショットガン", desc: "散弾銃。近距離で絶大な威力を誇るが、装弾数は少ない。", type: "equipment", slot: "weapon", handedness: "two", attack: 6, fireDamage: 65, durability: 100, weight: 3.5, volume: 6.0, graphic: "images/shotgun.png", value: 200, ammoType: 'shotgun', ammoCapacity: 5, loadedAmmo: 0 },
    { name: "ライフル", desc: "高精度なライフル。遠距離の敵を狙える。", type: "equipment", slot: "weapon", handedness: "two", attack: 5, fireDamage: 55, durability: 100, weight: 4.0, volume: 10.0, graphic: "images/rifle.png", value: 220, ammoType: 'rifle', ammoCapacity: 5, loadedAmmo: 0, bayonetAttached: false },
    { name: "ピストルの弾", desc: "ピストル用の弾薬。", type: "ammo", ammoType: "pistol", weight: 0.02, volume: 0.1, graphic: "images/ammo_pistol.png", value: 8 },
    { name: "ショットガンの弾", desc: "ショットガン用の弾薬。", type: "ammo", ammoType: "shotgun", weight: 0.05, volume: 0.2, graphic: "images/ammo_shotgun.png", value: 12 },
    { name: "ライフルの弾", desc: "ライフル用の弾薬。", type: "ammo", ammoType: "rifle", weight: 0.03, volume: 0.1, graphic: "images/ammo_rifle.png", value: 10 },

    { name: "ヘルメット", desc: "頭部を保護する", type: "equipment", slot: "head", defense: 10, durability: 100, insulation: 1.5, weight: 2.5, volume: 4.0, graphic: "images/helmet.png", value: 35 },
    { name: "メガネ", desc: "視力を補正する。目が悪い特性を打ち消す。", type: "equipment", slot: "eyes", durability: 60, weight: 0.1, volume: 0.5, graphic: "images/glasses.png", value: 30 },

    { name: "手作りのポシェット", desc: "腰に巻く小さなバッグ。最大重量が少し増える。", type: "equipment", slot: "pochette", weight: 0.4, volume: 1.0, graphic: "images/handmade_pouch.png", value: 20, tags: [HANDMADE_TAG, NO_LOOT_TAG], effects: { maxWeight: 3, maxVolume: 5 }, durability: 80 },
    { name: "大きなバックパック", desc: "大容量のバックパック。最大重量が大幅に増える。", type: "equipment", slot: "back", durability: 100, weight: 2, volume: 2.0, graphic: "images/backpack_large.png", value: 90, effects: { maxWeight: 20, maxVolume: 25 } },
    
    { name: "Tシャツ", desc: "軽い衣服。重ね着できる。", type: "clothing", slot: "body_inner", defense: 1, durability: 100, insulation: 0.5, weight: 0.3, volume: 1.0, graphic: "images/tshirt.png", value: 10, wetness: 'dry' },
    { name: "コート", desc: "暖かく、防寒に優れる。", type: "clothing", slot: "body_outer", defense: 3, durability: 100, insulation: 4.0, weight: 2.5, volume: 6.0, graphic: "images/coat.png", value: 60, wetness: 'dry' },
    { name: "防弾ベスト", desc: "銃弾から身を守るベスト。衝撃には強いが重い。", type: "clothing", slot: "body_outer", defense: 25, durability: 100, insulation: 1.0, weight: 8.0, volume: 5.0, graphic: "images/bulletproof_vest.png", value: 120, wetness: 'dry' },
    { name: "ズボン", desc: "下半身を保護する。", type: "clothing", slot: "legs", defense: 2, durability: 100, insulation: 2.0, weight: 1.2, volume: 3.0, graphic: "images/pants.png", value: 25, wetness: 'dry' },
    { name: "帽子", desc: "頭部を暖める。", type: "clothing", slot: "head", defense: 0, durability: 100, insulation: 1.2, weight: 0.3, volume: 1.5, graphic: "images/cap.png", value: 15, wetness: 'dry' },
    { name: "手作りの手袋", desc: "手を保護し、少し暖かい。", type: "clothing", slot: "hands", defense: 1, durability: 60, insulation: 0.8, weight: 0.2, volume: 0.8, graphic: "images/handmade_gloves.png", value: 12, tags: [HANDMADE_TAG, NO_LOOT_TAG], wetness: 'dry' },
    { name: "手作りの帽子", desc: "頭を少しだけ暖める。", type: "clothing", slot: "head", defense: 0, durability: 70, insulation: 1.0, weight: 0.2, volume: 1.2, graphic: "images/handmade_hat.png", value: 18, tags: [HANDMADE_TAG, NO_LOOT_TAG], wetness: 'dry' },
    { name: "手作りの服", desc: "体を覆う簡単な服。", type: "clothing", slot: "body_inner", defense: 1, durability: 60, insulation: 1.5, weight: 0.8, volume: 2.0, graphic: "images/handmade_clothes.png", value: 25, tags: [HANDMADE_TAG, NO_LOOT_TAG], wetness: 'dry' },
    { name: "手作りのズボン", desc: "脚を覆う簡単なズボン。", type: "clothing", slot: "legs", defense: 1, durability: 60, insulation: 1.2, weight: 0.7, volume: 2.5, graphic: "images/handmade_pants.png", value: 25, tags: [HANDMADE_TAG, NO_LOOT_TAG], wetness: 'dry' },
    { name: "手作りのコート", desc: "複数の毛皮を繋ぎ合わせた暖かいコート。", type: "clothing", slot: "body_outer", defense: 2, durability: 50, insulation: 3.0, weight: 2.0, volume: 5.0, graphic: "images/coat.png", value: 50, tags: [HANDMADE_TAG, NO_LOOT_TAG], wetness: 'dry' },
    { name: "スニーカー", desc: "どこにでもある一般的な運動靴。動きやすいが、保護性能は低い。", type: "clothing", slot: "feet", defense: 2, insulation: 0.5, soundModifier: 0.8, durability: 80, weight: 0.8, volume: 1.5, value: 20, wetness: 'dry', graphic: "images/sneakers.png" },
    { name: "革靴", desc: "オフィスワーカーが履いていたであろう革靴。硬く、歩くとコツコツと音が響く。", type: "clothing", slot: "feet", defense: 3, insulation: 0.8, soundModifier: 1.5, durability: 70, weight: 1.2, volume: 2.0, value: 25, wetness: 'dry', graphic: "images/leather_shoes.png" },
    { name: "ワークブーツ", desc: "つま先に鉄心が入った安全靴。非常に頑丈で防御力が高いが、重くて大きな音がする。", type: "clothing", slot: "feet", defense: 8, insulation: 1.5, soundModifier: 2.0, durability: 100, weight: 2.5, volume: 3.0, value: 50, wetness: 'dry', graphic: "images/work_boots.png" },
    { name: "登山靴", desc: "長距離の歩行を想定した丈夫な靴。悪路でも歩きやすく、保温性や防御力のバランスが良い。", type: "clothing", slot: "feet", defense: 6, insulation: 2.0, soundModifier: 1.2, durability: 90, weight: 1.8, volume: 2.5, value: 60, wetness: 'dry', graphic: "images/hiking_boots.png" },
    { name: "コンバットブーツ", desc: "軍用に設計されたブーツ。高い防御力を持ちながら、足音は比較的静かに保てる。希少品。", type: "clothing", slot: "feet", defense: 7, insulation: 1.8, soundModifier: 1.0, durability: 100, weight: 2.0, volume: 2.5, value: 85, wetness: 'dry', graphic: "images/combat_boots.png" },

    { name: "石", desc: "クラフトの材料になる硬い石。", type: "material", weight: 1, volume: 0.5, graphic: "images/stone.png", value: 5 },
    { name: "枝", desc: "クラフトの材料になる木の枝。", type: "material", weight: 0.5, volume: 2.0, graphic: "images/branch.png", value: 3 },
    { name: "布切れ", desc: "クラフトの材料になる布の切れ端。濡れた服を拭くこともできる。", type: "material", useAction: 'wipeClothes', weight: 0.1, volume: 0.2, graphic: "images/cloth_scrap.png", value: 4 },
    { name: "毛皮", desc: "クラフトの材料になる動物の毛皮。", type: "material", weight: 0.8, volume: 0.8, graphic: "images/fur.png", value: 15, tags: [NO_LOOT_TAG] },
    { name: "大きな葉", desc: "クラフトの材料になる大きくて丈夫な葉。", type: "material", weight: 0.1, volume: 1.5, graphic: "images/leaf_large.png", value: 4 },
    { name: "木箱", desc: "アイテムを10個保管できる箱。設置して使う。", type: "tool", useAction: 'placeWoodenBox', weight: 5, volume: 15.0, graphic: "images/wooden_box.png", value: 60, tags: [HANDMADE_TAG, NO_LOOT_TAG] },
    { name: "丸太", desc: "頑丈な丸太。バリケードなどのクラフトに使える。", type: "material", weight: 4.0, volume: 5.0, graphic: "images/log.png", value: 15 },
    { name: "バリケード", desc: "丸太を組んで作った粗雑な障害物。設置して敵の侵攻を一時的に防ぐ。持ち運びも可能。", type: "tool", useAction: 'placeBarricadeItem', weight: 4.0, volume: 5.0, graphic: "images/barricade.png", value: 45, tags: ["no_loot", "handmade"] },
    { name: "ニンジンの種", desc: "畑に植えるとニンジンが育つ。", type: "tool", useAction: 'plantSeed', plantResult: 'ニンジン', weight: 0.1, volume: 0.1, graphic: "images/seeds.png", value: 8, tags: [NO_LOOT_TAG]},
    { name: "キャベツの種", desc: "畑に植えるとキャベツが育つ。", type: "tool", useAction: 'plantSeed', plantResult: 'キャベツ', weight: 0.1, volume: 0.1, graphic: "images/seeds.png", value: 8, tags: [NO_LOOT_TAG]},
    { name: "ジャガイモの種", desc: "畑に植えるとジャガイモが育つ。", type: "tool", useAction: 'plantSeed', plantResult: 'ジャガイモ', weight: 0.1, volume: 0.1, graphic: "images/seeds.png", value: 8, tags: [NO_LOOT_TAG]},
];
const cookingMap = {
    "生肉": "焼いた肉",
    "キノコ": "焼いたキノコ",
    "トウモロコシ": "焼いたトウモロコシ",
    "ジャガイモ": "焼いたジャガイモ",
    "ニンジン": "焼いたニンジン",
};

// ▼▼▼ この配列を丸ごと置き換えてください ▼▼▼

const recipes = [
    { result: "石斧", ingredients: [{ name: "石", count: 1 }, { name: "枝", count: 1 }] },
    { result: "手作り石ナイフ", ingredients: [{ name: "石", count: 2 }] },
    { result: "手作りスピア", ingredients: [{ name: "枝", count: 2 }] },
    { result: "火起こし器", ingredients: [{ name: "枝", count: 3 }] },
    { result: "たき火キット", ingredients: [{ name: "石", count: 2 }, { name: "枝", count: 2 }] },
    { result: "簡単な包帯", ingredients: [{ name: "布切れ", count: 2 }] },
    { result: "手作りのポシェット", ingredients: [{ name: "毛皮", count: 1 }] },
    { result: "手作りの手袋", ingredients: [{ name: "毛皮", count: 1 }] },
    { result: "手作りの帽子", ingredients: [{ name: "毛皮", count: 2 }] },
    { result: "手作り水筒", ingredients: [{ name: "毛皮", count: 2 }] },
    { result: "手作りの服", ingredients: [{ name: "毛皮", count: 3 }] },
    { result: "手作りのズボン", ingredients: [{ name: "毛皮", count: 3 }] },
    { result: "手作りのコート", ingredients: [{ name: "毛皮", count: 5 }] },
    { result: "木箱", ingredients: [{ name: "枝", count: 5 }] },
    { result: "寝袋", ingredients: [{ name: "大きな葉", count: 2 }] },
    { result: "添え木", ingredients: [{ name: "枝", count: 3 }] },
    { result: "手作りの鍬", ingredients: [{ name: "枝", count: 1 }, { name: "石", count: 1 }] },
];

// ▼▼▼ このブロックをコピーして追加 ▼▼▼

// --- ワークベンチ関連のアイテム定義 ---
items.push(
    { name: "ワークベンチキット", desc: "高度なクラフトを行うための作業台を設置する。頑丈な道具が必要になる。", type: "tool", useAction: 'placeWorkbench', weight: 8.0, volume: 20.0, graphic: "images/workbench.png", value: 100, tags: [HANDMADE_TAG, NO_LOOT_TAG] }
    // ▲▲▲ 修正ここまで ▲▲▲
);

// --- ワークベンチキットの通常クラフトレシピ ---
recipes.push(
    { result: "ワークベンチキット", ingredients: [{ name: "丸太", count: 2 }] }
);

const workbenchRecipes = [
    { result: "ピストル", ingredients: [{ name: "鉄くず", count: 15 }, { name: "枝", count: 5 }] },
    { result: "ショットガン", ingredients: [{ name: "鉄くず", count: 25 }, { name: "丸太", count: 2 }] },
    { result: "ライフル", ingredients: [{ name: "鉄くず", count: 30 }, { name: "丸太", count: 3 }] },
    { result: "ピストルの弾", ingredients: [{ name: "鉄くず", count: 2 }] },
    { result: "ショットガンの弾", ingredients: [{ name: "鉄くず", count: 3 }] },
    { result: "ライフルの弾", ingredients: [{ name: "鉄くず", count: 3 }] },
    { result: "防弾ベスト", ingredients: [{ name: "鉄くず", count: 20 }, { name: "毛皮", count: 5 }] },
    { result: "大きなバックパック", ingredients: [{ name: "毛皮", count: 6 }, { name: "布切れ", count: 4 }] },
    // ▼▼▼ この行の数値を 3 から 1 に変更しました ▼▼▼
    { result: "バリケード", ingredients: [{ name: "丸太", count: 1 }] }
];
items.push(
    { name: "鉄くず", desc: "金属製品を解体して得られるクラフト材料。", type: "material", weight: 0.5, volume: 0.2, graphic: "images/scrap_metal.png", value: 8 }
);

// ▲▲▲ ここまで ▲▲▲

const dismantleRecipes = {
    "包帯": [{ name: "布切れ", count: 1 }],
    "Tシャツ": [{ name: "布切れ", count: 1 }],
    "ズボン": [{ name: "布切れ", count: 1 }],
    "添え木": [{ name: "枝", count: 1 }],
    "モップ": [{ name: "枝", count: 1 }],
    "テニスラケット": [{ name: "枝", count: 1 }],
    "野球のバット": [{ name: "枝", count: 1 }],
    "作業着": [{ name: "布切れ", count: 2 }],
    "白衣": [{ name: "布切れ", count: 2 }],
    "スーツのジャケット": [{ name: "布切れ", count: 2 }],
    "ジャージ": [{ name: "布切れ", count: 2 }],
    "コックコート": [{ name: "布切れ", count: 2 }],
    "コート": [{ name: "布切れ", count: 2 }],
    "ツールベルト": [{ name: "毛皮", count: 1 }],
    "手作りのポシェット": [{ name: "毛皮", count: 1 }],
    "手作りの服": [{ name: "毛皮", count: 1 }],
    "手作りのズボン": [{ name: "毛皮", count: 1 }],
    "バックパック": [{ name: "毛皮", count: 1 }, { name: "布切れ", count: 2 }],
    "大きなバックパック": [{ name: "毛皮", count: 2 }, { name: "布切れ", count: 3 }],
    "防弾ベスト": [{ name: "毛皮", count: 2 }, { name: "布切れ", count: 3 }],
    "手作りのコート": [{ name: "毛皮", count: 2 }]
};


// NEW: Starting equipment pools for each job
const jobStartingPools = {
    "エンジニア": ["作業着", "安全ヘルメット", "ツールベルト", "ダクトテープ"],
    "医師": ["メス", "白衣", "マスク", "救急キット", "包帯", "解熱剤", "下痢止め", "胃腸薬"],
    "軍人": ["コンバットナイフ", "ヘルメット", "水筒"],
    "教師": ["モップ", "ジャージ", "救急セット"],
    "アスリート": ["テニスラケット", "野球のバット", "ジャージ", "エナジードリンク", "プロテインバー"],
    "警察官": ["ピストル", "警棒", "防弾ベスト", "ピストルの弾"],
    "看護師": ["ハサミ", "白衣", "救急キット", "包帯", "解熱剤", "下痢止め", "胃腸薬"],
    "シェフ": ["包丁", "コックコート", "缶詰(豆)", "生肉", "ライター"],
    "学生": ["モップ", "野球のバット", "ジャージ", "バックパック"],
    "会社員": ["ハサミ", "スーツのジャケット", "水筒", "缶詰(豆)"]
};

// ▼▼▼ この配列を丸ごと置き換えてください ▼▼▼
const npcTemplates = [
    { type: 'Trader', name: '商人', icon: 'images/trader.png', health: 70, baseAttack: 5, baseDefense: 5, visionRange: 3, knowsSalvationCity: false, willSteal: 0.1,
        ascii: {
            high: `  o_o\n /|] \n / \\`,
            medium: `  o_o\n /|] \n / >`,
            low: `  o_~\n /|_ \n / \\`,
            critical: `  x_x\n _|_ \n / \\`
        },
        dialogue: { greeting: "npc_trader_greeting", fight: "npc_trader_fight", leave: "npc_trader_leave" }
    },
    { type: 'Survivor', name: '生存者', icon: 'images/survivor.png', health: 50, baseAttack: 8, baseDefense: 3, visionRange: 3, willSteal: 0.3,
        ascii: {
            high: `  ._.\n /|\\ \n / \\`,
            medium: `  '-'\n /|\\ \n / >`,
            low: `  ~_~\n /|~ \n / \\`,
            critical: `  x_x\n _|_ \n / \\`
        },
        dialogue: { greeting: "npc_survivor_greeting", fight: "npc_survivor_fight", leave: "npc_survivor_leave" }
    },
    { type: 'Raider', name: '略奪者', icon: 'images/raider.png', health: 80, baseAttack: 12, baseDefense: 8, visionRange: 3, willSteal: 1.0,
        ascii: {
            high: `  >_<\n /|\\ \n / \\`,
            medium: `  >_>\n /|\\ \n / >`,
            low: `  ~_<\n /|~ \n / \\`,
            critical: `  x_x\n _|_ \n / \\`
        },
        dialogue: { greeting: "npc_raider_greeting", fight: "npc_raider_fight", leave: "npc_raider_leave" }
    }
];
// ▲▲▲ 置き換えここまで ▲▲▲

// ▼▼▼ この const wildlifeTemplates = [ ... ]; の配列を丸ごと置き換えてください ▼▼▼
const wildlifeTemplates = [
    { type: 'Bear', name: '熊', icon: 'images/bear.png', health: 120, attack: 20, defense: 8, visionRange: 5, isAnimal: true, 
        ascii: {
            high: ` (\\_(-_-)_/)\n   _\\_”_/_  \n  /___”___\\`,
            medium: ` (\\_(-o-)_/)\n   _\\_”_/_  \n  /__ ”__ \\`,
            low: ` (\\_(>_<)_/)\n   _\\_”_/_  \n  /  ”   \\`,
            critical: ` (\\_(x_x)_/)\n   _\\_”_/_  `
        }, 
        loot: { meat: 8, fur: 5 }, biomes: ['Forest'] 
    },
    { type: 'Wolf', name: '狼', icon: 'images/wolf.png', health: 60, attack: 15, defense: 4, visionRange: 6, isAnimal: true, 
        ascii: {
            high: `  /\\_/\\ \n ( o.o ) \n > ^ <`,
            medium: `  /\\_/\\ \n ( o.o ) \n > ~ <`,
            low: `  /\\_/\\ \n ( >.< ) \n > ~ <`,
            critical: `  /\\_/\\ \n ( x.x ) \n > , <`
        }, 
        loot: { meat: 4, fur: 3 }, biomes: ['Forest', 'Plains'] 
    },
    { type: 'Deer', name: '鹿', icon: 'images/deer.png', health: 40, attack: 5, defense: 2, visionRange: 7, isAnimal: true, flees: true, 
        ascii: {
            high: `  Y Y  \n (o.o) \n  > <`,
            medium: `  Y Y  \n (o.o) \n  > ~`,
            low: `  Y Y  \n (>.<) \n  > ,`,
            critical: `  Y Y  \n (x.x) `
        }, 
        loot: { meat: 5, fur: 2 }, biomes: ['Plains', 'Forest'] 
    },
    { type: 'Rabbit', name: 'ウサギ', icon: 'images/rabbit.png', health: 15, attack: 1, defense: 0, visionRange: 6, isAnimal: true, flees: true, 
        ascii: {
            high: `  /\\ /\\ \n ( o.o ) \n c(___)"`,
            medium: `  /\\ /\\ \n ( o.o ) \n c(___)'`,
            low: `  /\\ /\\ \n ( >.< ) \n c(___)'`,
            critical: `  /\\ /\\ \n ( x.x )`
        }, 
        loot: { meat: 1, fur: 1 }, biomes: ['Plains'] 
    }
];

function randChoice(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

let map = [];
let turn = 0;
let currentSeason = '春';
let isNight = false;
let currentTime = new Date();
let droppedItems = {};

const seasons = ['春', '夏', '秋', '冬'];

let player = {
  x: 0, y: 0, hunger: 0, thirst: 0, health: 0, morale: 0, sleep: 0,
  bodyTemp: 36.5, weight: 0, maxWeight: 10, volume: 0, maxVolume: 10, bodyOdor: 0,
  vision: 2, inventory: [], equipment: [], injuries: [], sicknesses: [], hypothermiaTurns: 0, feverImmunityTurns: 0,
  baseAttack: 10, baseDefense: 5, attack: 10, defense: 5, insulation: 0,
  isInside: false,
  movementMode: 'walk'
};

function snapshotStats() {
    playerStatsBeforeAction = JSON.parse(JSON.stringify(player));
}

// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function speak(text, onEndCallback) {
  if (!isSpeechEnabled) {
    if (onEndCallback) {
      setTimeout(onEndCallback, 100); 
    }
    return;
  }

  if ('speechSynthesis' in window && text) {
    const utter = new SpeechSynthesisUtterance(text);
    utter.rate = 2.5;

if (currentLanguage === 'ja') {
    utter.lang = 'ja-JP';
} else if (currentLanguage === 'zh-CN') {
    utter.lang = 'zh-CN';
} else {
    utter.lang = 'en-US';
}

    if (onEndCallback) { utter.onend = onEndCallback; }
    speechSynthesis.cancel();
    speechSynthesis.speak(utter);
  } else if (onEndCallback) { 
    setTimeout(onEndCallback, 500); 
  }
}
function speakQueuedLogs() {
    // log関数で即時読み上げを行うため、この関数は不要になりました。
    // 念のためキューを空にする処理だけ残します。
    logSpeechQueue = [];
}
// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function placeWorkbench(item, itemIndex, source) {
    if (placedObjects.find(o => o.x === player.x && o.y === player.y)) {
        log(getString("log_workbench_blocked"));
        return;
    }
    snapshotStats();
    const removedItem = player.inventory.splice(itemIndex, 1)[0];
    player.weight -= removedItem.weight;
    player.volume -= removedItem.volume;
    log(getString("log_workbench_placed"));
    // ▼▼▼ この行を修正しました ▼▼▼
    placedObjects.push({ x: player.x, y: player.y, type: 'workbench', name: 'ワークベンチ', graphic: 'images/workbench.png' });
    // ▲▲▲ 修正ここまで ▲▲▲
    drawMap();
    updateItemPanels();
    updateStatus();
    hideItemDetail();
}

function openWorkbenchPanel() {
    const panel = document.getElementById('workbenchPanel');
    const listDiv = document.getElementById('workbenchCraftingList');
    listDiv.innerHTML = ""; // リストを初期化

    workbenchRecipes.forEach(recipe => {
        const resultItem = items.find(i => i.name === recipe.result);
        if (!resultItem) return;

        const isCraftable = canCraftItem(recipe);
        const div = document.createElement("div");
        div.className = isCraftable ? "item" : "item un-craftable";

        let ingredientsHtml = recipe.ingredients.map(ing => `${ing.name} x${ing.count}`).join(', ');
        div.innerHTML = `<button>作成</button><span style="margin-right: 5px;">${resultItem.graphic}</span>${resultItem.name}<div class="recipe-ingredients">${ingredientsHtml}</div>`;
        
        if (isCraftable) {
            div.querySelector("button").onclick = () => craftWorkbenchItem(recipe);
        }
        listDiv.appendChild(div);
    });

    panel.style.display = 'flex';
    bringToFront(panel);
}

function closeWorkbenchPanel() {
    document.getElementById('workbenchPanel').style.display = 'none';
}

function craftWorkbenchItem(recipe) {
    if (!canCraftItem(recipe)) { log("材料が足りません。"); return; }
    
    // craftItem関数とほぼ同じロジック
    snapshotStats();
    recipe.ingredients.forEach(ingredient => {
        for (let i = 0; i < ingredient.count; i++) {
            const invIndex = player.inventory.findIndex(invItem => invItem.name === ingredient.name);
            if (invIndex > -1) {
                const removedItem = player.inventory.splice(invIndex, 1)[0];
                player.weight -= removedItem.weight || 0;
                player.volume -= removedItem.volume || 0;
            } else {
                const groundItems = droppedItems[`${player.x},${player.y}`] || [];
                const groundIndex = groundItems.findIndex(gItem => gItem.name === ingredient.name);
                if (groundIndex > -1) groundItems.splice(groundIndex, 1);
            }
        }
    });

    const resultItemTemplate = items.find(item => item.name === recipe.result);
    if (resultItemTemplate) {
        const newItem = { ...resultItemTemplate };
        player.inventory.push(newItem);
        player.weight += newItem.weight || 0;
        player.volume += newItem.volume || 0;
        log(`${newItem.name}をクラフトした！`, true);
        createSound(player.x, player.y, 5);
    }
    
    // UIを更新して材料の消費と結果を反映
    updateItemPanels();
    updateStatus();
    openWorkbenchPanel(); // パネルを再描画してクラフト可能状態を更新
}

// ▲▲▲ ここまで ▲▲▲

function speakAndAlert(text) { speak(text); showModal(text); }

function speakAndConfirm(text, onConfirm, onCancel) {
    // Create a temporary element to strip HTML for speech synthesis
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = text;
    const plainText = tempDiv.textContent || tempDiv.innerText || "";
    speak(plainText); // Speak the plain text version
    showConfirmationModal(text, onConfirm, onCancel); // Show the HTML version in the modal
}

function showModal(message) {
  const modalDiv = document.createElement("div");
  modalDiv.style.cssText = `position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #333; color: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.5); z-index: 2000;`;
  modalDiv.innerHTML = `<p>${message}</p><button onclick="this.parentElement.remove();">${getString("btn_ok")}</button>`;
  document.body.appendChild(modalDiv);
}

function showConfirmationModal(message, onConfirm, onCancel) {
  isInteractionActive = true;
  const modalDiv = document.createElement("div");
  modalDiv.style.cssText = `position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #333; color: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.5); z-index: 2000;`;
  modalDiv.innerHTML = `<p>${message}</p><button id="confirmYes" style="margin-right: 10px;">${getString("btn_yes")}</button><button id="confirmNo">${getString("btn_no")}</button>`;
  document.body.appendChild(modalDiv);
  modalDiv.querySelector("#confirmYes").onclick = () => { modalDiv.remove(); isInteractionActive = false; if(onConfirm) onConfirm(); };
  modalDiv.querySelector("#confirmNo").onclick = () => { modalDiv.remove(); isInteractionActive = false; if(onCancel) onCancel(); };
}

function showItemComparisonModal(newItem, oldItem, onConfirm, onCancel) {
    isInteractionActive = true;
    const existingModal = document.getElementById("comparisonModal");
    if (existingModal) existingModal.remove();

    const modalDiv = document.createElement("div");
    modalDiv.id = "comparisonModal";
    
    const renderItem = (item, type) => {
        let statsHtml = '';
        const stats = ['attack', 'defense', 'insulation', 'weight', 'volume'];
        const otherItem = type === 'new' ? oldItem : newItem;

        stats.forEach(stat => {
            const val = item[stat] === undefined ? '-' : item[stat];
            const otherVal = otherItem[stat] === undefined ? '-' : otherItem[stat];
            let statClass = 'stat-neutral';
            
            if(val !== '-' && otherVal !== '-') {
                let a = (stat === 'weight' || stat === 'volume') ? otherVal : val;
                let b = (stat === 'weight' || stat === 'volume') ? val : otherVal;
                if (a > b) statClass = 'stat-positive';
                if (a < b) statClass = 'stat-negative';
            }
            statsHtml += `<div class="${statClass}">${getString(`detail_label_${stat}`)}: ${val}</div>`;
        });
        const durability = item.durability !== undefined ? `<div>${getString("detail_label_durability")}: ${item.durability.toFixed(0)}%</div>` : '';
        const headerText = type === 'new' ? getString("compare_equip_new") : getString("compare_equip_current");

        return `<div class="comparison-item"><h4>${headerText}</h4><div class="comparison-item-graphic">${getIconHTML(item.graphic, 48)}</div><div class="comparison-item-name">${getItemDisplayName(item)}</div><div class="comparison-stats">${statsHtml}${durability}</div></div>`;
    };

    modalDiv.innerHTML = `<h3>${getString("compare_equip_title")}</h3><div class="comparison-container">${renderItem(newItem, 'new')}${renderItem(oldItem, 'old')}</div><div class="comparison-actions"><button id="confirmSwapBtn">${getString("btn_yes")}</button><button id="cancelSwapBtn">${getString("btn_no")}</button></div>`;

    document.body.appendChild(modalDiv);
    document.getElementById("confirmSwapBtn").onclick = () => { modalDiv.remove(); isInteractionActive = false; if (onConfirm) onConfirm(); };
    document.getElementById("cancelSwapBtn").onclick = () => { modalDiv.remove(); isInteractionActive = false; if (onCancel) onCancel(); };
}


function generateBackstory() {
  const { fullNameKey, age, gender, job, race, traits } = character;
  const translatedFullName = getString(fullNameKey);
  let story = getString("backstory_intro", {
    fullName: translatedFullName,
    age: age,
    gender: getString(gender)
  });

  story += " " + getString(`backstory_${job}`);
  story += " " + getString(`backstory_${race}`);

  if (traits.length > 0) {
    story += " " + getString("backstory_traits_intro");
    traits.forEach((trait, index) => {
      story += getString(`trait_${trait}_name`);
      if (index < traits.length - 1) {
        story += getString("backstory_traits_separator");
      }
    });
    story += "。";
  }
  story += " " + getString("backstory_outro");
  return story;
}

function generateInitialCorpses() {
    const numCorpses = Math.floor(mapSize * mapSize * 0.015);
    
    for (let i = 0; i < numCorpses; i++) {
        let x, y, locationKey;
        do {
            x = Math.floor(Math.random() * mapSize);
            y = Math.floor(Math.random() * mapSize);
            locationKey = `${x},${y}`;
        } while ((x === player.x && y === player.y) || placedObjects.some(p => p.x === x && p.y === y));

        const isHuman = Math.random() < 0.5;

        if (isHuman) {
            let corpseLoot = [];
            const numItems = Math.floor(Math.random() * 3) + 1;
            const lootableItems = items.filter(item => !item.tags || (!item.tags.includes(NO_LOOT_TAG) && !item.tags.includes(HANDMADE_TAG)));
            for (let j = 0; j < numItems; j++) {
                if (lootableItems.length === 0) break;
                let newItem = JSON.parse(JSON.stringify(randChoice(lootableItems)));
                if (newItem.freshness !== undefined) newItem.freshness = Math.floor(Math.random() * 40);
                if (newItem.durability !== undefined) newItem.durability = Math.floor(Math.random() * 50) + 10;
                corpseLoot.push(newItem);
            }

            if (corpseLoot.length > 0) {
                const corpse = {
                    x: x, y: y, type: 'corpse', name: '古い死体', graphic: 'images/corpse_bones.png',
                    duration: Math.floor(Math.random() * 24) + 24,
                    isHumanCorpse: true, unsearched: true, potentialLoot: corpseLoot
                };
                placedObjects.push(corpse);
            }
        } else { // Animal corpse
            const corpse = {
                x: x, y: y, type: 'corpse', name: '動物の死骸', graphic: 'images/corpse_bones.png',
                duration: Math.floor(Math.random() * 24) + 48,
                isAnimalCorpse: true, unbutchered: true,
                potentialLoot: { 
                    meat: Math.floor(Math.random() * 3) + 1, 
                    fur: Math.floor(Math.random() * 2)
                }
            };
            placedObjects.push(corpse);
        }
    }
}
// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
async function loadLanguage(lang) {
    try {
        // main.jsに言語ファイルの読み込みを依頼する
        const loadedStrings = await ipcRenderer.invoke('load-language-file', lang);

        if (loadedStrings) {
            stringTable = loadedStrings;
            currentLanguage = lang;
            console.log(`${lang.toUpperCase()} の言語ファイルを適用しました。`);
            applyTranslations(); // 読み込んだテキストを画面に適用
        } else {
            // ファイルの読み込みに失敗した場合
            throw new Error(`ipcRendererからnullが返されました。`);
        }

    } catch (error) {
        console.error(`言語ファイル(${lang}.json)の処理中にエラーが発生しました:`, error);
        // 失敗した場合、安全のために日本語を再読み込み
        if (lang !== 'ja') {
            await loadLanguage(currentLanguage);
        }
    }
}
// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
/**
 * キーに対応する翻訳文字列を取得し、プレースホルダーを置換する
 * @param {string} key - 翻訳キー
 * @param {object} [replacements={}] - 置換する値のオブジェクト (例: { itemName: '石' })
 * @returns {string} - 翻訳・置換された文字列
 */
function getString(key, replacements = {}) {
    let text = (stringTable && stringTable[key]) ? stringTable[key] : key;
    if (text === key) {
        console.warn(`Translation key not found: ${key}`);
    }
    // 渡されたオブジェクトのキーを使って、{key} 形式のプレースホルダーを全て置換する
    for (const placeholder in replacements) {
        text = text.replace(new RegExp(`{${placeholder}}`, 'g'), replacements[placeholder]);
    }
    return text;
}
function applyTranslations() {
    if (!stringTable || Object.keys(stringTable).length === 0) {
        console.log("翻訳データがまだ読み込まれていません。");
        return;
    }

    // data-translate-key属性を持つ全てのHTML要素を取得して、テキストを置き換える
    document.querySelectorAll('[data-translate-key]').forEach(element => {
        const key = element.getAttribute('data-translate-key');
        if (stringTable[key]) {
            element.textContent = stringTable[key];
        }
    });

    // 言語切り替えボタンのスタイルを更新
    if (document.getElementById('langBtnJa')) {
        // 全てのボタンから一旦activeクラスを削除
        document.getElementById('langBtnJa').classList.remove('active');
        document.getElementById('langBtnEn').classList.remove('active');
        document.getElementById('langBtnZh').classList.remove('active');

        // 現在の言語に対応するボタンにactiveクラスを追加
        if (currentLanguage === 'ja') {
            document.getElementById('langBtnJa').classList.add('active');
        } else if (currentLanguage === 'zh-CN') {
            document.getElementById('langBtnZh').classList.add('active');
        } else { // デフォルトは英語
            document.getElementById('langBtnEn').classList.add('active');
        }
    }
    
if (map && map.length > 0) {
    updateCharacterInfo();
    updateItemPanels();
    updateCurrentLocationPanel(false);
    updateStatus(); // ← ステータスパネル全体を更新するためにこの行を追加
    updateTurnInfo(); // ← 時間情報とマップヘッダーを更新するためにこの行を追加
}
    // ▲▲▲ 修正ここまで ▲▲▲

    console.log("翻訳を適用しました。");
}

// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function genMap() {
    generateRandomCharacter();
    calculateMaxStats();
    map = []; entities = []; placedObjects = [];

    let biomeMap = Array(mapSize).fill(null).map(() => Array(mapSize).fill('Plains'));
    let allTownClusters = [];

    const numTowns = Math.floor(Math.random() * 3) + 2;
    const MIN_DISTANCE_BETWEEN_TOWNS = 20;

    for (let i = 0; i < numTowns; i++) {
        const currentCluster = [];
        const clusterSize = Math.floor(Math.random() * 6) + 5;
        let startX, startY, attempts = 0;
        do {
            startX = Math.floor(Math.random() * (mapSize - 10)) + 5;
            startY = Math.floor(Math.random() * (mapSize - 10)) + 5;
            attempts++;
            if(attempts > 100) break;
        } while (allTownClusters.flat().some(tile => getDistance(startX, startY, tile.x, tile.y) < MIN_DISTANCE_BETWEEN_TOWNS));
        
        biomeMap[startY][startX] = 'Town';
        currentCluster.push({ x: startX, y: startY });

        for (let j = 1; j < clusterSize; j++) {
            const lastTile = randChoice(currentCluster);
            const directions = [{dx:0, dy:1}, {dx:0, dy:-1}, {dx:1, dy:0}, {dx:-1, dy:0}];
            let placed = false;
            for(let k=0; k<4; k++) {
                const dir = randChoice(directions);
                directions.splice(directions.indexOf(dir), 1);
                const nextX = lastTile.x + dir.dx;
                const nextY = lastTile.y + dir.dy;
                if (nextX > 0 && nextX < mapSize - 1 && nextY > 0 && nextY < mapSize - 1 && biomeMap[nextY][nextX] === 'Plains') {
                    biomeMap[nextY][nextX] = 'Town';
                    currentCluster.push({ x: nextX, y: nextY });
                    placed = true;
                    break;
                }
            }
        }
        allTownClusters.push(currentCluster);
    }
    
    const numForests = Math.floor(mapSize / 15);
    const forestRadius = Math.floor(mapSize / 10);
    for(let i = 0; i < numForests; i++) {
        const forestX = Math.floor(Math.random() * mapSize), forestY = Math.floor(Math.random() * mapSize);
        for(let y = 0; y < mapSize; y++) for(let x = 0; x < mapSize; x++) if (Math.sqrt(Math.pow(x-forestX, 2) + Math.pow(y-forestY, 2)) < forestRadius * (1 + (Math.random() - 0.5) * 0.5) && biomeMap[y][x] === 'Plains') biomeMap[y][x] = 'Forest';
    }

    const townCenters = allTownClusters.map(cluster => {
        const sum = cluster.reduce((acc, tile) => ({ x: acc.x + tile.x, y: acc.y + tile.y }), { x: 0, y: 0 });
        return { x: Math.round(sum.x / cluster.length), y: Math.round(sum.y / cluster.length) };
    });

    for(let i = 0; i < townCenters.length - 1; i++) {
        let start = townCenters[i], end = townCenters[i+1], current = {...start};
        while(current.x !== end.x || current.y !== end.y) {
            if(Math.abs(end.x - current.x) > Math.abs(end.y - current.y)) current.x += Math.sign(end.x - current.x); else current.y += Math.sign(end.y - current.y);
            if(biomeMap[current.y][current.x] !== 'Town') biomeMap[current.y][current.x] = 'Road';
        }
    }

    let cabinCoords = []; 
    const MIN_CABIN_DISTANCE = 6; 

    for(let y=0; y<mapSize; y++) {
        const row = [];
        for(let x=0; x<mapSize; x++) {
            const biome = biomeMap[y][x];
            let loc;
            
            if (biome === 'Town') {
                loc = randChoice(biomeLocations.Town);
            } else if (biome === 'Forest') {
                const isTooCloseToCabin = cabinCoords.some(coord => getDistance(x, y, coord.x, coord.y) < MIN_CABIN_DISTANCE);
                if (isTooCloseToCabin) {
                    const nonCabinForestLocations = biomeLocations.Forest.filter(l => l.nameKey !== "location_cabin");
                    loc = randChoice(nonCabinForestLocations);
                } else {
                    loc = randChoice(biomeLocations.Forest);
                    if (loc.nameKey === "location_cabin") {
                        cabinCoords.push({x: x, y: y});
                    }
                }
            } else {
                loc = (biome === 'Road') ? randChoice(biomeLocations.Road) : randChoice(biomeLocations.Plains);
            }

            const tileData = { loc: {...loc}, explored: false, biome: biome, searched: false };
            if (tileData.loc.nameKey === 'location_forest') {
                tileData.logSupply = Math.floor(Math.random() * 3) + 1;
            }
            row.push(tileData);
        }
        map.push(row);
    }
    
    allTownClusters.forEach(cluster => {
        if (Math.random() < 0.5) {
            const shopTileCoords = randChoice(cluster);
            map[shopTileCoords.y][shopTileCoords.x].loc = biomeLocations.TraderShop;
        }
    });
    player.x = Math.floor(Math.random() * mapSize); player.y = Math.floor(Math.random() * mapSize);
    
    droppedItems = {};
    generateInitialCorpses(); 
    
    let scX, scY;
    do { 
        scX = Math.floor(Math.random() * mapSize); 
        scY = Math.floor(Math.random() * mapSize);
    } while (map[scY][scX].biome === 'Town' || Math.sqrt(Math.pow(scX - player.x, 2) + Math.pow(scY - player.y, 2)) <= 20 || placedObjects.some(p => p.x === scX && p.y === scY));

    salvationCityCoords = { x: scX, y: scY };
    map[scY][scX] = { loc: salvationCityLocation, explored: false, biome: 'Plains', searched: false };
    salvationCityDiscovered = false;

    const numEntities = mapSize * mapSize * 0.05;
    for (let i = 0; i < numEntities; i++) {
        let x, y;
        do {
            x = Math.floor(Math.random() * mapSize);
            y = Math.floor(Math.random() * mapSize);
        } while (
            Math.max(Math.abs(x - player.x), Math.abs(y - player.y)) <= 2 ||
            entities.some(e => e.x === x && e.y === y) ||
            placedObjects.some(p => p.x === x && p.y === y)
        );
        
        const biome = map[y][x].biome;
        const entityTypeRoll = Math.random();
        
        let health = 50 + Math.floor(Math.random() * 30);
        if (biome === 'Town') {
            if (entityTypeRoll < 0.7) { 
                entities.push({ type: 'Zombie', name: 'ゾンビ', icon: 'images/zombie.png', x, y, health: health, maxHealth: health, attack: 8 + Math.floor(Math.random() * 8), defense: 2, visionRange: 3, isZombie: true, stunnedTurns: 0, aiState: 'wandering', target: null, investigationTarget: null });
            } else {
                const npc = generateNPC(); npc.x = x; npc.y = y; npc.stunnedTurns = 0;
                npc.aiState = 'wandering'; npc.target = null; npc.investigationTarget = null;
                entities.push(npc);
            }
        } else {
            if (entityTypeRoll < 0.25) {
                entities.push({ type: 'Zombie', name: 'ゾンビ', icon: 'images/zombie.png', x, y, health: health, maxHealth: health, attack: 8 + Math.floor(Math.random() * 8), defense: 2, visionRange: 3, isZombie: true, stunnedTurns: 0, aiState: 'wandering', target: null, investigationTarget: null });
            } else if (entityTypeRoll < 0.65) {
                const possibleWildlife = wildlifeTemplates.filter(w => w.biomes.includes(biome));
                if (possibleWildlife.length > 0) {
                    const newWildlife = { ...JSON.parse(JSON.stringify(randChoice(possibleWildlife))), x, y, stunnedTurns: 0, aiState: 'wandering', target: null, investigationTarget: null };
                    entities.push(newWildlife);
                }
            } else {
                const npc = generateNPC(); npc.x = x; npc.y = y; npc.stunnedTurns = 0;
                npc.aiState = 'wandering'; npc.target = null; npc.investigationTarget = null;
                entities.push(npc);
            }
        }
    }

    ensureKnowledgeableTrader();
    

    turn = 0;
    currentSeason = randChoice(seasons);
    currentTime = new Date();
    currentTime.setFullYear(2025);
    switch (currentSeason) {
        case '春': currentTime.setMonth(2, 21); break;
        case '夏': currentTime.setMonth(5, 21); break;
        case '秋': currentTime.setMonth(8, 22); break;
        case '冬': currentTime.setMonth(11, 21); break;
    }
    currentTime.setHours(8, 0, 0, 0);
    isNight = false;

    const weatherOptions = [ { name: "快晴", icon: "☀️", chance: 50, tempMod: 2 }, { name: "曇り", icon: "☁️", chance: 25, tempMod: 0 }, { name: "雨", icon: "🌧️", chance: 15, tempMod: -3 }, { name: "嵐", icon: "⛈️", chance: 10, tempMod: -5 } ];
    let totalChance = weatherOptions.reduce((sum, w) => sum + w.chance, 0), randomValue = Math.random() * totalChance, accumulatedChance = 0;
    for (const weather of weatherOptions) {
        accumulatedChance += weather.chance;
        if (randomValue <= accumulatedChance) {
            currentWeather = weather;
            break;
        }
    }
    
    player.hunger = Math.floor(maxStats.hunger * (0.6 + Math.random() * 0.3));
    player.thirst = Math.floor(maxStats.thirst * (0.7 + Math.random() * 0.2));
    player.health = Math.floor(maxStats.health * (0.8 + Math.random() * 0.15));
    player.morale = Math.floor(maxStats.morale * (0.4 + Math.random() * 0.4));
    player.sleep = Math.floor(maxStats.sleep * (0.5 + Math.random() * 0.3));
    player.bodyTemp = 36.5 + (Math.random() * 0.4 - 0.2);
    player.bodyOdor = 0;
    player.weight = 0;
    player.maxWeight = maxStats.maxWeight;
    player.volume = 0;
    player.maxVolume = maxStats.maxVolume;
    player.vision = maxStats.vision || 2;
    player.inventory = []; player.equipment = []; player.injuries = []; player.sicknesses = [];
    player.baseAttack = 10; player.baseDefense = 5; player.attack = 10; defense: 5;

    const startingItemPool = jobStartingPools[character.job];
    if (startingItemPool) {
        const itemName = randChoice(startingItemPool);
        const itemTemplate = items.find(i => i.name === itemName);
        if (itemTemplate) {
            const newItem = JSON.parse(JSON.stringify(itemTemplate));
            if (newItem.type === 'container') {
                newItem.content = null;
            }
            player.inventory.push(newItem);
        }
    }
    updateEquippedStats();
    updateExploration();
}
/**
 * [デバッグ用] 視界範囲を計算し、その過程をコンソールに出力する関数
 * @returns {number} - 最終的な視界範囲
 */
function getVisionRange() {
    // --- 計算開始の合図 ---
    console.log("--- 視界計算開始 (ターン: " + turn + ") ---");

    if (player.isInside) {
        console.log("状態: 小屋の中です。");
        console.log("最終的な視界: 0");
        console.log("---------------------------------");
        return 0;
    }

    // --- ステップ1: キャラクターの基本視界 ---
    // 職業、年齢、特性によって決まるキャラクターの素の視界値です。
    let finalVision = player.vision;
    console.log(`1. 基本視界 (player.vision): ${finalVision}`);

    // --- ステップ2: 装備や特性による補正 ---
    if (character.traits.includes("bad_eyesight")) {
        console.log(" - 特性「目が悪い」を検出しました。");
    }
    if (character.traits.includes("good_eyesight")) {
        console.log(" - 特性「目がいい」を検出しました。");
    }
    if (character.traits.includes("目が悪い") && player.equipment.some(e => e.name === 'メガネ')) {
        finalVision++;
        console.log(`2. メガネ着用により補正 → ${finalVision}`);
    }

    // --- ステップ3: 時間帯による補正 ---
    const hasTorch = player.equipment.some(e => e.isTorch);
    if (!currentTime) {
        console.error("!!! [バグの可能性] currentTimeが未定義です。");
        return 0;
    }
    const hour = currentTime.getHours();
    const isEvening = hour >= 18 && hour < 21;
    const isDeepNight = hour >= 21 || hour < 6;

    console.log(`3. 時間帯: 現在時刻=${hour}時, 松明=${hasTorch}, 夕方=${isEvening}, 深夜=${isDeepNight}`);

    if (isEvening) {
        finalVision = Math.max(1, finalVision - 3);
        console.log(` - 夕方のため視界が減少 → ${finalVision}`);
    } else if (isDeepNight) {
        let nightVision = 0;
        if (hasTorch) nightVision = Math.max(nightVision, 1);
        // BUGFIX: 正しい特性ID "good_eyesight" を参照するように修正
        if (character.traits.includes("good_eyesight")) nightVision = Math.max(nightVision, 1);
        finalVision = nightVision;
        console.log(` - 深夜のため視界が${nightVision}に固定 → ${finalVision}`);
    }

    // --- ステップ4: 天候による補正 ---
    if (!currentWeather || !currentWeather.name) {
        console.error("!!! [バグの可能性] currentWeatherが未定義です。");
        return 0;
    }
    console.log(`4. 天候: ${currentWeather.name}`);
    if (currentWeather.name === '雨') {
        let before = finalVision;
        finalVision *= 0.75;
        console.log(` - 雨のため視界が75%に減少: ${before.toFixed(2)} → ${finalVision.toFixed(2)}`);
    }
    if (currentWeather.name === '嵐') {
        let before = finalVision;
        finalVision *= 0.5;
        console.log(` - 嵐のため視界が50%に減少: ${before.toFixed(2)} → ${finalVision.toFixed(2)}`);
    }

    // --- ステップ5: 最終計算 ---
    const roundedVision = Math.round(finalVision);
    const finalResult = Math.max(0, roundedVision);
    console.log(`5. 最終計算: ${finalVision.toFixed(2)} (四捨五入)→ ${roundedVision} (マイナスなら0に)→ ${finalResult}`);
    console.log(`>>> 最終的な視界: ${finalResult}`);
    console.log("---------------------------------");

    return finalResult;
}

function getEntityVisionRange(entity) {
    let baseVision;
    const hour = currentTime.getHours();

    const isEvening = hour >= 18 && hour < 21;
    const isDeepNight = hour >= 21 || hour < 6;
    const isMorning = hour >= 6 && hour < 8;
    const isDay = hour >= 8 && hour < 18;

    // プレイヤーのその時間帯での基本視野をまず計算
    let playerCurrentVision;
    const hasTorch = player.equipment.some(e => e.isTorch);
    if (isMorning) {
        playerCurrentVision = 3;
    } else if (isDay) {
        playerCurrentVision = 3;
    } else if (isEvening) {
        playerCurrentVision = 1;
    } else { // isDeepNight
        playerCurrentVision = 0;
        if (hasTorch) playerCurrentVision = 1;
        if (character.traits.includes("目がいい")) playerCurrentVision = Math.max(playerCurrentVision, 1);
    }
    
    if (entity.isAnimal) {
        // 野生動物は常にプレイヤーの視界+1
        baseVision = playerCurrentVision + 1;
    } else { 
        // NPCとゾンビはプレイヤーの視界と同じ
        baseVision = playerCurrentVision;
        if (isDeepNight) {
            const hasGoodEyesight = entity.traits && entity.traits.includes("目がいい");
            if (hasGoodEyesight) {
                baseVision = Math.max(baseVision, 1);
            }
        }
    }
    
    if (currentWeather.name === '雨') baseVision *= 0.75;
    if (currentWeather.name === '嵐') baseVision *= 0.5;

    return Math.max(0, Math.round(baseVision));
}


function updateExploration() {
    const visionRange = getVisionRange();
    for (let y = Math.max(0, player.y - visionRange); y <= Math.min(mapSize - 1, player.y + visionRange); y++) {
        for (let x = Math.max(0, player.x - visionRange); x <= Math.min(mapSize - 1, player.x + visionRange); x++) {
            const distance = Math.sqrt(Math.pow(player.x - x, 2) + Math.pow(player.y - y, 2));
            if (distance <= visionRange) {
                if (hasLineOfSight(player.x, player.y, x, y) && !map[y][x].explored) {
                    map[y][x].explored = true;
                    if(x === salvationCityCoords.x && y === salvationCityCoords.y && !salvationCityDiscovered) {
                        salvationCityDiscovered = true; playSound('victory'); log(getString("log_salvation_city_discovered"));
                    }
                }
            }
        }
    }
    if (isNight) {
        const campfire = placedObjects.find(obj => obj.type === 'campfire' && Math.abs(player.x - obj.x) <= 1 && Math.abs(player.y - obj.y) <= 1);
        if (campfire) {
            for (let y = Math.max(0, campfire.y - 1); y <= Math.min(mapSize - 1, campfire.y + 1); y++) {
                for (let x = Math.max(0, campfire.x - 1); x <= Math.min(mapSize - 1, campfire.x + 1); x++) {
                    map[y][x].explored = true;
                }
            }
        }
    }
}

function triggerRandomEvent() {
    const movementMode = player.movementMode;

    if (movementMode === 'run') {
        // 走行時: 25%の確率でイベント発生
        if (Math.random() < 0.05) {
            // さらに、その中で25%がアイテム紛失、75%が装備破損
            if (Math.random() < 0.25) {
                event_loseItem(); // アイテムを落とすイベント
            } else {
                event_damageEquipment(); // アイテムの耐久値が下がるイベント
            }
        }
    } else if (movementMode === 'walk') {
        // 歩行時: 3%の確率で装備破損イベントのみ発生
        if (Math.random() < 0.01) {
            event_damageEquipment();
        }
    }
    // その他の移動モードではイベントは発生しない
}

function event_loseItem() {
    // 所持品がない場合は何もしない
    if (player.inventory.length === 0) {
        return;
    }
    // 所持品の中からランダムなインデックスを選ぶ
    const itemIndex = Math.floor(Math.random() * player.inventory.length);
    const lostItem = player.inventory[itemIndex];

    // 選ばれたアイテムを所持品から削除
    player.inventory.splice(itemIndex, 1);

    // プレイヤーの重量と容量を更新
    player.weight -= lostItem.weight || 0;
    player.volume -= lostItem.volume || 0;

    const eventMessage = `移動中に何かを落としてしまったようだ...！<span style="color: indianred;">（${getItemDisplayName(lostItem)}を紛失）</span>`;
    log(eventMessage, true);
    showModal(eventMessage); // Pop-up is displayed
    updateItemPanels();
    updateStatus();
}
// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function event_damageEquipment() {
    // 装備品と所持品の中から、耐久度を持つアイテムをすべてリストアップ
    const damageableItems = [...player.equipment, ...player.inventory].filter(item => 
        item.durability !== undefined && 
        (item.type === 'clothing' || item.type === 'equipment') &&
        item.slot !== 'weapon'
    );
    
    // 対象アイテムがない場合は何もしない
    if (damageableItems.length === 0) {
        return;
    }

    // 対象アイテムの中からランダムに1つ選ぶ
    const targetItem = randChoice(damageableItems);
    const damageAmount = Math.floor(Math.random() * 30) + 20; // 20から49のダメージ
    const originalDurability = targetItem.durability;
    
    targetItem.durability -= damageAmount;

    let eventMessage;
    // ▼▼▼ ここからが修正箇所です ▼▼▼
    if (targetItem.durability <= 0) {
        targetItem.durability = 0;
        eventMessage = getString("log_event_equip_damage_break", { itemName: getItemDisplayName(targetItem) });
    } else {
        eventMessage = getString("log_event_equip_damage_minor", { itemName: getItemDisplayName(targetItem) });
    }
    // ▲▲▲ 修正ここまで ▲▲▲

    log(eventMessage, true);
    showModal(eventMessage); // Pop-up is displayed
    updateItemPanels();
    updateEquippedStats();
    updateStatus();
}

// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function handleTileClick(targetX, targetY) {
    closeWorkbenchPanel();
    if (isInteractionActive || targetingState.active) {
        if (targetingState.active) handleTargetingClick(targetX, targetY);
        return;
    }
    const barricade = placedObjects.find(o => o.x === targetX && o.y === targetY && o.type === 'barricade' && o.health > 0);
    if (barricade) {
        log(getString("log_barricade_blocks"));
        return;
    }
    const dx = Math.abs(player.x - targetX), dy = Math.abs(player.y - targetY), dist = Math.max(dx, dy);
    if (dist === 0) {
        const placedObject = placedObjects.find(p => p.x === player.x && p.y === player.y);
        if (placedObject) {
            if (placedObject.type === 'wooden_box') openStoragePanel(placedObject);
            else showPlacedObjectDetail(placedObject);
        } else {
            speakAndConfirm(getString("confirm_wait_turn"), waitOneTurn);
        }
        return;
    }
    if (player.movementMode === 'run') {
        const isStraightLineRun = (dx === 2 && dy === 0) || (dx === 0 && dy === 2) || (dx === 2 && dy === 2);
        if (!isStraightLineRun) {
            log(getString("log_run_mode_error"));
            return;
        }
        
        const midX = player.x + Math.sign(targetX - player.x);
        const midY = player.y + Math.sign(targetY - player.y);
        const blockingEntity = entities.find(e => e.x === midX && e.y === midY);

        if (blockingEntity) {
            const entityName = getString(`item_${blockingEntity.name}_name`) || blockingEntity.name;
            log(getString("log_run_blocked_by_entity", { entityName: entityName }));
            return;
        }

        // ▼▼▼ ここからが修正箇所です ▼▼▼
        // 走行アニメーション
        isInteractionActive = true; // アニメーション中は他の操作を禁止
        
        // 1マス目の移動
        player.x = midX;
        player.y = midY;
        drawMap();
        
        setTimeout(() => {
            // 2マス目の移動
            player.x = targetX;
            player.y = targetY;
            drawMap();

            // 移動後の通常処理
            isInteractionActive = false; // 操作禁止を解除
            snapshotStats();
            player.isInside = false;
            player.hunger -= 2;
            player.thirst -= 4;
            createSound(targetX, targetY, 8);
            log(getString("log_moved_run"));

            if (player.x === salvationCityCoords.x && player.y === salvationCityCoords.y) {
                triggerGameClear();
                return;
            }
            exploreTile();
            triggerRandomEvent();
            advanceTurn();
            updateTurnInfo();
            drawMinimap();
            updateStatus();
            updateItemPanels();
            updateCharacterBody();
            updateCharacterInfo();
            checkGameOver();
        }, 150); // 0.15秒後に2マス目に移動（アニメーション速度）
        return; // 通常の移動処理は行わない
        // ▲▲▲ 修正ここまで ▲▲▲

    } else { //歩行モード
        if (dist !== 1) {
            log(getString("log_walk_mode_error"));
            return;
        }
    }
    snapshotStats();
    player.isInside = false;
    player.x = targetX;
    player.y = targetY;
    updateExploration();
    createSound(targetX, targetY, 2);
    
    if (player.x === salvationCityCoords.x && player.y === salvationCityCoords.y) {
        triggerGameClear();
        return;
    }
    exploreTile();
    triggerRandomEvent();
    advanceTurn();
    updateTurnInfo();
    drawMap();
    drawMinimap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    checkGameOver();
}
// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function drawMap() {
    if (!map || map.length === 0 || !player) return;
    
    mapIconIntervals.forEach(clearInterval);
    mapIconIntervals = [];

    const mapDiv = document.getElementById("map");
    mapDiv.style.gridTemplateColumns = `repeat(${viewportSize}, 40px)`;
    mapDiv.innerHTML = "";
    const halfView = Math.floor(viewportSize / 2),
        startX = player.x - halfView,
        startY = player.y - halfView;
        
    for (let yOffset = 0; yOffset < viewportSize; yOffset++) {
        for (let xOffset = 0; xOffset < viewportSize; xOffset++) {
            const x = startX + xOffset,
                y = startY + yOffset;
            let div = document.createElement("div");
            div.className = "tile";
            
            if (x < 0 || y < 0 || x >= mapSize || y >= mapSize) {
                div.classList.add("unexplored");
                div.style.background = "#111";
                mapDiv.appendChild(div);
                continue;
            }
            
            const tile = map[y][x];

            if (targetingState.active && getDistance(player.x, player.y, x, y) <= targetingState.range) {
                if (hasLineOfSight(player.x, player.y, x, y)) {
                    div.classList.add("targeting");
                }
            }

            if (tile.explored) {
                const isInSight = getDistance(player.x, player.y, x, y) <= getVisionRange() && hasLineOfSight(player.x, player.y, x, y);

                if (isInSight) {
                    div.classList.add("explored");
                    if (tile.loc.nameKey === 'location_road') div.classList.add('road-tile');
                    
                    const entityOnTile = entities.find(e => e.x === x && e.y === y);
                    const placedObjectsOnTile = placedObjects.filter(c => c.x === x && c.y === y);
                    const isPlayerOnTile = (player.x === x && player.y === y);

                    // ▼▼▼ ここからが新しい描画ロジックです ▼▼▼
                    div.innerHTML = ''; // タイルの中身を一度リセット
                    const htmlElements = [];

                    // レイヤー1: 地形
                    htmlElements.push(`<img src="${tile.loc.icon}" class="tile-img tile-terrain" style="width:40px; height:40px;">`);

                    // レイヤー2: プレイヤー
                    if (isPlayerOnTile) {
                        const playerIconPath = (character.gender === "男性") ? "images/player_male.png" : "images/player_female.png";
                        htmlElements.push(`<img src="${playerIconPath}" class="tile-img tile-player" style="width:40px; height:40px;">`);
                        div.classList.add("player-tile");
                    }

                    // レイヤー3: 敵、NPC、動物
                    if (entityOnTile) {
                        htmlElements.push(`<img src="${entityOnTile.icon}" class="tile-img tile-entity" style="width:40px; height:40px;">`);
                    }
                    
                    // レイヤー3: 設置物（たき火などを優先表示）
// レイヤー3: 設置物（たき火などを優先表示）
const campfire = placedObjectsOnTile.find(p => p.type === 'campfire' || p.type === 'unlit_campfire');
const mostImportantObject = campfire || placedObjectsOnTile[0];
if (mostImportantObject) {
    let objectStyle = 'width:40px; height:40px;';
    if(mostImportantObject.type === 'unlit_campfire') objectStyle += 'filter: grayscale(1); opacity: 0.8;';
    htmlElements.push(`<img src="${mostImportantObject.graphic}" class="tile-img tile-object" style="${objectStyle}">`);
}

                    div.innerHTML = htmlElements.join('');
                    // ▲▲▲ 描画ロジックここまで ▲▲▲

                    const showCombinedTooltip = (e) => {
                        const preview = document.getElementById("statusPreview");
                        let contentHtml = '';

                        contentHtml += `<strong>${getString(tile.loc.nameKey)}</strong>`;
                        if (tile.loc.blocksVision) {
                            contentHtml += `<div style="color: indianred; font-size: 0.9em;">(${getString("info_blocks_vision")})</div>`;
                        }

                        if (entityOnTile) {
                            const entityName = getString(`item_${entityOnTile.name}_name`) || entityOnTile.name;
                            contentHtml += `<div style='border-top: 1px solid #555; margin-top:5px; padding-top:5px;'><strong>${entityName}</strong><br/>${getString("tooltip_entity_health")}: ${entityOnTile.health.toFixed(0)}`;
                            
                            let awarenessText = '';
                            let awarenessColor = '';
                            switch (entityOnTile.aiState) {
                                case 'attacking':
                                    if (entityOnTile.target === player) {
                                        awarenessText = getString("tooltip_awareness_hostile");
                                        awarenessColor = '#e74c3c';
                                    } else {
                                        awarenessText = getString("tooltip_awareness_unaware");
                                        awarenessColor = '#95a5a6';
                                    }
                                    break;
                                case 'investigating':
                                    awarenessText = getString("tooltip_awareness_investigating");
                                    awarenessColor = '#f1c40f';
                                    break;
                                case 'fleeing':
                                    awarenessText = getString("tooltip_awareness_fleeing");
                                    awarenessColor = '#3498db';
                                    break;
                                default:
                                    awarenessText = getString("tooltip_awareness_unaware");
                                    awarenessColor = '#27ae60';
                                    break;
                            }
                            contentHtml += `<br/>${getString("tooltip_awareness_label")}: <span style="color: ${awarenessColor}; font-weight: bold;">${awarenessText}</span>`;
                            
                            if (!entityOnTile.isZombie && !entityOnTile.isAnimal && entityOnTile.equipment && entityOnTile.equipment.length > 0) {
                                contentHtml += `<br/>${getString("combat_equipment")}: `;
                                const equipmentNames = entityOnTile.equipment.map(eq => `${getIconHTML(eq.graphic, 12)} ${getBaseItemName(eq)}`).join(', ');
                                contentHtml += equipmentNames;
                            }
                            contentHtml += `</div>`;
                        }

                        placedObjectsOnTile.forEach(pObj => {
    const objectName = getPlacedObjectDisplayName(pObj);
    contentHtml += `<div style='border-top: 1px solid #555; margin-top:5px; padding-top:5px;'><strong>${objectName}</strong>`;
                            if (pObj.type === 'barricade') {
                                 contentHtml += `<br/>${getString("combat_health")}: ${pObj.health.toFixed(0)} / ${pObj.maxHealth.toFixed(0)}`;
                            } else if (pObj.isAnimalCorpse) {
                                contentHtml += `<br/>${pObj.unbutchered ? getString("tooltip_corpse_animal_unbutchered") : getString("tooltip_corpse_animal_butchered")}`;
                            } else if (pObj.isHumanCorpse) {
                                contentHtml += `<br/>${pObj.unsearched ? getString("tooltip_corpse_human_unsearched") : getString("tooltip_corpse_human_searched")}`;
                            }
                            contentHtml += `</div>`;
                        });

                        if (isPlayerOnTile) {
                            contentHtml += `<div style='border-top: 1px solid #555; margin-top:5px; padding-top:5px;'><strong>${getString("you")}</strong><br/>${getString(character.fullNameKey)}</div>`;
                        }
                        
                        preview.innerHTML = contentHtml;
                        preview.style.display = 'block';
                        updatePreviewPosition(e);
                    };

                    div.addEventListener('mouseenter', showCombinedTooltip);
                    div.addEventListener('mouseleave', hideStatusPreview);
                    div.addEventListener('mousemove', (e) => updatePreviewPosition(e));

                } else {
                    div.classList.add("memorized-tile");
                    div.innerHTML = getIconHTML(tile.loc.icon, 40);
                    div.title = `${getString(tile.loc.nameKey)} (${getString("info_memorized")})`;
                }

            } else {
                div.classList.add("unexplored");
                div.textContent = "?";
                div.title = getString("info_unexplored");
            }
            
            div.addEventListener("click", () => handleTileClick(x, y));
            mapDiv.appendChild(div);
        }
    }
}
function updatePlayerSmell() {
    let totalSmell = 0;

    // 1. 所持品による臭い
    const smellyItems = [...player.inventory, ...player.equipment].filter(item => item.smell);
    if (smellyItems.length > 0) {
        totalSmell += smellyItems.reduce((sum, item) => sum + item.smell, 0);
    }

    // 2. 状態による臭い（例：出血）
    if (player.injuries.some(i => i.type === 'bleeding')) {
        totalSmell += 15;
    }

    // 3. 体臭による臭い
    totalSmell += Math.floor(player.bodyOdor / 5);

    currentPlayerSmell = totalSmell;
}

// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function advanceTurn() {
    if (isLoading) return;
    turn++;
    previousSoundLevel = currentSoundLevel;
    previousPlayerSmell = currentPlayerSmell;
    currentSoundLevel = 0;
    currentTime.setHours(currentTime.getHours() + 1);
    const dayOfYear = Math.floor((turn / 24) % 360);
    const newSeason = seasons[Math.floor(dayOfYear / 90)];
    if (newSeason !== currentSeason) {
        currentSeason = newSeason;
        const translatedSeason = getString(`season_${currentSeason}`);
        log(getString("log_season_changed", { seasonName: translatedSeason }));
    }
    isNight = (currentTime.getHours() >= 18 || currentTime.getHours() < 6);
    const isRaining = currentWeather.name === '雨' || currentWeather.name === '嵐';
    if (!player.isInside) {
        player.equipment.forEach(item => {
            if (item.type === 'clothing') {
                if (currentWeather.name === '嵐') {
                    if (item.wetness !== 'soaking_wet') {
                        item.wetness = 'soaking_wet';
                        log(getString("log_wet_clothes_major", { itemName: getItemDisplayName(item) }));
                    }
                } else if (currentWeather.name === '雨') {
                    if (item.wetness === 'dry') {
                        item.wetness = 'wet';
                        log(getString("log_wet_clothes_minor", { itemName: getItemDisplayName(item) }));
                    } else if (item.wetness === 'wet') {
                        item.wetness = 'soaking_wet';
                        log(getString("log_wet_soaking", { itemName: getItemDisplayName(item) }));
                    }
                }
            }
        });
    }
    placedObjects = placedObjects.filter(obj => {
        if (obj.planted && !obj.isHarvestable) {
            obj.growth++;
            if (obj.growth >= obj.growthTime) {
                obj.isHarvestable = true;
                obj.name = `${obj.planted}(収穫可能)`;
                const cropTemplate = items.find(i => i.name === obj.planted);
                if (cropTemplate) obj.graphic = cropTemplate.graphic;
            }
        }
        if (obj.type === 'campfire' || obj.type === 'corpse') {
            if (obj.type === 'campfire' && isRaining) {
                if(Math.abs(player.x - obj.x) <= 1 && Math.abs(player.y - obj.y) <= 1) log(getString("log_campfire_extinguished_rain"));
                return false;
            }
            obj.duration--;
            if (obj.duration <= 0) {
                 if(obj.type === 'campfire' && player.x === obj.x && player.y === obj.y) log(getString("log_campfire_extinguished"));
                 return false;
            }
        }
        return true;
    });
    const torch = player.equipment.find(e => e.isTorch);
    if (torch) {
        torch.duration--;
        if (torch.duration <= 0) {
            log(getString("log_torch_extinguished"));
            const torchIndex = player.equipment.findIndex(e => e.isTorch);
            if(torchIndex > -1) {
                const removedItem = player.equipment.splice(torchIndex, 1)[0];
                player.weight -= removedItem.weight || 0;
                player.volume -= removedItem.volume || 0;
            }
            updateEquippedStats();
            updateItemPanels();
        }
    }
    ensureKnowledgeableTrader();
    updateEntities(); 
    checkStats();
    updatePlayerSmell(); 
    updateBackgroundColor();
    drawMinimap();
}

// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function updateEntities() {
    const activeEntities = [...entities];
    activeEntities.forEach(entity => {
        if (!entities.includes(entity) || isInteractionActive || entity.stunnedTurns > 0) {
            if (entity.stunnedTurns > 0) entity.stunnedTurns--;
            return;
        }

        if (entity.isZombie) {
            const moveChance = 0.8; 
            if (Math.random() > moveChance) {
                return;
            }
        }

        let visualTarget = null;
        let closestTargetDist = Infinity;
        const visionRange = getEntityVisionRange(entity);

        const distToPlayer = getDistance(entity.x, entity.y, player.x, player.y);
        if (distToPlayer <= visionRange && hasLineOfSight(entity.x, entity.y, player.x, player.y)) {
            visualTarget = player;
            closestTargetDist = distToPlayer;
        }

        activeEntities.forEach(otherEntity => {
            if (entity === otherEntity || otherEntity === player) return;
            const distToOther = getDistance(entity.x, entity.y, otherEntity.x, otherEntity.y);
            if (distToOther < closestTargetDist && distToOther <= visionRange) {
                let isHostile = false;
                if (entity.isZombie || entity.type === 'Raider' || (entity.isAnimal && !entity.flees)) {
                    if (!otherEntity.isZombie) isHostile = true;
                }
                if (isHostile && hasLineOfSight(entity.x, entity.y, otherEntity.x, otherEntity.y)) {
                    visualTarget = otherEntity;
                    closestTargetDist = distToOther;
                }
            }
        });

        if (visualTarget) {
            entity.target = visualTarget;
            entity.investigationTarget = null;
            if (entity.isZombie || entity.type === 'Raider' || (entity.isAnimal && !entity.flees)) {
                entity.aiState = 'attacking';
            } else if (entity.flees || entity.type === 'Survivor' || entity.type === 'Trader') {
                entity.aiState = 'fleeing';
                entity.fleeingTurns = 5;
            }
        } else {
            if (entity.fleeingTurns > 0) {
                entity.fleeingTurns--;
                entity.aiState = 'fleeing';
            } else {
                entity.target = null;
                if (entity.aiState === 'attacking' || entity.aiState === 'fleeing') {
                    entity.aiState = 'wandering';
                }
            }
            
            if (entity.aiState !== 'fleeing' && (entity.isZombie || (entity.isAnimal && !entity.flees)) && currentPlayerSmell > 0) {
                const smellDetectionChance = currentPlayerSmell / 50;
                const distanceToPlayer = getDistance(entity.x, entity.y, player.x, player.y);
                if (distanceToPlayer <= 10 && Math.random() < smellDetectionChance) {
                    entity.investigationTarget = { x: player.x, y: player.y };
                    entity.aiState = 'investigating';
                    if (getDistance(player.x, player.y, entity.x, entity.y) <= getVisionRange()) {
                        log(`${entity.name}が何かの臭いを嗅ぎつけたようだ...`);
                    }
                }
            }
        }

        switch (entity.aiState) {
            case 'attacking':
                if (entity.target && getDistance(entity.x, entity.y, entity.target.x, entity.target.y) <= 1) {
                    // ▼▼▼ このブロックを修正しました ▼▼▼
                    if (entity.target === player) {
                        // プレイヤーがターゲットの場合、直接 resolveEntityCombat を呼び出す
                        resolveEntityCombat(entity, player);
                    } else {
                        // プレイヤー以外がターゲットの場合
                        resolveEntityCombat(entity, entity.target);
                    }
                    // ▲▲▲ 修正ここまで ▲▲▲
                } else if (entity.target) {
                    moveEntityTowards(entity, entity.target.x, entity.target.y);
                }
                break;

            case 'fleeing':
                if (entity.target) {
                    moveEntityAwayFrom(entity, entity.target.x, entity.target.y);
                }
                break;

            case 'investigating':
                if (entity.investigationTarget && entity.x === entity.investigationTarget.x && entity.y === entity.investigationTarget.y) {
                    entity.aiState = 'wandering';
                    entity.investigationTarget = null;
                } else if (entity.investigationTarget) {
                    moveEntityTowards(entity, entity.investigationTarget.x, entity.investigationTarget.y);
                }
                break;

            case 'wandering':
            case 'alert':
                if (Math.random() < 0.3) {
                    let newX = entity.x + randChoice([-1, 0, 1]);
                    let newY = entity.y + randChoice([-1, 0, 1]);
                    moveEntityTo(entity, newX, newY);
                }
                break;
        }

        entity.x = Math.max(0, Math.min(mapSize - 1, entity.x));
        entity.y = Math.max(0, Math.min(mapSize - 1, entity.y));
    });
}

function resolveEntityAttackOnObject(attacker, object) {
    if (object.type !== 'barricade') return;
    const damage = Math.max(1, (attacker.attack || attacker.baseAttack || 5) + (Math.floor(Math.random() * 3) - 1));
    object.health -= damage;
    const distanceToPlayer = Math.abs(attacker.x - player.x) + Math.abs(attacker.y - player.y);
    if (distanceToPlayer <= getVisionRange()) {
        const attackerName = getString(`item_${attacker.name}_name`) || attacker.name;
        log(getString("log_barricade_attacked", { entityName: attackerName, health: object.health.toFixed(0) }));
    }
    if (object.health <= 0) {
        if (distanceToPlayer <= getVisionRange()) log(getString("log_barricade_destroyed"));
        const logItem = items.find(i => i.name === '丸太');
        if (logItem) {
            const locationKey = `${object.x},${object.y}`;
            if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
            droppedItems[locationKey].push({ ...logItem });
        }
        const objectIndex = placedObjects.findIndex(o => o === object);
        if (objectIndex > -1) placedObjects.splice(objectIndex, 1);
    }
}

// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function resolveEntityCombat(attacker, defender) {
    if (defender === player) {
        if (getDistance(attacker.x, attacker.y, player.x, player.y) <= 1) {
            // 1. 攻撃者をプレイヤーのマスに移動させる
            attacker.x = player.x;
            attacker.y = player.y;

            // 2. マップを再描画して、移動した様子をプレイヤーに見せる
            drawMap(); // ← この行が重要です

            // 3. 少し遅れてから戦闘を開始する
            setTimeout(() => {
                isInteractionActive = true;
                log(getString("log_npc_encounter", { npcName: getString(`item_${attacker.name}_name`) || attacker.name }));
                startCombat(attacker, false); // false: NPCが先制攻撃
            }, 500); // 0.5秒の遅延
        }
        return;
    }
    if(attacker === player) return;
    const attackerDamage = Math.max(1, (attacker.attack || attacker.baseAttack || 5) - (defender.defense || defender.baseDefense || 0) + (Math.floor(Math.random() * 5) - 2));
    defender.health -= attackerDamage;
    const distanceToPlayer = getDistance(attacker.x, attacker.y, player.x, player.y);
    if(distanceToPlayer <= getVisionRange()) {
         const attackerName = getString(`item_${attacker.name}_name`) || attacker.name;
         const defenderName = getString(`item_${defender.name}_name`) || defender.name;
         log(getString("log_entity_attacked", { attackerName: attackerName, defenderName: defenderName }));
    }
    if (defender.health <= 0) {
        const defenderName = getString(`item_${defender.name}_name`) || defender.name;
        if(distanceToPlayer <= getVisionRange()) log(getString("log_entity_defeated", { entityName: defenderName }));
        if (defender.isAnimal && defender.loot) {
            const corpse = { x: defender.x, y: defender.y, type: 'corpse', name: `${defender.name}の死体`, graphic: 'images/corpse_bones.png', duration: 48, isAnimalCorpse: true, unbutchered: true, potentialLoot: defender.loot };
            placedObjects.push(corpse);
        } else if (!defender.isZombie) {
            const lootItems = [...(defender.inventory || []), ...(defender.equipment || [])];
            const corpse = { x: defender.x, y: defender.y, type: 'corpse', name: `${defender.name}の死体`, graphic: 'images/corpse_bones.png', duration: 24, isHumanCorpse: true, unsearched: true, potentialLoot: lootItems };
            placedObjects.push(corpse);
        }
        const defenderIndex = entities.findIndex(e => e === defender);
        if (defenderIndex > -1) entities.splice(defenderIndex, 1);
    }
}

// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function generateWeatherAndTemperature() {
    const hour = currentTime.getHours();
    let seasonBaseTemp;
    switch(currentSeason) { case '夏': seasonBaseTemp = 28; break; case '春': seasonBaseTemp = 18; break; case '秋': seasonBaseTemp = 15; break; case '冬': seasonBaseTemp = 5; break; default: seasonBaseTemp = 15; }
    const currentBiome = map[player.y][player.x].biome;
    let biomeModifier = (currentBiome === 'Forest') ? -3 : (currentBiome === 'Town') ? 2 : 0;
    const timeOfDayModifier = (hour >= 6 && hour < 18) ? 5 : -5;
    let baseTemp = seasonBaseTemp + biomeModifier + timeOfDayModifier;
    const weatherOptions = [ { name: "快晴", icon: "☀️", chance: 50, tempMod: 2 }, { name: "曇り", icon: "☁️", chance: 25, tempMod: 0 }, { name: "雨", icon: "🌧️", chance: 15, tempMod: -3 }, { name: "嵐", icon: "⛈️", chance: 10, tempMod: -5 } ];
    
    if (Math.random() < 0.2 || turn === 1) {
      let totalChance = weatherOptions.reduce((sum, w) => sum + w.chance, 0), randomValue = Math.random() * totalChance, accumulatedChance = 0;
      for (const weather of weatherOptions) {
        accumulatedChance += weather.chance;
        if (randomValue <= accumulatedChance) {
          if (turn > 1 && currentWeather.name !== weather.name) {
              const translatedWeather = getString(`weather_${weather.name}`);
              log(getString("log_weather_changed", { weatherName: translatedWeather }));
          }
          currentWeather = weather; 
          break;
        }
      }
    }

    if (currentWeather.name === '雨' || currentWeather.name === '嵐') {
        stopClouds();
        startWeatherEffect(currentWeather.name);
    } else if (currentWeather.name === '曇り') {
        stopWeatherEffect();
        startClouds();
    } else {
        stopWeatherEffect();
        stopClouds();
    }

    baseTemp += currentWeather.tempMod;
    currentTemperature = baseTemp + (Math.random() - 0.5) * 4;

    updateWeatherAudio(); // ← この行を追加しました
}

// index.html内

function checkStats() {
    let totalTurnDamage = 0;
    if (player.feverImmunityTurns > 0) player.feverImmunityTurns--;
    const newInjuries = [];
    player.injuries.forEach(injury => {
        let stillInjured = true;
        switch (injury.type) {
            case 'bleeding':
                totalTurnDamage += 3;
                log(getString("log_bleeding_damage"), false);
                break;
            case 'bruise':
                totalTurnDamage += 1;
                injury.duration--;
                if (injury.duration <= 0) {
                    log(getString("log_bruise_healed"), true);
                    stillInjured = false;
                }
                break;
            case 'fracture':
                totalTurnDamage += injury.splinted ? 2 : 5;
                injury.duration--;
                if (injury.duration <= 0) {
                    log(getString("log_fracture_healed"), true);
                    stillInjured = false;
                }
                break;
        }
        if (stillInjured) newInjuries.push(injury);
    });
    player.injuries = newInjuries;
    if (player.bodyTemp < 35.5) player.hypothermiaTurns++;
    else player.hypothermiaTurns = 0;
    if (player.hypothermiaTurns > 4 && !player.sicknesses.some(s => s.type === 'fever') && player.feverImmunityTurns <= 0) {
        if (Math.random() < 0.6) {
            log(getString("log_hypothermia_fever"), true);
            player.sicknesses.push({ type: 'fever', duration: 48 });
            player.hypothermiaTurns = 0;
        }
    }
    const newSicknesses = [];
    player.sicknesses.forEach(sickness => {
        let stillSick = true;
        const sicknessName = getSicknessName(sickness.type);
        switch (sickness.type) {
            case 'food_poisoning':
                totalTurnDamage += 2;
                log(getString("log_food_poisoning_damage"), false);
                break;
            case 'diarrhea':
                totalTurnDamage += 2;
                log(getString("log_diarrhea_damage"), false);
                break;
            case 'fever':
                totalTurnDamage += 4;
                log(getString("log_fever_damage"), false);
                break;
        }
        if (sickness.medicated_duration) {
            sickness.medicated_duration--;
            if (sickness.medicated_duration <= 0) {
                log(getString("log_sickness_healed_meds", { sicknessName: sicknessName }), true);
                if (sickness.type === 'fever') {
                    player.feverImmunityTurns = 48;
                    log(getString("log_fever_immunity"));
                }
                stillSick = false;
            }
        } else {
            sickness.duration--;
            if (sickness.duration <= 0) {
                 log(getString("log_sickness_healed_natural", { sicknessName: sicknessName }), true);
                 if (sickness.type === 'fever') {
                    player.feverImmunityTurns = 48;
                    log(getString("log_fever_immunity"));
                 }
                 stillSick = false;
            }
        }
        if (stillSick) newSicknesses.push(sickness);
    });
    player.sicknesses = newSicknesses;
    let hungerLoss = 2, thirstLoss = 3, moraleLoss = 1, sleepLoss = 5;
    const campfireNearby = placedObjects.find(c => c.type === 'campfire' && Math.abs(c.x - player.x) <=1 && Math.abs(c.y - player.y) <= 1);
    const insideBonus = player.isInside ? 5 : 0;
    const effectiveTemperature = currentTemperature + (campfireNearby ? 15 : 0) + insideBonus;
    const totalInsulation = player.insulation;
    const insulationFactor = Math.max(0.1, 1 - (totalInsulation / 10));
    const tempDiff = effectiveTemperature - 25;
    player.bodyTemp += (tempDiff * 0.05) * insulationFactor;
    player.bodyTemp -= (player.bodyTemp - 36.5) * 0.08;
    let wetItems = 0, soakingWetItems = 0;
    player.equipment.forEach(item => {
        if (item.type === 'clothing') {
            if (item.wetness === 'wet') wetItems++;
            else if (item.wetness === 'soaking_wet') soakingWetItems++;
        }
    });
    if (wetItems > 0 || soakingWetItems > 0) {
        const wetnessPenalty = (wetItems * 0.1) + (soakingWetItems * 0.25);
        player.bodyTemp -= wetnessPenalty;
        if (soakingWetItems > 0) log(getString("log_wetness_draining_major"), false);
        else if (wetItems > 0) log(getString("log_wetness_draining_minor"), false);
    }
    if (player.bodyTemp > 38.5 || player.bodyTemp < 34.5) moraleLoss += 2; 
    else if (player.bodyTemp > 37.5) { moraleLoss += 1; totalTurnDamage += 0.5; } 
    else if (player.bodyTemp < 35.5) { hungerLoss += 1; moraleLoss += 1; totalTurnDamage += 0.5; }
    if (currentWeather.name === "雨") { moraleLoss += 1; if (currentTemperature < 20 && !campfireNearby) player.bodyTemp -= 0.2 * insulationFactor; } 
    else if (currentWeather.name === "嵐") { moraleLoss += 3; totalTurnDamage += 1; if(!campfireNearby) player.bodyTemp -= 0.4 * insulationFactor; } 
    else if (currentWeather.name === "快晴" && !isNight) { moraleLoss = Math.max(0, moraleLoss - 1); player.morale += 0.5; }
    player.hunger -= hungerLoss; player.thirst -= thirstLoss; player.sleep -= sleepLoss; player.morale -= moraleLoss;
    if (player.sleep <= 0) player.morale -= 2;
    if (player.morale <= 0) totalTurnDamage += 1;
    if (player.hunger <= 0) totalTurnDamage += 1.5;
    if (player.thirst <= 0) totalTurnDamage += 2;
    if(player.hunger >= maxStats.hunger) { player.health += 0.5; player.morale += 1; }
    if(player.thirst >= maxStats.thirst) { player.health += 0.5; player.morale += 1; }
    if (totalTurnDamage > 0) player.health -= totalTurnDamage;
    let bodyOdorIncrease = 1.5;
    if (player.bodyTemp > 37.5) bodyOdorIncrease += 0.5;
    if (player.equipment.some(e => e.type === 'clothing' && e.wetness === 'soaking_wet')) bodyOdorIncrease += 0.5;
    player.bodyOdor += bodyOdorIncrease;
    player.hunger = Math.max(0, player.hunger); player.thirst = Math.max(0, player.thirst); player.sleep = Math.max(0, player.sleep);
    player.morale = Math.max(0, Math.min(maxStats.morale, player.morale)); player.health = Math.min(maxStats.health, player.health);
    player.bodyOdor = Math.max(0, Math.min(maxStats.bodyOdor, player.bodyOdor));
    [...player.inventory, ...player.equipment].forEach(item => {
      if (item.type === "consumable" && item.freshness !== undefined) item.freshness = Math.max(0, item.freshness - 2);
      if ((item.type === "equipment" || item.type === "clothing") && item.durability !== undefined && (currentWeather.name === "雨" || currentWeather.name === "嵐")) item.durability = Math.max(0, item.durability - 0.5);
      if (item.type === 'container' && item.content && item.content.type === 'clean') {
          item.content.freshness = Math.max(0, item.content.freshness - 1);
          if (item.content.freshness === 0) { log(getString("log_water_now_dirty", { containerName: getItemDisplayName(item) })); item.content.type = 'dirty'; }
      }
    });
    updateEquippedStats(); updateItemPanels(); updateItemDetailPanel(); generateWeatherAndTemperature();
}

function updateItemDetailPanel() {
    if (currentItemDetail) {
        let updatedItem, itemIndex = currentItemDetail.index, itemSource = currentItemDetail.source;
        if (itemSource === 'inventory') updatedItem = player.inventory[itemIndex];
        else if (itemSource === 'equipment') updatedItem = player.equipment[itemIndex];
        else if (itemSource === 'dropped') updatedItem = (droppedItems[`${player.x},${player.y}`] || [])[itemIndex];
        else if (itemSource === 'placed') updatedItem = placedObjects.find(o => o.x === currentItemDetail.coords.x && o.y === currentItemDetail.coords.y);

        if (updatedItem) {
            if (itemSource === 'placed') showPlacedObjectDetail(updatedItem);
            else showItemDetail(updatedItem, itemIndex, itemSource);
        } else hideItemDetail();
    }
}

function generateNPC() {
    const template = JSON.parse(JSON.stringify(randChoice(npcTemplates)));
    const npc = { ...template, inventory: [], equipment: [], traits: [] }; // traitsプロパティを追加
    const invItemCount = Math.floor(Math.random() * 3) + 1;
    for(let i=0; i<invItemCount; i++) {
        const itemTemplate = randChoice(items.filter(item => (!item.tags || !item.tags.includes(NO_LOOT_TAG))));
        let newItem = JSON.parse(JSON.stringify(itemTemplate));
        if (newItem.type === "consumable") newItem.freshness = Math.max(20, Math.floor(Math.random() * 80) + 20);
        else if (newItem.type === "equipment" || newItem.type === "clothing") newItem.durability = Math.max(20, Math.floor(Math.random() * 80) + 20);
        else if (newItem.type === 'container') {
             const waterType = randChoice(['clean', 'dirty', null]);
             if (waterType === 'clean') newItem.content = { type: 'clean', freshness: Math.floor(Math.random() * 50) + 50 };
             else if (waterType === 'dirty') newItem.content = { type: 'dirty' };
        }
        npc.inventory.push(newItem);
    }
    const equipItemCount = Math.floor(Math.random() * 3);
     for(let i=0; i<equipItemCount; i++) {
        const equipableItems = items.filter(item => (item.type === "equipment" || item.type === "clothing") && (!item.tags || !item.tags.includes(NO_LOOT_TAG)));
        if(equipableItems.length === 0) continue;
        const itemTemplate = randChoice(equipableItems);
        const newItem = JSON.parse(JSON.stringify(itemTemplate));
        newItem.durability = Math.max(20, Math.floor(Math.random() * 80) + 20);
        if (!npc.equipment.some(e => e.slot === newItem.slot)) npc.equipment.push(newItem);
    }

    // ▼▼▼ ここからが修正箇所 ▼▼▼
    // 20%の確率で視界に関する特性を付与
    if (Math.random() < 0.2) {
        if (Math.random() < 0.5) {
            npc.traits.push("目がいい");
            npc.visionRange += 1; // 基本視界3+1 = 4
        } else {
            npc.traits.push("目が悪い");
            npc.visionRange -= 1; // 基本視界3-1 = 2
        }
    }
    // ▲▲▲ ここまで ▲▲▲

    npc.attack = npc.baseAttack; npc.defense = npc.baseDefense;
    npc.equipment.forEach(item => {
        const durabilityFactor = item.durability / 100;
        npc.attack += (item.attack || 0) * durabilityFactor;
        npc.defense += (item.defense || 0) * durabilityFactor;
    });
    npc.attack = Math.floor(npc.attack); npc.defense = Math.floor(npc.defense);
    return npc;
}

// index.html内

// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function exploreTile() {
    if (isInteractionActive || player.health <= 0) return;
    let tile = map[player.y][player.x];
    const entityOnTile = entities.find(e => e.x === player.x && e.y === player.y);
    if(entityOnTile) {
        const entityName = getString(`item_${entityOnTile.name}_name`) || entityOnTile.name;
        if(entityOnTile.isZombie || entityOnTile.isAnimal) {
             log(getString("log_npc_encounter", { npcName: entityName }), false); 
             playSoundFile('sounds/zombie_spot.wav');
             // ▼▼▼ この行を修正しました ▼▼▼
             startCombat(entityOnTile, true); // true: プレイヤーが先制攻撃
             // ▲▲▲ 修正ここまで ▲▲▲
             updateCurrentLocationPanel(true, entityOnTile); 
             return;
        } else { 
            currentNPC = entityOnTile; 
            startNPCEncounter(); 
            return; 
        }
    }
    searchCurrentLocation();
}

function searchCurrentLocation() {
    let tile = map[player.y][player.x];
    const translatedLocationName = getString(tile.loc.nameKey);
    const locationKey = `${player.x},${player.y}`;
    if (!droppedItems[locationKey]) droppedItems[locationKey] = [];

    // 修正点：池エリアに必ず水があるように、この判定を関数の最初に移動
    const waterReference = items.find(i => i.name === '汚れた水');
    if (tile.loc.nameKey === 'location_pond' && waterReference && !droppedItems[locationKey].some(item => item.type === 'water_source')) {
        droppedItems[locationKey].push({ ...waterReference });
    }

    if (tile.searched) {
        log(getString("log_location_here_searched", { locationName: translatedLocationName }));
        updateCurrentLocationPanel(false);
        return;
    }

    log(getString("log_location_here", { locationName: translatedLocationName }));
    updateCurrentLocationPanel(false);

    let itemsFound = [];
    const itemReference = {
        stone: items.find(i => i.name === '石'), branch: items.find(i => i.name === '枝'),
        leaf: items.find(i => i.name === '大きな葉'),
        emptyCan: items.find(i => i.name === '空き缶'),
        plasticBottle: items.find(i => i.name === 'ペットボトル'),
        lighter: items.find(i => i.name === 'ライター'),
        flint: items.find(i => i.name === '火打石'),
        mushroom: items.find(i => i.name === 'キノコ'),
        corn: items.find(i => i.name === 'トウモロコシ'),
        potato: items.find(i => i.name === 'ジャガイモ'),
        carrot: items.find(i => i.name === 'ニンジン'),
        carrotSeeds: items.find(i => i.name === 'ニンジンの種'),
        cabbageSeeds: items.find(i => i.name === 'キャベツの種'),
        potatoSeeds: items.find(i => i.name === 'ジャガイモの種'),
    };

    if (tile.loc.nameKey === 'location_rock') {
        if (Math.random() < 0.25) itemsFound.push({ ...itemReference.flint });
        if (Math.random() < 0.8) itemsFound.push({ ...itemReference.stone });
    } else if (tile.loc.nameKey === 'location_field') {
        if (Math.random() < 0.3) itemsFound.push({ ...itemReference.corn });
        if (Math.random() < 0.3) itemsFound.push({ ...itemReference.potato });
        if (Math.random() < 0.3) itemsFound.push({ ...itemReference.carrot });
        if (Math.random() < 0.1) itemsFound.push({ ...itemReference.carrotSeeds });
        if (Math.random() < 0.1) itemsFound.push({ ...itemReference.cabbageSeeds });
        if (Math.random() < 0.1) itemsFound.push({ ...itemReference.potatoSeeds });
    } else if (tile.biome === 'Forest') {
        if (Math.random() < 0.7) itemsFound.push({ ...itemReference.leaf });
        if (Math.random() < 0.6) itemsFound.push({ ...itemReference.branch });
        if (Math.random() < 0.4) itemsFound.push({ ...itemReference.stone });
        if (Math.random() < 0.2) itemsFound.push({ ...itemReference.mushroom });
    } else if (tile.biome === 'Plains') {
        if (Math.random() < 0.4) itemsFound.push({ ...itemReference.leaf });
        if (Math.random() < 0.3) itemsFound.push({ ...itemReference.branch });
        if (Math.random() < 0.2) itemsFound.push({ ...itemReference.stone });
    }

    if (tile.biome === 'Town' || tile.loc.nameKey === 'location_cabin') {
        if (Math.random() < 0.05) { 
            const medicineTypes = items.filter(i => ['整腸剤', '下痢止め', '解熱剤'].includes(i.name));
            itemsFound.push({ ...randChoice(medicineTypes) });
        }
        if (tile.loc.nameKey === 'location_cabin') {
            if (Math.random() < 0.05) itemsFound.push({ ...itemReference.carrotSeeds });
            if (Math.random() < 0.05) itemsFound.push({ ...itemReference.cabbageSeeds });
            if (Math.random() < 0.05) itemsFound.push({ ...itemReference.potatoSeeds });
        }
    }
    if (Math.random() * 100 < tile.loc.loot) {
        let lootableItems = items.filter(i => (!i.tags || !i.tags.includes(NO_LOOT_TAG)) && i.type !== 'ammo' && !['整腸剤', '下痢止め', '解熱剤'].includes(i.name));
        if (lootableItems.length > 0) {
            let newItem = {...randChoice(lootableItems)};
            if (newItem.type === 'container') {
                const waterType = randChoice(['clean', 'dirty', null]);
                if (waterType === 'clean') newItem.content = { type: 'clean', freshness: Math.floor(Math.random() * 50) + 50 };
                else if (waterType === 'dirty') newItem.content = { type: 'dirty' };
                else newItem.content = null;
            } else if (newItem.type === "consumable" && newItem.freshness !== undefined) {
                newItem.freshness = Math.max(10, Math.floor(Math.random() * 90) + 10);
                if(newItem.isSealed && Math.random() < 0.05) newItem.isSpoiled = true;
            } else if ((newItem.type === "equipment" || newItem.type === "clothing" || newItem.type === "tool") && newItem.durability !== undefined) {
                newItem.durability = Math.max(10, Math.floor(Math.random() * 90) + 10);
            }
            itemsFound.push(newItem);
        }
    }
    if (tile.loc.nameKey === 'location_cabin' || tile.biome === 'Town') {
        if (Math.random() < 0.08) { 
            const gunOrAmmo = randChoice(['gun', 'ammo']);
            if (gunOrAmmo === 'gun') {
                const gunTypes = items.filter(i => i.ammoType && i.type === 'equipment');
                const newGun = {...randChoice(gunTypes)};
                newGun.loadedAmmo = Math.floor(Math.random() * 3) + 1;
                newGun.durability = Math.max(20, Math.floor(Math.random() * 80) + 20);
                itemsFound.push(newGun);
                log(getString("log_gun_found"), false);
            } else {
                const ammoTypes = items.filter(i => i.type === 'ammo');
                const newAmmo = {...randChoice(ammoTypes)};
                itemsFound.push(newAmmo);
                log(getString("log_ammo_found"), false);
            }
        }
    }

    if (itemsFound.length > 0) {
        itemsFound.forEach(item => droppedItems[locationKey].push(item));
        updateCurrentLocationPanel(false);
    } else {
        log(getString("info_found_nothing"), false);
    }
    createSound(player.x, player.y, 3);
    tile.searched = true;
}

// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function showConditionTooltip(event, conditionType) {
    const preview = document.getElementById("statusPreview");
    
    // 基本情報を取得
    const title = getString(`condition_${conditionType}_title`);
    const description = getString(`condition_${conditionType}_desc`);
    
    // 詳細な効果と対処法を取得
    const effectText = getString(`injury_effect_${conditionType}`);
    const treatmentText = getString(`injury_treatment_${conditionType}`);

    // 表示用のHTMLを組み立てる
    let contentHtml = `<strong>${title}</strong>`;
    contentHtml += `<div style="margin-top: 5px; border-top: 1px solid #555; padding-top: 5px;">${description}</div>`;
    
    // 効果テキストが存在すれば表示（翻訳キーがない場合は非表示）
    if (effectText !== `injury_effect_${conditionType}`) {
        contentHtml += `<div style="margin-top: 8px;">`;
        contentHtml += `<strong>${getString("tooltip_label_effect")}:</strong> <span style="color: #e74c3c;">${effectText}</span>`;
        contentHtml += `</div>`;
    }

    // 対処法テキストが存在すれば表示
    if (treatmentText !== `injury_treatment_${conditionType}`) {
        contentHtml += `<div style="margin-top: 5px;">`;
        contentHtml += `<strong>${getString("tooltip_label_treatment")}:</strong> <span style="color: #27ae60;">${treatmentText}</span>`;
        contentHtml += `</div>`;
    }

    preview.innerHTML = contentHtml;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}
// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function updatePhysicalCondition() {
    const conditionDiv = document.getElementById("physicalCondition");
    const healthPercent = (player.health / maxStats.health) * 100;
    const hungerPercent = (player.hunger / maxStats.hunger) * 100;
    const thirstPercent = (player.thirst / maxStats.thirst) * 100;
    const sleepPercent = (player.sleep / maxStats.sleep) * 100;
    const moralePercent = (player.morale / maxStats.morale) * 100;
    const bodyTemp = player.bodyTemp;
    
    let messageElements = [], messages = [], conditionLevel = "normal";

    // --- 現在の状態を判定し、初回効果音を再生 ---
    const isCurrentlySleepy = sleepPercent < 50;
    const isCurrentlyHypothermic = bodyTemp < 35.5;
    const isCurrentlyThirsty = thirstPercent < 50;
    const isCurrentlyHungry = hungerPercent < 50;
    const isCurrentlyFeverish = player.sicknesses.some(s => s.type === 'fever');
    const isCurrentlyBleeding = player.injuries.some(i => i.type === 'bleeding');
    const isCurrentlyBruised = player.injuries.some(i => i.type === 'bruise');
    const isCurrentlyFractured = player.injuries.some(i => i.type === 'fracture');

// updatePhysicalCondition 関数内
    if (isCurrentlySleepy && !wasPreviouslySleepy) { playPlayerVoice('sounds/yawn.wav', 0.7); }
    if (isCurrentlyHypothermic && !wasPreviouslyHypothermic) { playPlayerVoice('sounds/shiver.wav', 0.6); }
    if (isCurrentlyThirsty && !wasPreviouslyThirsty) { playPlayerVoice('sounds/swallow.wav', 0.8); }
    if (isCurrentlyHungry && !wasPreviouslyHungry) { playPlayerVoice('sounds/rumble.wav', 0.5); }
    if (isCurrentlyFeverish && !wasPreviouslyFeverish) { playPlayerVoice('sounds/cough.wav', 0.7); }
    if (isCurrentlyBleeding && !wasPreviouslyBleeding) { playPlayerVoice('sounds/heartbeat.wav', 0.9); }
    if (isCurrentlyBruised && !wasPreviouslyBruised) { playPlayerVoice('sounds/grunt.wav', 0.8); }
    if (isCurrentlyFractured && !wasPreviouslyFractured) { playPlayerVoice('sounds/pain.wav', 0.9); }

    // 現在の状態を保存
    wasPreviouslySleepy = isCurrentlySleepy;
    wasPreviouslyHypothermic = isCurrentlyHypothermic;
    wasPreviouslyThirsty = isCurrentlyThirsty;
    wasPreviouslyHungry = isCurrentlyHungry;
    wasPreviouslyFeverish = isCurrentlyFeverish;
    wasPreviouslyBleeding = isCurrentlyBleeding;
    wasPreviouslyBruised = isCurrentlyBruised;
    wasPreviouslyFractured = isCurrentlyFractured;
    
    // --- (以下、既存の表示ロジックは変更なし) ---
    const addCondition = (textKey, tooltipType, level) => {
        messageElements.push(`<span onmouseenter="showConditionTooltip(event, '${tooltipType}')" onmouseleave="hideStatusPreview()">${getString(textKey)}</span>`);
        if (level === 'critical') {
            conditionLevel = 'critical';
        } else if (level === 'warning' && conditionLevel === 'normal') {
            conditionLevel = 'warning';
        }
    };

    if (healthPercent < 20) { addCondition("condition_critical_health_title", 'critical_health', 'critical'); }
    if (bodyTemp < 34.5) { addCondition("condition_severe_hypothermia_title", 'severe_hypothermia', 'critical'); } else if (bodyTemp < 35.5) { addCondition("condition_hypothermia_title", 'hypothermia', 'warning'); }
    if (hungerPercent < 20) { addCondition("condition_starving_title", 'starving', 'critical'); } else if (hungerPercent < 50) { messages.push(getString("condition_check_hunger")); if (conditionLevel === "normal") conditionLevel = "warning"; }
    if (thirstPercent < 20) { addCondition("condition_dehydrated_title", 'dehydrated', 'critical'); } else if (thirstPercent < 50) { messages.push(getString("condition_check_thirst")); if (conditionLevel === "normal") conditionLevel = "warning"; }
    if (sleepPercent < 20) { messages.push(getString("condition_check_extreme_sleepiness")); if (conditionLevel !== "critical") conditionLevel = "critical"; } else if (sleepPercent < 50) { messages.push(getString("condition_check_sleepiness")); if (conditionLevel === "normal") conditionLevel = "warning"; }
    if (moralePercent < 20) { messages.push(getString("condition_check_despair")); if (conditionLevel !== "critical") conditionLevel = "critical"; }
    
    if (bodyTemp > 38.5) { messages.push(getString("condition_check_high_fever")); conditionLevel = "critical"; } else if (bodyTemp > 37.5) { messages.push(getString("condition_check_mild_fever")); if (conditionLevel === "normal") conditionLevel = "warning"; }

    player.injuries.forEach(injury => {
        if (injury.type === 'bleeding') addCondition("condition_bleeding_title", 'bleeding', 'critical');
        else if (injury.type === 'bruise') addCondition("condition_bruise_title", 'bruise', 'warning');
        else if (injury.type === 'fracture') {
            const textKey = injury.splinted ? "condition_splinted_fracture_title" : "condition_fracture_title";
            const type = injury.splinted ? "splinted_fracture" : "fracture";
            addCondition(textKey, type, 'critical');
        }
    });

    player.sicknesses.forEach(sickness => {
        const level = sickness.type === 'fever' ? 'critical' : 'warning';
        addCondition(`condition_${sickness.type}_title`, sickness.type, level);
    });

    const finalMessages = messageElements.concat(messages);

    if (finalMessages.length === 0) {
        conditionDiv.innerHTML = `<strong>${getString("physical_condition_title")}:</strong><span class="condition-normal">${getString("condition_level_normal")}</span>`;
    } else {
        conditionDiv.innerHTML = `<strong>${getString("physical_condition_title")}:</strong><span class="condition-${conditionLevel}">${finalMessages.join(", ")}</span>`;
    }
}

function logStatChanges(before, after) {
    // 内部的なステータス名と、翻訳用のキーを対応付ける
    const statsToCheck = {
        health: "status_health",
        hunger: "status_hunger",
        thirst: "status_thirst",
        morale: "status_morale",
        sleep: "status_sleep",
        bodyTemp: "status_body_temp"
    };

    for (const stat in statsToCheck) {
        const beforeVal = Math.round(before[stat]);
        const afterVal = Math.round(after[stat]);
        const delta = afterVal - beforeVal;

        if (delta !== 0) {
            // ステータス名を現在の言語に翻訳
            const translatedStatName = getString(statsToCheck[stat]);
            
            // 増減に応じて使用する翻訳キーを決定
            const logKey = delta > 0 ? "log_stat_increase" : "log_stat_decrease";
            
            // 翻訳キーと値を使って、完全に翻訳されたメッセージを生成してログに出力
            log(getString(logKey, { 
                statName: translatedStatName, 
                amount: Math.abs(delta) 
            }));
        }
    }
}

function updateStatus() {
  function updateBar(idBar, idVal, val, maxVal, prevVal) {
    const displayVal = Math.max(0, val);
    const p = Math.min(1, displayVal / maxVal);
    document.getElementById(idBar).style.width = (p * 100) + "%";
    let deltaText = "";
    if (prevVal && prevVal[idVal.replace('Val','')] !== undefined) {
        const delta = Math.round(val - prevVal[idVal.replace('Val','')]);
        if (delta !== 0) deltaText = ` <span style="color:${delta > 0 ? 'limegreen' : 'indianred'}; font-weight:bold;">(${delta > 0 ? '+' : ''}${delta})</span>`;
    }
    document.getElementById(idVal).innerHTML = `${displayVal.toFixed(0)} / ${maxVal.toFixed(0)}${deltaText}`;
  }
  function updateValue(idVal, val, prevVal, suffix = '', precision = 0) {
    const valElem = document.getElementById(idVal);
    let deltaText = "";
    if (prevVal && prevVal[idVal.replace('Val','')] !== undefined) {
        const delta = parseFloat(val.toFixed(precision + 1)) - parseFloat(prevVal[idVal.replace('Val','')].toFixed(precision + 1));
        if (Math.abs(delta) > (precision === 0 ? 0.5 : 0)) deltaText = ` <span style="color:${delta > 0 ? 'limegreen' : 'indianred'}; font-weight:bold;">(${delta > 0 ? '+' : ''}${delta.toFixed(precision)})</span>`;
    }
    valElem.innerHTML = `${val.toFixed(precision)}${suffix}${deltaText}`;
  }
  updateBar("hungerBar", "hungerVal", player.hunger, maxStats.hunger, playerStatsBeforeAction);
  updateBar("thirstBar", "thirstVal", player.thirst, maxStats.thirst, playerStatsBeforeAction);
  updateBar("healthBar", "healthVal", player.health, maxStats.health, playerStatsBeforeAction);
  updateBar("moraleBar", "moraleVal", player.morale, maxStats.morale, playerStatsBeforeAction);
  updateBar("sleepBar", "sleepVal", player.sleep, maxStats.sleep, playerStatsBeforeAction);
  const sleepBtn = document.getElementById("sleepNowBtn");
  sleepBtn.style.display = (player.sleep >= maxStats.sleep || isInteractionActive) ? "none" : "block";
  const bodyTempBar = document.getElementById("bodyTempBar");
  const minTemp = 34.0, maxTemp = 41.0, normalRangeMin = 36.0, normalRangeMax = 37.5;
  const pTemp = (player.bodyTemp - minTemp) / (maxTemp - minTemp);
  bodyTempBar.style.width = (pTemp * 100) + "%";
  updateValue("bodyTempVal", player.bodyTemp, playerStatsBeforeAction, '°C', 1);
  if (player.bodyTemp < normalRangeMin || player.bodyTemp > normalRangeMax) bodyTempBar.style.background = (player.bodyTemp < 35.0 || player.bodyTemp > 38.5) ? '#e74c3c' : '#f1c40f';
  else bodyTempBar.style.background = '#27ae60';
  
  let pWeight = Math.min(1, player.weight / player.maxWeight);
  document.getElementById("weightBar").style.width = (pWeight * 100) + "%";
  document.getElementById("weightBar").style.background = player.weight > player.maxWeight ? '#e74c3c' : '#7f8c8d';
  updateValue("weightVal", player.weight, playerStatsBeforeAction, ` / ${player.maxWeight.toFixed(1)}`, 1);
  
  let pVolume = Math.min(1, player.volume / player.maxVolume);
  document.getElementById("volumeBar").style.width = (pVolume * 100) + "%";
  document.getElementById("volumeBar").style.background = player.volume > player.maxVolume ? '#e74c3c' : '#9b59b6';
  updateValue("volumeVal", player.volume, playerStatsBeforeAction, ` / ${player.maxVolume.toFixed(1)}`, 1);

  document.getElementById("attackBar").style.width = Math.min(1, player.attack / 50) * 100 + "%";
  updateValue("attackVal", player.attack, playerStatsBeforeAction, '', 0);
  document.getElementById("defenseBar").style.width = Math.min(1, player.defense / 50) * 100 + "%";
  updateValue("defenseVal", player.defense, playerStatsBeforeAction, '', 0);
  
  updateBar("bodyOdorBar", "bodyOdorVal", player.bodyOdor, maxStats.bodyOdor, playerStatsBeforeAction);
  const bodyOdorBar = document.getElementById("bodyOdorBar");
  if (player.bodyOdor > 70) bodyOdorBar.style.background = '#e74c3c';
  else if (player.bodyOdor > 40) bodyOdorBar.style.background = '#f1c40f';
  else bodyOdorBar.style.background = '#8B4513';
  
  updatePhysicalCondition();
  manageYawnEffect();
  manageShiverEffect();
  manageSwallowEffect();
  manageRumbleEffect();
  manageCoughEffect();
  manageHeartbeatEffect();
  manageGruntEffect();
  managePainEffect();
}


function sleepForOneHour() {
    if(isInteractionActive) return;
    const sleepingBag = placedObjects.find(o => o.type === 'sleeping_bag' && o.x === player.x && o.y === player.y);
    const sleepQuality = sleepingBag ? 2.0 : 0.5;
    const sleepAmount = 25 * sleepQuality;
    if (player.sleep >= maxStats.sleep) { log(getString("log_no_need_to_sleep")); return; }
    snapshotStats();
    log(sleepingBag ? getString("log_sleep_in_bag") : getString("log_sleep_on_ground"));
    player.sleep = Math.min(maxStats.sleep, player.sleep + sleepAmount);
    player.hunger -= 1; player.thirst -= 1;
    logStatChanges(playerStatsBeforeAction, player);
    advanceTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    checkGameOver();
    updateTurnInfo();
    updateCurrentLocationPanel(false);
}


// 【1. グローバル変数の追加】
// placedObjects の定義の下あたりに、以下の1行を追加します。
let previousVisionLevel = 0; // ★追加: 前のターンの視界レベルを記録
let isGameRunning = false; // ゲームが実行中かどうかのフラグ
// ▼▼▼ この行を追加 ▼▼▼
let yawnTimer = null; // あくび音のタイマーを管理する変数
let shiverTimer = null; // 震え音のタイマーを管理する変数
let wasPreviouslySleepy = false;
let wasPreviouslyHypothermic = false;
let wasPreviouslyThirsty = false;
let wasPreviouslyHungry = false;
let wasPreviouslyFeverish = false;
let wasPreviouslyBleeding = false;
let wasPreviouslyBruised = false;
let wasPreviouslyFractured = false;
let swallowTimer = null;
let rumbleTimer = null;
let coughTimer = null;
let heartbeatTimer = null;
let gruntTimer = null;
let painTimer = null;
// ▼▼▼ 以下の2行を追加 ▼▼▼
let lastPlayerVoiceTime = 0; // 最後にプレイヤーの声が再生された時刻を記録
const PLAYER_VOICE_COOLDOWN = 5000; // プレイヤーの声のクールダウン時間（ミリ秒）。この場合5秒。
// ▲▲▲ 追加ここまで ▲▲▲
let lastSoundCalculation = { base: 0, shoes: {name: '素足', modifier: 1.2}, weather: {name: '快晴', modifier: 1.0}, total: 0, source: 'なし' };
// 【2. 新しい関数の追加】
// updateTurnInfo 関数のすぐ上に、以下のツールチップ表示用関数を新たに追加します。

/**
 * 視界レベルにカーソルを合わせた際に、その内訳をツールチップで表示する関数
 * @param {MouseEvent} event - マウスイベント
 */
function showVisionTooltip(event) {
    const preview = document.getElementById("statusPreview");
    let contentHtml = `<strong>${getString("tooltip_vision_title")}</strong><br/>`;
    let visionCalc = player.vision;
    let calculationStepsHtml = `<div>${getString("tooltip_vision_base")}: ${player.vision}</div>`;
    if (character.traits.includes("目が悪い") && player.equipment.some(e => e.name === 'メガネ')) {
        calculationStepsHtml += `<div><span class="stat-positive">${getString("tooltip_vision_glasses")}</span>: +1</div>`;
        visionCalc++;
    }
    const hasTorch = player.equipment.some(e => e.isTorch);
    const hour = currentTime.getHours();
    const isEvening = hour >= 18 && hour < 21;
    const isDeepNight = hour >= 21 || hour < 6;

    if (isDeepNight) {
        let nightVision = 0;
        let nightReason = getString("tooltip_vision_night");
        if (hasTorch) {
            nightVision = 1;
            nightReason += `+<span class="stat-positive">${getString("tooltip_vision_torch")}</span>`;
        }
        if (character.traits.includes("目がいい")) {
             if(nightVision < 1) nightReason += `+<span class="stat-positive">${getString("tooltip_vision_trait")}</span>`;
            nightVision = Math.max(nightVision, 1);
        }
        calculationStepsHtml += `<div>${nightReason}のため <span class="stat-negative">${nightVision}</span> に補正</div>`;
        visionCalc = nightVision;
    } else if (isEvening) {
        let originalVision = visionCalc;
        visionCalc = Math.max(hasTorch ? 1 : 0, visionCalc - 1);
        let duskReason = getString("tooltip_vision_dusk");
        if (hasTorch && originalVision - 1 < 1) duskReason += ` (<span class="stat-positive">${getString("tooltip_vision_dusk_torch")}</span>)`;
        calculationStepsHtml += `<div>${duskReason}による補正: -1</div>`;
    }
    let weatherMultiplier = 1.0, weatherReason = "";
    if (currentWeather.name === '雨') { weatherMultiplier = 0.75; weatherReason = getString("tooltip_vision_rain"); }
    if (currentWeather.name === '嵐') { weatherMultiplier = 0.5; weatherReason = getString("tooltip_vision_storm"); }
    if (weatherMultiplier !== 1.0) {
        calculationStepsHtml += `<div>${weatherReason}${getString("tooltip_vision_penalty")}: ×${weatherMultiplier}</div>`;
        visionCalc *= weatherMultiplier;
    }
    const finalVision = Math.max(0, Math.round(visionCalc));
    contentHtml += calculationStepsHtml;
    contentHtml += `<div style="border-bottom: 1px solid #555; margin: 4px 0;"></div>`;
    if (Math.round(visionCalc) !== visionCalc) contentHtml += `<div>${getString("tooltip_vision_calc_result")}: ${visionCalc.toFixed(2)}</div>`;
    contentHtml += `<strong>${getString("tooltip_vision_final")}: ${finalVision}</strong>`;
    preview.innerHTML = contentHtml;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}
function showSmellTooltip(event) {
    const preview = document.getElementById("statusPreview");
    let contentHtml = `<strong>${getString("tooltip_smell_title")}</strong><br/>`;
    let totalSmell = 0, hasSource = false;
    const smellyItems = [...player.inventory, ...player.equipment].filter(item => item.smell);
    if (smellyItems.length > 0) {
        smellyItems.forEach(item => {
            contentHtml += `<div>${getItemDisplayName(item)}: +${item.smell}</div>`;
            totalSmell += item.smell;
        });
        hasSource = true;
    }
    if (player.injuries.some(i => i.type === 'bleeding')) {
        contentHtml += `<div><span class="stat-negative">${getString("tooltip_smell_bleeding")}</span>: +15</div>`;
        totalSmell += 15;
        hasSource = true;
    }
    const bodyOdorSmell = Math.floor(player.bodyOdor / 5);
    if (bodyOdorSmell > 0) {
        contentHtml += `<div>${getString("tooltip_smell_body_odor")}: +${bodyOdorSmell}</div>`;
        totalSmell += bodyOdorSmell;
        hasSource = true;
    }
    if (!hasSource) {
        contentHtml += `<div>${getString("tooltip_smell_no_source")}</div>`;
    }
    contentHtml += `<div style="border-bottom: 1px solid #555; margin: 2px 0;"></div>`;
    contentHtml += `<strong>${getString("tooltip_smell_total")}: ${totalSmell}</strong>`;
    preview.innerHTML = contentHtml;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}

function showSoundTooltip(event) {
    const preview = document.getElementById("statusPreview");
    const calc = lastSoundCalculation;
    let contentHtml = `<strong>${getString("tooltip_sound_title")}</strong><br/>`;
    if (calc.total === 0) {
        contentHtml += `<div>${getString("tooltip_sound_no_source")}</div>`;
    } else {
        const shoeName = getString(`item_${calc.shoes.name}_name`) || calc.shoes.name;
        const weatherName = getString(`weather_${calc.weather.name}`) || calc.weather.name;
        contentHtml += `<div>${getString("tooltip_sound_action")} (${calc.source}): ${calc.base.toFixed(1)}</div>`;
        contentHtml += `<div>${getString("tooltip_sound_equipment")} (${shoeName}): ×${calc.shoes.modifier.toFixed(1)}</div>`;
        if (calc.weather.modifier !== 1.0) {
            contentHtml += `<div>${getString("tooltip_sound_weather")} (${weatherName}): ×${calc.weather.modifier.toFixed(1)}</div>`;
        }
        contentHtml += `<div style="border-bottom: 1px solid #555; margin: 2px 0;"></div>`;
        contentHtml += `<strong>${getString("tooltip_sound_total")}: ${calc.total.toFixed(1)}</strong>`;
    }
    preview.innerHTML = contentHtml;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}

// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function updateTurnInfo() {
    const year = currentTime.getFullYear();
    const month = currentTime.getMonth() + 1;
    const day = currentTime.getDate();
    const currentHour = currentTime.getHours();
    const ampm = getString(currentHour >= 12 ? "time_pm" : "time_am");
    let hours = currentHour % 12;
    hours = hours ? hours : 12;
    const minutes = currentTime.getMinutes().toString().padStart(2, '0');

    let dateString;
    let timeString;

    // ▼▼▼ ここからが修正箇所です ▼▼▼
    if (currentLanguage === 'ja') {
        // 日本語の場合のフォーマット
        dateString = `${year}${getString("time_year")}${month}${getString("time_month")}${day}${getString("time_day")}`;
        timeString = `${ampm} ${hours}${getString("time_hour")}${minutes}${getString("time_minute")}`;
    } else if (currentLanguage === 'zh-CN') {
        // 中国語の場合のフォーマット
        dateString = getString("time_date_format_zh", { year: year, month: month, day: day }); // 例: 2025年9月5日
        timeString = `${ampm} ${hours}:${minutes}`; // 例: 上午 10:36
    } else {
        // デフォルト (英語) の場合のフォーマット
        const monthKeys = ["month_jan", "month_feb", "month_mar", "month_apr", "month_may", "month_jun", "month_jul", "month_aug", "month_sep", "month_oct", "month_nov", "month_dec"];
        const monthAbbr = getString(monthKeys[currentTime.getMonth()]);
        dateString = getString("time_date_format_en", { month: monthAbbr, day: day, year: year }); // 例: Sep 5, 2025
        timeString = `${hours}:${minutes} ${ampm}`; // 例: 10:36 AM
    }

    let turnInfoHtml = `${getString("time_turn")}: ${turn}<br>${dateString}<br>${timeString}`;
    // ▲▲▲ 修正ここまで ▲▲▲

    const soundLevelHtml = `<span onmouseenter="showSoundTooltip(event)" onmouseleave="hideInfoTooltip()" onmousemove="updatePreviewPosition(event)">${currentSoundLevel}</span>`;
    const smellLevelHtml = `<span onmouseenter="showSmellTooltip(event)" onmouseleave="hideInfoTooltip()" onmousemove="updatePreviewPosition(event)">${currentPlayerSmell}</span>`;
    
    turnInfoHtml += `<br><span onmouseenter="showSoundTooltip(event)" onmouseleave="hideInfoTooltip()" onmousemove="updatePreviewPosition(event)">${getString("info_sound_level")}</span>: ${soundLevelHtml}`;
    turnInfoHtml += `<br><span onmouseenter="showSmellTooltip(event)" onmouseleave="hideInfoTooltip()" onmousemove="updatePreviewPosition(event)">${getString("info_smell_level")}</span>: ${smellLevelHtml}`;
    
    const currentVision = getVisionRange();
    const visionLevelHtml = `<span onmouseenter="showVisionTooltip(event)" onmouseleave="hideInfoTooltip()" onmousemove="updatePreviewPosition(event)">${currentVision}</span>`;
    turnInfoHtml += `<br><span onmouseenter="showVisionTooltip(event)" onmouseleave="hideInfoTooltip()" onmousemove="updatePreviewPosition(event)">${getString("info_vision_level")}</span>: ${visionLevelHtml}`;
    previousVisionLevel = currentVision;
    
    document.getElementById("turnInfoText").innerHTML = turnInfoHtml;
    updateMapHeaderInfo();
}

function showInfoTooltip(event, title, description) {
    const preview = document.getElementById("statusPreview");
    preview.innerHTML = `<strong>${title}</strong><div style="margin-top: 5px;">${description}</div>`;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}

function hideInfoTooltip() {
    hideStatusPreview();
}

function updateMapHeaderInfo() {
    let dayStateKey, dayIcon, dayDescKey;
    const hour = currentTime.getHours();
    if (hour >= 6 && hour < 12) { dayStateKey = "daystate_朝"; dayIcon = "🌅"; } 
    else if (hour >= 12 && hour < 18) { dayStateKey = "daystate_昼"; dayIcon = "☀️"; } 
    else if (hour >= 18 && hour < 21) { dayStateKey = "daystate_夕方"; dayIcon = "🌇"; } 
    else { dayStateKey = "daystate_夜"; dayIcon = "🌙"; }

    const seasonKey = `season_${currentSeason}`;
    const weatherKey = `weather_${currentWeather.name}`;

    const seasonHtml = `<span>${seasonInfo[currentSeason].icon} ${getString(seasonKey)}</span>`;
    const weatherHtml = `<span>${weatherInfo[currentWeather.name].icon} ${getString(weatherKey)}</span>`;
    const dayStateHtml = `<span>${dayIcon} ${getString(dayStateKey)}</span>`;
    const tempHtml = `<span class="${currentTemperature > 28 ? 'temp-hot' : currentTemperature < 10 ? 'temp-cold' : 'temp-normal'}">${currentTemperature.toFixed(1)}°C</span>`;

    document.getElementById("mapHeaderInfo").innerHTML = `${seasonHtml}|${weatherHtml}|${dayStateHtml}|${tempHtml}`;
}

function logClear() { document.getElementById("log").innerHTML = ""; }

function log(text, doSpeak = true) {
    const logDiv = document.getElementById("log");
    Array.from(logDiv.children).forEach(div => {
        div.style.color = "#666";
        div.style.fontWeight = "normal";
    });
    let div = document.createElement("div");
    div.innerHTML = text;
    div.classList.add("new");
    logDiv.appendChild(div);
    logDiv.scrollTop = logDiv.scrollHeight;

    if (doSpeak) {
        const tempDiv = document.createElement("div");
        tempDiv.innerHTML = text;
        const plainText = tempDiv.textContent || tempDiv.innerText || "";
        speak(plainText);
    }
}
// index.html内 (getItemDisplayName の前に追加)

/**
 * アイテムの状態（耐久度など）を含まない、基本的な名前だけを翻訳して返す
 * @param {object} item - アイテムオブジェクト
 * @returns {string} - 翻訳された基本的なアイテム名
 */
function getBaseItemName(item) {
    if (!item) return "";
    return getString(`item_${item.name}_name`) || item.name;
}
// ▼▼▼ この関数を新しく追加してください ▼▼▼
function getPlacedObjectDisplayName(pObj) {
    if (pObj.isHumanCorpse) {
        return pObj.unsearched 
            ? getString('item_古い死体_name')
            : getString('item_漁られた死体_name');
    } else if (pObj.isAnimalCorpse) {
        const baseName = getString(`item_${pObj.name}_name`) || pObj.name;
        return pObj.unbutchered
            ? baseName
            : getString('item_解体済みの死骸_name');
    }
    // デフォルト（たき火、木箱など）
    return getString(`item_${pObj.name}_name`) || pObj.name;
}
function getItemDisplayName(item) {
    if (!item) return "";
    
    // 修正点：アイテムの'name'プロパティを元に、常に翻訳キーを生成してテキストを取得
    let baseName = getString(`item_${item.name}_name`) || item.name;

    let prefix = '';
    let color = '#eee';

    if (item.durability !== undefined) {
        const durabilityPercent = item.durability;
        if (durabilityPercent === 100) { prefix = getString("durability_new"); color = '#2ecc71'; } 
        else if (durabilityPercent >= 70) { prefix = getString("durability_likenew"); color = '#eee'; } 
        else if (durabilityPercent >= 30) { prefix = getString("durability_used"); color = '#FFD700'; } 
        else if (durabilityPercent > 0) { prefix = getString("durability_worn"); color = '#FFA500'; } 
        else { prefix = getString("durability_broken"); color = '#FF4444'; }
    }
    
    let durabilityPrefix = prefix ? `<span style="color: ${color};">${prefix}</span> ` : '';
    let wetnessPrefix = '';
    if (item.wetness === 'wet') { wetnessPrefix = `<span style="color: lightblue;">(${getString("wetness_wet")}) </span>`; } 
    else if (item.wetness === 'soaking_wet') { wetnessPrefix = `<span style="color: blue;">(${getString("wetness_soaking_wet")}) </span>`; }

    let name = wetnessPrefix + durabilityPrefix + baseName;

    if (item.ammoType && item.ammoCapacity) {
        name += ` (${item.loadedAmmo}/${item.ammoCapacity})`;
        if (item.name === 'ライフル' && item.bayonetAttached) {
            name += ` ${getString("bayonet_attached")}`;
        }
    } else if (item.type === 'container') {
        if (!item.content) return `${name} (${getString("container_empty")})`;
        if (item.content.type === 'clean') return `${name} (${getString("container_clean_water")})`;
        return `${name} (${getString("container_dirty_water")})`;
    }
    return name;
}

// index.html 内

function updateItemPanels() {
  const invDiv = document.getElementById("inventory"), equipDiv = document.getElementById("equipment");
  invDiv.innerHTML = ""; equipDiv.innerHTML = "";

  if (player.inventory.length === 0) {
      invDiv.textContent = getString("item_none");
  } else {
      player.inventory.forEach((item, idx) => {
        let div = document.createElement("div"); div.className = "item";
        let descText = "";
        if (item.type === "consumable" && item.freshness !== undefined) {
            descText = item.freshness > 0 ? `${getString("item_info_freshness")}: ${item.freshness.toFixed(0)}%` : getString("item_info_spoiled");
        } else if ((item.type === "equipment" || item.type === "clothing" || item.type === "tool") && item.durability !== undefined) {
            descText = `${getString("item_info_durability")}: ${item.durability.toFixed(0)}%`;
        } else if (item.type === "ammo") {
            descText = getString("item_info_ammo");
        }
        div.innerHTML = `${getIconHTML(item.graphic, 16)} ${getItemDisplayName(item)}${descText ? ` <span style="font-size: smaller; color: #888;">(${descText})</span>` : ''}`;
        div.onclick = () => showItemDetail(item, idx, 'inventory');
        invDiv.appendChild(div);
      });
  }
  
  if (player.equipment.length === 0) {
      equipDiv.textContent = getString("item_none");
  } else {
      player.equipment.forEach((item, idx) => {
        let div = document.createElement("div"); div.className = "item";
        let durabilityText = item.durability !== undefined ? item.durability.toFixed(0) : getString("item_info_not_applicable");
        let descText = `${getString("item_info_durability")}: ${durabilityText}%`;
        if (item.isTorch && item.duration) {
            descText += `, ${getString("item_info_remaining")}: ${item.duration}${getString("item_info_turns")}`;
        }
        let slotPrefix = item.slot ? `[${getSlotName(item.slot)}] ` : '';
        div.innerHTML = `${getIconHTML(item.graphic, 16)} ${slotPrefix}${getItemDisplayName(item)}<span style="font-size: smaller; color: #888;"> (${descText})</span>`;
        div.onclick = () => showItemDetail(item, idx, 'equipment');
        equipDiv.appendChild(div);
      });
  }

  updateCraftingPanel();
}
// index.html内

function updateCraftingPanel() {
    const craftListDiv = document.getElementById("craftingList");
    craftListDiv.innerHTML = "";

    const categories = {
        'available': { name: getString('craft_category_available'), recipes: [] },
        'weapon': { name: getString('craft_category_weapon'), recipes: [] },
        'armor_clothing': { name: getString('craft_category_armor_clothing'), recipes: [] },
        'tools': { name: getString('craft_category_tools'), recipes: [] },
        'other': { name: getString('craft_category_other'), recipes: [] }
    };

    recipes.forEach(recipe => {
        const resultItem = items.find(i => i.name === recipe.result);
        if (!resultItem) return;
        const isCraftable = canCraftItem(recipe);
        const recipeData = { ...recipe, canCraft: isCraftable };

        if (isCraftable) {
            categories['available'].recipes.push(recipeData);
        }
        
        if (resultItem.type === 'equipment' && resultItem.slot === 'weapon') {
            categories['weapon'].recipes.push(recipeData);
        } else if (resultItem.type === 'equipment' || resultItem.type === 'clothing') {
            categories['armor_clothing'].recipes.push(recipeData);
        } else if (resultItem.type === 'tool' || resultItem.type === 'container') {
            categories['tools'].recipes.push(recipeData);
        } else {
            categories['other'].recipes.push(recipeData);
        }
    });

    for (const categoryKey in categories) {
        const category = categories[categoryKey];
        if (category.recipes.length === 0) continue;

        const header = document.createElement("div");
        header.className = "crafting-category-header";
        header.innerHTML = `<span>${category.name}</span><span class="toggle-arrow">▼</span>`;
        craftListDiv.appendChild(header);

        const recipeContainer = document.createElement("div");
        recipeContainer.className = "recipe-container";
        craftListDiv.appendChild(recipeContainer);

        header.addEventListener('click', () => {
            recipeContainer.classList.toggle('collapsed');
            const arrow = header.querySelector('.toggle-arrow');
            arrow.textContent = recipeContainer.classList.contains('collapsed') ? '▶' : '▼';
        });

        category.recipes.sort((a, b) => {
            const nameA = getString(`item_${a.result}_name`) || a.result;
            const nameB = getString(`item_${b.result}_name`) || b.result;
            if (categoryKey === 'available') {
                return nameA.localeCompare(nameB);
            }
            if (a.canCraft && !b.canCraft) return -1;
            if (!a.canCraft && b.canCraft) return 1;
            return nameA.localeCompare(nameB);
        });

        category.recipes.forEach(recipe => {
            const resultItem = items.find(i => i.name === recipe.result);
            const div = document.createElement("div");
            div.className = "item";
            div.addEventListener('mouseenter', (e) => showRecipeTooltip(resultItem, e));
            div.addEventListener('mouseleave', hideStatusPreview);
            div.addEventListener('mousemove', (e) => updatePreviewPosition(e));
            
            if (!recipe.canCraft) {
                div.classList.add("un-craftable");
            }
            
            let ingredientsHtml = recipe.ingredients.map(ing => {
                const translatedName = getString(`item_${ing.name}_name`) || ing.name;
                return `${translatedName} x${ing.count}`;
            }).join(', ');
            
            // 修正点：「btn_use」を「btn_craft」に変更
            div.innerHTML = `<button>${getString("btn_craft")}</button>${getIconHTML(resultItem.graphic || 'images/barricade.png', 16)} ${getString(`item_${resultItem.name}_name`) || resultItem.name}<div class="recipe-ingredients">${ingredientsHtml}</div>`;
            
            if (recipe.canCraft) {
                div.querySelector("button").onclick = () => craftItem(recipe);
            }
            recipeContainer.appendChild(div);
        });
    }
}

function canCraftItem(recipe) {
    const availableMaterials = {};
    player.inventory.forEach(item => { 
        availableMaterials[item.name] = (availableMaterials[item.name] || 0) + 1; 
    });
    const locationKey = `${player.x},${player.y}`;
    const itemsOnGround = droppedItems[locationKey] || [];
    itemsOnGround.forEach(item => {
        availableMaterials[item.name] = (availableMaterials[item.name] || 0) + 1;
    });

    return recipe.ingredients.every(ingredient => (availableMaterials[ingredient.name] || 0) >= ingredient.count);
}

function craftItem(recipe) {
    if (!canCraftItem(recipe)) { log(getString("error_not_enough_materials")); return; }
    let failureChance = 0.10; 
    if (character.traits.includes("手先が器用")) failureChance = 0.05;
    else if (character.traits.includes("手先が不器用")) failureChance = 0.25;
    if (Math.random() < failureChance) {
        log(getString("craft_fail_lost_materials"), true);
        const materialsToLoseCount = Math.ceil(recipe.ingredients.length / 2);
        let ingredientPool = [];
        recipe.ingredients.forEach(ing => { for (let i = 0; i < ing.count; i++) ingredientPool.push(ing.name); });
        for (let i = 0; i < materialsToLoseCount; i++) {
            if (ingredientPool.length === 0) break;
            const lostIngredientName = randChoice(ingredientPool);
            ingredientPool.splice(ingredientPool.indexOf(lostIngredientName), 1);
            const invIndex = player.inventory.findIndex(invItem => invItem.name === lostIngredientName);
            if (invIndex > -1) {
                const removedItem = player.inventory.splice(invIndex, 1)[0];
                player.weight -= removedItem.weight || 0;
                player.volume -= removedItem.volume || 0;
                continue;
            }
            const locationKey = `${player.x},${player.y}`;
            const groundItems = droppedItems[locationKey] || [];
            const groundIndex = groundItems.findIndex(groundItem => groundItem.name === lostIngredientName);
            if (groundIndex > -1) groundItems.splice(groundIndex, 1);
        }
        updateItemPanels(); updateStatus(); updateCurrentLocationPanel(false);
        return;
    }
    snapshotStats();
    recipe.ingredients.forEach(ingredient => {
        for (let i = 0; i < ingredient.count; i++) {
            const invIndex = player.inventory.findIndex(invItem => invItem.name === ingredient.name);
            if (invIndex > -1) {
                const removedItem = player.inventory.splice(invIndex, 1)[0];
                player.weight -= removedItem.weight || 0;
                player.volume -= removedItem.volume || 0;
                continue;
            }
            const locationKey = `${player.x},${player.y}`;
            const groundItems = droppedItems[locationKey] || [];
            const groundIndex = groundItems.findIndex(groundItem => groundItem.name === ingredient.name);
            if (groundIndex > -1) groundItems.splice(groundIndex, 1);
        }
    });
    const resultItemTemplate = items.find(item => item.name === recipe.result);
    if (resultItemTemplate) {
        const newItem = { ...resultItemTemplate };
        if (player.weight + newItem.weight > player.maxWeight || player.volume + (newItem.volume || 0) > player.maxVolume) {
            log(getString("craft_success_grounded", { itemName: getItemDisplayName(newItem) }), true);
            const locationKey = `${player.x},${player.y}`;
            if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
            droppedItems[locationKey].push(newItem);
        } else {
            player.inventory.push(newItem);
            player.weight += newItem.weight || 0;
            player.volume += newItem.volume || 0;
        }
        log(getString("craft_success", { itemName: getItemDisplayName(newItem) }), true);
        createSound(player.x, player.y, 3);
    }
    advanceTurn(); drawMap(); updateStatus(); updateItemPanels(); updateCharacterBody(); updateCharacterInfo(); updateTurnInfo(); checkGameOver(); updateCurrentLocationPanel(false);
}

function dropItem(index) {
    snapshotStats();
    const droppedItem = player.inventory.splice(index, 1)[0];
    player.weight -= droppedItem.weight || 0;
    player.volume -= droppedItem.volume || 0;
    log(getString("log_drop_item", { itemName: getItemDisplayName(droppedItem) }));
    const locationKey = `${player.x},${player.y}`;
    if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
    droppedItems[locationKey].push(droppedItem);
    updateItemPanels(); updateCurrentLocationPanel(false); updateStatus(); updateCharacterBody();
}

function pickUpItemFromGround(index) {
  const locationKey = `${player.x},${player.y}`;
  const itemToPickUp = droppedItems[locationKey][index];
  if (itemToPickUp.type === 'water_source') { log(getString("log_cannot_pickup_water")); hideItemDetail(); return; }
  
  if (player.weight + itemToPickUp.weight > player.maxWeight) { 
      speakAndAlert(getString("alert_pickup_fail_weight", { itemName: getItemDisplayName(itemToPickUp) })); 
      return; 
  }
  if (player.volume + (itemToPickUp.volume || 0) > player.maxVolume) { 
      speakAndAlert(getString("alert_pickup_fail_volume", { itemName: getItemDisplayName(itemToPickUp) })); 
      return; 
  }

  snapshotStats();
  const pickedUpItem = droppedItems[locationKey].splice(index, 1)[0];
  player.inventory.push(pickedUpItem); 
  player.weight += pickedUpItem.weight || 0;
  player.volume += pickedUpItem.volume || 0;
  log(getString("log_pickup_item", { itemName: getItemDisplayName(pickedUpItem) }));
  updateCurrentLocationPanel(false); updateItemPanels(); updateStatus(); updateCharacterBody(); hideItemDetail();
}


function triggerCombatTurnForAction(logMessage) {
    log(logMessage);
    hideItemDetail();

    // ▼▼▼ 修正箇所 ▼▼▼
    // アイテム操作をリアルタイムで反映させるためにパネルの表示を更新する
    updateItemPanels(); 
    updateStatus();
    // ▲▲▲ 修正箇所 ▲▲▲

    // 敵のターンを実行
    enemyTurn(); 
}

// index.html内

function unequipItem(index, showLog = true) {
    const itemToUnequip = player.equipment[index];

    let futureMaxVolume = maxStats.maxVolume;
    player.equipment.forEach((item, i) => {
        if (i !== index && item.effects && item.effects.maxVolume) {
            futureMaxVolume += item.effects.maxVolume;
        }
    });

    const futurePlayerVolume = player.volume + (itemToUnequip.volume || 0);

    if (futurePlayerVolume > futureMaxVolume) {
        // 修正点：翻訳キーを使って警告メッセージを表示
        speakAndAlert(getString("alert_unequip_fail_volume", {
            newVolume: futurePlayerVolume.toFixed(1),
            newMaxVolume: futureMaxVolume.toFixed(1)
        }));
        hideItemDetail();
        return;
    }

    snapshotStats();
    const unequippedItem = player.equipment.splice(index, 1)[0];
    unequippedItem.slot = (unequippedItem.handedness) ? 'weapon' : unequippedItem.slot;
    player.inventory.push(unequippedItem);
    
    updateEquippedStats(); 

    if (currentEnemy) {
        triggerCombatTurnForAction(getString("log_unequip_item", { itemName: getItemDisplayName(unequippedItem) }));
    } else {
        if (showLog) log(getString("log_unequip_item", { itemName: getItemDisplayName(unequippedItem) }));
        if (showLog) {
            updateItemPanels(); 
            updateStatus(); 
            updateCharacterBody();
            speakQueuedLogs();
        }
    }
}

// ▼▼▼ この関数で既存のものを置き換えてください ▼▼▼
function updateEquippedStats() {
    // 1. 全てのステータスを基本値で初期化
    player.attack = player.baseAttack;
    player.defense = player.baseDefense;
    player.maxWeight = maxStats.maxWeight;
    player.maxVolume = maxStats.maxVolume;
    player.insulation = 0;

    // 2. 武器による攻撃力の計算を特別に行う
    const weapons = player.equipment.filter(e => e.attack || e.fireDamage);
    if (weapons.length > 0) {
        let bestMeleeWeapon = { attack: 0, durability: 100 }; // 比較用のダミー武器

        // 最も強い近接武器を1つだけ見つける
        weapons.forEach(w => {
            let currentAttack = w.attack || 0;
            // 銃剣付きライフルの弾切れ時の特殊処理
            if (w.name === 'ライフル' && w.bayonetAttached && w.loadedAmmo === 0) {
                const knife = items.find(i => i.name === 'ナイフ');
                currentAttack = knife ? knife.attack : (w.attack || 0);
            }

            if (currentAttack > bestMeleeWeapon.attack) {
                bestMeleeWeapon = w;
            }
        });

        // 最も強い武器の攻撃力ボーナスだけを加算する
        if (bestMeleeWeapon.attack > 0) {
            const durabilityFactor = (bestMeleeWeapon.durability === undefined ? 100 : bestMeleeWeapon.durability) / 100;
            
            let weaponAttackBonus = bestMeleeWeapon.attack || 0;
            // (再確認) 銃剣付きライフルの弾切れ時の特殊処理
            if (bestMeleeWeapon.name === 'ライフル' && bestMeleeWeapon.bayonetAttached && bestMeleeWeapon.loadedAmmo === 0) {
                const knife = items.find(i => i.name === 'ナイフ');
                weaponAttackBonus = knife ? knife.attack : bestMeleeWeapon.attack;
            }
            
            player.attack += weaponAttackBonus * durabilityFactor;
        }
    }

    // 3. 全ての装備品をループし、攻撃力以外のステータス（防御力など）を合算する
    player.equipment.forEach(item => {
        const durabilityFactor = (item.durability === undefined ? 100 : item.durability) / 100;
        player.defense += (item.defense || 0) * durabilityFactor;
        player.insulation += (item.insulation || 0) * durabilityFactor;
        
        if(item.effects) {
            const isBroken = item.durability !== undefined && item.durability <= 0;
            if (!isBroken) {
                if(item.effects.maxWeight) player.maxWeight += item.effects.maxWeight;
                if(item.effects.maxVolume) player.maxVolume += item.effects.maxVolume;
            }
        }
    });

    // 4. ステータスを整数に丸め、最終的な重量と容量を計算
    player.attack = Math.floor(player.attack);
    player.defense = Math.floor(player.defense);
    
    player.weight = [...player.inventory, ...player.equipment].reduce((sum, item) => sum + (item.weight || 0), 0);
    player.volume = player.inventory.reduce((sum, item) => sum + (item.volume || 0), 0);
}
// index.html内

function equipItem(idx) {
    const itemToEquip = player.inventory[idx];
    if (!itemToEquip) { console.error("equipItem: Invalid item index.", idx); return; }

    // --- 武器以外の装備品の処理 ---
    if (itemToEquip.slot !== 'weapon' || !itemToEquip.handedness) {
        let slot = itemToEquip.slot;
        if (!slot) { speakAndAlert(getString("alert_cannot_equip")); return; }
        
        const doEquip = () => {
            snapshotStats();
            let replacedItem = player.equipment.find(e => e.slot === slot);
            if(replacedItem) {
                const replacedItemIndex = player.equipment.findIndex(e => e.slot === slot);
                if (replacedItemIndex > -1) {
                    const itemToUnequip = player.equipment.splice(replacedItemIndex, 1)[0];
                    player.inventory.push(itemToUnequip);
                }
            }
            const newEquipIndex = player.inventory.findIndex(i => i === itemToEquip);
            if (newEquipIndex === -1) { console.error("Could not find item to equip after unequipping old one."); hideItemDetail(); return; }
            let newEquip = player.inventory.splice(newEquipIndex, 1)[0];
            player.equipment.push(newEquip);
            const logMessage = replacedItem ? getString("log_equip_swap", { oldItemName: getItemDisplayName(replacedItem), newItemName: getItemDisplayName(newEquip) }) : getString("log_equip_item", { itemName: getItemDisplayName(newEquip) });
            updateEquippedStats(); hideItemDetail();
            if (currentEnemy) {
                triggerCombatTurnForAction(getString("log_equip_attacked", { logMessage: logMessage }));
            } else {
                log(logMessage); updateItemPanels(); updateStatus(); updateCharacterBody();
            }
        };

        let replacedItem = player.equipment.find(e => e.slot === slot);
        if (replacedItem) showItemComparisonModal(itemToEquip, replacedItem, doEquip, () => log(getString("log_equip_swap_canceled")));
        else doEquip();
        return;
    }

    // --- 武器の装備処理 ---
    const mainHandWeapon = player.equipment.find(e => e.slot === 'main_hand' || e.handedness === 'two');
    const offHandWeapon = player.equipment.find(e => e.slot === 'off_hand');

    if (itemToEquip.handedness === 'two') {
        const confirmMessage = getString("confirm_equip_two_handed", { itemName: getItemDisplayName(itemToEquip) });
        
        speakAndConfirm(confirmMessage, () => {
            snapshotStats();
            // 修正点：現在装備している武器をすべて外す
            if (mainHandWeapon) {
                const mainHandIndex = player.equipment.findIndex(e => e === mainHandWeapon);
                if(mainHandIndex > -1) unequipItem(mainHandIndex, false);
            }
            if (offHandWeapon) {
                 const offHandIndex = player.equipment.findIndex(e => e === offHandWeapon);
                 if(offHandIndex > -1) unequipItem(offHandIndex, false);
            }

            const newWeaponIndex = player.inventory.findIndex(i => i === itemToEquip);
            if (newWeaponIndex === -1) { console.error("Could not find two-handed weapon after unequipping."); hideItemDetail(); return; }
            
            const newWeapon = player.inventory.splice(newWeaponIndex, 1)[0];
            newWeapon.slot = 'main_hand'; // 両手武器はmain_handスロットを使用
            player.equipment.push(newWeapon);
            
            const logMessage = getString("log_equip_two_handed", { itemName: getItemDisplayName(newWeapon) });
            updateEquippedStats(); hideItemDetail();
            if(currentEnemy){
                triggerCombatTurnForAction(getString("log_equip_attacked", { logMessage: logMessage }));
            } else {
                log(logMessage); updateItemPanels(); updateStatus(); updateCharacterBody();
            }
        });
    } 
    else if (itemToEquip.handedness === 'one') {
        const equipToOneHand = (targetSlot) => {
            const currentWeaponInSlot = player.equipment.find(e => e.slot === targetSlot);
            
            const doEquipAction = () => {
                snapshotStats();
                const twoHandedWeapon = player.equipment.find(e => e.handedness === 'two');
                if (twoHandedWeapon) {
                     const twoHandedIndex = player.equipment.findIndex(e => e === twoHandedWeapon);
                     if(twoHandedIndex > -1) unequipItem(twoHandedIndex, false);
                }
                
                if (currentWeaponInSlot) {
                    const currentWeaponIndex = player.equipment.findIndex(e => e === currentWeaponInSlot);
                    if(currentWeaponIndex > -1) unequipItem(currentWeaponIndex, false);
                }

                const newWeaponIndex = player.inventory.findIndex(i => i === itemToEquip);
                if (newWeaponIndex === -1) { console.error("Could not find one-handed weapon after unequipping."); hideItemDetail(); return; }
                
                const newWeapon = player.inventory.splice(newWeaponIndex, 1)[0];
                newWeapon.slot = targetSlot;
                player.equipment.push(newWeapon);
                
                const logMessage = getString("log_equip_one_handed", { slotName: getSlotName(targetSlot), itemName: getItemDisplayName(newWeapon) });
                updateEquippedStats(); hideItemDetail();
                
                if(currentEnemy){
                    triggerCombatTurnForAction(getString("log_equip_attacked", { logMessage: logMessage }));
                } else {
                    log(logMessage); updateItemPanels(); updateStatus(); updateCharacterBody();
                }
            };

            if (currentWeaponInSlot) {
                showItemComparisonModal(itemToEquip, currentWeaponInSlot, doEquipAction, () => log(getString("log_equip_swap_canceled")));
            } else {
                doEquipAction();
            }
        };
        
        // 装備するスロットを選択
        if (!mainHandWeapon || mainHandWeapon.handedness === 'two') {
            equipToOneHand('main_hand');
        } else if (!offHandWeapon) {
            equipToOneHand('off_hand');
        } else {
             // 両手が埋まっている場合は、メインハンドと交換するか確認する
             equipToOneHand('main_hand');
        }
    }
}
function useItem(idx, source = 'inventory') {
  let item = (source === 'inventory') ? player.inventory[idx] : player.equipment[idx];
  if(item.useAction) {
      window[item.useAction](item, idx, source);
      return;
  }
  if (item.type === "consumable") {
    snapshotStats();
    if(item.isSealed) { log(getString("log_item_is_sealed", { itemName: getItemDisplayName(item) })); hideItemDetail(); return; }
    if (item.name.includes("包帯") || item.name.includes("キット")) {
        const bleedingIndex = player.injuries.findIndex(i => i.type === 'bleeding');
        if (bleedingIndex > -1) {
            player.injuries.splice(bleedingIndex, 1);
            log(getString("log_bleeding_stopped"));
        }
    }
    if (item.freshness !== undefined) {
        let foodPoisoningChance = 0;
        if (item.freshness <= 0) foodPoisoningChance = 0.8; 
        else if (item.freshness < 40) foodPoisoningChance = 0.1;
        if (Math.random() < foodPoisoningChance && !player.sicknesses.some(s => s.type === 'food_poisoning')) {
            log(getString("log_food_poisoning"), true);
            player.sicknesses.push({ type: 'food_poisoning', duration: 36 });
        }
    }
    if (item.effects) {
        for (const stat in item.effects) {
            if (player[stat] !== undefined) {
              let effect = item.effects[stat];
              if (maxStats[stat]) player[stat] = Math.min(maxStats[stat], player[stat] + effect); else player[stat] += effect;
            }
        }
    }
    log(getString("log_use_item", { itemName: getItemDisplayName(item) }));
    const removedItem = player.inventory.splice(idx, 1)[0];
    player.weight -= removedItem.weight || 0;
    player.volume -= removedItem.volume || 0;
    logStatChanges(playerStatsBeforeAction, player);
    updateItemPanels(); updateStatus(); updateCharacterBody(); hideItemDetail();
  }
}

// --- Sound Effects ---
function playSound(type) {
    try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        if(!ctx) return;
        const o = ctx.createOscillator(), g = ctx.createGain();
        o.connect(g); g.connect(ctx.destination);
        let duration = 0.2;
        switch(type) {
            case 'start': o.type = 'sine'; o.frequency.setValueAtTime(440, ctx.currentTime); g.gain.setValueAtTime(0.2, ctx.currentTime); o.frequency.exponentialRampToValueAtTime(880, ctx.currentTime + 0.2); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.2); duration = 0.2; break;
case 'attack': o.type = 'triangle'; g.gain.setValueAtTime(0.2, ctx.currentTime); o.frequency.setValueAtTime(880, ctx.currentTime); o.frequency.exponentialRampToValueAtTime(220, ctx.currentTime + 0.15); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.15); duration = 0.2; break;
            case 'gunshot': o.type = 'sawtooth'; o.frequency.setValueAtTime(2000, ctx.currentTime); o.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.1); g.gain.setValueAtTime(0.4, ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.2); duration = 0.3; break;
            case 'damage': o.type = 'square'; o.frequency.setValueAtTime(110, ctx.currentTime); g.gain.setValueAtTime(0.3, ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.2); duration = 0.25; break;
            case 'victory': o.type = 'sine'; g.gain.setValueAtTime(0.2, ctx.currentTime); o.frequency.setValueAtTime(523.25, ctx.currentTime); o.frequency.linearRampToValueAtTime(659.26, ctx.currentTime + 0.1); o.frequency.linearRampToValueAtTime(783.99, ctx.currentTime + 0.2); o.frequency.linearRampToValueAtTime(1046.50, ctx.currentTime + 0.4); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.5); duration = 0.6; break;
            case 'defeat': o.type = 'sawtooth'; g.gain.setValueAtTime(0.3, ctx.currentTime); o.frequency.setValueAtTime(220, ctx.currentTime); o.frequency.exponentialRampToValueAtTime(55, ctx.currentTime + 1.0); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 1.0); duration = 1.1; break;
            case 'zombie': o.frequency.value = 400; o.type = "square"; g.gain.setValueAtTime(0.1, ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.00001, ctx.currentTime + 0.4); duration = 0.5; break;
        }
        o.start(); o.stop(ctx.currentTime + duration);
    } catch (e) { console.error("Web Audio API not supported or failed.", e); }
}
// ▼▼▼ 以下の2つの関数を新しく追加してください ▼▼▼

/**
 * あくび効果音の開始と停止を管理する関数
 */
function manageYawnEffect() {
    const sleepPercent = (player.sleep / maxStats.sleep) * 100;
    const isSleepy = sleepPercent < 50;

    if (isSleepy && !yawnTimer) {
        // 眠気があり、タイマーが動いていないなら、最初のあくびをスケジュールする
        const initialDelay = (Math.random() * 20 + 10) * 1000; // 10〜30秒後に最初のあくび
        yawnTimer = setTimeout(playYawnAndScheduleNext, initialDelay);
    } else if (!isSleepy && yawnTimer) {
        // 眠気がなく、タイマーが動いているなら停止する
        clearTimeout(yawnTimer);
        yawnTimer = null;
    }
}

/**
 * あくびを再生し、次のあくびを不定期にスケジュールする関数
 */

/**
 * 低体温時の震え効果音の開始と停止を管理する関数 (デバッグ版)
 */
/**
 * 低体温時の震え効果音の開始と停止を管理する関数
 */
function manageShiverEffect() {
    const isHypothermic = player.bodyTemp < 35.5;

    // 低体温状態で、かつタイマーが動いていない場合のみ、ループを開始する
    if (isHypothermic && !shiverTimer) {
        // 最初の効果音を少し遅らせて開始
        const initialDelay = (Math.random() * 15 + 5) * 1000;
        shiverTimer = setTimeout(playShiverAndScheduleNext, initialDelay);
    }
}

/**
 * 震え音を再生し、次の効果音を不定期にスケジュールする関数
 * この関数自身がループを継続するかどうかを判断する
 */
function playShiverAndScheduleNext() {
    if (player.bodyTemp >= 35.5) {
        clearTimeout(shiverTimer);
        shiverTimer = null;
        return;
    }
    playPlayerVoice('sounds/shiver.wav', 0.6);
    const nextShiverDelay = (Math.random() * 40 + 20) * 1000;
    shiverTimer = setTimeout(playShiverAndScheduleNext, nextShiverDelay);
}
function playYawnAndScheduleNext() {
    playPlayerVoice('sounds/yawn.wav', 0.7);
    const nextYawnDelay = (Math.random() * 50 + 40) * 1000;
    yawnTimer = setTimeout(playYawnAndScheduleNext, nextYawnDelay);
}
function startCombat(enemy, playerInitiates = true) {
    isInteractionActive = true;
    currentEnemy = enemy;
    currentNPC = null;

    // 戦闘に関係ないパネルを非表示にする
    const panelsToHide = document.querySelectorAll('.panel:not(#combatPanel):not(#statusPanel):not(#inventoryPanel):not(#equipmentPanel):not(#itemDetailPanel)');
    panelsToHide.forEach(p => {
        if (!p.classList.contains('minimized')) {
            p.style.display = 'none';
        }
    });
    document.getElementById('sleepNowBtn').style.display = 'none';

    // 戦闘用パネルを表示する
    const combatPanel = document.getElementById('combatPanel');
    combatPanel.style.display = 'block';
    bringToFront(combatPanel);
    document.getElementById('statusPanel').style.display = 'block';
    bringToFront(document.getElementById('statusPanel'));
    document.getElementById('inventoryPanel').style.display = 'flex';
    bringToFront(document.getElementById('inventoryPanel'));
    document.getElementById('equipmentPanel').style.display = 'flex';
    bringToFront(document.getElementById('equipmentPanel'));

    // 戦闘UIの初期化
    document.getElementById('combatEnemyName').textContent = getString(`item_${enemy.name}_name`) || enemy.name;
    updateCombatUI();
    document.getElementById('combatLog').innerHTML = '';
    
    // 最初は全てのボタンを無効化
    document.getElementById('attackMainBtn').disabled = true;
    document.getElementById('attackOffBtn').disabled = true;
    document.getElementById('fireBtn').disabled = true;
    document.getElementById('runBtn').disabled = true;

    const enemyName = getString(`item_${enemy.name}_name`) || enemy.name;
    const startMessageKey = (enemy.isZombie || enemy.isAnimal) ? "combat_start_hostile" : "combat_start_humanoid";
    const startMessage = getString(startMessageKey, { enemyName: enemyName });
    
    // 戦闘開始メッセージを表示
    combatLogMessage(startMessage, 'normal');

    // メッセージを読む時間を考慮して、1.2秒後にターンを開始する
    setTimeout(() => {
        if (!currentEnemy || player.health <= 0) return; // 戦闘が既に終了していたら何もしない

        if (playerInitiates) {
            // プレイヤーが先制攻撃の場合：ボタンを有効化
            log(getString("log_player_initiative"));
            document.getElementById('attackMainBtn').disabled = false;
            document.getElementById('attackOffBtn').disabled = false;
            document.getElementById('fireBtn').disabled = false;
            document.getElementById('runBtn').disabled = false;
            updateCombatUI();
        } else {
            // 敵が先制攻撃の場合：敵のターンを実行
            combatLogMessage(getString("log_preemptive_strike", { enemyName: enemyName }), 'enemyAttack');
            // 敵の攻撃メッセージを読ませるために、さらに少し遅延させる
            setTimeout(() => {
                if (currentEnemy && player.health > 0) {
                    enemyTurn();
                }
            }, 800);
        }
    }, 1200);

    // ボタンのクリックイベントを設定
    document.getElementById('attackMainBtn').onclick = () => handleAttack('main');
    document.getElementById('attackOffBtn').onclick = () => handleAttack('off');
    document.getElementById('fireBtn').onclick = handleFire;
    document.getElementById('runBtn').onclick = handleRun;
}

// --- 渇き ---
function manageSwallowEffect() {
    const isThirsty = (player.thirst / maxStats.thirst) * 100 < 50;
    if (isThirsty && !swallowTimer) {
        const initialDelay = (Math.random() * 20 + 10) * 1000;
        swallowTimer = setTimeout(playSwallowAndScheduleNext, initialDelay);
    }
}
function playSwallowAndScheduleNext() {
    if ((player.thirst / maxStats.thirst) * 100 >= 50) {
        clearTimeout(swallowTimer);
        swallowTimer = null;
        return;
    }
    playPlayerVoice('sounds/swallow.wav', 0.8);
    const nextDelay = (Math.random() * 40 + 30) * 1000;
    swallowTimer = setTimeout(playSwallowAndScheduleNext, nextDelay);
}

// --- 空腹 ---
function manageRumbleEffect() {
    const isHungry = (player.hunger / maxStats.hunger) * 100 < 50;
    if (isHungry && !rumbleTimer) {
        const initialDelay = (Math.random() * 25 + 15) * 1000;
        rumbleTimer = setTimeout(playRumbleAndScheduleNext, initialDelay);
    }
}
function playRumbleAndScheduleNext() {
    if ((player.hunger / maxStats.hunger) * 100 >= 50) {
        clearTimeout(rumbleTimer);
        rumbleTimer = null;
        return;
    }
    playPlayerVoice('sounds/rumble.wav', 0.5);
    const nextDelay = (Math.random() * 50 + 40) * 1000;
    rumbleTimer = setTimeout(playRumbleAndScheduleNext, nextDelay);
}

// --- 発熱 ---
function manageCoughEffect() {
    const isFeverish = player.sicknesses.some(s => s.type === 'fever');
    if (isFeverish && !coughTimer) {
        const initialDelay = (Math.random() * 20 + 10) * 1000;
        coughTimer = setTimeout(playCoughAndScheduleNext, initialDelay);
    }
}
function playCoughAndScheduleNext() {
    if (!player.sicknesses.some(s => s.type === 'fever')) {
        clearTimeout(coughTimer);
        coughTimer = null;
        return;
    }
    playPlayerVoice('sounds/cough.wav', 0.7);
    const nextDelay = (Math.random() * 45 + 35) * 1000;
    coughTimer = setTimeout(playCoughAndScheduleNext, nextDelay);
}
// --- 出血 ---
function manageHeartbeatEffect() {
    const isBleeding = player.injuries.some(i => i.type === 'bleeding');
    if (isBleeding && !heartbeatTimer) {
        const initialDelay = (Math.random() * 8 + 4) * 1000;
        heartbeatTimer = setTimeout(playHeartbeatAndScheduleNext, initialDelay);
    }
}
function playHeartbeatAndScheduleNext() {
    if (!player.injuries.some(i => i.type === 'bleeding')) {
        clearTimeout(heartbeatTimer);
        heartbeatTimer = null;
        return;
    }
    playPlayerVoice('sounds/heartbeat.wav', 0.9);
    const nextDelay = (Math.random() * 10 + 10) * 1000;
    heartbeatTimer = setTimeout(playHeartbeatAndScheduleNext, nextDelay);
}

// --- 打撲 ---
function manageGruntEffect() {
    const isBruised = player.injuries.some(i => i.type === 'bruise');
    if (isBruised && !gruntTimer) {
        const initialDelay = (Math.random() * 30 + 15) * 1000;
        gruntTimer = setTimeout(playGruntAndScheduleNext, initialDelay);
    }
}
function playGruntAndScheduleNext() {
    if (!player.injuries.some(i => i.type === 'bruise')) {
        clearTimeout(gruntTimer);
        gruntTimer = null;
        return;
    }
    playPlayerVoice('sounds/grunt.wav', 0.8);
    const nextDelay = (Math.random() * 60 + 40) * 1000;
    gruntTimer = setTimeout(playGruntAndScheduleNext, nextDelay);
}


// --- 骨折 ---
function managePainEffect() {
    const isFractured = player.injuries.some(i => i.type === 'fracture');
    if (isFractured && !painTimer) {
        const initialDelay = (Math.random() * 25 + 10) * 1000;
        painTimer = setTimeout(playPainAndScheduleNext, initialDelay);
    }
}
function playPainAndScheduleNext() {
    if (!player.injuries.some(i => i.type === 'fracture')) {
        clearTimeout(painTimer);
        painTimer = null;
        return;
    }
    playPlayerVoice('sounds/pain.wav', 0.9);
    const nextDelay = (Math.random() * 50 + 30) * 1000;
    painTimer = setTimeout(playPainAndScheduleNext, nextDelay);
}
// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function updateCombatUI() {
    const playerCombatImageContainer = document.getElementById('combatPlayerAscii');
    const enemyCombatImageContainer = document.getElementById('combatEnemyAscii');

    // プレイヤー画像の表示と枠線更新
    const playerIconPath = (character.gender === "男性") ? "images/player_male.png" : "images/player_female.png";
    playerCombatImageContainer.innerHTML = getIconHTML(playerIconPath, 96);
    const playerImg = playerCombatImageContainer.querySelector('img');
    if (playerImg) {
        const playerBorderColor = getHealthColor(player.health, maxStats.health);
        playerImg.style.borderColor = playerBorderColor;
    }

    if (currentEnemy) {
        // 敵画像の表示と枠線更新
        enemyCombatImageContainer.innerHTML = getIconHTML(currentEnemy.icon, 96);
        const enemyImg = enemyCombatImageContainer.querySelector('img');
        if (enemyImg) {
            let enemyMaxHealth = 100;
            if (currentEnemy.isAnimal) {
                const template = wildlifeTemplates.find(t => t.type === currentEnemy.type);
                if(template) enemyMaxHealth = template.health;
            } else if (currentEnemy.isZombie) {
                enemyMaxHealth = currentEnemy.maxHealth || 100;
            } else {
                const template = npcTemplates.find(t => t.type === currentEnemy.type);
                if(template) enemyMaxHealth = template.health;
            }
            const enemyBorderColor = getHealthColor(currentEnemy.health, enemyMaxHealth);
            enemyImg.style.borderColor = enemyBorderColor;
        }
        document.getElementById('combatEnemyHealth').textContent = Math.max(0, currentEnemy.health).toFixed(0);
    }

    document.getElementById('combatPlayerHealth').textContent = `${Math.max(0, player.health).toFixed(0)} / ${maxStats.health}`;
    document.getElementById('combatPlayerAttack').textContent = player.attack;
    document.getElementById('combatPlayerDefense').textContent = player.defense;
    const playerEquipDiv = document.getElementById('combatEquipmentList');
    playerEquipDiv.innerHTML = player.equipment.length > 0 ? player.equipment.map(item => `<div>${getIconHTML(item.graphic, 16)} ${getSlotName(item.slot)}: ${getItemDisplayName(item)}</div>`).join('') : getString('item_none');
    
    const playerInjuriesDiv = document.getElementById('combatPlayerInjuries');
    if (player.injuries.length > 0) {
        playerInjuriesDiv.style.display = 'block';
        // ▼▼▼ このブロックを修正しました ▼▼▼
        playerInjuriesDiv.innerHTML = player.injuries.map(i => {
            let textKey, tooltipType;
            if (i.type === 'fracture') {
                textKey = i.splinted ? 'condition_splinted_fracture_title' : 'condition_fracture_title';
                tooltipType = i.splinted ? 'splinted_fracture' : 'fracture';
            } else {
                textKey = `condition_${i.type}_title`;
                tooltipType = i.type;
            }
            // ツールチップを表示するためのspanタグで囲む
            return `<span onmouseenter="showConditionTooltip(event, '${tooltipType}')" onmouseleave="hideStatusPreview()" style="cursor: help; text-decoration: underline dotted;">${getString(textKey)}</span>`;
        }).join(', ');
        // ▲▲▲ 修正ここまで ▲▲▲
    } else {
        playerInjuriesDiv.style.display = 'none';
    }

    const enemyEquipPanel = document.getElementById('combatEnemyEquipment');
    const enemyEquipListDiv = document.getElementById('combatEnemyEquipmentList');
     if (currentEnemy && (currentEnemy.isZombie || currentEnemy.isAnimal || !currentEnemy.equipment || currentEnemy.equipment.length === 0)) {
        enemyEquipPanel.style.display = 'none';
    } else if (currentEnemy) {
        enemyEquipPanel.style.display = 'block';
        enemyEquipListDiv.innerHTML = currentEnemy.equipment.map(item => `<div>${getIconHTML(item.graphic, 16)} ${getItemDisplayName(item)}</div>`).join('');
    }

    const attackContainer = document.getElementById('combatAttackContainer'), defenseContainer = document.getElementById('combatDefenseContainer');
    attackContainer.onmouseenter = (e) => showCombatStatTooltip('attack', e);
    attackContainer.onmouseleave = hideCombatStatTooltip;
    attackContainer.onmousemove = (e) => updatePreviewPosition(e);
    defenseContainer.onmouseenter = (e) => showCombatStatTooltip('defense', e);
    defenseContainer.onmouseleave = hideCombatStatTooltip;
    defenseContainer.onmousemove = (e) => updatePreviewPosition(e);
    
    const mainHandWeapon = player.equipment.find(e => e.slot === 'main_hand' || e.handedness === 'two');
    const offHandWeapon = player.equipment.find(e => e.slot === 'off_hand');
    const attackMainBtn = document.getElementById('attackMainBtn');
    const attackOffBtn = document.getElementById('attackOffBtn');
    const fireBtn = document.getElementById('fireBtn');
    const loadedGun = player.equipment.find(e => e.ammoType && e.loadedAmmo > 0);

    attackMainBtn.style.display = 'none';
    attackOffBtn.style.display = 'none';
    fireBtn.style.display = 'none';
    attackMainBtn.style.gridColumn = 'auto';
    attackOffBtn.style.gridColumn = 'auto';

    if (mainHandWeapon) {
        attackMainBtn.textContent = `${getString('combat_attack')} (${getBaseItemName(mainHandWeapon)})`;
        attackMainBtn.style.display = 'block';
        if (mainHandWeapon.handedness === 'two') {
            attackMainBtn.style.gridColumn = 'span 2';
        }
    } else {
        attackMainBtn.textContent = `${getString('combat_attack')} (${getString('combat_attack_bare_hand')})`;
        attackMainBtn.style.display = 'block';
    }
    if (offHandWeapon) {
        attackOffBtn.textContent = `${getString('combat_attack')} (${getBaseItemName(offHandWeapon)})`;
        attackOffBtn.style.display = 'block';
        if (!mainHandWeapon) {
             attackMainBtn.style.display = 'none';
             attackOffBtn.style.gridColumn = 'span 2';
        }
    }
    if (loadedGun) {
        fireBtn.style.display = 'block';
        if (attackMainBtn.style.display === 'block' && attackOffBtn.style.display === 'block') {
            attackOffBtn.style.display = 'none';
            attackMainBtn.style.gridColumn = '1 / 2';
            fireBtn.style.gridColumn = '2 / 3';
        } 
        else if (attackMainBtn.style.display === 'block') {
            attackMainBtn.style.gridColumn = '1 / 2';
            fireBtn.style.gridColumn = '2 / 3';
        }
        else if (attackOffBtn.style.display === 'block') {
            attackOffBtn.style.gridColumn = '1 / 2';
            fireBtn.style.gridColumn = '2 / 3';
        }
    }
}
function showCombatStatTooltip(stat, event) {
    const preview = document.getElementById("statusPreview");
    let contentHtml = `<strong>${getString(stat === 'attack' ? "tooltip_combat_stat_attack" : "tooltip_combat_stat_defense")}</strong><br/>`;
    let total = 0, baseStat = 0;
    if (stat === 'attack') { baseStat = player.baseAttack; total = player.attack; } else { baseStat = player.baseDefense; total = player.defense; }
    
    contentHtml += `<div>${getString("tooltip_combat_stat_base")}: ${baseStat}</div><div style="border-bottom: 1px solid #555; margin: 2px 0;"></div>`;
    
    player.equipment.forEach(item => {
        const durabilityFactor = (item.durability === undefined ? 100 : item.durability) / 100;
        let bonus = 0;
        if (stat === 'attack') {
             let itemAttack = item.attack || 0;
            if (item.ammoType && item.loadedAmmo === 0 && item.name === 'ライフル' && item.bayonetAttached) {
                const knife = items.find(i => i.name === 'ナイフ');
                itemAttack = knife ? knife.attack : item.attack;
            }
            bonus = itemAttack * durabilityFactor;
        } else {
            bonus = (item.defense || 0) * durabilityFactor;
        }

        if (bonus > 0) contentHtml += `<div>${getBaseItemName(item)}: +${Math.floor(bonus)}</div>`;
    });
    
    contentHtml += `<div style="border-bottom: 1px solid #555; margin: 2px 0;"></div><div><strong>${getString("tooltip_combat_stat_total")}: ${total}</strong></div>`;
    preview.innerHTML = contentHtml; 
    preview.style.display = 'block'; 
    updatePreviewPosition(event);
}


function hideCombatStatTooltip() { document.getElementById("statusPreview").style.display = "none"; }


function combatLogMessage(msg, type = 'normal', onEndCallback) {
    const combatLog = document.getElementById('combatLog'), msgDiv = document.createElement('div');
    msgDiv.textContent = msg;
    if (type === 'playerAttack') msgDiv.style.color = 'lightblue'; else if (type === 'enemyAttack') msgDiv.style.color = 'indianred';
    else if (type === 'playerFire') msgDiv.style.color = '#e67e22';
    else if (type === 'victory') msgDiv.style.color = 'lightgreen'; else if (type === 'defeat') msgDiv.style.color = 'red';
    else if (type === 'run') msgDiv.style.color = 'yellow';
    combatLog.appendChild(msgDiv); combatLog.scrollTop = combatLog.scrollHeight;
    speak(msg, onEndCallback);
}

function showDealtDamage(dmg) {
    const damageText = document.createElement('div'); damageText.textContent = `-${dmg}`;
    damageText.style.cssText = "position: absolute; left: 50%; top: 40%; transform: translate(-50%, -50%) scale(1); font-size: 4em; font-weight: bold; color: #3498db; text-shadow: 0 0 8px #000; opacity: 0; pointer-events: none; transition: opacity 0.5s ease-out, transform 0.5s ease-out; z-index: 100;";
    const enemyPanel = document.getElementById('combatEnemy');
    enemyPanel.appendChild(damageText);
    setTimeout(() => { damageText.style.opacity = '1'; damageText.style.transform = 'translate(-50%, -50%) scale(1.5)'; }, 10);
    setTimeout(() => { damageText.style.opacity = '0'; damageText.style.transform = 'translate(-50%, -50%) scale(3)'; setTimeout(() => { if(damageText.parentNode) enemyPanel.removeChild(damageText); }, 500); }, 600);
}

// index.html内
// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function handleAttack(hand) {
    snapshotStats();
    document.getElementById('attackMainBtn').disabled = true;
    document.getElementById('attackOffBtn').disabled = true;
    document.getElementById('fireBtn').disabled = true; 
    document.getElementById('runBtn').disabled = true;
    
    playSoundFile('sounds/attack.wav');
    createSound(player.x, player.y, 4);
    
    let weapon, weaponNameKey = "combat_attack_bare_hand", baseDamage = player.baseAttack;
    const targetSlot = (hand === 'off') ? 'off_hand' : 'main_hand';
    weapon = player.equipment.find(e => e.slot === targetSlot);

    if (!weapon && hand === 'main') {
        weapon = player.equipment.find(e => e.handedness === 'two');
    }

    if (weapon) {
        const durabilityFactor = (weapon.durability === undefined ? 100 : weapon.durability) / 100;
        let itemAttack = weapon.attack || 0;
        
        weaponNameKey = getBaseItemName(weapon);
        
        if (weapon.ammoType && weapon.loadedAmmo === 0 && weapon.name === 'ライフル' && weapon.bayonetAttached) {
            const knife = items.find(i => i.name === 'ナイフ');
            itemAttack = knife ? knife.attack : weapon.attack;
        }
        baseDamage = Math.floor(itemAttack * durabilityFactor);
    }
    
    const playerDamage = Math.max(1, baseDamage - (currentEnemy.defense || 0) + (Math.floor(Math.random() * 5) - 2));
    currentEnemy.health -= playerDamage;
    showDealtDamage(playerDamage.toFixed(0));
    
    if (weapon && weapon.durability !== undefined) {
        weapon.durability -= 1; 
        if (weapon.durability <= 0) {
            weapon.durability = 0;
            combatLogMessage(getString("combat_weapon_break", { weaponName: getItemDisplayName(weapon) }), 'enemyAttack');
        }
    }
    
    const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;
    const logKey = weapon ? "combat_attack_player" : "combat_attack_player_barehand";
    
    const weaponNameForLog = weapon ? getBaseItemName(weapon) : getString("combat_attack_bare_hand");
    const logText = getString(logKey, { 
        weaponName: weaponNameForLog, 
        enemyName: enemyName, 
        damage: playerDamage.toFixed(0) 
    });

    combatLogMessage(logText, 'playerAttack', () => {
        updateEquippedStats(); 
        updateCombatUI();
        updateItemPanels();
        if (currentEnemy.health <= 0) {
            endCombat(true);
        } else if (currentEnemy.flees && Math.random() < 0.5) {
            const fleeEnemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;
            
            // ▼▼▼ ここからが修正箇所です ▼▼▼
            const fleeTile = findSafeFleeTileForEntity(currentEnemy);
            if (fleeTile) {
                const enemyInList = entities.find(e => e === currentEnemy);
                if (enemyInList) {
                    enemyInList.x = fleeTile.x;
                    enemyInList.y = fleeTile.y;
                }
            }
            // ▲▲▲ 修正ここまで ▲▲▲

            // 逃走メッセージのキー名が不自然だったため修正
            combatLogMessage(getString("log_enemy_fled", { enemyName: fleeEnemyName }), 'run', () => endCombat('escaped'));
        }
        else {
            enemyTurn();
        }
    });
}
function handleFire() {
    snapshotStats();
    document.getElementById('attackMainBtn').disabled = true;
    document.getElementById('attackOffBtn').disabled = true;
    document.getElementById('fireBtn').disabled = true;
    document.getElementById('runBtn').disabled = true;
    
    const gun = player.equipment.find(e => e.ammoType && e.loadedAmmo > 0);
    if (!gun) {
        document.getElementById('runBtn').disabled = false;
        return;
    }

    playSound('gunshot');
    createSound(player.x, player.y, 25);
    gun.loadedAmmo--;
    
    const playerDamage = Math.max(1, gun.fireDamage - (currentEnemy.defense || 0) + (Math.floor(Math.random() * 10) - 5));
    currentEnemy.health -= playerDamage;
    showDealtDamage(playerDamage.toFixed(0));

    const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;
    // 修正点：ログメッセージの武器名に getBaseItemName を使用
    const weaponName = getBaseItemName(gun);
    const logText = getString("combat_fire_player", { 
        weaponName: weaponName, 
        enemyName: enemyName, 
        damage: playerDamage.toFixed(0) 
    });

    combatLogMessage(logText, 'playerFire', () => {
        updateCombatUI();
        if (currentEnemy.health <= 0) endCombat(true);
        else enemyTurn();
    });
}
// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function enemyTurn() {
    playSound('damage');
    const enemyDamage = Math.max(1, currentEnemy.attack - player.defense + (Math.floor(Math.random() * 5) - 2));
    player.health -= enemyDamage; showDamage(enemyDamage.toFixed(0));
    
    const injuryChance = enemyDamage / 50;
    if (Math.random() < injuryChance) {
        const hasBleeding = player.injuries.some(i => i.type === 'bleeding');
        const hasFracture = player.injuries.some(i => i.type === 'fracture');
        
        if (enemyDamage > 15 && Math.random() < 0.3 && !hasFracture) {
            player.injuries.push({ type: 'fracture', duration: 48, splinted: false });
            // ▼▼▼ この行を修正しました ▼▼▼
            log(getString("log_got_fracture"), true);
        } else if (enemyDamage > 8 && Math.random() < 0.5 && !hasBleeding) {
            player.injuries.push({ type: 'bleeding' });
            // ▼▼▼ この行を修正しました ▼▼▼
            log(getString("log_got_bleeding"), true);
        } else {
            if (!player.injuries.some(i => i.type === 'bruise')) {
                 player.injuries.push({ type: 'bruise', duration: 24 });
                 log(getString("log_got_bruise"), true);
            }
        }
    }

    const enemyName = getString(`item_${currentEnemy.name}_name`) || currentEnemy.name;
    const logText = getString("combat_attack_enemy")
        .replace('{enemyName}', enemyName)
        .replace('{damage}', enemyDamage.toFixed(0));
    
    combatLogMessage(logText, 'enemyAttack', () => {
        updateCombatUI(); 
        updateStatus(); 
        updateCharacterBody();
        if (player.health <= 0) {
            endCombat(false);
        }
    });

    if (player.health > 0) {
        setTimeout(() => {
            if (currentEnemy) {
                document.getElementById('attackMainBtn').disabled = false;
                document.getElementById('attackOffBtn').disabled = false;
                document.getElementById('fireBtn').disabled = false;
                document.getElementById('runBtn').disabled = false;
                updateCombatUI(); 
            }
        }, 800);
    }
}


// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function handleRun() {
    snapshotStats();
    document.getElementById('attackMainBtn').disabled = true;
    document.getElementById('attackOffBtn').disabled = true;
    document.getElementById('fireBtn').disabled = true;
    document.getElementById('runBtn').disabled = true;
    player.thirst -= 5; player.morale -= 8;
    const escapeChance = currentEnemy.isAnimal ? 0.6 : 0.3;

    if (Math.random() < escapeChance) {
        const enemyInList = entities.find(e => e.x === currentEnemy.x && e.y === currentEnemy.y);
        if (enemyInList) enemyInList.stunnedTurns = 1;

        // ▼▼▼ ここからが修正箇所です ▼▼▼
        const fleeTile = findSafeFleeTile();
        if (fleeTile) {
            player.x = fleeTile.x;
            player.y = fleeTile.y;
        }
        // ▲▲▲ 修正ここまで ▲▲▲

        combatLogMessage(getString("combat_run_success"), "run", () => {
            updateStatus();
            endCombat('escaped');
        });
    } else {
        combatLogMessage(getString("combat_run_fail"), "run", () => {
            updateStatus();
            enemyTurn();
        });
    }
}

function endCombat(result) {
    const wasVictory = result === true, wasEscaped = result === 'escaped';
    const originalEnemy = { ...currentEnemy };
    const enemyIndex = entities.findIndex(e => e && currentEnemy && e.x === currentEnemy.x && e.y === currentEnemy.y);

    const cleanupAndExit = () => {
        const allPanels = document.querySelectorAll('.panel');
        allPanels.forEach(panel => {
            if (['combatPanel', 'dialoguePanel', 'tradePanel', 'storagePanel', 'workbenchPanel', 'itemDetailPanel'].includes(panel.id)) {
                panel.style.display = 'none';
            } else if (!panel.classList.contains('minimized')) {
                panel.style.display = 'block';
                if (['mapPanel', 'inventoryPanel', 'equipmentPanel', 'minimapPanel', 'craftingPanel', 'currentLocationPanel'].includes(panel.id)) {
                    panel.style.display = 'flex';
                }
            }
        });
        isInteractionActive = false;
        if (wasVictory) {
            if (originalEnemy.isAnimal && originalEnemy.loot) {
                const corpse = { x: originalEnemy.x, y: originalEnemy.y, type: 'corpse', name: `${originalEnemy.name}の死体`, graphic: 'images/corpse_bones.png', duration: 48, isAnimalCorpse: true, unbutchered: true, potentialLoot: originalEnemy.loot };
                placedObjects.push(corpse);
            } else if (!originalEnemy.isZombie) {
                const lootItems = [...(originalEnemy.inventory || []), ...(originalEnemy.equipment || [])];
                const corpse = { x: originalEnemy.x, y: originalEnemy.y, type: 'corpse', name: `${originalEnemy.name}の死体`, graphic: 'images/corpse_bones.png', duration: 24, isHumanCorpse: true, unsearched: true, potentialLoot: lootItems };
                placedObjects.push(corpse);
            }
            if (enemyIndex > -1) entities.splice(enemyIndex, 1);
        }
        currentEnemy = null; currentNPC = null;
        
        // ▼▼▼ 修正箇所 ▼▼▼
        updateExploration(); // プレイヤーの新しい位置で視界を更新
        // ▲▲▲ 修正ここまで ▲▲▲

        drawMap(); 
        updateStatus(); 
        updateCharacterBody(); 
        updateCurrentLocationPanel(false);
    };

    const enemyName = getString(`item_${originalEnemy.name}_name`) || originalEnemy.name;
    
    if (wasEscaped) {
        cleanupAndExit();
    } else if (wasVictory) {
        playSound('victory');
        combatLogMessage(getString("combat_end_victory", { enemyName: enemyName }), 'victory', () => setTimeout(cleanupAndExit, 1500));
    } else { // 敗北時
        playSound('defeat');
        combatLogMessage(getString("combat_end_defeat", { enemyName: enemyName }), 'defeat', () => {
            setTimeout(() => {
                const gameOverMessage = getString("log_game_over_combat");
                speak(gameOverMessage + " " + getString("log_game_over_title"));
                handleGameOver(gameOverMessage);
                document.getElementById('combatPanel').style.display = 'none';
                isInteractionActive = false; currentEnemy = null; currentNPC = null;
            }, 1500);
        });
    }
}

// --- Game Over System ---
function initGame() {
    stopWeatherEffect();
    stopClouds();
    document.getElementById('startScreen').style.display = 'none';
    document.getElementById('gameClearScreen').style.display = 'none';
    document.querySelectorAll('.panel').forEach(p => p.style.display = 'none');
    restartGame();
}

function restartGame() {
      const panels = ["mapPanel", "statusPanel", "turnPanel", "logPanel", "inventoryPanel", "equipmentPanel", "craftingPanel", "characterPanel", "currentLocationPanel", "minimapPanel"];
      panels.forEach(id => {
      const panel = document.getElementById(id);
      if (panel) {
          panel.style.display = 'block';
           if (['mapPanel', 'inventoryPanel', 'equipmentPanel', 'minimapPanel', 'craftingPanel', 'currentLocationPanel'].includes(id)) {
              panel.style.display = 'flex';
          }
      }
  });
    document.getElementById('itemDetailPanel').style.display = 'none';
    document.getElementById('gameClearScreen').style.display = 'none';
    genMap(); generateWeatherAndTemperature(); snapshotStats();
    drawMap(); updateStatus(); updateItemPanels(); logClear();
    updateCurrentLocationPanel(false); updateCharacterBody(); updateCharacterInfo(); updateTurnInfo();
    log(generateBackstory());
    speakQueuedLogs(); // Add this line right here
    updateBackgroundColor();
    isInteractionActive = false;
    drawMinimap();
    updateMovementButtons();
    isGameRunning = true; // ← この行を追加    
}

// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function showRetryModal(message) {
    if (document.getElementById("retryModal")) return;
    const modalDiv = document.createElement("div"); 
    modalDiv.id = "retryModal";
    modalDiv.style.cssText = `position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #222; color: white; padding: 30px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.6); z-index: 9999; text-align: center; font-family: sans-serif;`;
    
    // ボタンのテキストを「はい」と「メニューに戻る」に変更
    modalDiv.innerHTML = `<p style="font-size: 1.2em; margin-bottom: 20px;">${message}<br>${getString("confirm_retry_q")}</p><button id="retryYesBtn" style="background: #4CAF50; color: white; border: none; padding: 10px 20px; margin-right: 10px; border-radius: 5px; cursor: pointer;">${getString("btn_yes")}</button><button id="retryNoBtn" style="background: #4a4a52; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">${getString("btn_return_to_menu")}</button>`;
    
    document.body.appendChild(modalDiv);
    
    // 「はい」を押すとリトライ
    document.getElementById("retryYesBtn").onclick = () => { modalDiv.remove(); restartGame(); };
    // 「メニューに戻る」を押すと新しい関数を呼び出す
    document.getElementById("retryNoBtn").onclick = returnToMenu;
}
// ▼▼▼ この関数を新しく追加してください ▼▼▼
function returnToMenu() {
    // ▼▼▼ この行を追加 ▼▼▼
    // 進行中の音声読み上げをすべて停止する
    speechSynthesis.cancel();
    // ▲▲▲ 追加ここまで ▲▲▲

    // すべてのゲームパネルを非表示にする
    document.querySelectorAll('.panel').forEach(p => p.style.display = 'none');
    
    // ゲームオーバーのウィンドウを削除
    const modal = document.getElementById("retryModal");
    if (modal) modal.remove();

    // スタート画面を表示する
    document.getElementById('startScreen').style.display = 'flex';
    isGameRunning = false;

    // 天候エフェクトやBGMを停止
    stopWeatherEffect();
    stopClouds();
    if (bgm) {
        bgm.pause();
        bgm.currentTime = 0; // 曲を最初に戻す
    }
}
// ▲▲▲ 追加ここまで ▲▲▲
function handleGameOver(message) {
    isInteractionActive = true;
    stopWeatherEffect();
    stopClouds();
    document.querySelectorAll('.panel').forEach(p => p.style.display = 'none');
    showRetryModal(message);
}
function waitOneTurn() {
    if(isInteractionActive) return;
    snapshotStats();
    // ▼▼▼ この行を修正しました ▼▼▼
    log(getString("info_waited_one_turn"));
    // ▲▲▲ 修正ここまで ▲▲▲
    advanceTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    checkGameOver();
    updateTurnInfo();
    updateCurrentLocationPanel(false);
    speakQueuedLogs();
}
function triggerGameClear() {
    isInteractionActive = true; 
    log(getString("log_salvation_city_discovered")); 
    playSound('victory');
    document.querySelectorAll('.panel').forEach(p => p.style.display = 'none');
    const clearScreen = document.getElementById('gameClearScreen');
    const gateArt = document.getElementById('gateArt');
    const clearHeader = document.getElementById('clearHeader');
    const clearMessage = document.getElementById('clearMessage');
    const art1 = `
      ||||||||
    ||||||||||||
   | o ______ o |
   | o|      |o |
   | o|______|o |
    ||||||||||||
      ||||||||`;
    const msg1 = getString("game_clear_message_1");
    gateArt.textContent = art1; 
    clearMessage.textContent = msg1;
    clearScreen.style.display = 'flex'; 
    speak(getString("game_clear_header"));
    speak(msg1);
    setTimeout(() => {
        const art2 = `
      |||    |||
    |||||    |||||
   | o |    | o |
   | o |    | o |
   | o |____| o |
    |||||    |||||
      |||    |||`;
        const msg2 = getString("game_clear_message_2");
        gateArt.textContent = art2; 
        clearMessage.textContent = msg2; 
        speak(msg2);
    }, 3000);
}

function checkGameOver() {
    if (player.health <= 0 && !isInteractionActive) {
        let reasonKey = "";
        let replacements = {};
        if (player.bodyTemp >= 41) {
            reasonKey = "log_game_over_heatstroke";
            replacements = { temp: player.bodyTemp.toFixed(1) };
        } else if (player.bodyTemp <= 34) {
            reasonKey = "log_game_over_hypothermia";
            replacements = { temp: player.bodyTemp.toFixed(1) };
        } else if (player.thirst <= 0 && player.hunger <= 0) {
            reasonKey = "log_game_over_starvation_dehydration";
        } else if (player.thirst <= 0) {
            reasonKey = "log_game_over_dehydration";
        } else if (player.hunger <= 0) {
            reasonKey = "log_game_over_starvation";
        } else if (player.morale <= 0) {
            reasonKey = "log_game_over_despair";
        } else {
            reasonKey = "log_game_over_weakness";
        }
        const causeMessage = getString(reasonKey, replacements);
        const gameOverMessage = getString("log_game_over_reason", { reason: causeMessage });
        speak(gameOverMessage + " " + getString("log_game_over_title"));
        handleGameOver(gameOverMessage);
    }
}

function playZombieSound() { playSound('zombie'); }
// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function updateCurrentLocationPanel(isEncounter, entity = null) {
    const locationName = document.getElementById("locationName"),
        locationAscii = document.getElementById("locationAscii"),
        droppedItemsList = document.getElementById("droppedItemsList"),
        locationActions = document.getElementById("locationActions");
    locationActions.innerHTML = '';
    let tile = map[player.y][player.x];

    const workbench = placedObjects.find(p => p.x === player.x && p.y === player.y && p.type === 'workbench');
    if (workbench) {
        const useWorkbenchBtn = document.createElement('button');
        useWorkbenchBtn.textContent = getString("btn_use_workbench");
        useWorkbenchBtn.onclick = openWorkbenchPanel;
        locationActions.appendChild(useWorkbenchBtn);
    }
    const harvestableCrop = placedObjects.find(p => p.x === player.x && p.y === player.y && p.isHarvestable);
    if (harvestableCrop) {
        const harvestBtn = document.createElement('button');
        harvestBtn.textContent = getString("btn_harvest_crop", { cropName: getString(`item_${harvestableCrop.planted}_name`) });
        harvestBtn.onclick = harvestCrop;
        locationActions.appendChild(harvestBtn);
    }
    const barricade = placedObjects.find(p => p.x === player.x && p.y === player.y && p.type === 'barricade');
    if (barricade && barricade.health < barricade.maxHealth) {
        const repairBtn = document.createElement('button');
        repairBtn.textContent = getString("btn_repair_barricade");
        repairBtn.onclick = repairBarricade;
        locationActions.appendChild(repairBtn);
    }
    if (tile.loc.isShop) {
        const enterShopBtn = document.createElement('button');
        enterShopBtn.textContent = getString("btn_enter_shop");
        enterShopBtn.onclick = startTraderShopEncounter;
        locationActions.appendChild(enterShopBtn);
    }
    if (tile.loc.nameKey === 'location_cabin') {
        const cabinBtn = document.createElement('button');
        if (player.isInside) {
            cabinBtn.textContent = getString("btn_exit_cabin");
            cabinBtn.onclick = exitCabin;
        } else {
            cabinBtn.textContent = getString("btn_enter_cabin");
            cabinBtn.onclick = enterCabinWithEncounter;
        }
        locationActions.appendChild(cabinBtn);
    }
    if (tile.loc.nameKey === 'location_pond') {
        const washBtn = document.createElement('button');
        washBtn.textContent = getString("btn_wash_body");
        washBtn.onclick = washBody;
        locationActions.appendChild(washBtn);
    }
    if (tile.loc.nameKey === 'location_forest') {
        const gatherBtn = document.createElement('button');
        gatherBtn.id = 'gatherLogBtn';
        gatherBtn.textContent = getString("btn_gather_log", { count: tile.logSupply || 0 });
        const hasAxe = player.inventory.some(i => i.isAxe) || player.equipment.some(i => i.isAxe);
        if (!hasAxe || !tile.logSupply || tile.logSupply <= 0) {
            gatherBtn.disabled = true;
        }
        gatherBtn.onclick = gatherLog;
        locationActions.appendChild(gatherBtn);
    }

    if (isEncounter && entity) {
        locationName.textContent = getString(`item_${entity.name}_name`) || entity.name;
        // ▼▼▼ サイズを 64 から 128 に変更 ▼▼▼
        locationAscii.innerHTML = getIconHTML(entity.icon, 128);
    } else {
        if (player.isInside) {
            locationName.textContent = getString("location_cabin_inside");
            const cabinTemplate = biomeLocations.Forest.find(loc => loc.nameKey === 'location_cabin');
            // ▼▼▼ サイズを 64 から 128 に変更 ▼▼▼
            if(cabinTemplate) locationAscii.innerHTML = getIconHTML(cabinTemplate.icon, 128);

        } else {
            locationName.textContent = getString(tile.loc.nameKey);
            // ▼▼▼ サイズを 64 から 128 に変更 ▼▼▼
            locationAscii.innerHTML = getIconHTML(tile.loc.icon, 128);
        }
    }

    droppedItemsList.innerHTML = "";
    const itemsHere = droppedItems[`${player.x},${player.y}`] || [];
    if (itemsHere.length === 0) {
        droppedItemsList.textContent = getString("item_none");
        return;
    }
    itemsHere.forEach((item, idx) => {
        let div = document.createElement("div");
        div.className = "item";
        let descText = "";
        if (item.type === "consumable" && item.freshness !== undefined) descText = item.freshness > 0 ? `${getString("item_info_freshness")}: ${item.freshness.toFixed(0)}%` : getString("item_info_spoiled");
        else if ((item.type === "equipment" || item.type === "clothing" || item.type === "tool") && item.durability !== undefined) descText = `${getString("item_info_durability")}: ${item.durability.toFixed(0)}%`;
        div.innerHTML = `${getIconHTML(item.graphic, 16)} ${getItemDisplayName(item)}${descText ? ` <span style="font-size: smaller; color: #888;">(${descText})</span>` : ''}`;
        div.onclick = () => showItemDetail(item, idx, 'dropped');
        droppedItemsList.appendChild(div);
    });
}
// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function enterCabinWithEncounter() {
    // 小屋に入った瞬間にプレイヤーを「中にいる」状態にする
    player.isInside = true;
    updateCurrentLocationPanel(false);

    // 5%の確率でエンカウント発生
    if (Math.random() < 0.05) {
        log("小屋のドアをゆっくりと開けると...中に誰かいる！");
        
        const possibleEncounters = [
            { type: 'Zombie', chance: 35 }, { type: 'Bear', chance: 10 }, { type: 'Wolf', chance: 15 },
            { type: 'Survivor', chance: 20 }, { type: 'Trader', chance: 5 }, { type: 'Raider', chance: 15 }
        ];
        let totalChance = possibleEncounters.reduce((sum, e) => sum + e.chance, 0);
        let randomValue = Math.random() * totalChance;
        let selectedType;
        for (const encounter of possibleEncounters) {
            randomValue -= encounter.chance;
            if (randomValue <= 0) {
                selectedType = encounter.type;
                break;
            }
        }

        let newEntity;
        if (selectedType === 'Zombie') {
            const health = 60;
            newEntity = { type: 'Zombie', name: '潜んでいたゾンビ', icon: 'images/zombie.png', x: player.x, y: player.y, health: health, maxHealth: health, attack: 10, defense: 2, visionRange: 3, isZombie: true, stunnedTurns: 0, aiState: 'wandering', target: null, investigationTarget: null };
        } else if (selectedType === 'Bear' || selectedType === 'Wolf') {
            const template = wildlifeTemplates.find(t => t.type === selectedType);
            newEntity = { ...JSON.parse(JSON.stringify(template)), x: player.x, y: player.y, stunnedTurns: 0, aiState: 'attacking', target: player };
        } else {
            newEntity = generateNPC();
            newEntity.type = selectedType;
            const template = npcTemplates.find(t => t.type === selectedType);
            newEntity.name = template.name;
            newEntity.icon = template.icon;
            newEntity.x = player.x;
            newEntity.y = player.y;
        }
        
        // ▼▼▼ ここからが修正箇所です ▼▼▼
        // 1. エンティティをリストに追加
        entities.push(newEntity);

        // 2. マップを再描画して、エンティティをプレイヤーに見せる
        drawMap();
        
        // 3. 少し遅れてからイベントを開始する
        if (newEntity.isZombie || newEntity.type === 'Bear' || newEntity.type === 'Wolf' || newEntity.type === 'Raider') {
            setTimeout(() => startCombat(newEntity, false), 500); // false: 待ち伏せなのでNPCが先制
        } else {
            currentNPC = newEntity;
            setTimeout(() => startNPCEncounter(), 500);
        }
        // ▲▲▲ 修正ここまで ▲▲▲

    } else {
        // 通常通り、誰もいない場合
        drawMap();
        log("小屋に入った。雨風をしのげるだろう。");
    }
}
function exitCabin() {
    player.isInside = false;
    drawMap(); // ← この行を追加
    log("小屋から出た。");
    updateCurrentLocationPanel(false);
    drawMap(); // ← この行を追加してマップを再描画
}
// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function updateCharacterBody() {
  const pre = document.getElementById("charBody");
  if (!pre) return;

  // 最初にinnerHTMLを設定してimg要素を確実に生成する
  if (player.health <= 0) {
      pre.innerHTML = getIconHTML('images/corpse_bones.png', 96);
  } else {
      const playerIconPath = (character.gender === "男性") ? "images/player_male.png" : "images/player_female.png";
      pre.innerHTML = getIconHTML(playerIconPath, 96);
  }

  const imgElement = pre.querySelector('img');
  if (!imgElement) return;

  if (player.health <= 0) {
      imgElement.style.borderColor = 'black'; // 死亡時は黒い枠
      return;
  }
  
  // ▼▼▼ 色の決定ロジックを新しい関数に置き換えました ▼▼▼
  const borderColor = getHealthColor(player.health, maxStats.health);
  // ▲▲▲ 修正ここまで ▲▲▲
  
  imgElement.style.borderColor = borderColor;
}

// index.html内

function updateCharacterInfo() {
  document.getElementById("charName").textContent = getString(character.fullNameKey);
  document.getElementById("charAge").textContent = character.age;
  document.getElementById("charGender").textContent = getString(character.gender);
  document.getElementById("charJob").textContent = getString(character.job);
  document.getElementById("charRace").textContent = getString(character.race);
  
  const traitsContainer = document.getElementById("charTraits");
  traitsContainer.innerHTML = "";
  character.traits.forEach(traitId => {
      const trait = characterTraits.find(t => t.id === traitId);
      if (trait) {
          const pill = document.createElement("span");
          pill.className = "trait-pill";
          pill.textContent = getString(`trait_${trait.id}_name`) || trait.id;
          pill.addEventListener("mouseenter", (e) => showTraitDetail(e, trait));
          pill.addEventListener("mouseleave", hideTraitDetail);
          traitsContainer.appendChild(pill);
      }
  });

  const memoryContainer = document.getElementById("memoryContainer");
  memoryContainer.innerHTML = "";
  if (character.salvationCityHint) {
      const memoryDiv = document.createElement("div");
      memoryDiv.style.cssText = "color: #f1c40f; font-size: 12px;";
      memoryDiv.innerHTML = `<strong data-translate-key="char_info_memory">記憶</strong>:<br>${character.salvationCityHint}`;
      memoryContainer.appendChild(memoryDiv);
  }
}
// index.html内
// index.html内

function showTraitDetail(event, trait) {
  const preview = document.getElementById("statusPreview");
  preview.style.display = "block";
  preview.style.pointerEvents = "none";
  
  const traitName = getString(`trait_${trait.id}_name`) || trait.id;
  const traitDesc = getString(`trait_${trait.id}_desc`) || "No description available.";
  
  let contentHtml = `<strong>${traitName}</strong><br><div style="margin-top: 5px; margin-bottom: 5px;">${traitDesc}</div>`;
  
  if (trait.effects && Object.keys(trait.effects).length > 0) {
      contentHtml += `<div style="margin-top: 5px;"><strong>${getString("tooltip_label_effect")}:</strong></div>`;
      contentHtml += Object.keys(trait.effects).map(stat => {
        const change = trait.effects[stat];
        const sign = change > 0 ? "+" : "";
        const className = change > 0 ? "positive" : "negative";
        return `<div class="preview-stat"><span class="preview-stat-name">${getStatName(stat)}:</span><span class="preview-change ${className}">${sign}${change}</span></div>`;
    }).join('');
  }
  preview.innerHTML = contentHtml;
  updatePreviewPosition(event);
}

function hideTraitDetail() {
  document.getElementById("statusPreview").style.display = "none";
}

function drawMinimap() {
  const canvas = document.getElementById('minimapCanvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  
  canvas.width = canvas.offsetWidth;
  canvas.height = canvas.offsetHeight;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  const tileSize = minimapZoomLevel;

  const halfTilesX = canvas.width / (2 * tileSize);
  const halfTilesY = canvas.height / (2 * tileSize);
  
  const startMapX = Math.floor(player.x - halfTilesX);
  const endMapX = Math.ceil(player.x + halfTilesX);
  const startMapY = Math.floor(player.y - halfTilesY);
  const endMapY = Math.ceil(player.y + halfTilesY);

  for (let mapY = startMapY; mapY < endMapY; mapY++) {
    for (let mapX = startMapX; mapX < endMapX; mapX++) {
      if (mapX < 0 || mapY < 0 || mapX >= mapSize || mapY >= mapSize) {
        continue;
      }
      
      const tile = map[mapY][mapX];
      if (!tile.explored) {
        continue; 
      }
      
      let color = '#333'; 
      switch (tile.biome) {
        case 'Plains': color = '#5a6349'; break;
        case 'Forest': color = '#2d572c'; break;
        case 'Town':   color = '#666666'; break;
        case 'Road':   color = '#444444'; break;
      }
      
      const placedObject = placedObjects.find(obj => obj.x === mapX && obj.y === mapY);
      if (placedObject && placedObject.type === 'sleeping_bag') {
          color = '#9b59b6'; // 寝袋用の特別な色（紫）
      }

      const drawX = (canvas.width / 2) + (mapX - player.x - 0.5) * tileSize;
      const drawY = (canvas.height / 2) + (mapY - player.y - 0.5) * tileSize;

      ctx.fillStyle = color;
      ctx.fillRect(drawX, drawY, tileSize, tileSize);
    }
  }

  // ▼▼▼ 修正箇所 ▼▼▼
  // もしサルベーションシティが「発見済み」の場合のみミニマップに表示する
  if (salvationCityDiscovered) {
      const cityDrawX = (canvas.width / 2) + (salvationCityCoords.x - player.x - 0.5) * tileSize;
      const cityDrawY = (canvas.height / 2) + (salvationCityCoords.y - player.y - 0.5) * tileSize;
      ctx.fillStyle = '#ffd700'; 
      ctx.fillRect(cityDrawX, cityDrawY, tileSize, tileSize);
  }
  // ▲▲▲ 修正箇所 ▲▲▲

  ctx.fillStyle = '#ff0000'; 
  ctx.fillRect((canvas.width / 2) - (tileSize / 2), (canvas.height / 2) - (tileSize / 2), tileSize, tileSize);
}

function showDamage(dmg) {
  const dp = document.getElementById("damagePop");
  const popContainer = currentEnemy ? document.getElementById('combatPlayer') : document.body;
  if (currentEnemy) popContainer.style.position = 'relative';
  popContainer.appendChild(dp);
  dp.textContent = `-${dmg}`;
  dp.style.opacity = "1";
  dp.style.transform = "translate(-50%, -50%) scale(1.5)";
  setTimeout(() => {
      dp.style.opacity = "0";
      dp.style.transform = "translate(-50%, -50%) scale(3)";
  }, 100);
}
// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function showItemDetail(item, index, source) {
  const panel = document.getElementById("itemDetailPanel"),
      header = document.getElementById("itemDetailHeader"),
      graphic = document.getElementById("itemDetailGraphic"),
      content = document.getElementById("itemDetailContent");
  currentItemDetail = { item, index, source };
  header.innerHTML = `${getItemDisplayName(item)}`;
  graphic.innerHTML = getIconHTML(item.graphic, 96);
  
  let description = getString(`item_${item.name}_desc`) || item.desc;
  let details = `<div class="item-description">${description}</div>`;

  const itemTypeMap = {
      "consumable": "item_type_consumable", "container": "item_type_container",
      "equipment": "item_type_equipment", "clothing": "item_type_clothing",
      "tool": "item_type_tool", "material": "item_type_material",
      "water_source": "item_type_water_source", "ammo": "item_type_ammo"
  };
  const typeKey = itemTypeMap[item.type] || item.type;
  details += `<strong>${getString("detail_label_type")}</strong> ${getString(typeKey)}<br>`;

  if (item.type === "consumable") {
      if (item.freshness !== undefined) {
          if (item.freshness > 0) {
              details += `<strong>${getString("detail_label_freshness")}</strong> ${item.freshness.toFixed(0)}%<br>`;
          } else {
              details += `<strong>${getString("detail_label_condition")}</strong> <span style="color:indianred;">${getString("condition_spoiled")}</span><br>`;
          }
      }
  } else if (item.type === "container") {
      if (item.content) {
          const contentText = (item.content.type === 'clean') ? 
              `${getString("container_clean_water")} (${getString("detail_label_freshness")}: ${item.content.freshness.toFixed(0)}%)` : 
              `<span style="color:indianred;">${getString("container_dirty_water")}</span>`;
          details += `<strong>${getString("detail_label_contents")}</strong> ${contentText}<br>`;
      } else {
          details += `<strong>${getString("detail_label_contents")}</strong> ${getString("container_empty")}<br>`;
      }
  } else if (["equipment", "clothing", "tool"].includes(item.type)) {
      if(item.handedness) details += `<strong>${getString("detail_label_handedness")}</strong> ${getString(item.handedness === 'one' ? 'handedness_one' : 'handedness_two')}<br>`;
      if (item.slot) details += `<strong>${getString("detail_label_slot")}</strong> ${getSlotName(item.slot)}<br>`;
      if (item.durability !== undefined) details += `<strong>${getString("detail_label_durability")}</strong> ${item.durability.toFixed(0)}%<br>`;
      
      const durabilityFactor = (item.durability === undefined ? 100 : item.durability) / 100;
      if (item.attack) {
          const effectiveAttack = Math.floor(item.attack * durabilityFactor);
          // ▼▼▼ この行を修正しました ▼▼▼
          details += `<strong>${getString("detail_label_attack_melee")}</strong> <span class="item-effect-positive">+${effectiveAttack}</span> (${getString("detail_label_base")}: ${item.attack})<br>`;
      }
      if (item.fireDamage) {
          details += `<strong>${getString("detail_label_attack_ranged")}</strong> <span class="item-effect-positive">${item.fireDamage}</span><br>`;
      }
      if (item.defense) {
          const effectiveDefense = Math.floor(item.defense * durabilityFactor);
          // ▼▼▼ この行を修正しました ▼▼▼
          details += `<strong>${getString("detail_label_defense")}</strong> <span class="item-effect-positive">+${effectiveDefense}</span> (${getString("detail_label_base")}: ${item.defense})<br>`;
      }
      if (item.insulation) {
          const effectiveInsulation = (item.insulation * durabilityFactor).toFixed(1);
          // ▼▼▼ この行を修正しました ▼▼▼
          details += `<strong>${getString("detail_label_insulation")}</strong> <span class="item-effect-positive">+${effectiveInsulation}</span> (${getString("detail_label_base")}: ${item.insulation.toFixed(1)})<br>`;
      }
      if (item.effects && item.effects.maxWeight) details += `<strong>${getString("detail_label_max_weight")}</strong> <span class="item-effect-positive">+${item.effects.maxWeight}</span><br>`;
      if (item.effects && item.effects.maxVolume) details += `<strong>${getString("detail_label_max_volume")}</strong> <span class="item-effect-positive">+${item.effects.maxVolume}</span><br>`;
      if (item.isTorch) details += `<strong>${getString("detail_label_duration")}</strong> ${item.duration} Turns<br>`;
  }

  details += `<strong>${getString("detail_label_weight")}</strong> ${item.weight || 0}<br><strong>${getString("detail_label_volume")}</strong> ${item.volume || 0}<br><strong>${getString("detail_label_value")}</strong> ${item.value || 0}<br>`;
  
  content.innerHTML = details;
  
  document.getElementById("itemDetailActions").querySelectorAll('button').forEach(btn => btn.style.display = 'none');
  document.getElementById("closeItemDetailBtn").style.display = 'inline-block';
  const unlitCampfireNearby = placedObjects.some(c => c.type === 'unlit_campfire' && c.x === player.x && c.y === player.y);
  const isOnCampfire = placedObjects.some(c => c.type === 'campfire' && c.x === player.x && c.y === player.y);
  const hasBlade = player.inventory.some(i => i.isBlade) || player.equipment.some(i => i.isBlade);
  const hasCanOpener = player.inventory.some(i => i.name === '缶切り');
  const hasLighter = player.inventory.some(i => i.name === 'ライター');
  if (item.throwable && source === 'inventory') {
      document.getElementById("throwItemBtn").style.display = 'inline-block';
      document.getElementById("throwItemBtn").onclick = () => startTargeting(item, index, source);
  }
  const wipeClothBtn = document.getElementById("wipeClothBtn");
  const wringClothBtn = document.getElementById("wringClothBtn");
  if ((item.name === 'タオル' || item.name === '布切れ') && source === 'inventory') {
      const hasSoakingWetClothes = player.equipment.some(e => e.type === 'clothing' && e.wetness === 'soaking_wet');
      if (hasSoakingWetClothes) {
          wipeClothBtn.style.display = 'inline-block';
          wipeClothBtn.onclick = () => wipeClothes(item, index, source);
      }
  }
  if (item.type === 'clothing' && item.wetness === 'soaking_wet' && source === 'equipment') {
      wringClothBtn.style.display = 'inline-block';
      wringClothBtn.onclick = () => wringCloth(item, index, source);
  }
  if (source === 'inventory' || source === 'equipment') {
      if (dismantleRecipes[item.name]) {
          document.getElementById("dismantleBtn").style.display = 'inline-block';
          document.getElementById("dismantleBtn").onclick = () => dismantleItem(index, source);
      }
  }
  if (source === 'inventory') {
      document.getElementById("dropItemBtn").style.display = 'inline-block';
      document.getElementById("dropItemBtn").onclick = () => { dropItem(index); hideItemDetail(); };
      if (item.type === "consumable") {
          if (item.name === "ダクトテープ") {
              document.getElementById("repairItemBtn").style.display = 'inline-block';
              document.getElementById("repairItemBtn").onclick = () => repairItemWithTape(index);
          } else if (item.isSealed) {
              if (hasCanOpener || hasBlade) {
                  document.getElementById("openItemBtn").style.display = 'inline-block';
                  document.getElementById("openItemBtn").onclick = () => openCan(index);
              }
              document.getElementById("forceOpenItemBtn").style.display = 'inline-block';
              document.getElementById("forceOpenItemBtn").onclick = () => forceOpenCan(index);
          } else {
              document.getElementById("useItemBtn").style.display = 'inline-block';
              document.getElementById("useItemBtn").onclick = () => useItem(index, 'inventory');
          }
          if (cookingMap[item.name] && isOnCampfire) {
              document.getElementById("cookItemBtn").style.display = 'inline-block';
              document.getElementById("cookItemBtn").onclick = () => cookFood(index);
          }
      } else if (item.type === 'container') {
          const waterSourceOnGround = droppedItems[`${player.x},${player.y}`]?.find(i => i.type === 'water_source');
          if (item.content) {
              document.getElementById("drinkItemBtn").style.display = 'inline-block';
              document.getElementById("drinkItemBtn").onclick = () => drinkFromContainer(index);
              document.getElementById("emptyItemBtn").style.display = 'inline-block';
              document.getElementById("emptyItemBtn").onclick = () => emptyContainer(index);
              if (item.content.type === 'dirty' && isOnCampfire) {
                  document.getElementById("boilItemBtn").style.display = 'inline-block';
                  document.getElementById("boilItemBtn").onclick = () => boilWater(index);
              }
          } else if (waterSourceOnGround) {
              document.getElementById("fillItemBtn").style.display = 'inline-block';
              document.getElementById("fillItemBtn").onclick = fillContainerFromSource;
          }
      } else if (item.type === "equipment" || item.type === "clothing") {
          document.getElementById("equipItemBtn").style.display = 'inline-block';
          document.getElementById("equipItemBtn").onclick = () => equipItem(index);
      } else if (item.type === 'tool') {
          if (item.useAction && !['startFire', 'wipeClothes'].includes(item.useAction)) {
              document.getElementById("useItemBtn").style.display = 'inline-block';
              document.getElementById("useItemBtn").onclick = () => useItem(index, 'inventory');
          }
          if (item.useAction === 'startFire' && unlitCampfireNearby) {
              document.getElementById("startFireBtn").style.display = 'inline-block';
              document.getElementById("startFireBtn").onclick = () => startFire(item, index, 'inventory');
          }
      } else if (item.name === '枝') {
          if (isOnCampfire) {
              document.getElementById("addFuelBtn").style.display = 'inline-block';
              document.getElementById("addFuelBtn").onclick = () => addFuelToCampfire(index);
          }
          if (hasLighter) {
              document.getElementById("craftTorchBtn").style.display = 'inline-block';
              document.getElementById("craftTorchBtn").onclick = () => craftTorchWithLighter(index);
          }
      } else if (item.type === 'ammo') {
          const gunToReload = player.equipment.find(e => e.ammoType === item.ammoType && e.loadedAmmo < e.ammoCapacity);
          if (gunToReload) {
              document.getElementById("reloadGunBtn").style.display = 'inline-block';
              document.getElementById("reloadGunBtn").onclick = () => reloadWeapon();
          }
      }
  } else if (source === 'equipment') {
      document.getElementById("unequipItemBtn").style.display = 'inline-block';
      document.getElementById("unequipItemBtn").onclick = () => { unequipItem(index); hideItemDetail(); };
      if (item.useAction === 'startFire' && unlitCampfireNearby) {
          document.getElementById("startFireBtn").style.display = 'inline-block';
          document.getElementById("startFireBtn").onclick = () => startFire(item, index, 'equipment');
      }
      if (item.ammoType && item.loadedAmmo < item.ammoCapacity && player.inventory.some(i => i.ammoType === item.ammoType)) {
          document.getElementById("reloadGunBtn").style.display = 'inline-block';
          document.getElementById("reloadGunBtn").onclick = () => reloadWeapon(index);
      }
      if (item.ammoType && item.loadedAmmo > 0) {
          document.getElementById("unloadGunBtn").style.display = 'inline-block';
          document.getElementById("unloadGunBtn").onclick = () => unloadWeapon(index);
      }
      if (item.name === 'ライフル' && !item.bayonetAttached && player.inventory.some(i => i.name === 'ナイフ')) {
          document.getElementById("attachBayonetBtn").style.display = 'inline-block';
          document.getElementById("attachBayonetBtn").onclick = () => attachBayonet(index);
      }
  } else if (source === 'dropped') {
      const waterSource = droppedItems[`${player.x},${player.y}`]?.find(i => i.type === 'water_source');
      if (item.type === 'container' && !item.content && waterSource) {
          document.getElementById("fillItemBtn").style.display = 'inline-block';
          document.getElementById("fillItemBtn").onclick = () => fillContainerFromSource(index);
      }
      if (item.type === 'water_source') {
          document.getElementById("drinkItemBtn").style.display = 'inline-block';
          document.getElementById("drinkItemBtn").onclick = drinkFromSource;
      } else {
          document.getElementById("pickupItemBtn").style.display = 'inline-block';
          document.getElementById("pickupItemBtn").onclick = () => pickUpItemFromGround(index);
      }
  }
  panel.style.display = 'block';
  panel.style.top = "100px";
  panel.style.left = "100px";
  panel.style.transform = "none";
  bringToFront(panel);
}

function getStatName(stat) {
    switch (stat) {
        case 'health': return getString('status_health');
        case 'hunger': return getString('status_hunger');
        case 'thirst': return getString('status_thirst');
        case 'morale': return getString('status_morale');
        case 'sleep': return getString('status_sleep');
        case 'bodyTemp': return getString('status_body_temp');
        case 'attack': return getString('status_attack');
        case 'defense': return getString('status_defense');
        case 'insulation': return getString('status_insulation');
        case 'weight': return getString('status_weight');
        case 'volume': return getString('status_volume');
        case 'maxWeight': return getString('status_max_weight');
        // 修正点：'maxVolume': の後にコロン':'を追加
        case 'maxVolume': return getString('status_max_volume');
        case 'vision': return getString('status_vision');
        default: return stat;
    }
}
function getSicknessName(type) {
    // 修正点：ハードコードされた日本語を、翻訳キーを呼び出す形に修正
    return getString(`sickness_${type}`);
}
function getSlotName(slot) {
    switch (slot) {
        case 'main_hand': return getString('slot_main_hand');
        case 'off_hand': return getString('slot_off_hand');
        case 'weapon': return getString('slot_weapon');
        case 'head': return getString('slot_head');
        case 'body_inner': return getString('slot_body_inner');
        case 'body_outer': return getString('slot_body_outer');
        case 'legs': return getString('slot_legs');
        case 'hands': return getString('slot_hands');
        case 'feet': return getString('slot_feet');
        case 'back': return getString('slot_back');
        case 'pochette': return getString('slot_pochette');
        case 'eyes': return getString('slot_eyes');
        default: return getString('slot_other');
    }
}
function hideItemDetail() { 
    document.getElementById("itemDetailPanel").style.display = 'none';
    currentItemDetail = null; 
}

document.getElementById("closeItemDetailBtn").onclick = hideItemDetail;

function updatePreviewPosition(event) {
  const preview = document.getElementById("statusPreview");
  const rect = preview.getBoundingClientRect();
  let left = event.clientX + 10,
      top = event.clientY - 10;
  if (left + rect.width > window.innerWidth) left = event.clientX - rect.width - 10;
  if (top + rect.height > window.innerHeight) top = event.clientY - rect.height - 10;
  if (top < 0) top = 10;
  if (left < 0) left = 10;
  preview.style.left = left + "px";
  preview.style.top = top + "px";
}

function hideStatusPreview() { document.getElementById("statusPreview").style.display = "none"; }

// index.html 内

function showBodyTempTooltip(event) {
    const preview = document.getElementById("statusPreview");
    const campfireNearby = placedObjects.find(c => c.type === 'campfire' && Math.abs(c.x - player.x) <= 1 && Math.abs(c.y - player.y) <= 1);
    const insideBonus = player.isInside ? 5 : 0;
    const effectiveTemperature = currentTemperature + (campfireNearby ? 15 : 0) + insideBonus;
    
    let contentHtml = `<strong>${getString("tooltip_body_temp_title")}</strong><div>${getString("tooltip_body_temp_outside")}: ${currentTemperature.toFixed(1)}°C</div>`;
    if (player.isInside) contentHtml += `<div>${getString("tooltip_body_temp_cabin")}: <span class="stat-positive">+${insideBonus}°C</span></div>`;
    if (campfireNearby) contentHtml += `<div>${getString("tooltip_body_temp_campfire")}: <span class="stat-positive">+15°C</span></div>`;
    contentHtml += `<div>${getString("tooltip_body_temp_insulation")}: <span class="stat-positive">${player.insulation.toFixed(1)}</span></div><div style="border-bottom: 1px solid #555; margin: 2px 0;"></div><strong>${getString("tooltip_body_temp_effective")}: ${effectiveTemperature.toFixed(1)}°C</strong>`;
    
    preview.innerHTML = contentHtml;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}

function showMovementTooltip(event, mode) {
    const preview = document.getElementById("statusPreview");
    let title = '';
    let description = '';

    if (mode === 'walk') {
        title = '歩行';
        description = '標準的な移動方法。1ターンに1マス移動します。立てる音は比較的小さいです。';
    } else if (mode === 'run') {
        title = '走行';
        description = '高速移動。1ターンに必ず2マス移動します。大きな音を立て、追加で空腹と渇きを消費します。';
    } else {
        return;
    }

    preview.innerHTML = `<strong>${title}</strong><div style="margin-top: 5px;">${description}</div>`;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}
function getDirectionHint(fromX, fromY, toX, toY) {
    const deltaX = toX - fromX,
        deltaY = toY - fromY;
    let vertical = "",
        horizontal = "";
    if (Math.abs(deltaY) > 2) vertical = (deltaY < 0) ? "北" : "南";
    if (Math.abs(deltaX) > 2) horizontal = (deltaX > 0) ? "東" : "西";
    if (vertical && horizontal) return `ここから${vertical}${horizontal}の方角に、生存者の最後の楽園があるという噂だ。`;
    if (vertical) return `ここから${vertical}の方角に、生存者の最後の楽園があるという噂だ。`;
    if (horizontal) return `ここから${horizontal}の方角に、生存者の最後の楽園があるという噂だ。`;
    return "この辺りにあると聞くが...詳しい場所まではわからないな。";
}


// --- NPC and Trade System ---
function startTraderShopEncounter() {
    isInteractionActive = true;
    const shopKeeper = generateNPC();
    shopKeeper.type = 'Trader';
    shopKeeper.name = '店の商人';
    currentNPC = shopKeeper;
    startNPCEncounter();
}

// index.html内
// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function startNPCEncounter() {
    isInteractionActive = true;
    const npcName = getString(`item_${currentNPC.name}_name`) || currentNPC.name;
    if (currentNPC.type === 'Raider') {
        log(getString("log_npc_encounter", { npcName: npcName }), false);
        startCombat(currentNPC);
        return;
    }
    const dialoguePanel = document.getElementById('dialoguePanel');
    document.querySelectorAll('.panel:not(#dialoguePanel)').forEach(p => p.style.display = 'none');
    document.getElementById('dialogueNpcName').textContent = npcName;
    document.getElementById('dialogueNpcAscii').innerHTML = getIconHTML(currentNPC.icon, 96);

    // ▼▼▼ ここからが追加ブロックです ▼▼▼
    // NPCの体力に応じて枠線の色を設定する
    const dialogueImg = document.getElementById('dialogueNpcAscii').querySelector('img');
    if (dialogueImg) {
        const template = npcTemplates.find(t => t.type === currentNPC.type);
        if (template) {
            const maxHealth = template.health;
            const borderColor = getHealthColor(currentNPC.health, maxHealth);
            dialogueImg.style.borderColor = borderColor;
        }
    }
    // ▲▲▲ 追加ここまで ▲▲▲

    document.getElementById('dialogueText').innerHTML = `<p><i>「${getString(currentNPC.dialogue.greeting)}」</i></p>`;
    const infoBtn = document.getElementById('dialogueInfoBtn');
    if (currentNPC.knowsSalvationCity) {
        infoBtn.style.display = 'block';
        infoBtn.disabled = false;
        infoBtn.onclick = () => {
            const hint = getDirectionHint(player.x, player.y, salvationCityCoords.x, salvationCityCoords.y);
            document.getElementById('dialogueText').innerHTML += `<p style="color: yellow;"><i>「${hint}」</i></p>`;
            document.getElementById('dialogueText').scrollTop = document.getElementById('dialogueText').scrollHeight;
            character.salvationCityHint = hint;
            updateCharacterInfo();
            infoBtn.disabled = true;
        };
    } else { infoBtn.style.display = 'none'; }
    document.getElementById('dialogueTradeBtn').onclick = openTradeWindow;
    document.getElementById('dialogueFightBtn').onclick = () => {
        dialoguePanel.style.display = 'none';
        log(getString("log_npc_attack", { npcName: npcName }), false);
        startCombat(currentNPC);
    };
    document.getElementById('dialogueLeaveBtn').onclick = () => {
        log(getString("log_npc_farewell", { npcName: npcName }));
        endNPCEncounter();
    };
    dialoguePanel.style.display = 'block';
    bringToFront(dialoguePanel);
}

function endNPCEncounter() {
    isInteractionActive = false;
    currentNPC = null;
    currentEnemy = null;

    document.getElementById('dialoguePanel').style.display = 'none';
    document.getElementById('tradePanel').style.display = 'none';

    // ▼▼▼ 修正箇所 ▼▼▼
    // 再表示するパネルのリストから、ポップアップ系のパネル(#workbenchPanel, #itemDetailPanel) を除外
    const panelsToShow = document.querySelectorAll('.panel:not(#dialoguePanel):not(#tradePanel):not(#combatPanel):not(#storagePanel):not(#workbenchPanel):not(#itemDetailPanel)');
    // ▲▲▲ 修正ここまで ▲▲▲

    panelsToShow.forEach(panel => {
        if (!panel.classList.contains('minimized')) {
            if (['mapPanel', 'inventoryPanel', 'equipmentPanel', 'craftingPanel', 'currentLocationPanel', 'minimapPanel'].includes(panel.id)) {
                panel.style.display = 'flex';
            } else {
                panel.style.display = 'block';
            }
        }
    });

    drawMap();
    updateStatus();
    updateTurnInfo();
}
let playerOffer = [],
    npcOffer = [],
    tradePlayerInv = [],
    tradePlayerEquip = [],
    tradeNpcInv = [],
    tradeNpcEquip = [];

function openTradeWindow() {
    tradePlayerInv = JSON.parse(JSON.stringify(player.inventory));
    tradePlayerEquip = JSON.parse(JSON.stringify(player.equipment));
    tradeNpcInv = JSON.parse(JSON.stringify(currentNPC.inventory));
    tradeNpcEquip = JSON.parse(JSON.stringify(currentNPC.equipment));
    playerOffer = [];
    npcOffer = [];
    document.getElementById('dialoguePanel').style.display = 'none';
    const tradePanel = document.getElementById('tradePanel');
    tradePanel.style.display = 'flex';
    bringToFront(tradePanel);
    renderTradeUI();
    document.getElementById('executeTradeBtn').onclick = executeTrade;
    document.getElementById('cancelTradeBtn').onclick = () => {
        tradePanel.style.display = 'none';
        document.getElementById('dialoguePanel').style.display = 'block';
    };
}

// index.html内

function renderTradeUI() {
    const playerInvDiv = document.getElementById('playerTradeInventory'),
        playerEquipDiv = document.getElementById('playerTradeEquipment'),
        npcInvDiv = document.getElementById('npcTradeInventory'),
        npcEquipDiv = document.getElementById('npcTradeEquipment'),
        playerOfferDiv = document.getElementById('playerOfferArea'),
        npcOfferDiv = document.getElementById('npcOfferArea');
    playerInvDiv.innerHTML = '';
    playerEquipDiv.innerHTML = '';
    npcInvDiv.innerHTML = '';
    npcEquipDiv.innerHTML = '';
    playerOfferDiv.innerHTML = '';
    npcOfferDiv.innerHTML = '';
    const createItemDiv = (item, source, index) => {
        const div = document.createElement('div');
        div.className = 'item';
        div.innerHTML = `${getIconHTML(item.graphic, 16)} ${getItemDisplayName(item)} (${getString("trade_item_value")}: ${item.value || 0})`;
        div.onclick = () => moveTradeItem(source, index);
        return div;
    };
    tradePlayerInv.forEach((item, i) => playerInvDiv.appendChild(createItemDiv(item, 'playerInv', i)));
    tradePlayerEquip.forEach((item, i) => playerEquipDiv.appendChild(createItemDiv(item, 'playerEquip', i)));
    tradeNpcInv.forEach((item, i) => npcInvDiv.appendChild(createItemDiv(item, 'npcInv', i)));
    tradeNpcEquip.forEach((item, i) => npcEquipDiv.appendChild(createItemDiv(item, 'npcEquip', i)));
    playerOffer.forEach((item, i) => playerOfferDiv.appendChild(createItemDiv(item, 'playerOffer', i)));
    npcOffer.forEach((item, i) => npcOfferDiv.appendChild(createItemDiv(item, 'npcOffer', i)));
    updateTradeValues();
}

function moveTradeItem(source, index) {
    const move = (from, to, idx) => { to.push(from.splice(idx, 1)[0]); };
    if (source === 'playerInv') move(tradePlayerInv, playerOffer, index);
    else if (source === 'playerEquip') move(tradePlayerEquip, playerOffer, index);
    else if (source === 'npcInv') move(tradeNpcInv, npcOffer, index);
    else if (source === 'npcEquip') move(tradeNpcEquip, npcOffer, index);
    else if (source === 'playerOffer') {
        const itemToMove = playerOffer.splice(index, 1)[0];
        const wasEquipped = player.equipment.some(e => e.name === itemToMove.name && e.graphic === itemToMove.graphic);
        if (wasEquipped && !tradePlayerEquip.some(e => e.slot === itemToMove.slot)) tradePlayerEquip.push(itemToMove);
        else tradePlayerInv.push(itemToMove);
    } else if (source === 'npcOffer') {
        const itemToMove = npcOffer.splice(index, 1)[0];
        const wasEquipped = currentNPC.equipment.some(e => e.name === itemToMove.name && e.graphic === itemToMove.graphic);
        if (wasEquipped && !tradeNpcEquip.some(e => e.slot === itemToMove.slot)) tradeNpcEquip.push(itemToMove);
        else tradeNpcInv.push(itemToMove);
    }
    renderTradeUI();
}

function updateTradeValues() {
    const playerValue = playerOffer.reduce((sum, item) => sum + (item.value || 0), 0);
    const npcValue = npcOffer.reduce((sum, item) => sum + (item.value || 0), 0);
    document.getElementById('playerTradeValue').textContent = playerValue;
    document.getElementById('npcTradeValue').textContent = npcValue;
    const tradeBtn = document.getElementById('executeTradeBtn');
    if (playerValue >= npcValue * 0.9 && (playerValue > 0 || npcValue > 0)) {
        tradeBtn.disabled = false;
        tradeBtn.style.background = '#4CAF50';
    } else {
        tradeBtn.disabled = true;
        tradeBtn.style.background = '#333';
    }
}

function executeTrade() {
    snapshotStats();
    const finalInventory = [...tradePlayerInv, ...npcOffer];
    const finalEquipment = [...tradePlayerEquip];
    const finalItems = [...finalInventory, ...finalEquipment];
    let newWeight = finalItems.reduce((sum, item) => sum + (item.weight || 0), 0);
    let newVolume = finalInventory.reduce((sum, item) => sum + (item.volume || 0), 0);
    let newMaxWeight = maxStats.maxWeight;
    let newMaxVolume = maxStats.maxVolume;
    finalEquipment.forEach(item => {
        if(item.effects) {
            if(item.effects.maxWeight) newMaxWeight += item.effects.maxWeight;
            if(item.effects.maxVolume) newMaxVolume += item.effects.maxVolume;
        }
    });
    if (newWeight > newMaxWeight) {
        speakAndAlert(getString("alert_trade_fail_weight")); return;
    }
    if (newVolume > newMaxVolume) {
        speakAndAlert(getString("alert_trade_fail_volume")); return;
    }
    log(getString("trade_success"));
    player.inventory = finalInventory;
    player.equipment = finalEquipment;
    currentNPC.inventory = [...tradeNpcInv, ...playerOffer];
    currentNPC.equipment = [...tradeNpcEquip];
    updateEquippedStats();
    document.getElementById('tradePanel').style.display = 'none';
    document.getElementById('dialoguePanel').style.display = 'block';
    const dialogueText = document.getElementById('dialogueText');
    dialogueText.innerHTML += `<p style="color: lightgreen;"><i>${getString("trade_success")}</i></p>`;
    dialogueText.scrollTop = dialogueText.scrollHeight;
    updateItemPanels();
    updateStatus();
}

// --- Rain Animation Functions ---
function triggerLightning() {
    const flash = document.getElementById('lightning-flash');
    if (flash && currentWeather.name === '嵐') {
        flash.classList.add('active');
        setTimeout(() => {
            flash.classList.remove('active');
        }, 300);

        if (lightningTimeout) clearTimeout(lightningTimeout);
        lightningTimeout = setTimeout(triggerLightning, Math.random() * 8000 + 4000);
    }
}

function startWeatherEffect(weatherType) {
    const weatherContainer = document.getElementById('weather-container');
    if (!weatherContainer) return;

    weatherContainer.innerHTML = '';
    weatherContainer.style.display = 'block';
    weatherContainer.className = '';

    let dropCount = 100;
    if (weatherType === '嵐') {
        dropCount = 150;
        weatherContainer.classList.add('storm');
        if (lightningTimeout) clearTimeout(lightningTimeout);
        lightningTimeout = setTimeout(triggerLightning, Math.random() * 5000 + 2000);
    }

    for (let i = 0; i < dropCount; i++) {
        const drop = document.createElement('div');
        drop.className = 'drop';
        drop.style.left = Math.random() * 120 - 10 + 'vw';

        let duration = (Math.random() * 0.5 + 0.5);
        if (weatherType === '嵐') {
            duration = (Math.random() * 0.3 + 0.3);
        }

        drop.style.animationDuration = duration + 's';
        drop.style.animationDelay = Math.random() * 5 + 's';
        weatherContainer.appendChild(drop);
    }
}
function stopWeatherAudio() {
    [...rainSourceNodes, ...stormSourceNodes, ...birdsSourceNodes, ...windSourceNodes].forEach(node => {
        try {
            node.stop();
        } catch (e) {
            // Do nothing
        }
    });
    rainSourceNodes = [];
    stormSourceNodes = [];
    birdsSourceNodes = [];
    windSourceNodes = [];
}
function stopWeatherEffect() {
    stopWeatherAudio(); // 音声の停止を専門の関数に任せる

    // ここから下はアニメーションなど、見た目のエフェクトのみを停止する
    const weatherContainer = document.getElementById('weather-container');
    if (weatherContainer) {
        weatherContainer.style.display = 'none';
        weatherContainer.innerHTML = '';
    }
    if (lightningTimeout) {
        clearTimeout(lightningTimeout);
        lightningTimeout = null;
    }
    const flash = document.getElementById('lightning-flash');
    if (flash) flash.classList.remove('active');
}

function playSeamlessLoop(audioBuffer, gainNode, sourceNodesArray, weatherName) {
    const sourceNode = audioCtx.createBufferSource();
    sourceNode.buffer = audioBuffer;
    sourceNode.connect(gainNode);
    sourceNode.start(0);

    sourceNode.onended = () => {
        const index = sourceNodesArray.indexOf(sourceNode);
        if (index > -1) {
            sourceNodesArray.splice(index, 1);
        }
    };

    sourceNodesArray.push(sourceNode);

    const loopTimeout = setTimeout(() => {
        if (currentWeather.name === weatherName && sourceNodesArray.length > 0) {
            playSeamlessLoop(audioBuffer, gainNode, sourceNodesArray, weatherName);
        }
    }, audioBuffer.duration * 1000);
}

function startClouds() {
    const cloudContainer = document.getElementById('cloud-container');
    if (!cloudContainer || cloudContainer.style.display === 'block') return;

    cloudContainer.innerHTML = '';
    cloudContainer.style.display = 'block';

    const cloudCount = 5;
    for (let i = 0; i < cloudCount; i++) {
        const cloud = document.createElement('div');
        cloud.className = 'cloud';

        const size = Math.random() * 0.5 + 0.75;
        cloud.style.transform = `scale(${size})`;
        cloud.style.top = `${Math.random() * 80}%`;

        const duration = Math.random() * 30 + 40;
        cloud.style.animationDuration = `${duration}s`;
        cloud.style.animationDelay = `-${Math.random() * duration}s`;

        cloudContainer.appendChild(cloud);
    }
}

function stopClouds() {
    const cloudContainer = document.getElementById('cloud-container');
    if (cloudContainer) {
        cloudContainer.style.display = 'none';
        cloudContainer.innerHTML = '';
    }
}
// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function placeUnlitCampfire(item, itemIndex, source) {
    if (placedObjects.find(o => o.x === player.x && o.y === player.y && (o.type === 'unlit_campfire' || o.type === 'campfire'))) { 
        log(`ここには既にたき火がある。`);
        return; 
    }
    snapshotStats();
    const removedItem = player.inventory.splice(itemIndex, 1)[0];
    player.weight -= removedItem.weight;
    player.volume -= removedItem.volume;
    log("たき火キットを設置した。火をつける必要がある。");
    // ▼▼▼ この行を修正しました ▼▼▼
    placedObjects.push({ x: player.x, y: player.y, type: 'unlit_campfire', name: 'まだ火のついていないたき火', graphic: 'images/campfire_kit.png' });
    // ▲▲▲ 修正ここまで ▲▲▲
    drawMap();
    updateItemPanels();
    updateStatus();
    hideItemDetail();
}

function startFire(fireStarter, itemIndex, source) {
    const unlitCampfire = placedObjects.find(c => c.type === 'unlit_campfire' && c.x === player.x && c.y === player.y);
    if (!unlitCampfire) { log(getString("log_fire_no_target")); hideItemDetail(); return; }
    snapshotStats();
    log(getString("log_fire_started", { fireStarterName: getItemDisplayName(fireStarter) }));
    unlitCampfire.type = 'campfire';
    unlitCampfire.name = 'たき火';
    unlitCampfire.duration = 2;
    const itemContainer = (source === 'inventory') ? player.inventory : player.equipment;
    if (fireStarter.isTorch) {
        fireStarter.duration -= 1;
        if (fireStarter.duration <= 0) {
            log(getString("combat_weapon_break", { weaponName: getItemDisplayName(fireStarter) }));
            const removedItem = itemContainer.splice(itemIndex, 1)[0];
            player.weight -= removedItem.weight;
            player.volume -= removedItem.volume;
        }
    } else if (fireStarter.durability) {
        fireStarter.durability -= 20;
        if (fireStarter.durability <= 0) {
            log(getString("combat_weapon_break", { weaponName: getItemDisplayName(fireStarter) }));
            const removedItem = itemContainer.splice(itemIndex, 1)[0];
            player.weight -= removedItem.weight;
            player.volume -= removedItem.volume;
        }
    }
    drawMap(); updateItemPanels(); updateStatus(); hideItemDetail();
}

function addFuelToCampfire(itemIndex) {
    const campfire = placedObjects.find(c => c.type === 'campfire' && c.x === player.x && c.y === player.y);
    if (!campfire) return;
    snapshotStats();
    const removedItem = player.inventory.splice(itemIndex, 1)[0];
    player.weight -= removedItem.weight;
    player.volume -= removedItem.volume;
    campfire.duration += 2;
    log(getString("log_add_fuel_success", { duration: campfire.duration }));
    updateItemPanels(); updateStatus(); hideItemDetail(); drawMap();
}

function craftTorchWithLighter(branchIndex) {
    snapshotStats();
    const lighterIndex = player.inventory.findIndex(i => i.name === 'ライター');
    if (lighterIndex === -1) return;
    const lighter = player.inventory[lighterIndex];
    lighter.durability -= 10;
    const removedBranch = player.inventory.splice(branchIndex, 1)[0];
    player.weight -= removedBranch.weight;
    player.volume -= removedBranch.volume;
    const torchTemplate = items.find(i => i.name === '松明');
    const newTorch = { ...torchTemplate, duration: torchTemplate.duration, durability: 100 };
    player.inventory.push(newTorch);
    player.weight += newTorch.weight;
    player.volume += newTorch.volume;
    log(getString("log_torch_crafted"));
    if (lighter.durability <= 0) {
        log(getString("log_lighter_empty"));
        const removedLighter = player.inventory.splice(lighterIndex, 1)[0];
        player.weight -= removedLighter.weight;
        player.volume -= removedLighter.volume;
    }
    updateItemPanels(); updateStatus(); hideItemDetail();
}

// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function placeSleepingBag(item, itemIndex, source) {
    if (placedObjects.find(o => o.x === player.x && o.y === player.y)) { 
        log(getString("log_sleeping_bag_blocked"));
        return; 
    }
    snapshotStats();
    const removedItem = player.inventory.splice(itemIndex, 1)[0];
    player.weight -= removedItem.weight;
    player.volume -= removedItem.volume;
    log(getString("log_sleeping_bag_placed"));
    // ▼▼▼ この行を修正しました ▼▼▼
    placedObjects.push({ x: player.x, y: player.y, type: 'sleeping_bag', name: '寝袋', graphic: 'images/sleeping_bag.png' });
    // ▲▲▲ 修正ここまで ▲▲▲
    drawMap(); updateItemPanels(); updateStatus(); hideItemDetail();
}
// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function placeWoodenBox(item, itemIndex, source) {
    if (placedObjects.find(o => o.x === player.x && o.y === player.y)) { log(getString("log_wooden_box_blocked")); return; }
    snapshotStats();
    const removedItem = player.inventory.splice(itemIndex, 1)[0];
    player.weight -= removedItem.weight;
    player.volume -= removedItem.volume;
    log(getString("log_wooden_box_placed"));
    // ▼▼▼ この行を修正しました ▼▼▼
    placedObjects.push({ x: player.x, y: player.y, type: 'wooden_box', name: '木箱', graphic: 'images/wooden_box.png', content: [], capacity: 10 });
    // ▲▲▲ 修正ここまで ▲▲▲
    drawMap(); updateItemPanels(); updateStatus(); hideItemDetail();
}

// index.html内

function cookFood(itemIndex) {
    const rawItem = player.inventory[itemIndex];
    const cookedItemName = cookingMap[rawItem.name];
    if (!cookedItemName) return;

    snapshotStats();
    const removedItem = player.inventory.splice(itemIndex, 1)[0];
    player.weight -= removedItem.weight;
    player.volume -= removedItem.volume;
    const cookedItemTemplate = items.find(i => i.name === cookedItemName);
    
    // 修正点：新しいアイテムを生成する際に、翻訳キーと一致する'name'プロパティを確実に設定
    const newItem = { ...cookedItemTemplate, name: cookedItemName };
    
    player.inventory.push(newItem);
    player.weight += newItem.weight;
    player.volume += newItem.volume;
    log(getString("log_cooked_item", { rawItemName: getItemDisplayName(rawItem), cookedItemName: getItemDisplayName(newItem) }));
    updateItemPanels();
    updateStatus();
    hideItemDetail();
}
function boilWater(itemIndex) {
    snapshotStats();
    player.inventory[itemIndex].content = { type: 'clean', freshness: 100 };
    log(getString("log_water_boiled", { containerName: getItemDisplayName(player.inventory[itemIndex]) }));
    updateItemPanels(); updateStatus(); hideItemDetail();
}

function drinkFromContainer(itemIndex) {
    snapshotStats();
    const container = player.inventory[itemIndex];
    if (container.content.type === 'clean') {
        player.thirst = Math.min(maxStats.thirst, player.thirst + 40);
        log(getString("log_drink_clean"));
    } else {
        player.thirst = Math.min(maxStats.thirst, player.thirst + 20);
        if (Math.random() < 0.8 && !player.sicknesses.some(s => s.type === 'diarrhea')) {
            log(getString("log_drink_dirty_sick"), true);
            player.sicknesses.push({ type: 'diarrhea', duration: 36 });
        } else {
            log(getString("log_drink_dirty_ok"));
        }
    }
    container.content = null;
    logStatChanges(playerStatsBeforeAction, player);
    updateItemPanels(); updateStatus(); hideItemDetail();
}


function drinkFromSource() {
    snapshotStats();
    player.thirst = Math.min(maxStats.thirst, player.thirst + 20);
    if (Math.random() < 0.9 && !player.sicknesses.some(s => s.type === 'diarrhea')) {
        log("地面の水を直接飲んだ...すぐに後悔することになった！", true);
        player.sicknesses.push({ type: 'diarrhea', duration: 36 });
    } else {
        log("地面の水を直接飲んだ。喉は潤ったが、腹の調子が悪い...");
    }
    logStatChanges(playerStatsBeforeAction, player);
    updateStatus();
    hideItemDetail();
}

function fillContainerFromSource() {
    const emptyContainerIndex = player.inventory.findIndex(i => i.type === 'container' && !i.content);
    if (emptyContainerIndex === -1) { log("水を汲むための空の容器がない。"); hideItemDetail(); return; }
    snapshotStats();
    player.inventory[emptyContainerIndex].content = { type: 'dirty' };
    log(`空の${getItemDisplayName(player.inventory[emptyContainerIndex])}に汚れた水を汲んだ。`);
    updateItemPanels();
    updateStatus();
    hideItemDetail();
}

function emptyContainer(itemIndex) {
    snapshotStats();
    const container = player.inventory[itemIndex];
    log(`${getItemDisplayName(container)}の中身を地面に捨てた。`);
    const water = { ...items.find(i => i.name === '汚れた水') };
    const locationKey = `${player.x},${player.y}`;
    if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
    droppedItems[locationKey].push(water);
    container.content = null;
    updateItemPanels();
    updateCurrentLocationPanel();
    updateStatus();
    hideItemDetail();
}

function openCan(itemIndex) {
    snapshotStats();
    const can = player.inventory[itemIndex];
    can.isSealed = false;
    // 修正点：'openedName'プロパティを削除し、'name'プロパティを新しい翻訳キーの名前に直接変更
    can.name = '開けた缶(豆)';
    can.effects = can.sealedEffects;
    can.smell = 3;
    log(getString("log_open_can_success", { canName: getString(`item_${can.name}_name`) || can.name }));
    updateItemPanels();
    updateStatus();
    hideItemDetail();
}

function forceOpenCan(itemIndex) {
    snapshotStats();
    const can = player.inventory[itemIndex];
    const emptyCanTemplate = items.find(i => i.name === '空き缶');
    if (Math.random() < 0.6) {
        log(getString("log_force_open_fail", { canName: getString(`item_${can.name}_name`) || can.name }));
        const removedCan = player.inventory.splice(itemIndex, 1)[0];
        player.inventory.push({ ...emptyCanTemplate });
        player.weight -= (removedCan.weight - emptyCanTemplate.weight);
        player.volume -= (removedCan.volume - emptyCanTemplate.volume);
    } else {
        can.isSealed = false;
        // 修正点：'openedName'プロパティを削除し、'name'プロパティを新しい翻訳キーの名前に直接変更
        can.name = '開けた缶(豆)';
        can.effects = can.sealedEffects;
        can.smell = 3;
        log(getString("log_force_open_success", { canName: getString(`item_${can.name}_name`) || can.name }));
    }
    updateItemPanels();
    updateStatus();
    hideItemDetail();
}
// index.html内

// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function showPlacedObjectDetail(object) {
  const panel = document.getElementById("itemDetailPanel");
  const header = document.getElementById("itemDetailHeader");
  const graphic = document.getElementById("itemDetailGraphic");
  const content = document.getElementById("itemDetailContent");

  currentItemDetail = { item: object, source: 'placed', coords: { x: object.x, y: object.y } };
  // 修正点: オブジェクト名を翻訳
  header.textContent = getPlacedObjectDisplayName(object);
  graphic.innerHTML = getIconHTML(object.graphic, 48);

  // 修正点: デフォルトの説明文と各説明文を翻訳キーで取得
  let description = getString("tooltip_placed_object_no_desc");
  let weight = 0;
  let volume = 0;

  if (object.type === 'barricade') {
    description = getString("item_バリケード_desc");
  } else if (object.isAnimalCorpse) {
    description = object.unbutchered ? getString("tooltip_corpse_animal_unbutchered") : getString("tooltip_corpse_animal_butchered");
  } else if (object.isHumanCorpse) {
    description = object.unsearched ? getString("tooltip_corpse_human_unsearched") : getString("tooltip_corpse_human_searched");
  } else {
    const itemTemplate = items.find(i => object.name.includes(i.name));
    if (itemTemplate) {
      description = getString(`item_${itemTemplate.name}_desc`) || itemTemplate.desc;
      weight = itemTemplate.weight || 0;
      volume = itemTemplate.volume || 0;
    }
  }
  
  // 修正点: パネル内のHTMLを全て翻訳キーで生成
  if (object.type === 'barricade') {
    content.innerHTML = `<div class="item-description">${description}</div><strong>${getString("detail_label_type")}</strong> ${getString("item_type_placed_object")}<br><strong>${getString("combat_health")}</strong> ${object.health.toFixed(0)} / ${object.maxHealth.toFixed(0)}`;
  } else {
    content.innerHTML = `<div class="item-description">${description}</div><strong>${getString("detail_label_type")}</strong> ${getString("item_type_placed_object")}<br><strong>${getString("detail_label_weight")}</strong> ${weight}<br><strong>${getString("detail_label_volume")}</strong> ${volume}`;
  }

  document.getElementById("itemDetailActions").querySelectorAll('button').forEach(btn => btn.style.display = 'none');
  document.getElementById("closeItemDetailBtn").style.display = 'inline-block';
  
  const hasAxe = player.inventory.some(i => i.isAxe) || player.equipment.some(i => i.isAxe);
  
  if (object.type === 'barricade' && hasAxe) {
      document.getElementById("dismantleBtn").style.display = 'inline-block';
      document.getElementById("dismantleBtn").onclick = dismantleBarricade;
  } else if (object.isAnimalCorpse && object.unbutchered) {
    const hasBlade = player.inventory.some(i => i.isBlade) || player.equipment.some(i => i.isBlade);
    if (hasBlade) {
        document.getElementById("butcherItemBtn").style.display = 'inline-block';
        document.getElementById("butcherItemBtn").onclick = butcherAnimalCorpse;
    }
  } else if (object.isHumanCorpse && object.unsearched) {
      document.getElementById("searchCorpseBtn").style.display = 'inline-block';
      document.getElementById("searchCorpseBtn").onclick = searchHumanCorpse;
  } else if (object.type === 'sleeping_bag' || object.type === 'unlit_campfire' || (object.type === 'wooden_box' && (!object.content || object.content.length === 0))) {
      const pickupBtn = document.getElementById("pickupItemBtn");
      pickupBtn.style.display = 'inline-block';
      pickupBtn.onclick = () => pickupPlacedObject(object);
  }

  panel.style.display = 'block';
  bringToFront(panel);
}

function pickupPlacedObject(object) {
    let itemTemplate;
    if (object.type === 'sleeping_bag') {
        itemTemplate = items.find(i => i.name === '寝袋');
    } else if (object.type === 'wooden_box') {
        itemTemplate = items.find(i => i.name === '木箱');
    } else if (object.type === 'unlit_campfire') {
        itemTemplate = items.find(i => i.name === 'たき火キット');
    } else {
        log(getString("log_pickup_fail_generic"));
        return;
    }
    
    if (!itemTemplate) return;
    const itemName = getItemDisplayName(itemTemplate);

    if (player.weight + itemTemplate.weight > player.maxWeight) {
        log(getString("log_pickup_fail_weight", { itemName: itemName }));
        return;
    }
    if (player.volume + (itemTemplate.volume || 0) > player.maxVolume) {
        log(getString("log_pickup_fail_volume", { itemName: itemName }));
        return;
    }

    const objectIndex = placedObjects.findIndex(o => o.x === object.x && o.y === object.y);
    if (objectIndex > -1) {
        placedObjects.splice(objectIndex, 1);
        const newItem = { ...itemTemplate };
        player.inventory.push(newItem);
        player.weight += newItem.weight;
        player.volume += newItem.volume;
        log(getString("log_pickup_placed_object_success", { itemName: itemName }));
        hideItemDetail();
        drawMap();
        updateItemPanels();
        updateStatus();
    }
}

function showRecipeTooltip(item, event) {
    const preview = document.getElementById("statusPreview");
    
    // アイテム名と説明を翻訳キーから取得
    const itemName = getString(`item_${item.name}_name`) || item.name;
    const itemDesc = getString(`item_${item.name}_desc`) || item.desc;

    let details = `<strong>${itemName}</strong><br><div class="item-description">${itemDesc}</div>`;

    // 各ステータスのラベルも翻訳キーから取得
    if (item.attack) details += `<strong>${getString('detail_label_attack_melee')}</strong> <span class="item-effect-positive">+${item.attack}</span><br>`;
    if (item.defense) details += `<strong>${getString('detail_label_defense')}</strong> <span class="item-effect-positive">+${item.defense}</span><br>`;
    if (item.insulation) details += `<strong>${getString('detail_label_insulation')}</strong> <span class="item-effect-positive">+${item.insulation.toFixed(1)}</span><br>`;
    if (item.effects && item.effects.maxWeight) details += `<strong>${getString('detail_label_max_weight')}</strong> <span class="item-effect-positive">+${item.effects.maxWeight}</span><br>`;
    if (item.effects && item.effects.maxVolume) details += `<strong>${getString('detail_label_max_volume')}</strong> <span class="item-effect-positive">+${item.effects.maxVolume}</span><br>`;
    
    details += `<strong>${getString('detail_label_weight')}</strong> ${item.weight || 0}<br><strong>${getString('detail_label_volume')}</strong> ${item.volume || 0}<br>`;
    
    preview.innerHTML = details;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}

let currentStorageBox = null;
function openStoragePanel(boxObject) {
    isInteractionActive = true; currentStorageBox = boxObject;
    const storagePanel = document.getElementById('storagePanel');
    document.getElementById('storagePanelHeader').textContent = `${boxObject.name}の中身`;
    renderStorageUI();
    storagePanel.style.display = 'flex'; bringToFront(storagePanel);
}

function renderStorageUI() {
    if(!currentStorageBox) return;
    const boxArea = document.getElementById('storageBoxArea'), playerArea = document.getElementById('storagePlayerInventory');
    boxArea.innerHTML = ''; playerArea.innerHTML = '';
    document.getElementById('storageBoxTitle').textContent = `木箱の中身 (${currentStorageBox.content.length}/${currentStorageBox.capacity})`;
    const createItemDiv = (item, source, index) => {
        const div = document.createElement('div'); div.className = 'item';
        // ▼▼▼ この行を修正しました ▼▼▼
        div.innerHTML = `${getIconHTML(item.graphic, 16)} ${getItemDisplayName(item)}`;
        // ▲▲▲ 修正ここまで ▲▲▲
        div.onclick = () => moveStorageItem(source, index); return div;
    };
    currentStorageBox.content.forEach((item, i) => boxArea.appendChild(createItemDiv(item, 'box', i)));
    player.inventory.forEach((item, i) => playerArea.appendChild(createItemDiv(item, 'player', i)));
    const pickupBtn = document.getElementById('pickupStorageBtn');
    pickupBtn.disabled = currentStorageBox.content.length > 0;
}

function moveStorageItem(source, index) {
    if(source === 'player') {
        if(currentStorageBox.content.length < currentStorageBox.capacity) {
            const itemToStore = player.inventory.splice(index, 1)[0];
            currentStorageBox.content.push(itemToStore);
        } else { log("木箱はもう満杯だ。"); }
    } else {
        const itemToTake = currentStorageBox.content[index];
        if(player.weight + itemToTake.weight > player.maxWeight) { log("これ以上持てない。"); } 
        else if(player.volume + (itemToTake.volume || 0) > player.maxVolume) { log("容量が足りない。"); } 
        else { 
            player.inventory.push(currentStorageBox.content.splice(index, 1)[0]); 
        }
    }
    updateEquippedStats(); updateStatus(); renderStorageUI();
}

function pickupStorageBox() {
    if (currentStorageBox && currentStorageBox.content.length === 0) {
        const boxItem = items.find(i => i.name === '木箱');
        if (player.weight + boxItem.weight > player.maxWeight) {
            log("重すぎて木箱を拾えない。"); return;
        }
        if (player.volume + (boxItem.volume || 0) > player.maxVolume) {
            log("容量が足りなくて木箱を拾えない。"); return;
        }
        const boxIndex = placedObjects.findIndex(o => o.x === currentStorageBox.x && o.y === currentStorageBox.y);
        if (boxIndex > -1) {
            placedObjects.splice(boxIndex, 1);
            player.inventory.push({...boxItem});
            log("空の木箱を拾い上げた。");
            closeStoragePanel();
            drawMap(); 
            updateEquippedStats(); 
            updateStatus();
            updateItemPanels();
        }
    }
}

function closeStoragePanel() {
    document.getElementById('storagePanel').style.display = 'none';
    currentStorageBox = null; isInteractionActive = false;
    updateItemPanels();
}

function reloadWeapon(gunIndexInEquipment) {
    const gun = player.equipment[gunIndexInEquipment];
    if (!gun || !gun.ammoType) return;

    let reloadedCount = 0;
    while (gun.loadedAmmo < gun.ammoCapacity) {
        const ammoIndex = player.inventory.findIndex(i => i.ammoType === gun.ammoType);
        if (ammoIndex > -1) {
            const ammo = player.inventory.splice(ammoIndex, 1)[0];
            player.weight -= ammo.weight;
            player.volume -= ammo.volume;
            gun.loadedAmmo++;
            reloadedCount++;
        } else {
            break;
        }
    }

    if (reloadedCount > 0) {
        log(`${gun.name}に弾を${reloadedCount}発装填した。`);
        updateItemPanels();
        updateEquippedStats();
        updateStatus();
        hideItemDetail();
    } else {
        log("適合する弾薬を持っていない。");
    }
}

function attachBayonet(rifleIndexInEquipment) {
    const rifle = player.equipment[rifleIndexInEquipment];
    const knifeIndex = player.inventory.findIndex(i => i.name === 'ナイフ');

    if (rifle && rifle.name === 'ライフル' && knifeIndex > -1) {
        const knife = player.inventory.splice(knifeIndex, 1)[0];
        player.weight -= knife.weight;
        player.volume -= knife.volume;
        rifle.bayonetAttached = true;
        log(`${rifle.name}に${knife.name}を装着した。近接攻撃が強化される。`);
        updateEquippedStats();
        updateItemPanels();
        updateStatus();
        hideItemDetail();
    }
}

function ensureKnowledgeableTrader() {
    const knowledgeableTraderExists = entities.some(e => e.type === 'Trader' && e.knowsSalvationCity);
    if (!knowledgeableTraderExists) {
        const anyTrader = entities.find(e => e.type === 'Trader');
        if (anyTrader) {
            anyTrader.knowsSalvationCity = true;
        } else {
            let x, y;
            do {
                x = Math.floor(Math.random() * mapSize);
                y = Math.floor(Math.random() * mapSize);
            } while (entities.some(e => e.x === x && e.y === y) || (player.x === x && player.y === y));
            
            const newTrader = generateNPC();
            newTrader.type = 'Trader';
            newTrader.x = x;
            newTrader.y = y;
            newTrader.stunnedTurns = 0;
            newTrader.knowsSalvationCity = true;
            entities.push(newTrader);
        }
    }
}

function updateBackgroundColor() {
    const hour = currentTime.getHours();
    let color;

    if (hour >= 5 && hour <= 8) {
        color = '#87CEEB';
    } else if (hour >= 9 && hour <= 16) {
        color = '#FFF8DC';
    } else if (hour >= 17 && hour <= 19) {
        color = '#E9967A';
    } else {
        color = '#0F192D';
    }
    document.body.style.backgroundColor = color;
}

// ▼▼▼ butcherAnimalCorpse関数を丸ごと置き換えてください ▼▼▼
function butcherAnimalCorpse() {
    const corpse = currentItemDetail.item;
    if (!corpse || !corpse.unbutchered) return;

    const blade = player.inventory.find(i => i.isBlade) || player.equipment.find(i => i.isBlade);
    if (!blade) {
        log(getString("log_butcher_need_blade"), true);
        return;
    }
    
    snapshotStats();
    
    const bladeName = getItemDisplayName(blade);
    const corpseName = getString(`item_${corpse.name}_name`) || corpse.name;
    log(getString("log_butcher_start", { bladeName: bladeName, corpseName: corpseName }), true);
    
    let itemsFound = [];
    const meatTemplate = items.find(i => i.name === '生肉');
    const furTemplate = items.find(i => i.name === '毛皮');
    
    if (meatTemplate && corpse.potentialLoot.meat > 0) {
        for (let i = 0; i < corpse.potentialLoot.meat; i++) { itemsFound.push({...meatTemplate}); }
        log(getString("log_butcher_meat", { count: corpse.potentialLoot.meat }), true);
    }
    if (furTemplate && corpse.potentialLoot.fur > 0) {
        for (let i = 0; i < corpse.potentialLoot.fur; i++) { itemsFound.push({...furTemplate}); }
        log(getString("log_butcher_fur", { count: corpse.potentialLoot.fur }), true);
    }

    const locationKey = `${player.x},${player.y}`;
    if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
    itemsFound.forEach(item => droppedItems[locationKey].push(item));
    
    const corpseIndex = placedObjects.findIndex(p => p === corpse);
    if (corpseIndex > -1) {
const newCorpseObject = { 
    ...corpse, 
    unbutchered: false, 
    graphic: 'images/corpse_bones.png'
};
placedObjects.splice(corpseIndex, 1, newCorpseObject);
    }

    hideItemDetail();
    advanceTurn();
    updateCurrentLocationPanel(false);
    updateStatus();
    updateCharacterBody();
    updateTurnInfo();
}

// ▼▼▼ searchHumanCorpse関数を丸ごと置き換えてください ▼▼▼
function searchHumanCorpse() {
    const corpse = currentItemDetail.item;
    if (!corpse || !corpse.unsearched) return;
    snapshotStats();
    
    const corpseName = getString(`item_${corpse.name}_name`) || corpse.name;
    log(getString("log_search_corpse", { corpseName: corpseName }), true);

    const locationKey = `${player.x},${player.y}`;
    if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
    
    if (corpse.potentialLoot && corpse.potentialLoot.length > 0) {
        corpse.potentialLoot.forEach(item => { droppedItems[locationKey].push(item); });
        log(getString("log_corpse_found_items"), true);
    } else {
        log(getString("log_corpse_found_nothing"), true);
    }

    const corpseIndex = placedObjects.findIndex(p => p === corpse);
    if (corpseIndex > -1) {
const newCorpseObject = { 
    ...corpse, 
    unsearched: false, 
    graphic: 'images/corpse_bones.png'
};
        placedObjects.splice(corpseIndex, 1, newCorpseObject);
    }

    hideItemDetail();
    advanceTurn();
    updateCurrentLocationPanel(false);
    updateStatus();
    updateCharacterBody();
    updateTurnInfo();
}

function applySplint(item, itemIndex, source) {
    const fracture = player.injuries.find(i => i.type === 'fracture' && !i.splinted);
    if (fracture) {
        fracture.splinted = true;
        log("添え木で骨折箇所を固定した。痛みが少し和らいだ。", true);
        const removedItem = player.inventory.splice(itemIndex, 1)[0];
        player.weight -= removedItem.weight;
        player.volume -= removedItem.volume;
        updateItemPanels();
        updateStatus();
        hideItemDetail();
        speakQueuedLogs(); // 【追加】
    } else {
        log("添え木を使う必要はないようだ。");
        speakQueuedLogs(); // 【追加】
    }
}

function cureSickness(sicknessType, medicineName, itemIndex) {
    const sickness = player.sicknesses.find(s => s.type === sicknessType);
    if (sickness) {
        log(`${medicineName}を服用した。少し楽になったようだ。`, true);
        sickness.medicated_duration = 6; 
        const removedItem = player.inventory.splice(itemIndex, 1)[0];
        player.weight -= removedItem.weight;
        player.volume -= removedItem.volume;
        updateItemPanels();
        updateStatus();
        hideItemDetail();
        speakQueuedLogs(); // 【追加】
    } else {
        log(`${medicineName}を飲む必要はないようだ。`);
        speakQueuedLogs(); // 【追加】
    }
}
// index.html 内

function repairItemWithTape(tapeIndex) {
    const repairableItems = [...player.equipment, ...player.inventory].filter(i =>
        (i.type === 'equipment' || i.type === 'clothing' || i.type === 'tool') &&
        i.durability !== undefined && i.durability < 100
    );

    if (repairableItems.length === 0) {
        log(getString("log_repair_no_items"));
        return;
    }

    hideItemDetail();

    const modalDiv = document.createElement("div");
    modalDiv.id = "repairModal";
    modalDiv.style.cssText = `position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #222; color: white; padding: 20px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.6); z-index: 1001; max-height: 80vh; display: flex; flex-direction: column;`;
    
    modalDiv.innerHTML = `<h3 style="margin-top:0; padding-bottom:10px; border-bottom:1px solid #555;">${getString("repair_select_title")}</h3>`;

    const itemListDiv = document.createElement("div");
    itemListDiv.className = "item-list";
    itemListDiv.style.maxHeight = "60vh";

    repairableItems.forEach(itemToRepair => {
        const itemDiv = document.createElement("div");
        itemDiv.className = "item";
        itemDiv.innerHTML = `${getIconHTML(itemToRepair.graphic, 16)} ${getItemDisplayName(itemToRepair)} (${getString("item_info_durability")}: ${itemToRepair.durability.toFixed(0)}%)`;
        itemDiv.onclick = () => {
            executeRepair(itemToRepair, tapeIndex);
            document.body.removeChild(modalDiv);
        };
        itemListDiv.appendChild(itemDiv);
    });
    
    modalDiv.appendChild(itemListDiv);

    const cancelBtn = document.createElement("button");
    cancelBtn.textContent = getString("trade_cancel");
    cancelBtn.style.cssText = `margin-top: 15px; padding: 8px 15px; background: #444; color: #eee; border: none; border-radius: 5px; cursor: pointer;`;
    cancelBtn.onclick = () => document.body.removeChild(modalDiv);
    
    modalDiv.appendChild(cancelBtn);
    document.body.appendChild(modalDiv);
}

function executeRepair(itemToRepair, tapeIndex) {
    const repairAmount = 50;
    const originalDurability = itemToRepair.durability;
    itemToRepair.durability = Math.min(100, itemToRepair.durability + repairAmount);

    log(`ダクトテープを使って${getItemDisplayName(itemToRepair)}を修理した。(耐久度: ${originalDurability.toFixed(0)}% -> ${itemToRepair.durability.toFixed(0)}%)`);

    // ダクトテープを消費
    const removedTape = player.inventory.splice(tapeIndex, 1)[0];
    player.weight -= removedTape.weight;
    player.volume -= removedTape.volume;

    updateItemPanels();
    updateStatus();
    speakQueuedLogs(); // 【追加】
}


function cureFoodPoisoning(item, itemIndex) {
    cureSickness('food_poisoning', '胃腸薬', itemIndex);
}

function cureDiarrhea(item, itemIndex) {
    cureSickness('diarrhea', '下痢止め', itemIndex);
}

function cureFever(item, itemIndex) {
    cureSickness('fever', '解熱剤', itemIndex);
}
function gatherLog() {
    snapshotStats();
    let tile = map[player.y][player.x];
    if (Math.random() < 0.5) {
        log(getString("log_gather_log_fail"));
    } else {
        const logItemTemplate = items.find(i => i.name === '丸太');
        const newItem = { ...logItemTemplate };
        if (player.weight + newItem.weight > player.maxWeight || player.volume + newItem.volume > player.maxVolume) {
            log(getString("log_gather_log_grounded"));
            const locationKey = `${player.x},${player.y}`;
            if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
            droppedItems[locationKey].push(newItem);
        } else {
            log(getString("log_gather_log_success"));
            player.inventory.push(newItem);
            player.weight += newItem.weight;
            player.volume += newItem.volume;
        }
        tile.logSupply--;
    }
    advanceTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    updateTurnInfo();
    checkGameOver();
    updateCurrentLocationPanel(false);
}

function placeBarricade(recipe) {
    if (placedObjects.some(o => o.x === player.x && o.y === player.y)) {
        log("ここには既に何か設置されているため、バリケードを設置できない。");
        return;
    }
    snapshotStats();
    log("丸太を消費してバリケードを設置した。");
    createSound(player.x, player.y, 6);
    
    for (let i = 0; i < recipe.ingredients[0].count; i++) {
        const logIndex = player.inventory.findIndex(item => item.name === '丸太');
        if (logIndex > -1) {
            const removedLog = player.inventory.splice(logIndex, 1)[0];
            player.weight -= removedLog.weight;
            player.volume -= removedLog.volume;
        }
    }

    placedObjects.push({ 
        x: player.x, 
        y: player.y, 
        type: 'barricade', 
        name: 'バリケード', 
        graphic: '🚧', 
        health: 100,
        maxHealth: 100 
    });

    advanceTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    updateTurnInfo();
    checkGameOver();
    updateCurrentLocationPanel(false);
}

// ▼▼▼ この関数を丸ごと置き換えてください ▼▼▼
function placeBarricadeItem(item, itemIndex, source) {
    if (placedObjects.find(o => o.x === player.x && o.y === player.y)) { 
        log(`ここには既に何かが設置されている。`); 
        return; 
    }
    
    snapshotStats();
    
    const removedItem = player.inventory.splice(itemIndex, 1)[0];
    player.weight -= removedItem.weight;
    player.volume -= removedItem.volume;
    
    log("バリケードを設置した。");
    createSound(player.x, player.y, 6);
    
    // ▼▼▼ この行を修正しました ▼▼▼
    placedObjects.push({ 
        x: player.x, 
        y: player.y, 
        type: 'barricade', 
        name: 'バリケード', 
        graphic: 'images/barricade.png', 
        health: 100,
        maxHealth: 100 
    });
    // ▲▲▲ 修正ここまで ▲▲▲
    
    drawMap();
    updateItemPanels();
    updateStatus();
    hideItemDetail();
}

function dismantleBarricade() {
    const barricadeObject = currentItemDetail.item;
    if (!barricadeObject || barricadeObject.type !== 'barricade') return;
    
    log("斧を使い、バリケードを解体してアイテムに戻した。");

    const barricadeItem = items.find(i => i.name === 'バリケード');
    if (barricadeItem) {
        const newItem = { ...barricadeItem };

        if (player.weight + newItem.weight > player.maxWeight || player.volume + newItem.volume > player.maxVolume) {
            log("重さか容量が足りなくて持てないため、地面に置いた。");
            const locationKey = `${barricadeObject.x},${barricadeObject.y}`;
            if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
            droppedItems[locationKey].push(newItem);
        } else {
            log("バリケードを所持品に加えた。");
            player.inventory.push(newItem);
            player.weight += newItem.weight;
            player.volume += newItem.volume;
        }
    }

    const objectIndex = placedObjects.findIndex(o => o === barricadeObject);
    if (objectIndex > -1) {
        placedObjects.splice(objectIndex, 1);
    }
    
    hideItemDetail();
    advanceTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCurrentLocationPanel(false);
}

function dismantleItem(itemIndex, source) {
    const sourceArray = source === 'inventory' ? player.inventory : player.equipment;
    const itemToDismantle = sourceArray[itemIndex];
    if (!itemToDismantle) return;
    const recipe = dismantleRecipes[itemToDismantle.name];
    if (!recipe) {
        log(getString("log_dismantle_cannot"));
        return;
    }
    log(getString("log_dismantle_success", { itemName: getItemDisplayName(itemToDismantle) }));
    const removedItem = sourceArray.splice(itemIndex, 1)[0];
    player.weight -= removedItem.weight || 0;
    if (source === 'inventory') player.volume -= removedItem.volume || 0;
    recipe.forEach(result => {
        const materialTemplate = items.find(i => i.name === result.name);
        if (materialTemplate) {
            for (let i = 0; i < result.count; i++) {
                const newItem = { ...materialTemplate };
                if (player.weight + newItem.weight <= player.maxWeight && player.volume + newItem.volume <= player.maxVolume) {
                    player.inventory.push(newItem);
                    player.weight += newItem.weight || 0;
                    player.volume += newItem.volume || 0;
                    log(getString("log_dismantle_result", { itemName: getItemDisplayName(newItem) }));
                } else {
                    const locationKey = `${player.x},${player.y}`;
                    if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
                    droppedItems[locationKey].push(newItem);
                    log(getString("log_dismantle_grounded", { itemName: getItemDisplayName(newItem) }));
                }
            }
        }
    });
    hideItemDetail(); updateEquippedStats(); updateItemPanels(); updateStatus(); updateCurrentLocationPanel(false);
}

function wipeClothes(item, itemIndex, source) {
    const soakingWetClothes = player.equipment.filter(e => e.type === 'clothing' && e.wetness === 'soaking_wet');
    if (soakingWetClothes.length === 0) {
        log(getString("log_wipe_clothes_not_needed"));
        hideItemDetail();
        return;
    }

    log(getString("log_wipe_clothes_success", { itemName: getItemDisplayName(item) }));
    soakingWetClothes.forEach(cloth => {
        cloth.wetness = 'wet';
    });

    updateItemPanels();
    updateStatus();
    hideItemDetail();
}
function wringCloth(item, itemIndex, source) {
    if (item.wetness !== 'soaking_wet') {
        log(getString("log_wring_not_needed"));
        hideItemDetail();
        return;
    }
    snapshotStats();
    log(getString("log_wring_clothes", { itemName: getItemDisplayName(item) }));
    item.wetness = 'wet';
    hideItemDetail();
    advanceTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    updateTurnInfo();
    checkGameOver();
    updateCurrentLocationPanel(false);
}

// --- NEW Vision and Sound Functions ---
function getDistance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}
// ▼▼▼ この関数を新しく追加してください ▼▼▼
/**
 * プレイヤーの周囲にある、敵がおらず移動可能な安全なタイルを探す
 * @returns {object|null} - 安全なタイルの座標 {x, y} または null
 */
function findSafeFleeTile() {
    const fleeRadius = 2; // 逃走する範囲（周囲2マス）
    let safeTiles = [];

    // プレイヤーの周囲のマスをチェック
    for (let y = player.y - fleeRadius; y <= player.y + fleeRadius; y++) {
        for (let x = player.x - fleeRadius; x <= player.x + fleeRadius; x++) {
            // プレイヤーの現在地と、マップ範囲外は除外
            if ((x === player.x && y === player.y) || x < 0 || y < 0 || x >= mapSize || y >= mapSize) {
                continue;
            }

            // そのマスに他のエンティティがいないかチェック
            const isOccupied = entities.some(e => e.x === x && e.y === y);
            // そのマスが通行可能かチェック（壁などを避ける）
            const isPassable = !map[y][x].loc.blocksVision;

            if (!isOccupied && isPassable) {
                safeTiles.push({ x: x, y: y });
            }
        }
    }

    if (safeTiles.length > 0) {
        return randChoice(safeTiles); // 安全なマスの中からランダムに1つ選んで返す
    } else {
        return null; // 安全なマスが見つからなかった場合
    }
}
// ▼▼▼ この関数を新しく追加してください ▼▼▼
/**
 * 指定されたエンティティの周囲にある、移動可能な安全なタイルを探す
 * @param {object} entity - 対象のエンティティ
 * @returns {object|null} - 安全なタイルの座標 {x, y} または null
 */
function findSafeFleeTileForEntity(entity) {
    const fleeRadius = 1; // 隣接するマスのみを対象
    let safeTiles = [];

    for (let y = entity.y - fleeRadius; y <= entity.y + fleeRadius; y++) {
        for (let x = entity.x - fleeRadius; x <= entity.x + fleeRadius; x++) {
            if ((x === entity.x && y === entity.y) || x < 0 || y < 0 || x >= mapSize || y >= mapSize) {
                continue;
            }

            const isOccupiedByOther = entities.some(e => e !== entity && e.x === x && e.y === y);
            const isPlayerOccupied = (player.x === x && player.y === y);
            const isPassable = !map[y][x].loc.blocksVision;

            if (!isOccupiedByOther && !isPlayerOccupied && isPassable) {
                safeTiles.push({ x: x, y: y });
            }
        }
    }

    if (safeTiles.length > 0) {
        return randChoice(safeTiles);
    } else {
        return null; // 安全なマスが見つからなかった場合
    }
}
// ▲▲▲ 追加ここまで ▲▲▲

function hasLineOfSight(x1, y1, x2, y2) {
    let dx = Math.abs(x2 - x1);
    let dy = -Math.abs(y2 - y1);
    let sx = x1 < x2 ? 1 : -1;
    let sy = y1 < y2 ? 1 : -1;
    let err = dx + dy;

    // ループの終点（対象のマス）自体は遮蔽物判定から除外する
    const endX = x2;
    const endY = y2;

    while (true) {
        // 現在のマスが終点（対象のマス）でなければ、遮蔽物かどうかをチェック
        if (x1 !== endX || y1 !== endY) {
            if (map[y1][x1].loc.blocksVision) {
                return false;
            }
        }
        
        if (x1 === endX && y1 === endY) break;
        
        let e2 = 2 * err;
        if (e2 >= dy) {
            err += dy;
            x1 += sx;
        }
        if (e2 <= dx) {
            err += dx;
            y1 += sy;
        }
    }
    return true;
}

function createSound(x, y, radius, sourceAction = '不意の物音') {
    const shoes = player.equipment.find(e => e.slot === 'feet');
    const soundModifier = shoes ? (shoes.soundModifier || 1.0) : 1.2; 
    let weatherModifier = 1.0;
    if (currentWeather.name === '雨') weatherModifier = 0.7;
    if (currentWeather.name === '嵐') weatherModifier = 0.4;

    let soundRadius = radius * soundModifier * weatherModifier;
    
    currentSoundLevel = parseFloat(soundRadius.toFixed(1));

    lastSoundCalculation = {
        base: radius,
        shoes: shoes ? { name: shoes.name, modifier: soundModifier } : { name: '素足', modifier: soundModifier },
        weather: { name: currentWeather.name, modifier: weatherModifier },
        total: currentSoundLevel,
        source: sourceAction
    };

    entities.forEach(entity => {
        if (getDistance(x, y, entity.x, entity.y) <= soundRadius) {
            if (entity.isZombie || (entity.isAnimal && !entity.flees)) {
                entity.investigationTarget = { x, y };
                entity.aiState = 'investigating';
            } else if (radius > 5 && (entity.flees || entity.type === 'Survivor' || entity.type === 'Trader')) {
                entity.target = {x, y}; 
                entity.aiState = 'fleeing';
            }
        }
    });
}

function moveEntityTowards(entity, targetX, targetY) {
    let dx = targetX - entity.x;
    let dy = targetY - entity.y;
    let newX = entity.x;
    let newY = entity.y;

    if (Math.abs(dx) > Math.abs(dy)) {
        newX += Math.sign(dx);
    } else if (Math.abs(dy) > 0) {
        newY += Math.sign(dy);
    }
    moveEntityTo(entity, newX, newY);
}

function moveEntityAwayFrom(entity, targetX, targetY) {
    let dx = entity.x - targetX;
    let dy = entity.y - targetY;
    let newX = entity.x;
    let newY = entity.y;

    if (Math.abs(dx) > Math.abs(dy)) {
        newX += Math.sign(dx);
    } else {
        newY += Math.sign(dy);
    }
    moveEntityTo(entity, newX, newY);
}

function moveEntityTo(entity, newX, newY) {
    if (newX < 0 || newY < 0 || newX >= mapSize || newY >= mapSize) return;

    const barricade = placedObjects.find(o => o.x === newX && o.y === newY && o.type === 'barricade' && o.health > 0);
    if (barricade) {
        resolveEntityAttackOnObject(entity, barricade);
    } else if (!entities.some(e => e.x === newX && e.y === newY) && !(player.x === newX && player.y === newY)) {
        entity.x = newX;
        entity.y = newY;
    }
}

// --- NEW Targeting Functions ---
function startTargeting(item, index, source) {
    targetingState.active = true;
    targetingState.item = item;
    targetingState.itemIndex = index;
    targetingState.source = source;
    targetingState.range = item.throwRange || 5;

    const itemName = getItemDisplayName(item);
log(getString("log_select_throw_target", { itemName: itemName }));
    hideItemDetail();
    drawMap();
}

function cancelTargeting() {
    targetingState.active = false;
    log(getString("log_cancel_throw"));
    drawMap();
}

function handleTargetingClick(targetX, targetY) {
    if (Math.abs(targetX - player.x) > targetingState.range || Math.abs(targetY - player.y) > targetingState.range) {
        log("そこまでは届かない。");
        cancelTargeting();
        return;
    }

    const item = targetingState.item;
    const itemIndex = targetingState.itemIndex;

    log(`${item.name}を (${targetX}, ${targetY}) に投げた。`);
    
    // Create sound at the target location
    createSound(targetX, targetY, item.throwSoundRadius || 5);
    
    // Remove item from inventory
    const removedItem = player.inventory.splice(itemIndex, 1)[0];
    player.weight -= removedItem.weight;
    player.volume -= removedItem.volume;
    
    // Drop the item at the target location
    const locationKey = `${targetX},${targetY}`;
    if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
    droppedItems[locationKey].push(removedItem);

    cancelTargeting();
    advanceTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    updateTurnInfo();
    checkGameOver();
}

function setMovementMode(mode) {
    player.movementMode = mode;
    const modeName = getString(`move_${mode}`);
    const message = getString("log_movement_mode_changed", { modeName: modeName });

    const logDiv = document.getElementById("log");
    Array.from(logDiv.children).forEach(div => {
        div.style.color = "#666";
        div.style.fontWeight = "normal";
    });
    let div = document.createElement("div");
    div.innerHTML = message;
    div.classList.add("new");
    logDiv.appendChild(div);
    logDiv.scrollTop = logDiv.scrollHeight;

    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = message;
    const plainText = tempDiv.textContent || tempDiv.innerText || "";
    speak(plainText);

    updateMovementButtons();
}

// index.html 内

function showBodyOdorTooltip(event) {
    const preview = document.getElementById("statusPreview");
    const description = getString("tooltip_body_odor_desc");
    let contentHtml = `<strong>${getString("tooltip_body_odor_title")}</strong><div style="margin-top: 5px;">${description}</div>`;
    preview.innerHTML = contentHtml;
    preview.style.display = 'block';
    updatePreviewPosition(event);
}
function updateMovementButtons() {
    document.querySelectorAll('#movementControls button').forEach(btn => btn.classList.remove('active'));
    if (player.movementMode === 'walk') document.getElementById('moveWalkBtn').classList.add('active');
    else if (player.movementMode === 'run') document.getElementById('moveRunBtn').classList.add('active');
}

function washBody() {
    if (player.bodyOdor <= 0) {
        log(getString("log_wash_body_not_needed"));
        return;
    }

    const performWash = () => {
        snapshotStats();
        log(getString("log_wash_body_success"));
        createSound(player.x, player.y, 3, '水浴び');
        player.bodyOdor = 0;
        
        updatePlayerSmell();

        player.equipment.forEach(item => {
            if (item.type === 'clothing') {
                if (item.wetness === 'dry') item.wetness = 'wet';
                else if (item.wetness === 'wet') item.wetness = 'soaking_wet';
            }
        });
        log(getString("log_wash_clothes_wet"));

        updateTurnInfo();
        drawMap();
        updateStatus();
        updateItemPanels();
        updateCharacterBody();
        updateCharacterInfo();
        advanceTurn();
        checkGameOver();
    };

    if (currentTime.getHours() === 17) {
        speakAndConfirm(getString("confirm_wash_body_dusk"), performWash, () => {
            log(getString("log_wash_body_cancel"));
        });
    } else {
        performWash();
    }
}
function tillSoil(item, itemIndex, source) {
    const tile = map[player.y][player.x];
    if (tile.loc.nameKey !== 'location_field') {
        log(getString("log_till_fail_not_field"));
        return;
    }
    if (placedObjects.some(o => o.x === player.x && o.y === player.y)) {
        log(getString("log_till_fail_blocked"));
        return;
    }

    snapshotStats();
    log(getString("log_till_success"));
    
    item.durability -= 5;
    if (item.durability <= 0) {
        log(getString("combat_weapon_break", { weaponName: getItemDisplayName(item) }));
        const itemContainer = source === 'inventory' ? player.inventory : player.equipment;
        const actualIndex = itemContainer.findIndex(i => i === item);
        if(actualIndex > -1) {
            const removedItem = itemContainer.splice(actualIndex, 1)[0];
            player.weight -= removedItem.weight;
            player.volume -= removedItem.volume;
        }
    }

    placedObjects.push({
        x: player.x,
        y: player.y,
        type: 'tilled_field',
        name: '耕された畑',
        graphic: 'images/tilled_field.png',
        planted: null,
        growth: 0,
        growthTime: 5
    });
    
    hideItemDetail();
    advanceTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    updateTurnInfo();
    checkGameOver();
    updateCurrentLocationPanel(false);
}

function plantSeed(item, itemIndex, source) {
    const tilledField = placedObjects.find(o => o.x === player.x && o.y === player.y && o.type === 'tilled_field');
    if (!tilledField) {
        log(getString("log_plant_fail_not_tilled"));
        return;
    }
    if (tilledField.planted) {
        log(getString("log_plant_fail_blocked"));
        return;
    }

    snapshotStats();
    
    const seedItem = player.inventory.splice(itemIndex, 1)[0];
    player.weight -= seedItem.weight;
    player.volume -= seedItem.volume;

    tilledField.planted = seedItem.plantResult;
    tilledField.name = `${seedItem.plantResult}(成長中)`;
    tilledField.graphic = 'images/seeds.png';

    log(getString("log_plant_success", { seedName: getItemDisplayName(seedItem) }));

    hideItemDetail();
    advanceTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    updateTurnInfo();
    checkGameOver();
    updateCurrentLocationPanel(false);
}

function harvestCrop() {
    const crop = placedObjects.find(o => o.x === player.x && o.y === player.y && o.isHarvestable);
    if (!crop) return;

    snapshotStats();
    
    const yieldAmount = Math.floor(Math.random() * 3) + 1;
    const cropTemplate = items.find(i => i.name === crop.planted);
    
    if (cropTemplate) {
        const cropDisplayName = getString(`item_${crop.planted}_name`) || crop.planted;
        log(getString("log_harvest_success", { cropName: cropDisplayName, count: yieldAmount }));
        
        for (let i = 0; i < yieldAmount; i++) {
            const newItem = { ...cropTemplate };
            if (player.weight + newItem.weight > player.maxWeight || player.volume + (newItem.volume || 0) > player.maxVolume) {
                log(getString("log_harvest_grounded"));
                const locationKey = `${player.x},${player.y}`;
                if (!droppedItems[locationKey]) droppedItems[locationKey] = [];
                droppedItems[locationKey].push(newItem);
            } else {
                player.inventory.push(newItem);
                player.weight += newItem.weight || 0;
                player.volume += newItem.volume || 0;
            }
        }
    }

    const cropIndex = placedObjects.findIndex(o => o === crop);
    if (cropIndex > -1) {
        placedObjects.splice(cropIndex, 1);
    }
    
    advanceTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    updateTurnInfo();
    checkGameOver();
    updateCurrentLocationPanel(false);
}
function repairBarricade() {
    const barricade = placedObjects.find(p => p.x === player.x && p.y === player.y && p.type === 'barricade');
    if (!barricade) return;
    if (barricade.health >= barricade.maxHealth) {
        log(getString("log_repair_not_needed"));
        return;
    }
    snapshotStats();
    const oldHealth = barricade.health;
    barricade.health = Math.min(barricade.maxHealth, barricade.health + 20);
    log(getString("log_barricade_repaired", { oldHealth: oldHealth.toFixed(0), newHealth: barricade.health.toFixed(0) }));
    createSound(player.x, player.y, 4, '修理');
    advanceTurn();
    drawMap();
    updateStatus();
    updateItemPanels();
    updateCharacterBody();
    updateCharacterInfo();
    updateTurnInfo();
    checkGameOver();
    updateCurrentLocationPanel(false);
}

// Initial setup
// ▼▼▼ このブロックで、既存のDOMContentLoadedのリスナーを丸ごと置き換えてください ▼▼▼
document.addEventListener('DOMContentLoaded', async () => {
    // ▼▼▼ ここからが追加・修正箇所です ▼▼▼
    
    /**
     * PCにインストールされている音声のリストを取得し、グローバル変数に保存する関数
     */
    function setupSpeechSynthesis() {
      // すぐにリストを取得してみる
      availableVoices = speechSynthesis.getVoices();
      
      if (availableVoices.length > 0) {
        // 既にリストが準備できていれば、コンソールに表示
        console.log("利用可能な音声リストを取得しました。", availableVoices);
      } else {
        // リストが空の場合、リストが変更された（準備ができた）タイミングで再取得する
        speechSynthesis.onvoiceschanged = () => {
          availableVoices = speechSynthesis.getVoices();
          console.log("利用可能な音声リストを再取得しました。", availableVoices);
        };
      }
    }
    // ゲーム起動時に音声リストの準備を開始する
    setupSpeechSynthesis();

    // ▲▲▲ 追加・修正ここまで ▲▲▲

    // 最初にオーディオコンテキストをユーザー操作で有効化する
    const resumeAudio = () => {
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
        document.body.removeEventListener('click', resumeAudio);
    };
    document.body.addEventListener('click', resumeAudio);

    const pkg = require('./package.json');
    const versionDisplay = document.getElementById('version-display');
    if (versionDisplay) versionDisplay.textContent = `v${pkg.version}`;

    await loadLanguage(currentLanguage);

    const startScreen = document.getElementById('startScreen');
    const optionsBtn = document.getElementById('optionsBtn');
    const optionsScreen = document.getElementById('optionsScreen');
    const backToMenuBtn = document.getElementById('backToMenuBtn');
    
    optionsBtn.addEventListener('click', () => {
        playSoundFile('sounds/ui_click.wav');
        startScreen.style.display = 'none';
        optionsScreen.style.display = 'flex';
    });

    backToMenuBtn.addEventListener('click', () => {
        playSoundFile('sounds/ui_cancel.wav');
        optionsScreen.style.display = 'none';
        if (!isGameRunning) {
            startScreen.style.display = 'flex';
        }
    });
    
    const volumeSlider = document.getElementById('volumeSlider');
    volumeSlider.addEventListener('input', updateWeatherAudio);
    
    document.querySelectorAll('.panel').forEach(panel => {
        panel.style.display = 'none';
        const header = panel.querySelector(".panel-header");
        if (header) {
            panel.addEventListener("mousedown", () => bringToFront(panel));
            header.addEventListener("click", () => { if (panel.classList.contains("minimized")) togglePanelSize(panel); });
            header.addEventListener("dblclick", () => { if (!panel.classList.contains("minimized")) togglePanelSize(panel); });
        }
        makeDraggable(panel); makeResizable(panel);
    });

    document.getElementById('map').addEventListener('contextmenu', e => {
        e.preventDefault();
        if (targetingState.active) cancelTargeting();
    });

    document.getElementById('startGameBtn').addEventListener('click', () => {
        playSoundFile('sounds/ui_confirm.wav');
        initGame();
    });
    
    document.getElementById('loadGameBtn').addEventListener('click', () => {
        playSoundFile('sounds/ui_confirm.wav');
        loadGame();
    });
    
    document.getElementById('quitGameBtn').addEventListener('click', () => {
        playSoundFile('sounds/ui_cancel.wav');
        setTimeout(() => window.close(), 300);
    });

    document.getElementById('langBtnJa').addEventListener('click', () => {
        playSoundFile('sounds/ui_click.wav');
        loadLanguage('ja');
    });

    document.getElementById('langBtnEn').addEventListener('click', () => {
        playSoundFile('sounds/ui_click.wav');
        loadLanguage('en');
    });

    document.getElementById('langBtnZh').addEventListener('click', () => {
        playSoundFile('sounds/ui_click.wav');
        loadLanguage('zh-CN');
    });

    document.getElementById('enableSpeechToggle').addEventListener('change', (event) => {
        isSpeechEnabled = event.target.checked;
        if (isSpeechEnabled) speak(getString("log_speech_enabled"));
    });
    
    document.getElementById('playAgainBtn').addEventListener('click', initGame);
    document.getElementById('closeStorageBtn').addEventListener('click', closeStoragePanel);
    document.getElementById('pickupStorageBtn').addEventListener('click', pickupStorageBox);
    document.getElementById('sleepNowBtn').addEventListener('click', sleepForOneHour);
    document.getElementById('suicideBtn').addEventListener('click', () => speakAndConfirm(getString("confirm_suicide_q"), () => handleGameOver(getString("log_suicide_success")), () => log(getString("log_suicide_cancel"))));
    document.getElementById('waitTurnBtn').addEventListener('click', waitOneTurn);    

    // --- Tooltip Listeners ---
    const statusLines = {
        'status_hunger': document.querySelector('[data-translate-key="status_hunger"]').parentElement,
        'status_thirst': document.querySelector('[data-translate-key="status_thirst"]').parentElement,
        'status_health': document.querySelector('[data-translate-key="status_health"]').parentElement,
        'status_morale': document.querySelector('[data-translate-key="status_morale"]').parentElement,
        'status_sleep': document.querySelector('[data-translate-key="status_sleep"]').parentElement,
        'status_weight': document.querySelector('[data-translate-key="status_weight"]').parentElement,
        'status_volume': document.querySelector('[data-translate-key="status_volume"]').parentElement,
        'status_attack': document.querySelector('[data-translate-key="status_attack"]').parentElement,
        'status_defense': document.querySelector('[data-translate-key="status_defense"]').parentElement
    };
    for (const key in statusLines) {
        if(statusLines[key]) {
            statusLines[key].style.cursor = 'help';
            statusLines[key].addEventListener('mouseenter', (e) => showInfoTooltip(e, getString(key), getString(`tooltip_${key}`)));
            statusLines[key].addEventListener('mouseleave', hideInfoTooltip);
            statusLines[key].addEventListener('mousemove', (e) => updatePreviewPosition(e));
        }
    }

    const bodyTempLine = document.getElementById('bodyTempStatusLine');
    bodyTempLine.addEventListener('mouseenter', showBodyTempTooltip);
    bodyTempLine.addEventListener('mouseleave', hideStatusPreview);
    bodyTempLine.addEventListener('mousemove', (e) => updatePreviewPosition(e));

    const bodyOdorLine = document.getElementById('bodyOdorStatusLine');
    bodyOdorLine.addEventListener('mouseenter', showBodyOdorTooltip);
    bodyOdorLine.addEventListener('mouseleave', hideStatusPreview);
    bodyOdorLine.addEventListener('mousemove', (e) => updatePreviewPosition(e));

    const walkBtn = document.getElementById('moveWalkBtn');
    const runBtn = document.getElementById('moveRunBtn');

    walkBtn.onclick = () => setMovementMode('walk');
    walkBtn.addEventListener('mouseenter', (e) => showInfoTooltip(e, getString('move_walk'), getString('move_tooltip_walk')));
    walkBtn.addEventListener('mouseleave', hideStatusPreview);
    walkBtn.addEventListener('mousemove', updatePreviewPosition);

    runBtn.onclick = () => setMovementMode('run');
    runBtn.addEventListener('mouseenter', (e) => showInfoTooltip(e, getString('move_run'), getString('move_tooltip_run')));
    runBtn.addEventListener('mouseleave', hideStatusPreview);
    runBtn.addEventListener('mousemove', updatePreviewPosition);

    document.getElementById('saveGameBtn').addEventListener('click', saveGame);
    
    const ingameOptionsBtn = document.getElementById('ingameOptionsBtn');
    ingameOptionsBtn.addEventListener('click', () => {
        playSoundFile('sounds/ui_click.wav');
        const optionsScreen = document.getElementById('optionsScreen');
        optionsScreen.style.display = 'flex';
        bringToFront(optionsScreen);
    });

    ipcRenderer.invoke('has-save-file').then(hasSave => {
        if (hasSave) {
            document.getElementById('loadGameBtn').style.display = 'inline-block';
        }
    });

    window.addEventListener('resize', drawMap);
    window.addEventListener('beforeunload', () => {
        speechSynthesis.cancel();
    });
});
</script>

</body>
</html>